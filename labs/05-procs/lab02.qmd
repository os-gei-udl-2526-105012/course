---
title: "Escape Room entre processos amb Pipes"
subtitle: "Unitat 3 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
lang: "ca"

execute:
  freeze: auto
  echo: false
---

## üéØ Objectius

- Crear i gestionar processos fills amb `fork()`.
- Comunicar processos amb pipes i FIFOs.
- Utilitzar senyals (`SIGALRM`, `SIGUSR1`).
- Sincronitzar i finalitzar processos.


## üèóÔ∏è Descripci√≥

En aquest laboratori us proposem implementar un joc senzill d‚ÄôEscape Room utilitzant processos i comunicaci√≥ entre ells mitjan√ßant pipes. Per fer-ho, haureu de crear un proc√©s pare que gestioni la partida i diversos processos fills que representin els jugadors. La idea √©s que els jugadors intentin endevinar una clau secreta abans que s‚Äôacabi el temps.

![](../../figures/labs/04-escape/disseny.png)

Per simplificar, la clau ser√† una cadena de 4 car√†cters (per exemple, **ABCD**) i els jugadors generaran combinacions aleat√≤ries fins a trobar la correcta o que s‚Äôacabi el temps.

El programa acceptar√† tres arguments: 

1. Temps m√†xim per a la partida (en segons).
2. Nombre de jugadors (processos fills).
3. Clau secreta (cadena de 4 car√†cters).

El programa finalitzar√† quan un jugador encerti la clau o quan s‚Äôacabi el temps. 

1. Els jugadors acertaran la clau enviant-la al proc√©s pare mitjan√ßant un pipe i guanyaran si ho aconsegueixen abans que s‚Äôacabi el temps.

    ![](../../figures/labs/04-escape/victoria.png)

2. Si el temps s‚Äôesgota, el proc√©s pare enviar√† un senyal als processos fills per indicar que la partida ha acabat.

    ![](../../figures/labs/04-escape/derrota.png)   

A m√©s, implementarem la l√≤gica del `jugador` i del `sala` (pare) en fitxers separats. El pare (`sala.c`) esperar√† la finalitzaci√≥ dels seus fills (`jugador.c`) per acabar la partida.

## üß© `jugador.c` 

El codi jugador el teniu a continuaci√≥ amb algunes seccions marcades com a TODO que heu de completar. Si compileu i executeu el codi tal qual est√† ara, veureu que cada jugador escriu un missatge a la sortida est√†ndard indicant que ha entrat a la sala. Heu de completar el codi per generar la clau aleat√≤ria i esperar el senyal de finalitzaci√≥. La vostra missi√≥ √©s completar les seccions marcades com a TODO.

```c
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>


int main(int argc, char *argv[]) {

    //TODO: Els misstges de log no han d'anar a stdout sin√≥ a stderr

    char s[100];
    sprintf(s, "--- Jugador %d ha entrat a la sala\n", getpid());
    write(1, s, strlen(s));

    // TODO: Gestionar senyal SIGUSR1 per acabar el proc√©s
    int n = 4;
    char pass[n];
    srand(time(NULL) + getpid());

    // TODO: Generar 4 car√†cters aleatoris (per ex. 'A' + rand() % 26)
    // TODO: Enviar els car√†cters al pare mitjan√ßant pipe

    sprintf(s, "--- La clau generada pel jugador %d √©s: %s\n", getpid(), pass);
    write(1, s, strlen(s));

    //TODO: Esperar senyal de finalitzaci√≥ (SIGUSR1)
    return 0;
}
```

Aquest codi s‚Äôexecuta aparentment b√©, per√≤ amaga un error subtil: utilitza una variable no inicialitzada per imprimir la clau generada. Aix√≤ pot provocar comportaments err√†tics, valors aleatoris o fins i tot fallades d‚Äôexecuci√≥ segons l‚Äôestat de la mem√≤ria. Aquest tipus d‚Äôerror √©s molt freq√ºent en programes amb punters i comunicaci√≥ entre processos, i pot ser molt dif√≠cil de detectar nom√©s amb proves manuals.

Per comprovar si el vostre programa pateix aquest problema, utilitzeu l‚Äôeina Valgrind, que permet rastrejar errors de mem√≤ria com:

- √ös de variables no inicialitzades.
- Lectura o escriptura fora dels l√≠mits d‚Äôun buffer.
- Fuites de mem√≤ria (malloc sense free).
- Errors en la gesti√≥ de punters.

Executeu el vostre programa amb Valgrind de la seg√ºent manera:

```bash
valgrind ./jugador
```

A la sortida, Valgrind us indicar√† exactament quina l√≠nia accedeix a mem√≤ria no inicialitzada o allibera mem√≤ria incorrectament.

Per instal¬∑lar Valgrind en sistemes basats en Debian o Ubuntu:

```bash
sudo apt-get install valgrind
```

:::{.callout-warning title="Recomanaci√≥"}
Durant tot el laboratori, executeu sempre el vostre codi amb Valgrind abans de donar-lo per bo. Un programa que funciona per√≤ genera errors de mem√≤ria no es considera correcte.
:::


## üß© sala.c 

```c 
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>

char *color_blue   = "\033[01;34m";
char *color_end    = "\033[00m";
char *color_red    = "\033[01;31m";
char *color_green  = "\033[01;32m";

char *args[] = {"jugador", "jugador", NULL};

// TODO: Funcionalitat per gestionar l'alarma (SIGALRM)

int main(int argc, char *argv[]) {
    int fd[2];
    char s[100];
    int *pids;
    int tempsPartida, numJugadors;
    char *clau;

    if (argc < 4) {
        fprintf(stderr, "√ös: %s tempsPartida numJugadors clau\n", argv[0]);
        exit(1);
    }

    //TODO: Llegir arguments
    //TODO: Definir l'acci√≥ per a la senyal SIGALRM

    sprintf(s, "Inici del Room Escape [%d] (%d segons)\n", getpid(), tempsPartida);
    write(1, s, strlen(s));

    sprintf(s, "--- Entren %d jugadors a la sala\n", numJugadors);
    write(1, s, strlen(s));

    sprintf(s, "--- La clau secreta √©s: %s\n", clau);
    write(1, s, strlen(s));

    /* TODO 2: Crear processos fills (jugadors) amb fork() */

    alarm(tempsPartida);

    //TODO 3: Esperar respostes dels jugadors mitjan√ßant pipe
    // Si algun jugador encerta la clau, mostrar missatge de vict√≤ria i acabar

    //TODO 5: Gestionar finalitzaci√≥ en funci√≥ de si s'ha encertat la clau o ha sonat l'alarma

    // TODO 6: Mostrar missatge final segons resultat

    exit(0);
}
```

## ü•ö Extensi√≥: Ou de pasqua amb FIFO

Canvia el programa per utilitzar un FIFO en lloc d‚Äôun pipe.
D‚Äôaquesta manera, un proc√©s extern pot *ajudar* els jugadors enviant la clau correcta.

1. Crea un FIFO amb `mkfifo()`.
2. Utilitza aquesta FIFO per escriure i llegir les claus generades pels jugadors enlloc del pipe.
3. Allibera el FIFO al final del programa amb `unlink()`.

Per testar el FIFO, pots utilitzar la comanda `echo` des d‚Äôun altre terminal per enviar la clau correcta.

```bash
echo "AAAA" > myfifo
```

![](../../figures/labs/04-escape/fifos.png)

## üìÑ Makefile

Prepareu un `Makefile` per compilar els fitxers `sala.c` i `jugador.c`.
Permeteu compilar, netejar i executar el programa amb diferents par√†metres.

## üìö Exercicis addicionals

1. Canvia el missatge que envia cada jugador per una estructura amb punters:

    ```c
    typedef struct {
        pid_t pid;
        char *clau;   
    } missatge_jugador;
    ```

2. Modifica el programa per permetre l'enviament de pistes als jugadors des del proc√©s pare. Per exemple:
   
    - Els jugadors poden enviar `SIGUSR2` per demanar una pista.
    - El pare respondr√† enviant un missatge pel pipe amb una pista. Per exemple, la primera lletra de la clau √©s 'A'. Cada pista permet reduir l'espai de cerca. √önicament es poden donar $n-1$ pistes on $n$ √©s la longitud de la clau.

3. Implementa un scape room competitiu on cada jugador √©s un proc√©s independent que competeix per trobar la clau abans que els altres. Al final, de la partida, s'ha de mostrar un ranking amb el nombre d'intents i el temps emprat per cada jugador.
