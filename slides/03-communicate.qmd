---
title: "Comunicaci贸 de processos"
subtitle: "Unitat 3 路 Sistemes Operatius (SO)"
author: "Jordi Mateo Forn茅s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 路 Sistemes Operatius (SO) [](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Reps de gesti贸 de processos {.smaller}

```echo "Missatge enviat" > missatge.txt```

![](../figures/slides/03-comunicate/reaci贸-proc.png)

:::{.callout-note title="Exercici"}
Implementeu un programa en C que simuli aquest comportament.
:::

## Comunicaci贸 entre processos (IPC) {.smaller}

En un sistema operatiu *multiprogramat o distribu茂t*, diversos processos sexecuten concurrentment i sovint necessiten intercanviar dades, sincronitzar accions o compartir recursos. Aquest intercanvi sanomena **Inter-Process Communication (IPC)**.

- Coordinaci贸 i sincronitzaci贸 entre processos independents.
- Transfer猫ncia dinformaci贸 sense accedir directament a lespai dadreces dels altres processos.
- Compartici贸 controlada de recursos (fitxers, mem貌ria, dispositius, sockets).

## Reptes de la comunicaci贸 (IPC) {.smaller}

1. **Com es pot transferir la informaci贸 entre processos?** Recorda que els processos operen en espais d'adre莽es independents. Per tant, **no poden accedir a la mateixa informaci贸**.

2. **Com es pot assegurar que dos processos no intentin accedir simultniament a la mateixa informaci贸?** Imagina't 2 processos executant una reserva en un avi贸 i els dos processos assignen el mateix seient a dos passatgers diferents.

3. **Com es poden coordinar els processos dependents entre si?** Imagina't un proc茅s que genera dades i un altre proc茅s que les processa. El proc茅s que processa les dades necessita esperar a que el proc茅s que les genera les hagi generat totes.

## Exemples de comunicaci贸/sincronitzaci贸 {.smaller}

* **Comunicaci贸**: Intercanvi d'informaci贸.

::: {.fragment}
```sh
cat missatge.txt | grep "e"
```
:::

* **Sincronitzaci贸**: Coordinaci贸 en l'acc茅s als recursos i en l'ordre d'execuci贸 de les tasques.

::: {.fragment}
```sh
echo "hola1"; echo "adeu1" && echo "hola2" || echo "adeu2"
```
:::

::: notes

* El `;` permet executar les comandes de forma seq眉encial.
* El `&&` permet executar la segona comanda si la primera s'ha executat correctament.
* El `||` permet executar la segona comanda si la primera no s'ha executat correctament.

:::

## ```cat < missatge.txt | grep "e"```

![](../figures/slides/03-comunicate/echo-grep.png)

## Esquema de la comunicaci贸/sincronitzaci贸 {.smaller}

::: columns
::: {.column width="45%"}
### Proc茅s 1
```c
while(!FiTasca1){
  EsperarFiTasca1();
}

while(ExisteixTasca){
  dades = FerTasca2();
  EnviarMissatge(pid2,dades);
}
```
:::
::: {.column width="45%"}
### Proc茅s 2
```c
RealitzarTasca1();
AvisarTasca1Completada();

while(ExisteixTasca){;
  RebreMissatge(pid2, &dades);
  RealitzarTasca(dades);
}
```
:::
:::

## Exemple: Cua d'impressi贸

Assumeix que un proces A vol imprimir un document:

1. El *proc茅s A* ha d'introduir el nom del fitxer a imprimir en una cua d'impressi贸.
2. El servei d'impressi贸 *proc茅s B* de forma peri貌dica revisa la cua d'impressi贸 i imprimeix els fitxers que hi ha en la cua.

::: {.fragment}
Per fer-ho, implementem una cua d'impressi贸 amb dos variables una que apunta al seg眉ent slot a imprimir (**out**) i una al seg眉ent slot lliure (**in**).
:::

## Exemple: Cua d'impressi贸 {.smaller}

::: columns
::: {.column width="65%"}

- El proc茅s A llegeix la variable **in** i escriu el valor 7 en una variable local (*next_free_slot*).
- El SO interromp el proc茅s A i executa el proc茅s B.
- El proc茅s B llegeix la variable **in** i escriu el valor 7 en una variable local (*next_free_slot*).
- El proc茅s B col路loca un fitxer a la cua d'impressi贸 al slot 7 i el servei d'impressi贸 modifica les variables **in** i **out**.
- El proc茅s B realitza altres tasques no relacionades amb la cua d'impressi贸.
- El SO interromp el proc茅s B i executa el proc茅s A. El proc茅s A utilitza la seva variable local (*next_free_slot*) per a escriure el fitxer a la cua d'impressi贸. El fitxer s'escriu al slot 7, i tamb茅 actualitza les variables **in** i **out**.
:::
::: {.column width="35%"}

![](../figures/slides/03-comunicate/impressio.png)

1. El proc茅s B ha perdut la impressi贸 del fitxer. El proc茅s A l'ha sobrescrit.
2. El servei d'impressi贸 no ha notat cap inconsistencia en les variables **in** i **out**.

::: 
::: 

## Condicions de carrera {.smaller}

Les condicions de carrera es produeixen quan dos o m茅s processos o fils d'execuci贸 intenten accedir simultniament a recursos compartits o a dades sense la deguda sincronitzaci贸.

::: {.fragment}
#### Problemes
Poden conduir a resultats inesperats o incorrectes en les operacions i a la inconsist猫ncia de les dades compartides.
:::

::: {.fragment}
#### Solucions 

1. **Exclusi贸 M煤tua**: Utilitzar mecanismes com semfors, mutex o candaus per a garantir que nom茅s un proc茅s pugui accedir als recursos compartits a la vegada.

2. **Sincronitzaci贸**: Coordinar l'execuci贸 dels processos mitjan莽ant sincronitzaci贸 de manera que no interfereixin entre ells quan accedeixen als recursos compartits.
:::

## Evitar les condicions de carrera {.smaller}

La **secci贸 cr铆tica** 茅s la part del codi on s'accedeix a recursos compartits. Per a evitar les condicions de carrera, els processos han de complir les seg眉ents condicions:

1. Dos processos no poden estar simultniament en la secci贸 cr铆tica.
2. No s'ha d'assumir que els processos s贸n executats de forma rpida o lenta.
3. Cap proc茅s que no estigui en la secci贸 cr铆tica pot bloquejar altres processos.
4. Cap proc茅s ha d'esperar per sempre per entrar a la secci贸 cr铆tica.

::: center-container
![](../figures/slides/03-comunicate//mutex.png)
:::


## Tipus de comunicaci贸 {.smaller}

#### Pas de missatges
- Permet integrar tasques de comunicaci贸 i sincronitzaci贸 entre processos situats en una mateixa mquina o en mquines distribu茂des.
- Un missatge 茅s un conjunt de dades intercanviades per 2 o m茅s processos.

:::{.fragment}
#### Mem貌ria compartida
- Els processos es comuniquen utilitzant variables o zones de mem貌ria compartida.
- S'utilitzen per comunicar processos en una mateixa mquina.
- Es necessita regular l'acc茅s a la informaci贸 compartida per garantir el resultat 貌ptim i evitar les *race conditions*.
:::

## Caracter铆stiques de la comunicaci贸 (I) {.smaller}

#### Identificaci贸
* Mecanismes de noms
    - Sense nom
    - Nom local
    - Nom de la red

* Identificador de dest铆
    - **Directe**: S'ha d'indicar el proc茅s origen i dest铆. El missatge s'envia a un proc茅s concret utilitzant el seu *pid*. El receptor pot (indicar o no) el proc茅s que vol rebre el missatge.
    - **Indirecte**: Els missatges s'envien a una zona contreta (bustia o port), sense identificar de forma expl铆cita el dest铆.

## Caracter铆stiques de la comunicaci贸 (II) {.smaller}

#### Flux de dades
- Unidireccional
- Bidireccional

:::{.fragment}
#### Buffering
- Amb buffers
- Sense buffers
:::

::: {.fragment}
#### Sincronitzaci贸
- Sincrons (bloquejants)
- As铆ncrons (no bloquejants)
:::

## Tipus de mecanismes

1. Fitxers.
2. Pipes.
3. FIFOS (Pipes amb nom).
4. Cues de missatges.
5. Sockets.
6. Mem貌ria compartida (IPC).

## Fitxers {.smaller}

La comunicaci贸 entre processos a trav茅s dels s**istemes de fitxers** 茅s una manera simple d'intercanviar informaci贸 entre ells. Aix貌 implica que dos o m茅s processos acorden un fitxer pel seu nom i el utilitzen per a la comunicaci贸. Un dels processos escriu al fitxer mentre que un altre processos llegeix el contingut del fitxer.

#### Limitacions

- **Persist猫ncia**: Els fitxers s贸n persistents, la informaci贸 roman en disc fins que s'elimina de forma expl铆cita. Aix貌 no 茅s 貌ptim per a la comunicaci贸 ef铆mera o temporal entre processos.

- **Problemes de Sincronitzaci贸**: Cal gestionar la sincronitzaci贸 de forma manual per garantir que un proc茅s no llegeixi el fitxer abans que un altre proc茅s hagi acabat d'escriure-hi. Aquesta sincronitzaci贸 pot ser complexa i pot conduir a errors si no es gestiona adequadament.

- **Efici猫ncia**: L'煤s de fitxers per a la comunicaci贸 no 茅s eficient en termes de rendiment, ja que involucra operacions d'entrada i sortida a disc, que s贸n m茅s lentes que altres m猫todes de comunicaci贸 en mem貌ria.


## Exemple: Comunicaci贸 amb fitxers

Un proc茅s 1 (escriptor) escriu un missatge en un fitxer anomenat *fitxer_comunicacio.txt*. 

```c
// Process 1 (escriptor)
int fd = open("fitxer_comunicacio.txt", O_WRONLY | O_CREAT, 0644);
write(fd, "Missatge des de Process 1", strlen("Missatge des de Process 1"));
close(fd);
```

Un proc茅s 2 (lector) llegeix el missatge d'aquest fitxer i el mostra per pantalla.

```c
// Process 2 (lector)
int fd = open("fitxer_comunicacio.txt", O_RDONLY);
char buffer[100];
read(fd, buffer, 100);
close(fd);
printf("Missatge rebut: %s\n", buffer);
```

## Pipes {.smaller}

Els **pipes** s贸n dispositius l貌gics dissenyats per permetre la comunicaci贸 entre processos. Es comporten com una cua de carcters amb una longitud fixa on els processos poden llegir o escriure.

- **Sense Nom**: Els pipes s贸n an貌nims, el que significa que no estan associats amb un fitxer del sistema de fitxers.
- **s Amb fork()**: Es poden heretar i utilitzar fcilment.
- **Identificaci贸**: Es caracteritzen per tenir dos descriptors de fitxers, un per a l'escriptura i un altre per a la lectura.
- **Flux de Dades Unidireccional**: El flux de dades als pipes 茅s unidireccional, la informaci贸 nom茅s es mou d'una direcci贸, 茅s a dir, del proc茅s escriptor al proc茅s lector.
- **Amb Buffering**: Els pipes utilitzen un mecanisme que permet acumular dades fins que es llegeixin.
- **Restriccions d'mbit Local**: Comunicaci贸 entre processos a la mateixa mquina, ja que no estan dissenyats per a la comunicaci贸 a trav茅s de xarxes.

## Exemple: Comunicaci贸 amb Pipes (Bash) 

En bash, podem utilitzar pipes per a comunicar dos processos. Per exemple, podem utilitzar el comandament `echo` per a enviar un missatge a trav茅s d'un pipe i el comandament `cat` per a llegir aquest missatge.

```sh
echo "Missatge des de Process Pare" | echo "Missatge rebut: $(cat)"
```


## Exemple: Comunicaci贸 amb pipes (C)

::: columns
::: {.column width="60%"}
```c
int pipe_fd[2];
pipe(pipe_fd);
if (fork() == 0) { // Fill (lector)
  close(pipe_fd[1]);
  char buffer[100];
  read(pipe_fd[0], buffer, 100);
  close(pipe_fd[0]);
  printf("Missatge rebut: %s\n", buffer);
} else { // Pare (escriptor)
  close(pipe_fd[0]);
  write(pipe_fd[1], 
  "Missatge des de Process pare", 
  strlen("Missatge des de Process pare")
  );
  close(pipe_fd[1]);
}
```
:::
::: {.column width="40%"}
![](../figures/slides/03-comunicate/pipe.png)
:::
:::


## FIFOS {.smaller}

* Funcionen com els **pipes**, per貌 amb un mecanisme de comunicaci贸 amb nom.
* Serveis:
  * ```mkfifo(char *name,mode_t mode)```;
  * ```open(char *name, int flag)```;
    * S'obre un FIFO per r,w, r+w
    * Acci贸 bloquejant fins que algun proc茅s estigui a l'altre extrem.
  * Lectura i escriptura (*read()*, *write()*).
  * Tancament amb *close()*.
  * Eliminaci贸 amb *unlink()*.

::: {.center-container .fragment}
Els **FIFOs** ofereixen una forma de comunicaci贸 m茅s flexible entre processos amb l'avantatge afegit de poder ser utilitzats per processos que no comparteixen un antecessor com煤.
:::

## Exemple: Comunicaci贸 amb FIFOS (Bash) {.smaller}

:::{.nonincremental}
1. Crear el FIFO en la terminal 1:

```sh
mkfifo fifo_example
```

2. Executarem el process 1 (escriptor) a la terminal 1:

```sh
echo "Missatge des de Process 1" > fifo_example
```

3. Executarem el process 2 (lector) a la terminal 2:

```sh
cat < fifo_example
```

4. Eliminarem el FIFO:

```sh
rm fifo_example
```
:::


## Exemple: Comunicaci贸 amb FIFOS (C)

```c
mkfifo("fifo_example", 0666);

// Process 1 (escriptor)
int fd = open("fifo_example", O_WRONLY);
write(fd, "Missatge des de Process 1", strlen("Missatge des de Process 1"));
close(fd);

// Process 2 (lector)
int fd = open("fifo_example", O_RDONLY);
char buffer[100];
read(fd, buffer, 100);
close(fd);
printf("Missatge rebut: %s\n", buffer);


unlink("fifo_example");
```

## Cua de missatges {.smaller}

- Comunicaci贸 mitjan莽ant pas de missatge de la llibreria IPC.
- Mateixa mquina.
- Identificaci贸: indirecta amb identificador especial **idCua**.
- Amb nom local.
- Amb buffering.
- Unidireccional.
- Sincronitzaci贸: bloquejant i no bloquejant.

:::{.fragment}
#### Operacions bsiques:

- `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)`: Envia un missatge *msgp* de mida *msgz* a la cua *msgid*.

- `ssize_t msgrcv(int msqid,void *msgp, size_t msgsz,long msgtyp,int msgflg)`: Rep un missatge de la cua *msgid* i el guarda a *msgp*.
:::


## Ex: Comunicaci贸 amb Cua de missatges (C) - Escriptor

```c
struct message {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key = ftok("msg_queue_example", 65);
    int msqid = msgget(key, 0666 | IPC_CREAT);
    struct message msg;
    msg.msg_type = 1;
    strcpy(msg.msg_text, "Aquest 茅s un missatge de prova!");
    msgsnd(msqid, &msg, sizeof(msg), 0);
    printf("Missatge enviat: %s\n", msg.msg_text);
    return 0;
}
```

## Ex: Comunicaci贸 amb Cua de missatges (C) - Lector


```c
struct message {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key = ftok("msg_queue_example", 65);
    int msqid = msgget(key, 0666 | IPC_CREAT);
    
    struct message msg;
    msgrcv(msqid, &msg, sizeof(msg), 1, 0);
    printf("Missatge rebut: %s\n", msg.msg_text);
    return 0;
}
```

## Sockets {.smaller}

Els **sockets** s贸n eines fonamentals per a la comunicaci贸 entre processos a trav茅s d'una xarxa o dins del mateix ordinador. Poden utilitzar-se per a la comunicaci贸 mitjan莽ant diferents protocols com *TCP/IP* o *UDP*.

- **Comunicaci贸 a trav茅s de la xarxa o local**: Els sockets permeten la comunicaci贸 entre processos que poden estar en el mateix ordinador o en diferents ordinadors a trav茅s de la xarxa.

- **Adreces**: Els sockets estan identificats per adreces, com les adreces IP per a la comunicaci贸 a trav茅s de xarxes o adreces locals per a comunicaci贸 dins del mateix ordinador.

- **Protocols**: Els sockets poden utilitzar diferents protocols com TCP/IP o UDP, segons les necessitats de la comunicaci贸.

## Exemple: Comunicaci贸 amb Sockets

![](../figures/slides/03-comunicate/socket.png)



## Ex: Comunicaci贸 amb Sockets (C) 

::: columns
::: {.column width="50%"}
#### Servidor
```c
int sockfd, new_sock;
struct sockaddr_in server_addr;
struct  sockaddr_in new_addr;
socklen_t addr_size;
char buffer[100];

sockfd=socket(AF_INET, SOCK_STREAM, 0);
// Configuraci贸 de la connexi贸...
// Esperar connexions i llegir
new_sock = accept(sockfd, 
(struct sockaddr*)&new_addr, 
&addr_size);
recv(new_sock, buffer, 100, 0);
printf("Missatge rebut: %s\n", buffer);
```

:::
::: {.column width="50%"}
#### Client
```c
int sockfd;
struct sockaddr_in server_addr;
char buffer[100];

sockfd=socket(AF_INET, SOCK_STREAM, 0);
// Configuraci贸 de la connexi贸...

// Enviar missatge al servidor
send(sockfd,"Missatge des del client",
strlen("Missatge des del client"), 0);
```
:::
:::

## Mem貌ria compartida {.smaller}

La comunicaci贸 mitjan莽ant **mem貌ria compartida** implica compartir una rea de mem貌ria entre diferents processos o fils d'execuci贸 d'un mateix proc茅s. Aquest rea de mem貌ria 茅s accessible per a tots els fils d'execuci贸 involucrats, permetent un acc茅s directe i eficient a les dades compartides.

* **Espai d'adre莽ament 煤nic**: Fils d'execuci贸 d'un proc茅s.
* **M煤ltiples espai d'adreces**: Zones de Mem貌ria que s贸n accessibles per processos diferents.
* *S'ha de controlar/sincronitzar* l'acc茅s a les **dades compartides** per assegurar la consist猫ncia de les dades amb mecanismes com semfors, mutex o candaus.

## Ex: Comunicaci贸 amb Mem貌ria Compartida (C)

```c
key_t key = ftok("fitxer_clau", 'R');
int shmid = shmget(key, 1024, 0666 | IPC_CREAT);
char *shared_memory = (char *)shmat(shmid, (void *)0, 0);

// Escriure dades a la mem貌ria compartida
strcpy(shared_memory, "Missatge a la mem貌ria compartida");

// Llegir dades de la mem貌ria compartida
printf("Missatge llegit: %s\n", shared_memory);

// Alliberar mem貌ria compartida
shmdt((void *)shared_memory);
shmctl(shmid, IPC_RMID, NULL);
```

## Llibreries de Mem貌ria compartida 

- **pthread (POSIX Threads)**: s una interf铆cie estndard que facilita la creaci贸 i gesti贸 de fils d'execuci贸 (threads) en C. Permet als processos tenir m煤ltiples fils d'execuci贸 que comparteixen mem貌ria i recursos.

- **OpenMP**: s una API que facilita la programaci贸 paral路lela. Permet als desenvolupadors marcar parts del codi com a regions paral路leles, que s'executaran de forma concurrent en diferents fils d'execuci贸.

## Comparaci贸/Selecci贸 de mecanismes de comunicaci贸 {.smaller}

- **Fitxers**: Comunicaci贸 temporal de dades. No recomanat.
- **Pipes**: Comunicaci贸 *unidireccional* entre processos amb un antecessor com煤.
- **FIFOS**: Comunicaci贸 *unidireccional* entre processos amb un antecessor com煤.
- **Cues de missatges**: Quan es necessita enviar missatges amb sincronitzaci贸 as铆ncrona i buffering.
- **Sockets**: Comunicaci贸 a trav茅s de la xarxa o local.
- **Mem貌ria compartida**: Quan es necessita accedir rpidament a dades compartides entre processos.


## Aix貌 茅s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE


:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::