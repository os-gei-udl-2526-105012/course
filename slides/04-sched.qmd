---
title: "Planificaci√≥ de processos"
subtitle: "Unitat 4 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 4 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

# Conceptes b√†sics

## Necessitat d'un proc√©s

Els **processos** presenten necessitats variades a l‚Äôhora d‚Äôutilitzar els recursos del sistema. En general, la majoria dels processos passen per **cicles de burst**, alternant entre per√≠odes d‚Äôactivitat *intensiva d'√∫s del processador (CPU)* i per√≠odes d‚Äôactivitat *d‚Äôentrada/sortida (E/S)*.

![](../figures/slides/04-sched/cicle-burst.png)

## Situaci√≥ 1: Executant un proc√©s

::: {.callout-note icon="false"}
## Obrint el firefox

Assumiu un sistema Linux on volem executar √∫nicament Firefox, assumint que la resta de processos del sistema operatiu s'executen en un altre processador.
:::

![](../figures/slides/04-sched/scheduling-intro-01.png)

::: notes
Assumim un sistema operatiu amb un sol processador on un usuari vol executa el proc√©s Firefox. En aquest escenari, el sistema operatiu ha de de gestionar la Mem√≤ria Principal, el Processador i el disc. Per fer-ho, l'usuari obre l'aplicaci√≥ Firefox des de l'espai d'usuari i el sistema operatiu gestiona la seva execuci√≥ en l'espai del nucli. Per simplificar, considerarem que tots els processos del sistema operatiu s'executen en un altre processador, i que el nucli del sistema operatiu no es veu afectat per la c√†rrega de treball de l'usuari.
:::

## Situaci√≥ 1: Accions del SO

![](../figures/slides/04-sched/scheduling-intro-02.png)

::: {.callout-note icon="false"}
## Resum

El SO (1) Carrega a Mem√≤ria Principal. (2) El planificador selecciona el proc√©s. (3) Despatxa a la CPU. (4) L'usuari interactua amb l'aplicaci√≥.
:::

::: notes
Per executar l'Aplicaci√≥ 1 (APP1), el sistema operatiu realitza les seg√ºents accions:

1.  **Carrega el proc√©s (APP1) a la Mem√≤ria Principal.** (Indicat amb el n√∫mero 1 a la imatge)
2.  **El Planificador despatxa APP1 al Processador.** (Pas conceptual que porta del n√∫mero 2 al 3 a la imatge)
3.  **L'usuari interactua amb APP1.** (Representat a l'Espai Usuari amb el n√∫mero 4)
:::

## Situaci√≥ 1: Execuci√≥ Concurrent

![](../figures/slides/04-sched/scheduling-intro-03.png)

::: notes
Imaginem ara que apareix una segona aplicaci√≥ (APP2) mentre APP1 encara s'est√† executant o est√† a la mem√≤ria principal. En un sistema monoprogramat, APP2 hauria d'esperar que APP1 finalitzi per poder comen√ßar la seva execuci√≥.
:::

## Mono vs. Multiprogramaci√≥

::: callout-tip
## Qu√® Succeeix?

Qu√® passa en aquest escenari si el sistema operatiu √©s **monoprogramat**? I si √©s **multiprogramat**? Pensa en com es gestionarien APP1 i APP2 en cada cas.
:::

::: fragment
-   **Monoprogramat:** Nom√©s un proc√©s a la mem√≤ria. APP2 ha d'esperar que APP1 acabi.
-   **Multiprogramat:** M√∫ltiples processos a la mem√≤ria. APP2 pot ser carregat i executat mentre APP1 est√† en espera o en execuci√≥.
:::

::: notes
En un sistema monoprogramat, fins que APP1 no finalitza, cap altra aplicaci√≥ pot utilitzar el processador de manera activa. Per tant APP1 i APP2 no poden conviure en mem√≤ria de forma concurrent. En canvi, en un sistema multiprogramat si.
:::

## Sistema Multiprogramat

![](../figures/slides/04-sched/scheduling-intro-04.png)

::: notes
En un sistema operatiu **multiprogramat**, com els que utilitzem actualment, ambdues aplicacions (APP1 i APP2) es carreguen a la Mem√≤ria Principal, dins l'espai d'adreces de l'usuari.

El **Planificador** (representat amb el signe d'interrogaci√≥, indicant la seva decisi√≥) utilitza un algorisme per decidir quin proc√©s (APP1 o APP2) s'executar√† al **Processador** en un moment donat.

Aquest proc√©s de decisi√≥ es repeteix cont√≠nuament. Un proc√©s pot sortir del processador i tornar a la Mem√≤ria Principal i un altre proc√©s pot deixar la Mem√≤ria Principal per accedir al processador.

D'aquesta manera, es crea la **concurr√®ncia**: ambdues aplicacions semblen executar-se alhora des de la perspectiva de l'usuari, permetent una utilitzaci√≥ m√©s eficient dels recursos del sistema i una millor experi√®ncia d'usuari.
:::

## Quin √©s l'objectiu de la planificaci√≥?

![](../figures/slides/04-sched/scheduling-sched-obj.png)

:::: notes
Com que hi ha m√∫ltiples processos a mem√≤ria per√≤ la CPU nom√©s pot executar-ne un a la vegada, el sistema operatiu utilitza un algorisme de planificaci√≥ per decidir:

::: non-incremental
1.  Quin proc√©s s'executa (i quin espera).
2.  En quin ordre s'assignen els recursos.

-   **Maximitzar l'√∫s dels recursos computacionals** (CPU, mem√≤ria, disc, xarxa, etc.).
-   **Minimitzar el temps d'espera dels processos**, garantint que els usuaris puguin executar tasques de manera eficient i r√†pida.
:::
::::

## Com funciona el planificador?

```{mermaid}
%%| echo: false
classDiagram
    direction LR

    class Scheduler {
        +selectProcess() Process
        +dispatch()
        +handleInterrupt(Interrupci√≥)
    }

    class ReadyQueue {
        +enqueue(Process)
        +dequeue() Process
        +sortBy()
        +processes: Process[]
    }

    class Process {
        +pid: int
        +priority: int
        +state: ProcessState
        +pcb: PCB
        +execute()
        +requestIO(IODevice)
        +yield()
    }

    class PCB {
        +context: Context
        +memoryInfo: MemoryInfo
        +ioInfo: IOInfo[]
        +saveContext()
        +loadContext()
    }

    class CPU {
        +currentProcess: Process
        +executeCycle()
        +raiseInterrupt(Interrupci√≥)
    }

    class IODevice {
        +deviceId: int
        +startIO(Process)
        +completeIO(int eventId)
    }

    class Interrupci√≥ {
        TIMER
        IO_COMPLETION
        SYSCALL
        ERROR
    }


    Scheduler --> ReadyQueue: selecciona
    Scheduler --> Despatxador: utilitza

    Despatxador --> CPU: controla
    Despatxador --> PCB: gestiona

    ReadyQueue "1" --> "*" Process: cont√©

    CPU --> Process: executa 0..1 
    CPU --> Interrupci√≥: genera
    CPU --> Scheduler: notifica

    IODevice --> Process: bloqueja/desbloqueja
    IODevice --> Interrupci√≥: genera
    IODevice --> Scheduler: notifica

    Process --> PCB: t√©
    Process --> CPU: s'executa
    Process --> IODevice: sol¬∑licita


```

## Quan s'ha de planificar?

![](../figures/slides/04-sched/scheduling-trigger-decision.png)

::: callout-tip
## El planificador s'executa:

En resposta a interrupcions o esdeveniments: a) **Interrupcions de rellotge**, b) **Crides al sistema**, c) **Finalitzaci√≥ d'operacions d'E/S**.
:::

::: notes
-   Interrupcions de rellotge (timer interrupts): Periodiques, per permetre el temps compartit.
-   Crides al sistema: Quan un proc√©s sol¬∑licita un recurs o canvia el seu estat.
-   Finalitzaci√≥ d'operacions d'E/S: Quan un dispositiu completa una operaci√≥ per a un proc√©s en espera.
:::

## Qu√® √©s l'apropiaci√≥?

![](../figures/slides/04-sched/scheduling-sched-preemption.png)

::: callout-tip
## Observacions

1.  ‚Üë *complexitat* del SO ‚Üí **Canvi de contexts**.
2.  ‚Üë *cost* ‚Üí Interrupcions peri√≤diques.
3.  ‚Üë la justicia i l'equitat.
:::

## Criteris de planificaci√≥ (Generals)

-   **Just√≠cia** Acc√©s equitatiu als recursos per a tots els processos.
-   **Equilibri** Totes les parts del sistema estiguin utilitzades.
-   **Prioritzaci√≥**: Prefer√®ncia a processos amb m√©s urg√®ncia.

## Criteris de planificaci√≥ (En lot)

-   **Utilitzaci√≥ de la CPU**: % de temps d'ocupaci√≥.
-   **Productivitat**: N¬∫ de processos completats per unitat de temps.
-   **Temps de retorn**: Temps total des que un proc√©s s‚Äôenvia fins que es completa, incloent temps d‚Äôespera i execuci√≥.

## Criteris de planificaci√≥ (Interactius)

-   **Temps d'espera**: Temps que un proc√©s roman a la cua de preparats.
-   **Temps de resposta**: Temps entre una sol¬∑licitud de l‚Äôusuari i la primera resposta.

## Criteris de planificaci√≥ (Temps real)

-   **Predictibilitat**: Capacitat del sistema per complir els requisits temporals de manera sistem√†tica.
-   **Deadline**: Capacitat de garantir que els processos finalitzin abans d‚Äôun temps l√≠mit establert.

## Minimitzar el temps de resposta

-   Minimitzar el temps transcorregut per completar una operaci√≥.
-   Minimitzar el temps que l'usuari percep.
    -   Temps per mostrar una tecla en un editor.
    -   Temps per compilar un programa.
    -   Tasques en temps real: complir terminis imposats per l'entorn.

## Maximitzar el rendiment

-   Maximitzar les operacions per segon.
-   Relacionat amb el temps de resposta, per√≤ no id√®ntic.
    -   Minimitzar el temps de resposta pot portar a m√©s canvis de context que si nom√©s es maximitza el rendiment.
-   Dos aspectes per maximitzar el rendiment:
    -   Minimitzar la sobrec√†rrega (per exemple, canvis de context).
    -   √ös eficient dels recursos (CPU, disc, mem√≤ria, etc).

## Just√≠cia

-   Compartir la CPU entre els usuaris de manera equitativa.
-   La just√≠cia no √©s minimitzar el temps de resposta mitj√†.
    -   Reduir el temps de resposta mitj√† pot comportar en alguns casos planificacions injustes.

## Planificaci√≥ √≤ptima

-   No existeix cap pol√≠tica **√≤ptima** que permeti satisfer tots els criteris anteriors al mateix temps.

-   Un algorisme pot *maximitzar* el **throughput** per√≤ no *minimitzar* el **temps de resposta**.

::: {.center-container .fragment}
La selecci√≥ de l'algorisme de planificaci√≥ dep√®n dels objectius espec√≠fics del sistema i de la c√†rrega de treball que s'espera gestionar.
:::

::: notes
Imagina un conjunt de tasques curtes i llargues, si sempre seleccionem les curtes optimitzarem el **throughput** per√≤ a cost del **temps de resposta**.
:::

# Algorismes de planificaci√≥

## FCFS - First-Come, First-Served

```{mermaid}
%%| echo: false
flowchart LR
    classDef iniciFi fill:#00A896,color:white,stroke:#007D6C,stroke-width:2px,font-size:22px;
    classDef decisio fill:#C46B9E,color:white,stroke:#963D6D,stroke-width:2px,font-size:22px;
    classDef proces fill:#fff,color:#333,stroke:#00A896,stroke-width:2px,font-size:22px;

    A([Inici]):::iniciFi --> B{Hi ha<br>processos<br>pendents?}:::decisio
    B -->|S√≠| C[[Ordenar per<br>arribada]]:::proces
    C --> D[[Executar<br>fins finalitzaci√≥]]:::proces
    D --> E{Tots<br>executats?}:::decisio
    E -->|No| C
    E -->|S√≠| F([Fi]):::iniciFi
    B -->|No| F

    linkStyle default stroke:#666, arrowhead:vee;
    style A text-align:center;
    style B text-align:center;
    style C text-align:center;
    style D text-align:center;
    style E text-align:center;
    style F text-align:center;
```

::: notes
L'algorisme FCFS √©s un dels m√©s senzills: funciona com una cua de persones; el primer que arriba √©s el primer que s'at√©n. Els processos s'executen en l'ordre d'arribada, sense considerar prioritat ni durada del burst. Adequat per sistemes previsibles o de lot amb processos de durada similar. Pot generar efecte convoy, on un proc√©s llarg bloqueja els curts, augmentant el temps d'espera.
:::

## FCFS - Caracter√≠stiques

-   **Simplicitat:** Algorisme senzill d'implementar i comprendre.
-   **No apropiatiu:** Un proc√©s s'executa fins a la seva finalitzaci√≥ o bloqueig.
-   **Garantia de no inanici√≥:** Tots els processos eventualment s'executen (sota la suposici√≥ que acaben).

## FCFS - Limitacions

-   **Efecte Convoy:** Processos curts poden quedar bloquejats per processos llargs, incrementant el temps d'espera mitj√†.
-   **Pot generar temps d'espera elevats:** Especialment per a processos curts darrere de processos llargs.

Adequat per a c√†rregues de treball **homog√®nies** on la durada dels processos √©s similar. Poc √≤ptim per a entorns amb variabilitat en la durada dels processos, ja que pot afectar la resposta i l'efici√®ncia del sistema.

## FCFS - Exemple Il¬∑lustratiu

::::: columns
::: {.column width="40%"}
|  $p$[^1]  | $t_a$[^2] | $t_{cpu}$[^3] |
|:---------:|:---------:|:-------------:|
| üü¢ **P1** |     0     |      20       |
| üîµ **P2** |     5     |       5       |
| üü£ **P3** |     6     |       5       |
:::

::: {.column width="55%"}
```{mermaid}
%%| echo: false
%%| column: screen-inset
gantt 
    title Planificaci√≥
    dateFormat  X
    axisFormat %s
    
    section Execuci√≥
    üü¢ P1 : 0, 20
    üîµ P2 : 20, 25
    üü£ P3 : 25, 30
    
    section Preparats
    üîµ P2 a la cua : 5, 20
    üü£ P3 a la cua : 6, 25
```
:::
:::::

[^1]: Proc√©s

[^2]: Temps d‚Äôarribada

[^3]: Durada del burst

## FCFS - Exemple Il¬∑lustratiu (M√®triques)

::::: columns
::: {.column width="50%"}
-   **Temps espera**:\
    $T_{espera} = T_f + T_a - T_{cpu}$
-   **Temps retorn**:\
    $T_{retorn} = T_f - T_a$
-   **Temps resposta**:\
    $T_{resposta}= T_{inici} - T_a$
:::

::: {.column width="50%"}
| M√®trica         | P1  | P2  | P3  | Avg   |
|-----------------|-----|-----|-----|-------|
| $T_a$[^4]       | 0   | 5   | 6   | \-    |
| $T_f$[^5]       | 20  | 25  | 30  | \-    |
| $T_{inici}$[^6] | 0   | 20  | 25  | \-    |
| $T_{cpu}$[^7]   | 20  | 5   | 5   | \-    |
| $T_{espera}$    | 0   | 15  | 19  | 11.33 |
| $T_{retorn}$    | 20  | 20  | 24  | 21.33 |
| $T_{resposta}$  | 0   | 15  | 19  | 11.33 |
:::
:::::

[^4]: Temps d'arribada

[^5]: Temps de finalitzaci√≥

[^6]: Temps del primer cicle d'execuci√≥

[^7]: Durada del burst

## Exercici 01: FCFS - Enunciat {.smaller}

Considera els seg√ºents escenari i respon les preguntes:

| Proc√©s | Temps arribada | R√†fegues  |
|--------|----------------|-----------|
| A      | 0              | $7_{CPU}$ |
| B      | 2              | $4_{CPU}$ |
| C      | 3              | $2_{CPU}$ |

1.  Dibuixa el diagrama de Gantt per a l'algorisme FCFS.
2.  Calcula les seg√ºents m√®triques de rendiment: Percentatge d'√∫s de la CPU, Productivitat, Temps d'espera mitj√†, Temps de retorn mitj√† i Temps de retorn normalitzat mitj√†.
3.  Quin √©s l'efecte convoy en aquest exemple? Com afecta les m√®triques calculades?

## Exercici 01: FCFS - Soluci√≥ {.smaller}

::::::: columns
::: {.column width="40%"}
| P   | 0   | 2   | 3   | 7   | 8   | 11  | 12  | 13  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| A   | E   | E   | E   | F   |     |     |     |     |
| B   |     | P   | P   | E   | E   | F   |     |     |
| C   |     |     | P   | P   | P   | E   | E   | F   |
:::

::::: {.column width="60%"}
::: fragment
$$ \%_{CPU} = \dfrac{Tcpu_{ocupada}}{Temps}=\dfrac{13}{13}=1=100\%$$
:::

::: fragment
$$ Productivitat = \dfrac{\#processos}{Temps}=\dfrac{3}{13}=0.23$$
:::
:::::
:::::::

::: fragment
$$ \tilde{T}_{espera}= \dfrac{\tilde{T}_{espera}{A} + \tilde{T}_{espera}{B} + \tilde{T}_{espera}{C} }{\#processos}=\dfrac{0+5+8}{3}=4.3$$
:::

::: fragment
$$ \tilde{T}_{retorn} = \dfrac{\tilde{T}_{retorn}{A} + \tilde{T}_{retorn}{B} + \tilde{T}_{retorn}{C}}{\#processos}=\dfrac{7+9+10}{3}=8.6$$
:::

::: fragment
$$ \tilde{T}retorn_{N} = \dfrac{7/7 + 9/4 + 10/2}{3}=2.75$$
:::

## Exercici 01: FCFS - An√†lisi {.smaller}

1.  **Efecte Convoy:** El proc√©s P1 (llarg) bloqueja els processos P2 i P3 (curts), incrementant el temps d'espera.
2.  **Sensible a l'ordre arribada:** Si P2 o P3 hagu√©s arribat abans que P1, el temps d'espera de P2 hauria estat menor.
3.  **No apropiatiu:** P1 ocupa la CPU fins a la seva finalitzaci√≥, sense donar oportunitat a P2 i P3.
4.  **No √©s adequat per a sistemes interactius o en temps real:** Els usuaris poden experimentar retards significatius en la resposta del sistema, ja que els processos curts poden quedar bloquejats darrere de processos llargs.

## RR - Diagrama de flux

```{mermaid}
%%| echo: false
flowchart LR
    classDef iniciFi fill:#00A896,color:white,stroke:#007D6C,stroke-width:2px,font-size:22px;
    classDef decisio fill:#C46B9E,color:white,stroke:#963D6D,stroke-width:2px,font-size:22px;
    classDef proces fill:#fff,color:#333,stroke:#00A896,stroke-width:2px,font-size:22px;

    A([Inici]):::iniciFi --> B{Hi ha<br>processos<br>pendents?}:::decisio
    B -->|S√≠| C[[Agafar proc√©s<br>de la cua]]:::proces
    C --> D{Temps del quantum<br>expirat?}:::decisio
    D -->|No| E[[Executar proc√©s]]:::proces
    E --> D
    D -->|S√≠| F[[Col¬∑locar al final de la cua]]:::proces
    F --> B
    B -->|No| G([Fi]):::iniciFi
```

## Round Robin (RR)

Aquesta pol√≠tica √©s una variant de FCFS que introdueix l'**apropiaci√≥** mitjan√ßant l'√∫s de **quantums de temps**.

-   Cada proc√©s rep un **quantum de temps** per executar-se.
-   Quan el **quantum** expira, el proc√©s √©s interromput i col¬∑locat al final de la cua de preparats.

::: {.fragment .center-container}
Quin √©s el temps d'espera en un sistema amb $n$ processos i un **quantum** de $q$ unitats de temps?*Amb arribades simult√†nies i sense variabilitat en bursts*.

-   El temps d'espera m√†xim per a qualsevol proc√©s √©s de $(n-1) \cdot q$ unitats de temps.
:::

## RR - Caracter√≠stiques

-   Cap proc√©s pot monopolitzar la CPU durant un **temps determinant (**$q$).
-   Utilitza una **cua FIFO** per gestionar els processos preparats.
-   Utilitza una **interrupci√≥ de rellotge** per implementar el quantum de temps.
-   √âs un algorisme **apropiatiu**.

## RR - Impacte del quantum de temps

Si analitzem l'elecci√≥ del quantum de temps ($q$):

-   Si $q$ √©s molt petit:
    -   Augmenta el nombre de canvis de context.
    -   Incrementa la sobrec√†rrega del sistema.
    -   Pot reduir l'efici√®ncia i el throughput.
-   Si $q$ √©s molt gran:
    -   El comportament s'assembla a FCFS.
    -   Pot augmentar el temps de resposta per a processos curts.

## RR - Exemple en sistemes interactius {.smaller}

RR √©s especialment adequat per a sistemes interactius on es requereix que els processos curts rebin resposta r√†pida.

-   En sistemes interactius, els processos es poden classificar com a:

    -   **Processos d'usuari**: Requereixen m√©s temps de CPU.
    -   **Processos del sistema**: Requereixen menys temps de CPU per√≤ respostes m√©s r√†pides.

-   Es pot assignar diferents quantums de temps segons el tipus de proc√©s.

-   A UNIX, per exemple, s'utilitzen diferents quantums per a processos d'usuari i del sistema per equilibrar la resposta i l'efici√®ncia.

    -   $q = 100ms$ per a processos d'usuari.
    -   $q = 10ms$ per a processos del sistema.
    -   El overhead del canvi de context √©s d'aproximadament $0.1ms - 1ms$. Aquest valor √©s petit comparat amb la durada del quantum, per√≤ rellevant si els quantum s√≥n molt petits.

## RR Q(20s) - Exemple Il¬∑lustratiu

::::: columns
::: {.column width="40%"}
|  $p$  | $t_a$ | $t_{cpu}$ |
|:-----:|:-----:|:---------:|
| üü¢ P1 |   0   |    53     |
| üîµ P2 |   0   |     8     |
| üü£ P3 |   0   |    68     |
| üü† P4 |   0   |    24     |

|                      | P1  | P2  | P3  | P4  | Avg   |
|----------------------|-----|-----|-----|-----|-------|
| $\tilde{T}_{espera}$ | 72  | 20  | 85  | 88  | 66.25 |
| $\tilde{T}_{retorn}$ | 125 | 28  | 153 | 112 | 104.5 |
:::

::: {.column width="55%"}
```{mermaid}
%%| echo: false
%%| column: screen-inset

gantt
title Planificaci√≥ Round Robin (Q=20)
dateFormat  X
axisFormat %s

section Execuci√≥
üü¢ P1 : 0, 20
üîµ P2 : 20, 28
üü£ P3 : 28, 48
üü† P4 : 48, 68
üü¢ P1 : 68, 88
üü£ P3 : 88, 108
üü† P4 : 108, 112
üü¢ P1 : 112, 125
üü£ P3 : 125, 145
üü£ P3 : 145, 153
```
:::
:::::

## RR Q(20s) - Impacte de $Q$ (Temps d'espera)

| Quantum / Estrat√®gia | P1  | P2  | P3  | P4  | Avg.  |
|----------------------|-----|-----|-----|-----|-------|
| Millor FCFS          | 32  | 0   | 85  | 8   | 31.25 |
| Q=1                  | 84  | 22  | 85  | 57  | 62    |
| Q=5                  | 82  | 20  | 85  | 58  | 61.25 |
| Q=20                 | 72  | 20  | 85  | 88  | 66.25 |
| Pitjor FCFS          | 68  | 145 | 0   | 121 | 83.5  |

## RR Q(20s) - Impacte de $Q$ (Temps de finalitzaci√≥)

| Quantum / Estrat√®gia | P1  | P2  | P3  | P4  | Avg.   |
|----------------------|-----|-----|-----|-----|--------|
| Millor FCFS          | 85  | 8   | 153 | 32  | 69.5   |
| Q=1                  | 137 | 30  | 153 | 81  | 100.25 |
| Q=5                  | 135 | 28  | 153 | 82  | 99.5   |
| Q=20                 | 125 | 28  | 153 | 112 | 104.5  |
| Pitjor FCFS          | 121 | 153 | 68  | 145 | 121.75 |

::: notes
Quantum molt petit ‚Üí molts canvis de context ‚Üí sobrec√†rrega i baix throughput.

Quantum molt gran ‚Üí es comporta com FCFS ‚Üí mala resposta per a processos curts.

RR √©s ideal per a entorns interactius, per√≤ el quantum ha de ser triat amb cura per equilibrar lat√®ncia i efici√®ncia.
:::

## Exercici 02: RR - Enunciat {.smaller}

Considera els seg√ºents processos i un planificador **(RR(Q=1))** *si dos processos arriben al mateix temps, s'executar√† el proc√©s amb prioritat m√©s elevada; en aquest cas concret (C,B,A)*:

| Proc√©s | Temps arribada | R√†fegues  |
|--------|----------------|-----------|
| A      | 0              | $7_{CPU}$ |
| B      | 2              | $4_{CPU}$ |
| C      | 3              | $2_{CPU}$ |

1.  Dibuixa el diagrama de Gantt per a l'algorisme Round-Robin amb un quantum de 1 unitat de temps.
2.  Calcula les seg√ºents m√®triques de rendiment: Temps d'espera mitj√†, Temps de retorn mitj√†, Temps de resposta mitj√† i Temps de retorn normalitzat mitj√†.

## Exercici 02: RR - Soluci√≥ {.smaller}

| P   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| A   | E   | E   | P   | E   | P   | P   | E   | P   | P   | E   | P   | E   | E   | F   |
| B   |     |     | E   | P   | P   | E   | P   | P   | E   | P   | E   | F   |     |     |
| C   |     |     |     | P   | E   | P   | P   | E   | F   |     |     |     |     |     |

$$ \tilde{T}_{espera}= \dfrac{\tilde{T}_{espera}{A} + \tilde{T}_{espera}{B} + \tilde{T}_{espera}{C} }{\#processos}=\dfrac{6+5+3}{3}=4.66$$ $$ \tilde{T}_{retorn} = \dfrac{\tilde{T}_{retorn}{A} + \tilde{T}_{retorn}{B} + \tilde{T}_{retorn}{C}}{\#processos}=\dfrac{13+9+5}{3}=9$$ $$ \tilde{T}resposta =\dfrac{\tilde{T}_{resposta}{A} + \tilde{T}_{resposta}{B} + \tilde{T}_{resposta}{C}}{\#processos}=\dfrac{0+0+1}{3}=0.33$$ $$ \tilde{T}retorn_{N} = \dfrac{7/7 + 9/4 + 5/2}{3}=2.2$$

## RR vs FCFS (I)

::: {center-container}
Si assumim que el canvi de context triga $0 ms$, **podem afirmar que RR √©s sempre millor que FCFS?**
:::

::: fragment
-   **RR no √©s sempre millor que FCFS**.
-   La decisi√≥ dep√®n de la c√†rrega de treball, la variabilitat dels bursts i els objectius del sistema (*throughput vs temps de resposta*).
:::

::: fragment
Suposa que tenim 10 tasques, cada una amb 100s de burst de CPU i un quantum de 1s, i demostra que FCFS pot ser m√©s eficient que RR en aquest cas.
:::

## RR vs FCFS (II) {.smaller}

::::: columns
::: {.column width="40%"}
| Tasca | Temps finalitzaci√≥ FCFS | Temps finalitzaci√≥ RR |
|-------|-------------------------|-----------------------|
| P1    | 100s                    | 991s                  |
| P2    | 200s                    | 992s                  |
| ...   | ...                     | ...                   |
| P10   | 1000s                   | 1000s                 |
:::

::: {.column width="60%"}
-   Els processos s‚Äôacaben pr√†cticament en el mateix moment amb ambd√≥s algorismes.
-   El **throughput** √©s molt millor amb FCFS en aquest cas, ja que RR introdueix m√©s alternan√ßa entre processos.
-   Els estats de cache poden ser compartits amb RR, per√≤ amb FCFS cada proc√©s pot utilitzar la cache de manera m√©s eficient.
-   RR √©s avantatj√≥s nom√©s quan els processos tenen durades variables o quan es busca responsivitat interactiva. En casos de processos molt llargs i uniformes, FCFS pot ser m√©s eficient.
:::
:::::

## Prioritats

-   L‚Äôalgorisme assigna un valor de prioritat a cada proc√©s, (a linux pots utilitzar `nice` per ajustar la prioritat).
-   En cas d‚Äôempat, es pot aplicar un altre algorisme (habitualment FIFO).
-   Les prioritats poden ser est√†tiques o din√†miques.

```{mermaid}
%%| echo: false
flowchart LR
    classDef iniciFi fill:#00A896,color:white,stroke:#007D6C,stroke-width:2px,font-size:22px;
    classDef decisio fill:#C46B9E,color:white,stroke:#963D6D,stroke-width:2px,font-size:22px;
    classDef proces fill:#fff,color:#333,stroke:#00A896,stroke-width:2px,font-size:22px;    

    A([Inici]):::iniciFi --> B{Hi ha<br>processos<br>pendents?}:::decisio
    B -->|S√≠| C[[Ordenar per<br>prioritat]]:::proces
    C --> D[[Executar proc√©s<br>m√©s prioritari]]:::proces
    D --> E{Tots<br>executats?}:::decisio
    E -->|No| C
    E -->|S√≠| F([Fi]):::iniciFi
    B -->|No| F
```

## Exercici 03: Prioritats - Enunciat {.smaller}

Considera els seg√ºents processos amb les seves respectives prioritats i respon les preguntes:

| Proc√©s | Temps arribada | R√†fegues  | Prioritat |
|--------|----------------|-----------|-----------|
| A      | 0              | $7_{CPU}$ | 5         |
| B      | 2              | $4_{CPU}$ | 1         |
| C      | 3              | $2_{CPU}$ | 6         |

1.  Dibuixa el diagrama de Gantt per a l'algorisme de planificaci√≥ per prioritats (suposant prioritat ascendent -\> B,A,C).
2.  Calcula les seg√ºents m√®triques de rendiment: Percentatge d'√∫s de la CPU, Productivitat, Temps d'espera mitj√†, Temps de retorn mitj√† i Temps de resposta mitj√†.

## Exercici 03: Prioritats - Soluci√≥ {.smaller}

::::: columns
::: {.column width="60%"}
| P   | 0   | 2   | 3   | 6   | 11  | 12  | 13  |
|-----|-----|-----|-----|-----|-----|-----|-----|
| A   | E   | P   | P   | E   | F   |     |     |
| B   |     | E   | E   | F   |     |     |     |
| C   |     |     | P   | P   | E   | E   | F   |
:::

::: {.column width="40%"}
$$ \%_{CPU} = \dfrac{Tcpu_{ocupada}}{Temps}=\dfrac{13}{13}=1=100\%$$ $$ Productivitat = \dfrac{\#processos}{Temps}=\dfrac{3}{13}$$
:::
:::::

$$ \tilde{T}_{espera} = \dfrac{\tilde{T}_{espera}(A) + \tilde{T}_{espera}(B) + \tilde{T}_{espera}(C)}{\#processos}=\dfrac{4+0+8}{3}=4$$ $$ \tilde{T}_{retorn} = \dfrac{\tilde{T}_{retorn}(A) + \tilde{T}_{retorn}(B) + \tilde{T}_{retorn}(C)}{\#processos}=\dfrac{11+4+10}{3}=8.33$$ $$ \tilde{T}_{resposta} = \dfrac{\tilde{T}_{resposta}(A) + \tilde{T}_{resposta}(B) + \tilde{T}_{resposta}(C)}{\#processos}=\dfrac{0+0+8}{3}=2.66$$

## Envelliment {.smaller}

Amb els **algorismes de prioritat**, els processos amb prioritat baixa poden quedar inactius indefinidament (**inanici√≥**) si sempre hi ha processos amb prioritat m√©s alta a la cua de preparats.

**L'envelliment** √©s una estrat√®gia utilitzada per abordar el problema d'inanici√≥ que pot sorgir en els algorismes de planificaci√≥ basats en prioritats. Augmenta peri√≤dicament la prioritat dels processos preparats que no aconsegueixen executar-se.

``` pseudocode
function Aging(processes):
    for each process in processes:
        if process.waitingTime >= agingThreshold:
            process.increasePriority() // Augmenta la prioritat del proc√©s
```

## I si coneixem el futur? ‚Äì SJF i SRTF {.smaller}

1.  Shortest Job First (SJF)
    -   Executa el proc√©s amb menor temps de CPU total.
    -   Tamb√© conegut com Shortest Time to Completion First (STCF).
    -   Politica no apropiativa: un cop un proc√©s comen√ßa, s‚Äôexecuta fins al final del burst o fi del proc√©s.
2.  Shortest Remaining Time First (SRTF)
    -   Versi√≥ apropiativa de SJF.
    -   Si arriba un proc√©s amb un temps restant menor que el del proc√©s actual, aquest √©s interromput immediatament.
    -   Tamb√© conegut com Shortest Remaining Time to Completion First (SRTCF).

## SJF - Exemple Il¬∑lustratiu

::::: columns
::: {.column width="40%"}
|  $p$[^8]  | $t_a$[^9] | $t_{cpu}$[^10] |
|:---------:|:---------:|:--------------:|
| üü¢ **P1** |     0     |       10       |
| üîµ **P2** |     0     |       5        |
| üü£ **P3** |     1     |       4        |
:::

::: {.column width="55%"}
```{mermaid}
%%| echo: false
gantt
title Planificaci√≥ SJF
dateFormat  X
axisFormat %s

section Execuci√≥
üîµ P2 : 0, 5
üü£ P3 : 5, 9
üü¢ P1 : 9, 19

section Preparats
üü¢ P1 a la cua : 0, 9
üü£ P3 a la cua : 1, 5
```

| M√®trica        | P1  | P2  | P3  | Mitjana |
|----------------|-----|-----|-----|---------|
| $T_{espera}$   | 9   | 0   | 4   | 4.33    |
| $T_{retorn}$   | 19  | 5   | 8   | 10.67   |
| $T_{resposta}$ | 9   | 0   | 4   | 4.33    |
:::
:::::

[^8]: Proc√©s

[^9]: Temps d‚Äôarribada

[^10]: Durada del burst

## SJF - Caracter√≠stiques

1.  Pot provocar **inanici√≥**? S√≠, qualsevol pol√≠tica que prioritzi una propietat pot provocar inanici√≥.
2.  Pot provocar **convoy**? S√≠, qualsevol pol√≠tica no apropiativa pot provocar convoy.
3.  Redueix el temps de retorn? S√≠, redueix el temps mitj√† de finalitzaci√≥ si i nom√©s si tots els processos arriben alhora.
4.  Requereix coneixement previ del temps de burst? S√≠, √©s un dels seus inconvenients principals.

## SRTF - Exemple Il¬∑lustratiu

::::: columns
::: {.column width="40%"}
|  $p$  | $t_a$ | $t_{cpu}$ |
|:-----:|:-----:|:---------:|
| üü¢ P1 |   0   |    20     |
| üîµ P2 |   5   |     5     |
| üü£ P3 |   8   |     1     |
:::

::: {.column width="55%"}
```{mermaid}
%%| echo: false
gantt
title Planificaci√≥ SRTF
dateFormat  X
axisFormat %s

section Execuci√≥
üü¢ P1 : 0, 5
üîµ P2 : 5, 8
üü£ P3 : 8, 9
üîµ P2 : 9, 11
üü¢ P1 : 11, 22

section Preparats
üü¢ P1 a la cua : 5, 11
üîµ P2 a la cua : 8, 9
```

| M√®trica        | P1  | P2  | P3  | Mitjana |
|----------------|-----|-----|-----|---------|
| $T_{espera}$   | 6   | 1   | 0   | 2.33    |
| $T_{retorn}$   | 22  | 6   | 1   | 9.67    |
| $T_{resposta}$ | 0   | 0   | 0   | 0       |
:::
:::::

## SRTF - Caracter√≠stiques

-   **Apropiatiu**: un proc√©s curt pot interrompre un proc√©s m√©s llarg.
-   Redueix significativament el temps mitj√† de resposta per a processos curts.
-   Pot provocar inanici√≥ en processos llargs si arriben processos curts constantment.
-   Cal considerar canvis de context i el seu cost associat.

## Preveient el futur: SRTF com a refer√®ncia

-   Si pogu√©ssim con√®ixer el temps restant de cada proc√©s, sempre podr√≠em executar el proc√©s que acabaria abans.

::: {.center-container .fragment}
Com fer-ho en la pr√†ctica?
:::

-   Alguns sistemes demanen a l‚Äôusuari indicar la durada estimada del job. Per evitar abusos, el sistema pot interrompre jobs que superin aquesta durada.
-   √âs molt dif√≠cil predir amb precisi√≥ el temps de burst, fins i tot per usuaris honestos.

## SRTF: el l√≠mit te√≤ric

-   SRTF (Shortest Remaining Time First) √©s una pol√≠tica √≤ptima pel temps de resposta mitj√†.
-   Cap altra pol√≠tica pot superar SRTF en aquest criteri.
-   Es fa servir sovint com a refer√®ncia de comparaci√≥ amb altres algorismes.

## Com es pot predir el futur?

Una estrat√®gia comuna √©s utilitzar estimacions basades en l'historial de comportament dels processos. Molts programes mostren patrons repetitius en la seva utilitzaci√≥ de la CPU i I/O. Si els processos tenen un comportament aleatori, aquesta estrat√®gia no seria √∫til.

$$t_n = f(t_{n-1}, t_{n-2}, t_{n-3}, \ldots)$$ On: $t_n$ √©s la durada estimada del seg√ºent burst de CPU. $f$ √©s una funci√≥ que utilitza els bursts anteriors per fer la predicci√≥.

::: center-container
Si un proc√©s ha estat E/S o CPU en el passat, probablement continuar√† sent-ho en el futur.
:::

## Exercici 04: SJF vs RR {.smaller}

Realitza la planificaci√≥ dels seg√ºents processos utilitzant els algorismes de planificaci√≥ **Round Robin amb un quantum de 3 unitats de temps** i **SJF (Shortest Job First) no apropiatiu**. En cas d'empat on 2 processos arribin a la cua de preparats al mateix temps, s'executar√† el proc√©s amb prioritat m√©s elevada en aquest cas (*B,A,C*).

| Proc√©s | Temps arribada | R√†fegues                                  |
|--------|----------------|-------------------------------------------|
| A      | 7              | $5_{CPU},2_{E/S},4_{CPU}$                 |
| B      | 3              | $4_{CPU},1_{E/S},1_{CPU},1_{E/S},1_{CPU}$ |
| C      | 1              | $2_{CPU},1_{E/S},3_{CPU},2_{E/S},1_{CPU}$ |

Es demana:

-   Mostrar la planificaci√≥ dels processos en un diagrama de Gantt.
-   Calcular el temps d'espera, resposta i retorn mitj√† de cada proc√©s.
-   Comparar els resultats obtinguts amb els algorismes de planificaci√≥.

Les solucions es troben a: [Round Robin Q=3](../activities/unit03/solutions/Diapositives_RRQ3.pdf) i [SJF](../activities/unit03/solutions/Diapositives_SJF_Noapropiatiu.pdf).

## Qu√® s√≥n les cues multinivell? {.smaller}

**Objectiu**: Optimitzar l'√∫s de la CPU separant processos segons les seves necessitats de recursos (com ara intensitat d'E/S o de CPU) i assignant-los a diferents cues, cadascuna amb pol√≠tiques de planificaci√≥ personalitzades.

::::: columns
::: {.column width="50%"}
![](../figures/slides/04-sched/cua-sense-retroalimentacio.png){scale="80%"}

**Cues Multinivell sense Retroalimentaci√≥**:

-   Assignaci√≥ fixa de processos a una cua segons les seves caracter√≠stiques inicials.
-   No es permet el moviment entre cues; cada proc√©s roman a la seva cua original.
:::

::: {.column width="50%"}
![](../figures/slides/04-sched/cua-retroalimentacio.png)

**Cues Multinivell amb Retroalimentaci√≥**:

-   Els processos poden canviar de cua en funci√≥ del seu comportament din√†mic.
-   Inclou promoci√≥ o degradaci√≥ de prioritats segons el rendiment o el consum de recursos.
:::
:::::

## Cues sense Retroalimentaci√≥ {.smaller}

-   **Assignaci√≥ Est√†tica de Processos a Cues:**
    -   Els processos es col¬∑loquen en una cua en funci√≥ de caracter√≠stiques fixes (p. ex., tipus d'operacions).
    -   Exemples: processos intensius en E/S en cues de primer pla i processos intensius en CPU en cues de segon pla.
-   **Pol√≠tiques de Planificaci√≥ Espec√≠fiques per a Cada Cua**:
    -   Round Robin (RR) per a cues de primer pla.
    -   First-Come-First-Served (FCFS) per a cues de segon pla.
-   **Assignaci√≥ de la CPU entre les Cues**:
    -   **Prioritat Absoluta**: S'assigna la CPU primer a la cua amb prioritat m√©s alta i nom√©s quan est√† buida es passa a la seg√ºent.
    -   **Assignaci√≥ Temporal (Time Slicing)**: Cada cua t√© un percentatge fix de temps de CPU, segons la seva prioritat (p. ex., 70% per la prioritat m√©s alta, 20% per la segona, 10% per la m√©s baixa).

## Cues amb Retroalimentaci√≥ {.smaller}

1.  Els processos s‚Äôassignen inicialment a la cua de major prioritat.
2.  El moviment entre cues es basa en el comportament durant l'execuci√≥, permetent que processos intensius en E/S, de curta durada, es mantinguin a prop de la CPU, mentre que els processos CPU-intensius descendeixin per no monopolitzar els recursos.

:::::: fragment
**Exemple**: Els processos curts o amb alta demanda d‚ÄôE/S es mantenen en la part superior, reduint la lat√®ncia de resposta, mentre que processos amb alta demanda de CPU es desplacen r√†pidament cap a cues de menor prioritat, aconseguint una efici√®ncia semblant a SRT (Shortest Remaining Time).

::::: columns
::: {.column width="50%"}
### Promoci√≥

Els processos que completen la seva execuci√≥ dins del seu **quantum** de temps poden ascendir a una cua de prioritat superior.
:::

::: {.column width="50%"}
### Degradaci√≥

Els processos que no completen la seva execuci√≥ dins del **quantum** descendeixen a una cua de prioritat inferior.
:::
:::::
::::::

## Assignaci√≥ Temporal de la CPU en Cues amb Retroalimentaci√≥ {.smaller}

**Quantum de Temps Variable**: Cada cua de prioritat t√© un quantum de temps espec√≠fic i progressivament m√©s llarg en cues de menor prioritat, optimitzant aix√≠ la gesti√≥ de processos de llarga durada.

**Exemple**: Cues Round Robin amb quantums exponencials (1ms, 2ms, 4ms, etc.) per a processos de llarga durada.

**Moviment Din√†mic entre Cues**: Si un proc√©s no finalitza dins del seu quantum assignat, es mou a una cua amb menor prioritat, on rebr√† un quantum m√©s llarg per√≤ menor prioritat d'execuci√≥.

**Exemple**: Els processos amb alta demanda de CPU descendeixen r√†pidament de prioritat, evitant que monopolitzin la CPU. Els processos de curta durada i/o intensius en E/S mantenen la prioritat alta, maximitzant el seu acc√©s a la CPU i reduint la lat√®ncia.

## Estrat√®gies de Planificaci√≥ i Contramesures {.smaller}

-   **Estructura Flexible de Cues**: Les cues amb retroalimentaci√≥ permeten que els processos amb canvis de comportament puguin ajustar la seva posici√≥.
-   **Temps de CPU per Cua**: Cada cua rep un percentatge del temps de CPU: P. ex., cues interactives reben un percentatge m√©s alt per a reduir el temps de resposta.

::: {.center-container .fragment}
Feta la llei, feta la trampa: els usuaris poden manipular les prioritats dels processos per obtenir un millor rendiment, tot i que aix√≤ pot afectar negativament la resta de processos **inversi√≥ de prioritats**.
:::

## Exemple: Othello {.smaller}

-   **Objectiu**: Mantenir el programa en una cua de major prioritat per garantir temps de CPU preferent i una resposta r√†pida en les decisions del joc.
-   El programa executava una s√®rie d'operacions de sortida (`printf()`), aparentment innecess√†ries des d‚Äôun punt de vista funcional. Aquesta activitat d'entrada/sortida feia que el sistema consider√©s el proc√©s com a input/output-bound (intensiu en E/S) en lloc de CPU-bound (intensiu en CPU).
-   **Resultat**: Mantenir-se en una cua de major prioritat gr√†cies a la detecci√≥ del seu comportament d‚ÄôE/S. Evitar el descens de prioritat que es produeix en els processos intensius en CPU que consumeixen els seus quantums sense fer operacions d‚ÄôE/S.

::: fragment
**Nota**: En sistemes de producci√≥, es poden aplicar pol√≠tiques restrictives o t√®cniques d‚Äôan√†lisi per detectar i limitar aquest tipus de manipulacions de prioritat per mantenir l'equilibri i l'efici√®ncia del sistema.
:::

## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE

La planificaci√≥ de processos √©s un dels aspectes m√©s importants dels sistemes operatius. Els algorismes de planificaci√≥ s√≥n fonamentals per garantir l'efici√®ncia i el rendiment del sistema.
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::