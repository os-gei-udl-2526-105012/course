---
title: "Processos a Linux"
subtitle: "Unitat 3 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Qu√® √©s un proc√©s?

Un **proc√©s** √©s una instancia d‚Äôun programa en execuci√≥ (tasca). Aix√≤ vol dir que si **10 usuaris d‚Äôun servidor** utilitzen el mateix programa, com `vi`, hi ha **10 processos** *vi* que s‚Äôexecuten al servidor, tot i que *tots comparteixen el mateix codi executable*.

-   Creaci√≥ i eliminaci√≥.
-   Garantir l'execuci√≥ i finalitzaci√≥.
-   Controlar errors i excepcions.
-   Assignaci√≥ de recursos.
-   Comunicaci√≥ i sincronitzaci√≥.

## `ps` (I) {.smaller}

Imagineu que utilitzem la comanda `sleep 120 &`. Aquest comanda ens crear√† 3 processos *sleep* en *background*. La eina **ps** ens permet veure'ls.

::::: columns
::: {.column width="50%"}
#### `ps -e`

L'opci√≥ **-e** indica a l'ordre que mostri **tots els processos del sistema**. Sense aquesta opci√≥, l'ordre nom√©s mostra els processos de l'usuari a la sessi√≥ actual.

Aquests processos tenen PID *1053, 1054 i 1054*. [*Tamb√© observeu l'ordre ps al final de la llista. Aix√≤ es deu al fet que l'ordre en si tamb√© √©s un proc√©s.*]{.alert}
:::

::: {.column width="50%"}
``` sh
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```
:::
:::::

## `ps` (II) {.smaller}

::::: columns
::: {.column width="50%"}
#### `ps -e`

-   La columna *CMD* identifica el nom del proc√©s en execuci√≥, com ara *sleep*.
-   La primera columna indica l‚Äôidentificador de proc√©s (**PID**) assignat al proc√©s pel sistema operatiu.
-   La segona columna mostra el terminal associat a un proc√©s o *?* si el proc√©s no s‚Äôassocia a cap terminal.
-   Finalment, la tercera columna mostra el *temps de la CPU* del proc√©s.
:::

::: {.column width="50%"}
``` {.sh size="tiny"}
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```
:::
:::::

## `ps` (III) {.smaller}

::::: columns
::: {.column width="50%"}
-   L'identificador de proc√©s (**PID**) √©s un identificador √∫nic per a un proc√©s.
-   El sistema operatiu utilitza un comptador de 32 bits *last_pid* per fer un seguiment de l‚Äô√∫ltim PID assignat a un proc√©s.
-   Quan es crea un proc√©s, el comptador augmenta i el seu valor es converteix en el **PID** del nou proc√©s.
-   El kernel ha de comprovar si el valor de *last_pid*++ ja pertany a una tasca, abans que pugui assignar-lo a un proc√©s nou.
:::

::: {.column width="50%"}
``` {.sh size="tiny"}
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```
:::
:::::

## `top`

::: center-container
![](../figures/slides/03-procs/top.png)
:::

## Estats dels processos {.smaller}

::::::: columns
::: {.column width="33%"}
-   **Nou**: Proc√©s que encara no est√† creat del tot, li falta el *PCB*.
-   **Inactiu**: Quan un proc√©s ha finalitzat.
-   **Preparat**: Quan un proc√©s t√© assignats tots els recursos necessaris per poder executar-se (excepte la CPU).
-   **Execuci√≥**: Quan un proc√©s t√© assignada la CPU.
-   **Espera**: Quan al proc√©s li falta algun recurs per poder executar-se.
:::

::: {.column width="3%"}
:::

:::: {.column width="64%"}
::: fragment
Per veure informaci√≥ dels processos en UNIX tornarem a fer servir la comanda *ps*. Si fem `man ps` i busquem PROCESS STATE CODES, veurem el seg√ºents estats:
:::

-   **D** uninterruptible sleep (usually IO)
-   **I** Idle kernel thread
-   **R** running or runnable (on run queue)
-   **S** interruptible sleep (waiting for an event to complete)
-   **T** stopped by job control signal
-   **t** stopped by debugger during the tracing
-   **W** paging (not valid since the 2.6.xx kernel)
-   **X** dead (should never be seen)
-   **Z** defunct ("zombie") process, terminated but not reaped by its parent
::::
:::::::

## `ps` (IV) {.smaller}

Es pot mostrar m√©s informaci√≥ sobre la llista de processos mitjan√ßant l‚Äôopci√≥ **-l** de l‚Äôordre ps:

``` sh
ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    00:00:00 bash
0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    00:00:00 vi
0 S     0    1064    1034  0  80   0 -  1326 -      pts/0    00:00:00 sleep
4 R     0    1065    1034  0  80   0 -  2405 -      pts/0    00:00:00 ps
```

-   La primera columna (**F**) de la sortida anterior identifica els indicadors de proc√©s (vegeu la p√†gina del manual si esteu interessats). La columna (**S**) indica l'estat d'un proc√©s.

-   Recordeu que sense l'opci√≥ **-e**, `ps` nom√©s mostra els processos al terminal actual, en aquest cas **pts/0**.

## Arbre de processos

-   Estructura jer√†rquica dels processos en formada d'arbre.
-   Tots els processos tenen un proc√©s pare, excepte el proc√©s inicial (**PID = 1**).
-   Els processos poden tenir zero o m√©s processos fills.
-   Els atributs **PID** i **PPID** identifiquen el proc√©s i el seu pare.

::: fragment
En l'exemple anterior, podeu veure que el proc√©s `bash` √©s el pare dels processos `sleep` i `ps`. Si esteu connectats per **ssh** al servidor, el proc√©s `bash` √©s fill del proc√©s `sshd`. I el proc√©s `sshd` √©s fill del proc√©s `init` (PID = 1).
:::

## Qui √©s el pare de PID=1?

El proc√©s amb **PID = 1** √©s el primer proc√©s que s'inicia quan el sistema arrenca. Aquest proc√©s es coneix com a **init** (o **systemd** en sistemes m√©s moderns) i √©s el **pare** de tots els altres processos en execuci√≥ al sistema.

-   Aquest proc√©s *el crea el kernel durant el proc√©s d'arrencada del sistema operatiu*.
-   El kernel √©s responsable de carregar i iniciar el sistema operatiu.
-   Aquest √©s l'√∫nic proc√©s que no t√© un proc√©s pare, ja que √©s el primer proc√©s que s'inicia en el sistema.

## Qu√® √©s un proc√©s inactiu?

Un proc√©s inactiu √©s un proc√©s que esta **esperant a que succeeixi un esdeveniment per poder continuar la seva execuci√≥**.

Aquest **esdeveniment** pot ser una *entrada de l'usuari*, la *finalitzaci√≥ d'una operaci√≥ d'entrada/sortida*, o qualsevol altra condici√≥ que el proc√©s necessita per continuar.

La majoria dels processos del sistema s√≥n **inactius**, que esperen algun tipus d‚Äôesdeveniment, com ara fer clic amb el ratol√≠ o pr√©mer una tecla. A l'exemple anterior, l'√∫nica ordre en execuci√≥ √©s `ps`.

## `pstree` {.smaller}

::::: columns
::: {.column width="50%"}
``` {.sh size="tiny"}
ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY      CMD
4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    bash
0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    vi
0 T     0    1066    1034  0  80   0 -  3448 -      pts/0    vim
0 T     0    1068    1034  0  80   0 -  2358 -      pts/0    top
0 T     0    3502    1034  0  80   0 - 30692 -      pts/0    emacs
0 T     0    3505    1034  0  80   0 - 30692 -      pts/0    emacs
4 R     0    3569    1034  0  80   0 -  2405 -      pts/0    ps
```

------------------------------------------------------------------------

``` sh
su root -c "apt-get install psmisc -y"
```
:::

::: {.column width="50%"}
``` {.sh size="tiny"}
pstree
systemd-|-agetty
        |--cron
        |--dbus-daemon
        |--dhclient---3*[{dhclient}]
        |--exim4
        |--rsyslogd---3*[{rsyslogd}]
        |--sshd-|-sshd---bash-|-2*[emacs---{emacs}]
        |       |             |--pstree
        |       |             |--top
        |       |             |--vi
        |       |             |--vim
        |       |--sshd---bash---emacs---{emacs}
        |--systemd---(sd-pam)
        |--systemd-journal
        |--systemd-logind
        |--systemd-timesyn---{systemd-timesyn}
        |--systemd-udevd
        |--wpa_supplicant
```
:::
:::::

## Diagrama de transici√≥ d'estats (I)

El temps de vida d'un proc√©s X pot ser dividit en un conjunt d'estats que descriuen el comportament de l'proc√©s.

-   **Executant-se** en *mode usuari*.
-   **Executant-se** en mode nucli o *supervisor*.
-   **Preparat en mem√≤ria principal per a ser executat**. El proc√©s no est√† executant, per√≤ est√† carregat en mem√≤ria principal. A punt per ser executat quan el planificador de processos ho decideixi.

## Diagrama de transici√≥ d'estats (II)

-   **Dormit o bloquejat en mem√≤ria principal**. El proc√©s es troba esperant en mem√≤ria principal a qu√® es produeixi un determinat esdeveniment, com per exemple, la finalitzaci√≥ d'una operaci√≥ d'E/S.
-   **Preparat en mem√≤ria secund√†ria per a ser executat**. El proc√©s esta preparat per a ser executat, per√≤ est√† intercanviat a mem√≤ria secund√†ria (disc).
-   **Dormit o bloquejat en mem√≤ria secund√†ria**. El proc√©s est√† esperant en mem√≤ria secund√†ria a qu√® es produeixi un determinat esdeveniment.

## Diagrama de transici√≥ d'estats (III)

-   **Creat**. El proc√©s s'ha creat recentment i est√† en un estat de *transici√≥*. El proc√©s existeix, per√≤ no es troba preparat per ser executat ni tampoc est√† adormit. Aquest estat √©s l'inicial per a tots els processos.
-   **Zombi**. Aquest √©s l'estat final d'un proc√©s. S'arriba mitjan√ßant l'execuci√≥ expl√≠citament o impl√≠cita de la crida a sistema `exit`.

## Diagrama de transici√≥ d'estats (IV) {.smaller}

-   **Expropiat**. Quan un **proc√©s (A)** e*xecutant-se en mode usuari* ha finalitzat el seu temps:
    -   El SO envia una interrupci√≥ del rellotge de sistema.
    -   El tractament d'aquesta interrupci√≥ s'ha de fer en mode kernel.
    -   S'expropia el **proc√©s A** i un cop en mode kernel el planificador de processos pot decidir quin √©s el seg√ºent proc√©s que s'executar√†.

::: {.fragment .center-container}
L'estat *expropiat* es similar a l'estat *preparat en mem√≤ria principal per ser executat*, per√≤ **un proc√©s expropiat t√© garantit que el seu pr√≤xim estat ser√† execuci√≥ en mode usuari quan torni a ser planificat per ser executat**
:::

## Diagrama de transici√≥ d'estats (V)

::: center-container
![](../figures/slides/03-procs/Estat_UNIX_.png){width="70%"}
:::

## Transicions d'estat: *Creaci√≥ i execuci√≥ d'un proc√©s*

Quan un **nou proc√©s (A)** es crea, mitjan√ßant una crida a sistema `fork` realitzada per un altre **proc√©s (B)**, el primer estat en qu√® entra **A** √©s l'estat creat. Des d'aqu√≠ pot passar, depenent de si hi ha prou espai en mem√≤ria principal: *a) preparat per a execuci√≥ en mem√≤ria principal* o *b) preparat per a execuci√≥ en mem√≤ria secund√†ria*.

## Transicions d'estat: *Crida a sistema* {.smaller}

-   Un **proc√©s A** invoca en mode usuari una crida a sistema, per exemple `read()`, per llegir dades d'un fitxer. En aquest moment el proc√©s A passa a l'estat execuci√≥ en mode nucli on s'executa la crida a sistema.
-   `read()` necessita realitzar una operaci√≥ d'E/S amb el disc, llavors el kernel ha d'esperar que es completi l'operaci√≥.
-   El **proc√©s A** passa a l'estat adormit en mem√≤ria principal.
-   Quan es completa l'operaci√≥ d'E/S, el maquinari interromp a la CPU i el manipulador de la interrupci√≥ despertar√† el proc√©s, la qual cosa provocar√† que passi a l'estat preparat per a execuci√≥ en mem√≤ria.

## Transicions d'estat: *Execuci√≥ en mem√≤ria secund√†ria* {.smaller}

-   Suposem que en el sistema s'estan executant molts processos i que no hi ha prou espai en mem√≤ria.
-   El SO tria per ser intercanviats a mem√≤ria secund√†ria a alguns processos que es troben en l'estat *preparat per a execuci√≥ en mem√≤ria principal* o en l'*estat expropiat*.
-   Aquests processos passaran a l'**estat preparat per a execuci√≥ en mem√≤ria secund√†ria**.
-   Per tornar a tenir possibilitat d'executar-se, aquests processos hauran de ser intercanviats de nou a mem√≤ria principal.

## Transicions d'estat: *Retorn a mem√≤ria principal*

-   En un moment donat, l'intercanviador tria el proc√©s m√©s apropiat per intercanviar a la mem√≤ria principal.
-   Aquest passa a l'estat preparat per a execuci√≥ en mem√≤ria.
-   El planificador en algun instant triar√† el proc√©s per executar-se i llavors passar√† a l'estat execuci√≥.

## Transicions d'estat: *Finalitzant el proc√©s*

Quan el proc√©s es completi, invocar√† expl√≠citament o impl√≠citament a la crida a sistema `exit`, en conseq√º√®ncia passar√† a l'estat execuci√≥ en mode supervisor. Quan es completi aquesta crida a sistema passar√† finalment a l'**estat zombi**.

## Qui controla les transicions d'estat?

Un proc√©s t√© control sobre algunes transicions d'estat. En primer lloc, un proc√©s pot crear un altre proc√©s. No obstant aix√≤, **√©s el kernel qui decideix** en quin moment es realitzen la transici√≥ des de l'estat creat a l'estat preparat per a execuci√≥ en mem√≤ria principal o a l'estat preparat per a execuci√≥ en mem√≤ria secund√†ria.

## Qui controla les transicions d'estat?

Un proc√©s pot invocar una crida a sistema, el que provocar√† que passi de l'estat execuci√≥ en mode usuari a l'estat execuci√≥ en mode kernel. No obstant aix√≤, **el proc√©s no t√© control de quan tornar√† d'aquest estat**, fins i tot alguns esdeveniments poden produir que mai retorni i passi a l'estat zombi.

## Qui controla les transicions d'estat?

Un proc√©s pot finalitzar realitzant una invocaci√≥ expl√≠cita de la crida a sistema **exit**, per√≤ d'altra banda esdeveniments externs tamb√© poden fer que es produeixi l'acabament de l'proc√©s.

## Qui controla les transicions d'estat?

La resta de les transicions d'estat segueixen un model r√≠gid codificat en el nucli. Per tant, el canvi d'estat d'un proc√©s davant l'aparici√≥ de certs esdeveniments es realitza d'acord a unes regles predefinides.

## Exemples pr√†ctics (I) {.smaller}

::::: columns
::: {.column width="70%"}
-   Obrirem 2 terminal i ens connectarem a debian per ssh.
-   Anirem al terminal 1 i crearem un proc√©s: `sleep 120`.
-   Anirem al terminal 2 i observarem com el proc√©s sleep es troba en estat (**S - Interruptible sleep**).
-   En la terminal 1 clicarem *control-z* (aquesta combinaci√≥ serveix per aturar qualsevol proc√©s).
-   Anirem al terminal 2 i observarem que l'estat del proc√©s sleep es (**T - Stopped by job control signal**).
-   Anirem al terminal 1 i llen√ßarem l'orde `bg`. Aquesta orde llan√ßa el proc√©s pausat en segon pla (similar a executar-lo amb & al final, deixant el terminal lliure).
-   Anirem al terminal 2 i observarem com el proc√©s sleep ha retornat a l'estat (**S - Interruptible sleep**).
:::

::: {.column width="30%"}
``` sh
sleep 100
^Z
#Proc√©s aturat
ps -o pid,state,command  
bg
#Proc√©s espera esdeveniment
ps -o pid,state,command 
```
:::
:::::

## Exemples pr√†ctics (II) {.smaller}

::::: columns
::: {.column width="55%"}
-   Obrirem 1 terminal i ens connectarem a debian per ssh.
-   Crearem un proc√©s en background: `sleep 120 &`
-   Observarem com el proc√©s sleep es troba en estat **(S - Interruptible sleep)**.
-   Enviarem un senyal per aturar el proc√©s: `kill -STOP {PID del proc√©s sleep}`
-   Observarem com el proc√©s sleep ha retornat a l'estat (**T - stopped by job control signal**).
-   Enviarem un senyal per continuar l'execuci√≥ del proc√©s: `kill -CONT {PID del proc√©s sleep}`
:::

::: {.column width="35%"}
``` sh
man kill
sleep 100 &
ps -o pid,state,command  
kill -STOP {pid}
ps -o pid,state,command
kill -CONT {pid}
kill -KILL {pid}
```
:::
:::::

## Espiant un proc√©s amb `strace`

En una terminal executem un proc√©s. Per exemple:

``` sh
  sleep 120 &
```

En un altra terminal executem la seg√ºent instrucci√≥:

``` sh
strace -f -p {pid}
```

-   Si en l'output de la comanda observem que el proc√©s est√† parat en crides a sistema del tipus `read()` el proc√©s est√† esperant entrada de dades.
-   En altres casos, veurem quines s√≥n les crides a sistema que est√† realitzant el proc√©s.

## PCB (Process Control Block) {.smaller}

::::: columns
::: {.column width="50%"}
El **PCB** √©s una estructura de dades que permet al sistema operatiu supervisar i control un proc√©s.

-   Informaci√≥ guardada al PCB:
    -   Punters.
    -   Estat del proc√©s.
    -   Identificadors.
    -   Taula de fitxers oberts.
    -   Recursos assignats.
    -   Context dels registre de CPU.
    -   Informaci√≥ sobre la m√®moria.
    -   Informaci√≥ sobre la planificaci√≥.
:::

::: {.column width="50%"}
![](../figures/slides/03-procs/pcb.png){width="80%"}
:::
:::::

## Estructura del PCB (I) {.smaller}

El PCB de Linux es defineix a struct *task_struct* al fitxer [**sched.h**](https://elixir.bootlin.com/linux/v6.13/source/include/linux/sched.h#L785).

-   **volatile long state**: cont√© l'estat del proc√©s. Que la variable estigui declarada com *volatile* li indica a l'compilador que el seu valor pot canviar-se de forma as√≠ncrona (per exemple des d'una rutina de tractament d'interrupci√≥).
-   **struct thread_info \* thread_infp**: Cont√© informaci√≥ de baix nivell sobre el proc√©s: *flags, estatus, cpu, domini d'execuci√≥, etc.*
-   **unsigned long flags**: cont√© l'estat detallat de l'proc√©s dins el nucli. Representa el cicle de vida d'un proc√©s. [Cada bit indica un possible esdeveniment i no s√≥n m√∫tuament exclusius]{.alert}.
-   **unsigned long ptrace**: Informaci√≥ sobre la monitoritzaci√≥ un proc√©s.

## Estructura del PCB (II) {.smaller}

-   *int exit_state, int exit_code, exit_signal*: Contenen l'estat del proc√©s a l'acabar, el valor de terminaci√≥ d'un proc√©s, en cas que hi hagi finalitzat mitjan√ßant la crida a sistema `exit (2)` o, si acaba per un senyal, contindr√† el identificador de senyal que el va matar.
-   *pid_t pid*: Cont√© l'identificador de l'proc√©s.
-   *pid_t tpid*: Cont√© l'identificador del grup de processos. Coincideix amb l'identificador de el lider de el grup.
-   *uid_t uid, euid, suid, fsuid*: Usuari propietari d'aquest proc√©s, tant real (uid), com efectiu (euid), i atributs m√©s espec√≠fics.
-   *gid_t gid, Egid, sgid, fsgid*: Grup propietari d'aquest proc√©s, tant real (gid), com efectiu (Egid), i atributs m√©s espec√≠fics.

## Intercanvi de processos (I)

::: center-container
![](../figures/slides/03-procs/intercanvi_procesos.png){width="50%"}
:::

## Intercanvi de processos (II)

El kernel gestiona una estructura de taula (diccionari) semblant a la representada en la imatge seg√ºent per poder accedir de forma eficient als diferents PCBs. Aquesta estrcutura de dades es coneix com a **Taula PCB**.

::: center-container
![](../figures/slides/03-procs/pcb-taula.png){width="40%"}
:::

## `/proc` {.smaller}

:::::: columns
::: {.column width="50%"}
-   **cmdline**: Cont√© l'ordre que comen√ßa el proc√©s, amb tots els seus par√†metres.
-   **cwd**: Enlace simb√≤lic al directori de treball actual (directori de treball actual) del proc√©s.
-   **environ**: Cont√© totes les variables d'entorn per al proc√©s.
-   **fd**: Cont√© els descriptors d‚Äôarxiu per al proc√©s, mostrant els fitxers o dispositius que estan utilitzant.
-   **maps, statm i mem**: Cont√© informaci√≥ relacionada amb la mem√≤ria en √∫s pel proc√©s.
-   **stat and status**: Cont√© nformaci√≥ sobre l'estat del proc√©s.
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
Per trobar la taula de processos necessitem observar la seg√ºent ruta: */proc*:

``` sh
sleep 60 &
less /proc/{pid}/stat
less /proc/{pid}/environ
```
:::
::::::

## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE

La gesti√≥ de processos a **Unix/Linux** √©s crucial per a una utilitzaci√≥ eficient del sistema i una correcta assignaci√≥ de recursos. El directori **/proc** ofereix acc√©s als PCBs que contenen informaci√≥ sobre cada proc√©s en execuci√≥.
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::