---
title: "Processos a Linux"
subtitle: "Unitat 3 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Qu√® √©s un proc√©s?

Un **proc√©s** √©s una instancia d‚Äôun programa en execuci√≥ (tasca).  Aix√≤ vol dir que si **10 usuaris d‚Äôun servidor** utilitzen el mateix programa, com ```vi```, hi ha **10 processos** *vi* que s‚Äôexecuten al servidor, tot i que *tots comparteixen el mateix codi executable*.

- Creaci√≥ i eliminaci√≥.
- Garantir l'execuci√≥ i finalitzaci√≥.
- Controlar errors i excepcions.
- Assignaci√≥ de recursos.
- Comunicaci√≥ i sincronitzaci√≥.

## `ps` (I) {.smaller}

Imagineu que utilitzem la comanda `sleep 120 &`. Aquest comanda ens crear√† 3 processos *sleep* en *background*. La eina **ps** ens permet veure'ls.

::: columns
::: {.column width="50%"}

#### `ps -e`

L'opci√≥ **-e** indica a l'ordre que mostri **tots els processos del sistema**. Sense aquesta opci√≥, l'ordre nom√©s mostra els processos de l'usuari a la sessi√≥ actual.

Aquests processos tenen PID *1053, 1054 i 1054*. [*Tamb√© observeu l'ordre ps al final de la llista. Aix√≤ es deu al fet que l'ordre en si tamb√© √©s un proc√©s.*]{.alert}

:::
::: {.column width="50%"}

```{.sh}
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```

:::
:::

## `ps` (II) {.smaller}

::: columns
::: {.column width="50%"}

#### `ps -e`

- La columna *CMD* identifica el nom del proc√©s en execuci√≥, com ara *sleep*.
- La primera columna indica l‚Äôidentificador de proc√©s (**PID**) assignat al proc√©s pel sistema operatiu.
- La segona columna mostra el terminal associat a un proc√©s o *?* si el proc√©s no s‚Äôassocia a cap terminal.
- Finalment, la tercera columna mostra el *temps de la CPU* del proc√©s.

:::
::: {.column width="50%"}

```{.sh size="tiny"}
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```

:::
:::

## `ps` (III) {.smaller}

::: columns
::: {.column width="50%"}

- L'identificador de proc√©s (**PID**) √©s un identificador √∫nic per a un proc√©s.
- El sistema operatiu utilitza un comptador de 32 bits *last_pid* per fer un seguiment de l‚Äô√∫ltim PID assignat a un proc√©s.
- Quan es crea un proc√©s, el comptador augmenta i el seu valor es converteix en el **PID** del nou proc√©s.
- El kernel ha de comprovar si el valor de *last_pid*++ ja pertany a una tasca, abans que pugui assignar-lo a un proc√©s nou.

:::
::: {.column width="50%"}

```{.sh size="tiny"}
ps -e
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      9 ?        00:00:00 mm_percpu_wq
     10 ?        00:00:00 rcu_tasks_rude_
     11 ?        00:00:00 rcu_tasks_trace
     12 ?        00:00:00 ksoftirqd/0
     13 ?        00:00:03 rcu_sched
     14 ?        00:00:00 migration/0
     15 ?        00:00:00 cpuhp/0
     17 ?        00:00:00 kdevtmpfs
     18 ?        00:00:00 netns
     ...
   1053 pts/0    00:00:00 sleep
   1054 pts/0    00:00:00 sleep
   1055 pts/0    00:00:00 sleep
   1056 pts/0    00:00:00 ps
```

:::
:::

## `top`

:::{.center-container}
![](../figures/slides/03-procs/top.png)
:::

## Estats dels processos {.smaller}

::: columns
::: {.column width="33%"}

-  **Nou**: Proc√©s que encara no est√† creat del tot, li falta el *PCB*.
-  **Inactiu**: Quan un proc√©s ha finalitzat.
-  **Preparat**: Quan un proc√©s t√© assignats tots els recursos necessaris per poder executar-se (excepte la CPU).
-  **Execuci√≥**: Quan un proc√©s t√© assignada la CPU.
-  **Espera**: Quan al proc√©s li falta algun recurs per poder executar-se.

:::
::: {.column width="3%"}
:::
::: {.column width="64%"}

:::{.fragment}
Per veure informaci√≥ dels processos en UNIX tornarem a fer servir la comanda *ps*. Si fem ```man ps``` i busquem PROCESS STATE CODES, veurem el seg√ºents estats:
:::

-  **D**   uninterruptible sleep (usually IO)
-  **I**     Idle kernel thread
-  **R**     running or runnable (on run queue)
-  **S**     interruptible sleep (waiting for an event to complete)
-  **T**     stopped by job control signal
-  **t**     stopped by debugger during the tracing
-  **W**     paging (not valid since the 2.6.xx kernel)
-  **X**     dead (should never be seen)
-  **Z**    defunct ("zombie") process, terminated but not reaped by its parent

:::
:::

## `ps` (IV) {.smaller}

Es pot mostrar m√©s informaci√≥ sobre la llista de processos mitjan√ßant l‚Äôopci√≥ **-l** de l‚Äôordre ps:

```sh
ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    00:00:00 bash
0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    00:00:00 vi
0 S     0    1064    1034  0  80   0 -  1326 -      pts/0    00:00:00 sleep
4 R     0    1065    1034  0  80   0 -  2405 -      pts/0    00:00:00 ps
```

- La primera columna (**F**) de la sortida anterior identifica els indicadors de proc√©s (vegeu la p√†gina del manual si esteu interessats). La columna (**S**) indica l'estat d'un proc√©s.

- Recordeu que sense l'opci√≥ **-e**, ```ps``` nom√©s mostra els processos al terminal actual, en aquest cas **pts/0**.


## Arbre de processos 

- Estructura jer√†rquica dels processos en formada d'arbre.
- Tots els processos tenen un proc√©s pare, excepte el proc√©s inicial (**PID = 1**).
- Els processos poden tenir zero o m√©s processos fills.
- Els atributs **PID** i **PPID** identifiquen el proc√©s i el seu pare.

:::{.fragment}
En l'exemple anterior, podeu veure que el proc√©s `bash` √©s el pare dels processos `sleep` i `ps`. Si esteu connectats per **ssh** al servidor, el proc√©s `bash` √©s fill del proc√©s `sshd`. I el proc√©s `sshd` √©s fill del proc√©s `init` (PID = 1).
:::

## Qui √©s el pare de PID=1?

El proc√©s amb **PID = 1** √©s el primer proc√©s que s'inicia quan el sistema arrenca. Aquest proc√©s es coneix com a **init** (o **systemd** en sistemes m√©s moderns) i √©s el **pare** de tots els altres processos en execuci√≥ al sistema. 

- Aquest proc√©s *el crea el kernel durant el proc√©s d'arrencada del sistema operatiu*. 
- El kernel √©s responsable de carregar i iniciar el sistema operatiu.
- Aquest √©s l'√∫nic proc√©s que no t√© un proc√©s pare, ja que √©s el primer proc√©s que s'inicia en el sistema.


## Qu√® √©s un proc√©s inactiu?

Un proc√©s inactiu √©s un proc√©s que esta **esperant a que succeeixi un esdeveniment per poder continuar la seva execuci√≥**. 

Aquest **esdeveniment** pot ser una *entrada de l'usuari*, la *finalitzaci√≥ d'una operaci√≥ d'entrada/sortida*, o qualsevol altra condici√≥ que el proc√©s necessita per continuar.

La majoria dels processos del sistema s√≥n **inactius**, que esperen algun tipus d‚Äôesdeveniment, com ara fer clic amb el ratol√≠ o pr√©mer una tecla. A l'exemple anterior, l'√∫nica ordre en execuci√≥ √©s ```ps```.

## `pstree` {.smaller}


::: columns
::: {.column width="50%"}

```{.sh size="tiny"}
ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY      CMD
4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    bash
0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    vi
0 T     0    1066    1034  0  80   0 -  3448 -      pts/0    vim
0 T     0    1068    1034  0  80   0 -  2358 -      pts/0    top
0 T     0    3502    1034  0  80   0 - 30692 -      pts/0    emacs
0 T     0    3505    1034  0  80   0 - 30692 -      pts/0    emacs
4 R     0    3569    1034  0  80   0 -  2405 -      pts/0    ps
```

---

```sh
su root -c "apt-get install psmisc -y"
```

:::
::: {.column width="50%"}

```{.sh size="tiny"}
pstree
systemd-|-agetty
        |--cron
        |--dbus-daemon
        |--dhclient---3*[{dhclient}]
        |--exim4
        |--rsyslogd---3*[{rsyslogd}]
        |--sshd-|-sshd---bash-|-2*[emacs---{emacs}]
        |       |             |--pstree
        |       |             |--top
        |       |             |--vi
        |       |             |--vim
        |       |--sshd---bash---emacs---{emacs}
        |--systemd---(sd-pam)
        |--systemd-journal
        |--systemd-logind
        |--systemd-timesyn---{systemd-timesyn}
        |--systemd-udevd
        |--wpa_supplicant
```

:::
:::

## Diagrama de transici√≥ d'estats (I)

El temps de vida d'un proc√©s X pot ser dividit en un conjunt d'estats que descriuen el comportament de l'proc√©s.

-  **Executant-se** en *mode usuari*.
-  **Executant-se** en mode nucli o *supervisor*.
-  **Preparat en mem√≤ria principal per a ser executat**. El proc√©s no est√† executant, per√≤ est√† carregat en mem√≤ria principal. A punt per ser executat quan el planificador de processos ho decideixi.
  


## Diagrama de transici√≥ d'estats (II)

-  **Dormit o bloquejat en mem√≤ria principal**. El proc√©s es troba esperant en mem√≤ria principal a qu√® es produeixi un determinat esdeveniment, com per exemple, la finalitzaci√≥ d'una operaci√≥ d'E/S.
-  **Preparat en mem√≤ria secund√†ria per a ser executat**. El proc√©s esta preparat per a ser executat, per√≤ est√† intercanviat a mem√≤ria secund√†ria (disc).
-  **Dormit o bloquejat en mem√≤ria secund√†ria**. El proc√©s est√† esperant en mem√≤ria secund√†ria a qu√® es produeixi un determinat esdeveniment.
  
## Diagrama de transici√≥ d'estats (III)

-  **Creat**. El proc√©s s'ha creat recentment i est√† en un estat de *transici√≥*. El proc√©s existeix, per√≤ no es troba preparat per ser executat ni tampoc est√† adormit. Aquest estat √©s l'inicial per a tots els processos.
-  **Zombi**. Aquest √©s l'estat final d'un proc√©s. S'arriba mitjan√ßant l'execuci√≥ expl√≠citament o impl√≠cita de la crida a sistema `exit`.
  

## Diagrama de transici√≥ d'estats (IV) {.smaller}

-  **Expropiat**. Quan un **proc√©s (A)** e*xecutant-se en mode usuari* ha finalitzat el seu temps:
    - El SO envia una interrupci√≥ del rellotge de sistema.
    - El tractament d'aquesta interrupci√≥ s'ha de fer en mode kernel.
    - S'expropia el **proc√©s A** i un cop en mode kernel el planificador de processos pot decidir quin √©s el seg√ºent proc√©s que s'executar√†.

:::{.fragment .center-container}  
L'estat *expropiat* es similar a l'estat *preparat en mem√≤ria principal per ser executat*, per√≤ **un proc√©s expropiat t√© garantit que el seu pr√≤xim estat ser√† execuci√≥ en mode usuari quan torni a ser planificat per ser executat**
:::

## Diagrama de transici√≥ d'estats (V)

::: {.center-container}
![](../figures/slides/03-procs/Estat_UNIX_.png){width="70%"}
:::

## Transicions d'estat: *Creaci√≥ i execuci√≥ d'un proc√©s* 

Quan un **nou proc√©s (A)** es crea, mitjan√ßant una crida a sistema `fork` realitzada per un altre **proc√©s (B)**, el primer estat en qu√® entra **A** √©s l'estat creat. Des d'aqu√≠ pot passar, depenent de si hi ha prou espai en mem√≤ria principal: *a) preparat per a execuci√≥ en mem√≤ria principal* o *b) preparat per a execuci√≥ en mem√≤ria secund√†ria*.


## Transicions d'estat: *Crida a sistema* {.smaller}

- Un **proc√©s A** invoca en mode usuari una crida a sistema, per exemple `read()`, per llegir dades d'un fitxer. En aquest moment el proc√©s A passa a l'estat execuci√≥ en mode nucli on s'executa la crida a sistema. 
- `read()` necessita realitzar una operaci√≥ d'E/S amb el disc, llavors el kernel ha d'esperar que es completi l'operaci√≥.
- El **proc√©s A** passa a l'estat adormit en mem√≤ria principal. 
- Quan es completa l'operaci√≥ d'E/S, el maquinari interromp a la CPU i el manipulador de la interrupci√≥ despertar√† el proc√©s, la qual cosa provocar√† que passi a l'estat preparat per a execuci√≥ en mem√≤ria.


## Transicions d'estat: *Execuci√≥ en mem√≤ria secund√†ria* {.smaller}

- Suposem que en el sistema s'estan executant molts processos i que no hi ha prou espai en mem√≤ria. 
- El SO tria per ser intercanviats a mem√≤ria secund√†ria a alguns processos que es troben en l'estat *preparat per a execuci√≥ en mem√≤ria principal* o en l'*estat expropiat*. 
- Aquests processos passaran a l'**estat preparat per a execuci√≥ en mem√≤ria secund√†ria**. 
- Per tornar a tenir possibilitat d'executar-se, aquests processos hauran de ser intercanviats de nou a mem√≤ria principal.


## Transicions d'estat: *Retorn a mem√≤ria principal*

- En un moment donat, l'intercanviador tria el proc√©s m√©s apropiat per intercanviar a la mem√≤ria principal.
- Aquest passa a l'estat preparat per a execuci√≥ en mem√≤ria. 
- El planificador en algun instant triar√† el proc√©s per executar-se i llavors passar√† a l'estat execuci√≥. 

## Transicions d'estat: *Finalitzant el proc√©s*

Quan el proc√©s es completi, invocar√† expl√≠citament o impl√≠citament a la crida a sistema `exit`, en conseq√º√®ncia passar√† a l'estat execuci√≥ en mode supervisor. Quan es completi aquesta crida a sistema passar√† finalment a l'**estat zombi**.

## Qui controla les transicions d'estat?

Un proc√©s t√© control sobre algunes transicions d'estat. En primer lloc, un proc√©s pot crear un altre proc√©s. No obstant aix√≤, **√©s el kernel qui decideix** en quin moment es realitzen la transici√≥ des de l'estat creat a l'estat preparat per a execuci√≥ en mem√≤ria principal o a l'estat preparat per a execuci√≥ en mem√≤ria secund√†ria.

## Qui controla les transicions d'estat?

Un proc√©s pot invocar una crida a sistema, el que provocar√† que passi de l'estat execuci√≥ en mode usuari a l'estat execuci√≥ en mode kernel. No obstant aix√≤, **el proc√©s no t√© control de quan tornar√† d'aquest estat**, fins i tot alguns esdeveniments poden produir que mai retorni i passi a l'estat zombi.

## Qui controla les transicions d'estat?

Un proc√©s pot finalitzar realitzant una invocaci√≥ expl√≠cita de la crida a sistema **exit**, per√≤ d'altra banda esdeveniments externs tamb√© poden fer que es produeixi l'acabament de l'proc√©s.

## Qui controla les transicions d'estat?

La resta de les transicions d'estat segueixen un model r√≠gid codificat en el nucli. Per tant, el canvi d'estat d'un proc√©s davant l'aparici√≥ de certs esdeveniments es realitza d'acord a unes regles predefinides.

## Exemples pr√†ctics (I) {.smaller}

::: columns
::: {.column width="70%"}

-  Obrirem 2 terminal i ens connectarem a debian per ssh.
-  Anirem al terminal 1 i crearem un proc√©s: ```sleep 120```.
-  Anirem al terminal 2 i observarem com el proc√©s sleep es troba en estat (**S - Interruptible sleep**).
-  En la terminal 1 clicarem *control-z* (aquesta combinaci√≥ serveix per aturar qualsevol proc√©s).
-  Anirem al terminal 2 i observarem que l'estat del proc√©s sleep es (**T - Stopped by job control signal**).
-  Anirem al terminal 1 i llen√ßarem l'orde ```bg```. Aquesta orde llan√ßa el proc√©s pausat en segon pla (similar a executar-lo amb & al final, deixant el terminal lliure).
-  Anirem al terminal 2 i observarem com el proc√©s sleep ha retornat a l'estat (**S - Interruptible sleep**).

:::
::: {.column width="30%"}

```sh
sleep 100
^Z
#Proc√©s aturat
ps -o pid,state,command  
bg
#Proc√©s espera esdeveniment
ps -o pid,state,command 
```

:::
:::

## Exemples pr√†ctics (II) {.smaller}

::: columns
::: {.column width="55%"}

-  Obrirem 1 terminal i ens connectarem a debian per ssh.
-  Crearem un proc√©s en background: ```sleep 120 &```
-  Observarem com el proc√©s sleep es troba en estat **(S - Interruptible sleep)**.
-  Enviarem un senyal per aturar el proc√©s: ```kill -STOP {PID del proc√©s sleep}```
-  Observarem com el proc√©s sleep ha retornat a l'estat (**T - stopped by job control signal**).
-  Enviarem un senyal per continuar l'execuci√≥ del proc√©s: ```kill -CONT {PID del proc√©s sleep}```

:::
::: {.column width="35%"}

```sh
man kill
sleep 100 &
ps -o pid,state,command  
kill -STOP {pid}
ps -o pid,state,command
kill -CONT {pid}
kill -KILL {pid}
```

:::
:::

## Espiant un proc√©s amb `strace`

En una terminal executem un proc√©s. Per exemple:

```sh
  sleep 120 &
```

En un altra terminal executem la seg√ºent instrucci√≥:

```sh
strace -f -p {pid}
```

- Si en l'output de la comanda observem que el proc√©s est√† parat en crides a sistema del tipus `read()` el proc√©s est√† esperant entrada de dades.
- En altres casos, veurem quines s√≥n les crides a sistema que est√† realitzant el proc√©s.

## PCB (Process Control Block) {.smaller}
  
::: columns
::: {.column width="50%"}

El **PCB** √©s una estructura de dades que permet al sistema operatiu supervisar i control un proc√©s.

* Informaci√≥ guardada al PCB:
  * Punters.
  * Estat del proc√©s.
  * Identificadors.
  * Taula de fitxers oberts.
  * Recursos assignats.
  * Context dels registre de CPU.
  * Informaci√≥ sobre la m√®moria.
  * Informaci√≥ sobre la planificaci√≥.

:::
::: {.column width="50%"}

![](../figures/slides/03-procs/pcb.png){width="80%"}


:::
:::

## Estructura del PCB (I) {.smaller}

El PCB de Linux es defineix a struct *task_struct* al fitxer [**sched.h**](https://elixir.bootlin.com/linux/v6.13/source/include/linux/sched.h#L785).  

-  **volatile long state**: cont√© l'estat del proc√©s. Que la variable estigui declarada com *volatile* li indica a l'compilador que el seu valor pot canviar-se de forma as√≠ncrona (per exemple des d'una rutina de tractament d'interrupci√≥).
-  **struct thread_info  * thread_infp**: Cont√© informaci√≥ de baix nivell sobre el proc√©s: *flags, estatus, cpu, domini d'execuci√≥, etc.*
-  **unsigned long flags**: cont√© l'estat detallat de l'proc√©s dins el nucli. Representa el cicle de vida d'un proc√©s. [Cada bit indica un possible esdeveniment i no s√≥n m√∫tuament exclusius]{.alert}.
-  **unsigned long ptrace**: Informaci√≥ sobre la monitoritzaci√≥  un proc√©s.


## Estructura del PCB (II) {.smaller}

-  *int exit_state, int exit_code, exit_signal*: Contenen l'estat del proc√©s a l'acabar, el valor de terminaci√≥ d'un proc√©s, en cas que hi hagi finalitzat mitjan√ßant la crida a sistema `exit (2)` o, si acaba per un senyal, contindr√† el identificador de senyal que el va matar.
-  *pid_t pid*: Cont√© l'identificador de l'proc√©s.
-  *pid_t tpid*: Cont√© l'identificador del grup de processos. Coincideix amb l'identificador de el lider de el grup.
-  *uid_t uid, euid, suid, fsuid*: Usuari propietari d'aquest proc√©s, tant real (uid), com efectiu (euid), i atributs m√©s espec√≠fics.
-  *gid_t gid, Egid, sgid, fsgid*: Grup propietari d'aquest proc√©s, tant real (gid), com efectiu (Egid), i atributs m√©s espec√≠fics.

## Intercanvi de processos (I)

::: center-container
![](../figures/slides/03-procs/intercanvi_procesos.png){width="50%"}
:::

## Intercanvi de processos (II)

El kernel gestiona una estructura de taula (diccionari) semblant a la representada en la imatge seg√ºent per poder accedir de forma eficient als diferents PCBs. Aquesta estrcutura de dades es coneix com a **Taula PCB**.

::: center-container
![](../figures/slides/03-procs/pcb-taula.png){width="40%"}
:::


## `/proc` {.smaller}

::: columns
::: {.column width="50%"}

-  **cmdline**: Cont√© l'ordre que comen√ßa el proc√©s, amb tots els seus par√†metres.
-  **cwd**: Enlace simb√≤lic al directori de treball actual (directori de treball actual) del proc√©s.
-  **environ**: Cont√© totes les variables d'entorn per al proc√©s.
-  **fd**: Cont√© els descriptors d‚Äôarxiu per al proc√©s, mostrant els fitxers o dispositius que estan utilitzant.
-  **maps, statm i mem**: Cont√© informaci√≥  relacionada amb la mem√≤ria en √∫s pel proc√©s.
-  **stat and status**: Cont√© nformaci√≥ sobre l'estat del proc√©s.

:::
::: {.column width="5%"}
:::
::: {.column width="45%"}

Per trobar la taula de processos necessitem observar la seg√ºent ruta: */proc*:

```sh
sleep 60 &
less /proc/{pid}/stat
less /proc/{pid}/environ
```

:::
:::

## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE
La gesti√≥ de processos a **Unix/Linux** √©s crucial per a una utilitzaci√≥ eficient del sistema i una correcta assignaci√≥ de recursos. El directori **/proc** ofereix acc√©s als PCBs que contenen informaci√≥ sobre cada proc√©s en execuci√≥.

:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::