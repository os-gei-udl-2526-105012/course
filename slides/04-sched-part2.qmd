---
title: "Planificaci√≥ de processos ¬∑ Just√≠cia"
subtitle: "Unitat 4 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 4 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---


## Qu√® √©s la planificaci√≥ justa? {.smaller}

::: {.incremental}
- **Objectiu:** Garantir que tots els processos rebin un **tracte equitatiu** en l‚Äôacc√©s a la CPU, independentment de la seva prioritat o √∫s anterior.

- **Principis:**
  - **Igualtat de servei:** Dos processos id√®ntics ‚Üí mateix temps de CPU, mateix rendiment.
  - **Work-conserving:** La CPU **mai resta inactiva** si hi ha tasques pendents. (no implica just√≠cia, sin√≥ efici√®ncia)
  - **Just√≠cia:** Evita la *inanici√≥* ‚Üí cap proc√©s queda sense atenci√≥.
  
- **Algorismes que aproximen la planificaci√≥ justa:**
  - Fair Sharing, Fair Queueing, Max-Min Fairness, Lottery Scheduling
:::
  


## Exemple 1: Planificaci√≥ Justa {.smaller}

::: {.center-container}
Quina quantitat de recurs hauria de rebre cada proc√©s per garantir una planificaci√≥ justa?*
:::

::: columns
::: {.column width="50%"}

Tenim una capacitat total de recurs:  

$$C = 10 \text{ unitats} $$

Dos processos amb demandes diferents:

- **P‚ÇÅ** ‚Üí demanda de **8** unitats  
- **P‚ÇÇ** ‚Üí demanda de **6** unitats

:::
::: {.column width="50%" .fragment}

**Soluci√≥ justa:**

- **P‚ÇÅ = 5 unitats**
- **P‚ÇÇ = 5 unitats**

::: {.fragment}
```{mermaid}
graph LR
  C["Capacitat 
    10 unitats"] -->|5| P1[P‚ÇÅ]
  C -->|5| P2[P‚ÇÇ]
  style C fill:#f0f0f0,stroke:#444,stroke-width:1px
  style P1 fill:#b3d4fc,stroke:#333,stroke-width:1px
  style P2 fill:#b3d4fc,stroke:#333,stroke-width:1px
```
:::

:::
:::

## Exemple 2: Planificaci√≥ Justa {.smaller}

::: {.center-container}
Quina quantitat de recurs hauria de rebre cada proc√©s per garantir una planificaci√≥ justa?*
:::

::: columns
::: {.column width="50%"}

Tenim una capacitat total de recurs:  

$$C = 10 \text{ unitats} $$

Dos processos amb demandes diferents:

- **P‚ÇÅ** ‚Üí demanda de **8** unitats  
- **P‚ÇÇ** ‚Üí demanda de **4** unitats

:::
::: {.column width="50%" .fragment}

**Soluci√≥ justa:**

- **P‚ÇÅ = 6 unitats**
- **P‚ÇÇ = 4 unitats**

::: {.fragment}
```{mermaid}
graph LR
  C["Capacitat 
    10 unitats"] -->|6| P1[P‚ÇÅ]
  C -->|4| P2[P‚ÇÇ]
  style C fill:#f0f0f0,stroke:#444,stroke-width:1px
  style P1 fill:#b3d4fc,stroke:#333,stroke-width:1px
  style P2 fill:#b3d4fc,stroke:#333,stroke-width:1px
```
:::

:::
:::

## Exemple 3: Planificaci√≥ Justa {.smaller}

::: {.center-container}
Quina quantitat de recurs hauria de rebre cada proc√©s per garantir una planificaci√≥ justa?*
:::

::: columns
::: {.column width="50%"}

Tenim una capacitat total de recurs:  

$$C = 10 \text{ unitats} $$

Dos processos amb demandes diferents:

- **P‚ÇÅ** ‚Üí demanda de **8** unitats  
- **P‚ÇÇ** ‚Üí demanda de **4** unitats
- **P‚ÇÉ** ‚Üí demanda de **2** unitats

:::
::: {.column width="50%" .fragment}

**Soluci√≥ justa:**

- **P‚ÇÅ = 4 unitats**
- **P‚ÇÇ = 4 unitats**
- **P‚ÇÉ = 2 unitats**

::: {.fragment}
```{mermaid}
graph LR
  C["Capacitat 
    10 unitats"] -->|4| P1[P‚ÇÅ]
  C -->|4| P2[P‚ÇÇ]
  C -->|2| P3[P‚ÇÉ]
  style C fill:#f0f0f0,stroke:#444,stroke-width:1px
  style P1 fill:#b3d4fc,stroke:#333,stroke-width:1px
  style P2 fill:#b3d4fc,stroke:#333,stroke-width:1px
  style P3 fill:#b3d4fc,stroke:#333,stroke-width:1px
```
:::

:::
:::


## Max-Min Fairness 

L'algorisme de **Max-Min Fairness** assegura que els recursos es distribueixin de manera que cap proc√©s **no rebi m√©s del que necessita** fins que tots els processos hagin rebut almenys la seva **demanda m√≠nima**.

## Max-Min Fairness (Algorisme) 

```python
C = total_resource_capacity
S = {J1, J2, ‚Ä¶, Jn}        # conjunt de treballs actius
D = [d1, d2, ‚Ä¶, dn]        # demanda de cada treball
A = [0]*n                  # vector d'assignaci√≥
while S != ‚àÖ:
    f = C / |S|            # quota justa per a cada treball
    b = True
    for j in S:
        if D[i] < f:       # si un treball demana menys del que li toca
            b = False
            A[i] = D[i]    # satisf√† la seva demanda
            C -= D[i]
            S = S \ {j}
    if b:                  # si ning√∫ demana menys
        for j in S:
            A[i] = f
            S = S \ {j} 
        S = ‚àÖ
```


## Planificaci√≥ Justa amb 1 recurs {.smaller}

::: {.center-container}
Si $n$ tasques han de compartir un recurs (CPU) $\Rightarrow$ cadascun rep, per defecte, una part de $\frac{1}{n}$ del recurs.
:::

:::{.fragment}
### Extensi√≥: Max-Min Fairness

S'utilitza per ajustar la distribuci√≥ quan un usuari no vol o no pot fer servir tota la seva quota de recurs.

**Exemple**: Si la tasca 1 nom√©s necessita un 20% del recurs, el recurs restant es redistribueix equitativament entre els altres usuaris.
:::

:::{.fragment}
### Extensi√≥: Weighted Max-Min Fairness:

Els pesos determinen la proporci√≥ del recurs disponible que correspon a cada proc√©s en cas de compet√®ncia.

**Exemple**: Si la tasca 1 t√© un pes de 1 i la tasca 2 t√© un pes de 2, la tasca 2 rebr√† proporcionalment m√©s recurs respecte a la tasca 1 (2/3 vs 1/3).
:::

## Planificaci√≥ amb algorisme Loteria

- Semblant a **Weighted Max-Min Fairness**, per√≤ amb **bitllets** en lloc de pesos fixos.  
- Cada proc√©s rep **un nombre de bitllets** segons la seva prioritat.  
- La planificaci√≥ √©s **aleat√≤ria**, per√≤ proporcional als bitllets.

## Funcionament de la planificaci√≥ Loteria

1. Cada proc√©s rep un **nombre de bitllets**.  
2. Cada cicle de planificaci√≥, es fa un **sorteig aleatori**.  
3. El proc√©s que t√© el bitllet seleccionat obt√© **temps de CPU**.  
4. Els processos amb m√©s bitllets tenen **m√©s oportunitats**, per√≤ cap proc√©s queda excl√≤s.


## Exemple: Planificaci√≥ Loteria {.smaller}

:::{.center-container}
Proc√©s curts: 10 bitllets - Proc√©s llargs: 1 bitllet.
:::

| N¬∫ curts | N¬∫ llargs | % CPU curts | % CPU llargs |
|----------|-----------|-------------|--------------|
| 1        | 1         | 91%         | 9%           |
| 0        | 2         | -           | 50%          |
| 2        | 0         | 50%         | -            |
| 10       | 1         | 99.0%        | 0.99%        |
| 1        | 10        | 50%         | 5%           |

$$\text{%CPU} = \frac{\text{nombre de bitllets del proc√©s}}{\text{nombre total de bitllets}} \times 100$$

:::{.callout-warning}
Si hi ha **massa processos curts**, el temps de resposta pot ser molt petit.  
- Soluci√≥: **desconnectar alguns processos** o ajustar els bitllets per equilibrar la c√†rrega.
:::

::: notes
- 1 curt i 1 llarg: El proc√©s curt t√© 10 bitllets i el llarg 1 bitllet. Per tant, el proc√©s curt t√© un 91% de possibilitats de ser seleccionat en cada sorteig.
- 0 curts i 2 llargs: Cada proc√©s llarg t√© 1 bitllet, per tant, cada proc√©s t√© un 50% de possibilitats de ser seleccionat en cada sorteig.
- 2 curts i 0 llargs: Cada proc√©s curt t√© 10 bitllets, per tant, cada proc√©s t√© un 50% de possibilitats de ser seleccionat en cada sorteig.
- 10 curts i 1 llarg: El proc√©s curt t√© 100 bitllets (10 processos curts x 10 bitllets cadascun) i el llarg t√© 1 bitllet. Per tant, el proc√©s curt t√© un 99.0% de possibilitats de ser seleccionat en cada sorteig.
- 1 curt i 10 llargs: El proc√©s curt t√© 10 bitllets i cada proc√©s llarg t√© 1 bitllet (10 processos llargs x 1 bitllet cadascun). Per tant, el proc√©s curt t√© un 50% de possibilitats de ser seleccionat en cada sorteig.
:::


## Cooperativisme amb Loteria (Extensi√≥)


::: {.center-container}
 √âs possible que els processos cooperin per obtenir **m√©s bitllets** i, per tant, **m√©s temps de CPU**?
:::

::: {.fragment}
- Un programa client/servidor pot cooperar.  
- Si el client ha acabat la seva tasca, pot **cedir els seus bitllets al servidor**.  
- Aix√≤ augmenta les **oportunitats del servidor** en els seg√ºents sortejos.
:::


## Generalized Processor Sharing (GPS)  {.smaller}

- **Mida dels paquet:** 1 bit
- **Capacitat de l'enlla√ß:** 10 bits per unitat de temps (*velocitat m√†xima de transmissi√≥*)

::: {.fragment}
::: columns 
::: {.column width="35%"}

$$A_i = \frac{P_i}{\sum_{j} P_j} \times C$$

| F | P | A |
|---|---|---|
| f | 5 | 50% |
| e | 1 | 10% |
| d | 1 | 10% |
| c | 1 | 10% | 
| b | 1 | 10% |
| a | 1 | 10% |



:::
::: {.column width="65%"}


![](../figures/slides/04-sched/fair/flow1.png)

- **P:** Pes (bits per unitat de temps) - $\omega_i$ 
- **A:** Ample de Banda Assignat - $\rho_i$


:::
:::
:::

::: notes 
GPS √©s un model te√≤ric la base de molts planificadors de xarxa moderns, ja que garanteix una distribuci√≥ de recursos totalment justa i proporcional.

Tots els paquets reben servei simult√†niament a una velocitat que √©s exactament proporcional al seu pes, garantint que cap flux sigui totalment privat de servei.

El problema √©s que en la pr√†ctica, els paquets s√≥n entitats discretes i no fluids, per la qual cosa no es pot implementar GPS directament.
:::

## De la Teoria a la Pr√†ctica: GPS i WFQ  {.smaller}

1. **Generalized Processor Sharing (GPS)** √©s un model te√≤ric i ideal on l'ample de banda es divideix de forma **perfectament cont√≠nua** (com un **fluid**) i simult√†nia entre tots els fluxos actius, segons els seus pesos.

2. **Weighted Fair Queuing (WFQ)** √©s un algorisme real i implementable que aproxima el comportament ideal del GPS. A les xarxes, els recursos es transmeten com a **paquets discrets** (no com a fluids). Per la qual cosa, l'enlla√ß nom√©s pot transmetre **un paquet complet a la vegada** (no simult√†niament).

:::{.fragment .center-container}
![](../figures/slides/04-sched/fair/flow2.png){width="50%"}
:::

::: notes
El WFQ √©s l'algorisme real que s'utilitza per aconseguir l'equitat de l'ample de banda (fairness) en les xarxes. Ho aconsegueix prioritzant els paquets que, segons el model te√≤ric (GPS), haurien de ser els seg√ºents a completar-se.
:::



## Limitacions del Temps Real en WFQ {.smaller}

- **No Apropiatiu:** Si un paquet de prioritat alta arriba mentre se'n transmet un altre de baixa prioritat, el segon no pot ser expulsat immediatament. Per mantenir la just√≠cia, el WFQ necessita una m√®trica estable i independent de la mida dels paquets que representi el servei **ideal** rebut (Temps de Finalitzaci√≥ Virtual).

- **Manteniment d'Inactivitat:** Si un flux roman inactiu i no envia dades, el temps d'inactivitat no s'ha de comptar com a servei rebut (cr√®dit guanyat). En reactivar-se, el flux ha de comen√ßar el servei sense penalitzaci√≥ (amb un 'comptador' que s'hagi aturat).

:::{.fragment .center-container}
**Temps Real (Real Time)** no es pot utilitzar directament com a mecanisme de planificaci√≥. El WFQ utilitza un **Temps de Refer√®ncia Virtual (Virtual Time)** com a reempla√ßament del temps real del model GPS.
:::


## Virtual Time 

- El temps de finalitzaci√≥ real √©s **inestable** i canvia cada vegada que un flux esdev√© actiu o inactiu (entrades/sortides).

- Mantenim una m√®trica de servei **estable** que a√Ølla la finalitzaci√≥ dels paquets de les fluctuacions de tr√†nsit.

:::{.fragment .center-container}
El Temps Virtual ($V(t)$) actua com un **Comptador de Rodes (Round Index)** en un planificador ideal **bit-per-bit Round-Robin**
:::


## $V(t)$

$V(t)$ √©s la taxa normalitzada de progr√©s per a qualsevol flux actiu en el sistema GPS ideal.

$$V(t) \rightarrow \frac{\partial V(t)}{\partial t}  =\frac{C}{\sum_{i \in A(t)} w_i} $$

on: 

- $C$ √©s la capacitat de l'enlla√ß.
- $A(t)$ √©s el conjunt de fluxos actius en el temps $t$.




## Weighted Fair Queuing (WFQ) {.smaller}

::: columns
::: {.column width="50%"}
- $\mathbf{F_i^k}$: Temps de Finalitzaci√≥ Virtual del $k$-√® paquet del flux $i$. 
- $\mathbf{a_i^k}$: Temps d'Arribada **Real** del $k$-√® paquet del flux $i$.
- $\mathbf{L_i^k}$: Mida (en bits) del $k$-√® paquet del flux $i$.
- $\mathbf{w_i}$: Pes (prioritat relativa) assignat al flux $i$.

:::
::: {.column width="50%"}

**C√†lcul del Temps de Finalitzaci√≥ Virtual ($\mathbf{F_i^k}$):**

El temps que tindria el paquet si el sistema fos GPS ideal

$$F_{i}^{k} = max(F_{i}^{k-1}, V(a_{i}^{k})) + \frac{L_{i}^{k}}{w_{i}}$$

:::
:::

::: {.fragment .center-container}
L'algorisme **WFQ** selecciona i transmet el paquet a la cua que tingui el Temps de Finalitzaci√≥ Virtual ($F_i^k$) m√©s petit.
:::

::: notes
La primera part, $\max(F_{i}^{k-1}, V(a_{i}^{k}))$, assegura que el paquet no acabi abans que el paquet anterior o que l‚Äôestat del sistema virtual.

La segona part, $\frac{L_{i}^{k}}{w_i}$, distribueix el servei proporcionalment al pes del flux.
:::

## El Problema del LAG en WFQ

√âs la difer√®ncia entre el servei que un flux hauria de rebre en el **sistema ideal (GPS)** i el servei que realment ha rebut en el **sistema de paquets (WFQ)**.

$$Lag_i(t) = \text{Servei Rebut} - \text{Servei Ideal}$$

El lag pot ser positiu o negatiu:

**LAG Positiu:** El flux ha rebut **m√©s servei** del que li correspondria (excedent de servei o r√†fega).
**LAG Negatiu:** El flux ha rebut **menys servei** del que li correspondria (d√®ficit de servei).

## Soluci√≥ al LAG: Temps d'Arribada Virtual ($\mathbf{S_i^k}$) {.smaller}

El temps d‚Äôarribada virtual serveix per sincronitzar l‚Äôentrada dels paquets al sistema ideal, evitant que un flux es benefici√Ø d‚Äôun retard menor o d‚Äôuna r√†fega.

El **Temps d'Arribada Virtual ($\mathbf{S_i^k}$)** (o Starting Tag) com a **filtre d'elegibilitat** per limitar les r√†fegues de paquets.

$$S_{i}^{k} = max(S_{i}^{k-1}, V(a_{i}^{k})) $$

Un paquet nom√©s pot ser seleccionat si el seu $S_i^k$ √©s menor o igual al $V(t)$ actual del sistema. Aix√≤ impedeix que el planificador seleccioni un paquet massa aviat, for√ßant-lo a esperar virtualment i limitant el LAG.
 
## Exemple: Limitaci√≥ del LAG en WFQ {.smaller}

:::columns
::: {.column width="70%"}
![](../figures/slides/04-sched/fair/flow3.png){width="80%"}

:::
::: {.column width="30%"}
- El lag √©s $2.5$ unitats de servei (dependentment del nombre de fluxos).
- El lag √©s $<0.5$ unitats de servei (independentment del nombre de fluxos).
:::
:::


## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE 
- **Max-Min Fairness** ‚Üí Just√≠cia determinista
- **Lottery Scheduling** ‚Üí Just√≠cia probabil√≠stica
- **WFQ** ‚Üí Just√≠cia proporcional amb temps virtual
- **GPS** ‚Üí Model ideal de refer√®ncia
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
::::








