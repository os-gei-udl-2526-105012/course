---
title: "Interbloqueig"
subtitle: "Unitat 5 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 5 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Contextualitzaci√≥ {.smaller}

El *sistemes inform√†tics* estan formats per molts recursos que **poden ser utilitzats per un o m√©s processos a la vegada**.

Imagineu 2 processos al mateix temps:

-   **Situaci√≥ 1**: escrivint a la impressora ‚Üí El resultat seria un text sense sentit.
-   **Situaci√≥ 2**: utilitzant la mateixa ranura de la taula del sistema de fitxers ‚Üí El resultat seria un sistema de fitxers corrupte.

::: {.center-container .fragment}
El sistema operatiu √©s **l'encarregat de gestionar aquests recursos i garantir que no hi hagi conflictes entre els processos que els utilitzen**. Per tant, poden concedir (*temporalment*) a un proc√©s l'acc√©s exclusiu a certs recursos.
:::

::: notes
Una ranura de la taula del sistema de fitxers √©s una estructura de dades que s'utilitza per emmagatzemar informaci√≥ sobre un fitxer o un directori. Aquesta informaci√≥ inclou el nom del fitxer o directori, la seva mida, els permisos d'acc√©s i altres dades.

Si dos processos intenten utilitzar la mateixa ranura al mateix temps, poden causar un conflicte. Per exemple, un proc√©s pot estar actualitzant la informaci√≥ de la ranura mentre l'altre proc√©s est√† llegint la informaci√≥. Aix√≤ pot provocar que la informaci√≥ de la ranura quedi corrupta.
:::

## Creaci√≥ d'un fitxer {.smaller}

Suposem que un **proc√©s (A)** est√† creant un nou fitxer.

1.  El **proc√©s A** necessita accedir a la taula del sistema de fitxers per crear una nova entrada per al nou fitxer. *Aquesta entrada cont√© informaci√≥ sobre el fitxer, com ara el seu nom, la seva mida i els permisos d'acc√©s*.
2.  El **proc√©s A** *necessita* **acc√©s exclusiu** a la ranura per al nou fitxer per poder crear l'entrada correcta.
3.  Si un **proc√©s B** intent√©s crear un fitxer amb el mateix nom al mateix temps, el sistema operatiu bloquejaria el **proc√©s B** fins que el **proc√©s A** finalitzi la creaci√≥ del nou fitxer.

::: {.center-container .fragment}
[Aquesta √©s una manera de garantir que la informaci√≥ del sistema de fitxers sigui precisa i consistent.]{.alert}
:::

## Problemes amb recursos compartits {.smaller}

Suposem l'escenari on tenim dos processos (**A i B**): Els dos processos tenen la finalitat de grabar un document escanejat en una mem√≤ria USB montada a */mnt/USB*.

1.  El **proc√©s A** demana perm√≠s per utilitzar l'escaner i se li concedeix.
2.  El **proc√©s B** demana perm√≠s per utilitzar la mem√≤ria USB i se li concedeix.
3.  El **proc√©s A** demana perm√≠s per utilitzar la mem√≤ria USB, per√≤ la petici√≥ queda suspesa fins que el proc√©s B alliberi la mem√≤ria USB.
4.  Desafortunadament,en lloc d'alliberar la mem√≤ria USB, el **proc√©s B** demana perm√≠s per utilitzar l'esc√†ner.
5.  En aquest punt, els dos processos estan bloquejats i ho seguiran per sempre.

## Qu√® √©s un interbloqueig? {.smaller}

Un **interbloqueig** √©s una situaci√≥ en la qual dos o m√©s processos queden bloquejats. Cada un d'ells espera que l'altre acabi la seva tasca per poder continuar. Aquesta situaci√≥ pot ser causada per l'√∫s de recursos compartits.

::: {.center-container .fragment}
Els interbloquejos poden produir-se en qualsevol sistema en qu√® hi hagi recursos compartits.
:::

-   **En un sistema de gesti√≥ de bases de dades**, dos processos poden estar intentant actualitzar la mateixa fila d'una taula.
-   **En un sistema de jocs en l√≠nia**, dos jugadors poden estar intentant utilitzar el mateix recurs, com ara una arma o una habilitat.
-   **En un sistema de fabricaci√≥**, dues m√†quines poden estar esperant que una tercera m√†quina alliberi un recurs, com ara una pe√ßa o una eina.

## Problema dels filosofs menjant {.smaller}

Imagina 5 fil√≤sofs asseguts al voltant d‚Äôuna taula circular. On cada fil√≤sof pensa i menja de manera c√≠clica. Si el fil√≤sof vol menjar, necessita agafar els dos coberts que t√© al costat.

::::: columns
::: {.column width="60%"}
-   Hi ha 5 fil√≤sofs i 5 coberts.
-   Cada fil√≤sof comparteix els coberts amb els seus ve√Øns.
-   Tots els fil√≤sofs necessiten dos recursos simult√†niament per menjar.
-   Els fil√≤sofs no poden arrencar els coberts dels altres fil√≤sofs (**no apropiatius**).
-   Si tots els fil√≤sofs agafen el cobert de la dreta alhora, es produeix un interbloqueig.
:::

::: {.column width="40%"}
![](../figures/slides/05-deadlock/philosopher.png)
:::
:::::

::: {.center-container .fragment}
Aix√≤ √©s equivalent a processos que necessiten dos recursos exclusius per continuar.
:::

## Recursos apropiatius i no apropiatius {.smaller}

-   **Apropiatiu**: el SO pot retirar-lo temporalment d‚Äôun proc√©s sense comprometre‚Äôn la coher√®ncia.
-   **No apropiatiu**: un cop el proc√©s l‚Äôha adquirit, no es pot retirar fins que l‚Äôallibera.

::: {.center-container .fragment}
La distinci√≥ no dep√®n del recurs en si, sin√≥ de com el sistema operatiu est√† implementat.
:::

-   Un recurs no √©s inherentment apropiatiu o no apropiatiu.
-   Dep√®n de si el SO t√© mecanismes per guardar i restaurar el seu estat.
-   Si l‚Äôestat del recurs √©s f√†cilment salvable ‚Üí pot ser apropiatiu

## Exemples apropiatius / no apropiatius {.smaller}

-   **CPU**: Apropiatiu. El SO pot interrompre un proc√©s (interrupt), guardar-ne l‚Äôestat (PCB) i continuar m√©s tard ‚Üí es pot expropiar sense problemes.
-   **Mem√≤ria**:
    -   **Apropiativa** en sistemes amb swapping o paginaci√≥ ‚Üí el SO pot copiar p√†gines al disc i recuperar-les despr√©s.
    -   **No apropiativa** en sistemes sense swapping(*android*) ‚Üí no es pot retirar mem√≤ria d‚Äôun proc√©s de manera segura ‚Üí pot causar p√®rdua d‚Äôestat.
-   **Dispositius d‚ÄôE/S**:
    -   **No apropiatius**: Impressores, discos durs ‚Üí no es pot interrompre una operaci√≥ d‚Äôescriptura sense perdre dades.
    -   **Apropiatius**: Dispositius amb b√∫fers ‚Üí el SO pot desar dades en un b√∫fer i continuar m√©s tard.

## Gesti√≥ de la sol¬∑licitud de recursos {.smaller}

En alguns sistemes, **quan un recurs no est√† disponible**, *el proc√©s es bloqueja fins que el recurs torni a estar disponible*. En altres sistemes, *la petici√≥ pot fallar amb un codi d'error, transferint la responsabilitat al proc√©s per gestionar la situaci√≥ de petici√≥ fallida i intentar novament obtenir el recurs despr√©s d'un temps determinat*.

::: fragment
Normalment, un proc√©s utilitza un bucle de petici√≥ de recurs, dormir, nova petici√≥ de recurs, dormir, etc. Aquesta t√®cnica √©s coneguda com a **polling**. El proc√©s no es bloqueja, per√≤ tampoc pot realitzar cap acci√≥ fins que el recurs estigui disponible.
:::

::: fragment
La manera exacta de sol¬∑licitar un recurs dep√®n en gran mesura del sistema. En alguns sistemes, es proporciona una **crida de sistema** de petici√≥ que permet als processos sol¬∑licitar expl√≠citament recursos. En altres, els √∫nics recursos que el sistema operatiu coneix s√≥n fitxers especials que nom√©s un proc√©s pot tenir oberts a la vegada. Aquests s'obtenen mitjan√ßant la crida **open**. *Si el fitxer ja est√† en √∫s, el proc√©s queda bloquejat fins que l'actual propietari el tanca*.
:::

## Condicions de Coffman (I) {.smaller}

Les condicions perqu√® es produeixi un interbloqueig de recursos, com van ser presentades per Coffman et al. (1971), s√≥n les seg√ºents:

1.  **Condici√≥ d'exclusi√≥ m√∫tua**: Cada recurs pot ser assignat a un √∫nic proc√©s.
2.  **Condici√≥ (Mantenir i Esperar)**: Un proc√©s que t√© recursos assignats previament pot sol¬∑licitar nous recursos.
3.  **Condici√≥ (No apropiaci√≥)**: Els recursos concedits pr√®viament no es poden prendre de manera for√ßada d'un proc√©s. Han de ser alliberats expl√≠citament pel proc√©s que els t√©.
4.  **Condici√≥ d'Espera Circular**: Ha d'existir una llista circular de dos o m√©s processos, cadascun dels quals espera un recurs que t√© el seg√ºent membre de la cadena.

## Exclusi√≥ m√∫tua {.smaller}

Si tots els recursos fossin c**ompartibles simult√†niament (no exclusius)**, cap proc√©s hauria d‚Äôesperar: m√∫ltiples processos podrien usar el mateix recurs alhora i per tant no s‚Äôorigina la situaci√≥ d‚Äôun proc√©s esperant indefinidament. Com que s√≠ hi ha deadlock, existeixen recursos que nom√©s poden ser ocupats per un proc√©s alhora. 

## Condici√≥ Mantenir i Esperar 

En un *deadlock* hi ha processos que ja tenen alguns recursos i alhora estan esperant altres recursos. Si cap proc√©s tingu√©s recursos mentre esperava (√©s a dir, si primer haguessin de sol¬∑licitar tots els recursos a l‚Äôinici), llavors no podria donar-se la situaci√≥ en qu√® un proc√©s retenint recursos impedeix que un altre progressi. Perqu√® el conjunt $D$ estigui bloquejat, cada proc√©s $P_i$  ret√© almenys un recurs i espera al menys un recurs addicional; aix√≠ s‚Äôest√† complint mantenir i esperar.

## Condici√≥ No apropiaci√≥ 

Si els recursos poguessin ser for√ßosament recuperats (**apropiaci√≥**), el plan de recuperaci√≥ podria prendre un recurs d‚Äôun proc√©s bloquejat i donar-lo al que el necessita, trencant el *deadlock*. Perqu√® el *deadlock* persisteixi indefinidament, **no es poden apropiar recursos de manera for√ßada**; els recursos nom√©s s‚Äôalliberen volunt√†riament pels processos. Per tant, la **no apropiaci√≥** ha de ser certa en la situaci√≥ de *deadlock*.

## Condici√≥ d'Espera Circular {.smaller}

Perqu√® hi hagi un *deadlock*, cal que hi hagi una depend√®ncia circular entre els processos bloquejats. Cada proc√©s dins del conjunt bloquejat $D$ espera un recurs que √©s posse√Øt per un altre proc√©s dins de $D$. Seguint aquestes depend√®ncies, s‚Äôarriba de nou al primer proc√©s, formant un cicle. Aquesta situaci√≥ √©s coneguda com a **espera circular**. Sense aquest cicle, hi hauria algun proc√©s que podria ser satisfet i desbloquejar la resta. Per tant, per a que hi hagi *deadlock*, la condici√≥ d'espera circular ha de ser certa.


## Condicions de Coffman (II)

::: fragment
Aquestes condicions estan relacionades amb una pol√≠tica que un sistema pot tenir o no. *Pot assignar-se un recurs determinat a m√©s d'un proc√©s alhora? Pot un proc√©s mantenir un recurs i sol¬∑licitar-ne un altre? Poden els recursos ser apropiats? Poden existir esperes circulars?*
:::

::: {.center-container .fragment}
**Totes quatre condicions han de ser presents perqu√® es produeixi un bloqueig de recursos. Si n'hi ha una que est√† absent, no √©s possible un bloqueig de recursos.**
:::

:::{.center-container .fragment}
Les 4 condicions s√≥n necess√†ries per√≤ no sempre suficients per a un interbloqueig.
:::

## Graf d'assignaci√≥ de recursos {.smaller}

Un **graf d'assignaci√≥ de recursos** √©s un **graf dirigit** que representa les relacions entre els processos i els recursos en un sistema. Els nodes del graf representen els processos i els recursos, i les arestes del graf representen les peticions de recursos.

::::: columns
::: {.column width="40%"}
![](../figures/slides/05-deadlock/graf-assi.jpg)
:::

::: {.column width="60%"}
-   Processos: Nodes (*Circulars*) del graf \blueArrow $P_1, P_2, \ldots, P_n$
-   Recursos: Nodes (*Rectangulars*) del graf \blueArrow $R_1, R_2, \ldots, R_m$
-   Instancies de recursos: Nodes (*Rectangulars*) del graf \blueArrow $R_1^1, R_1^2, \ldots, R_1^{n_1}, R_2^1, R_2^2, \ldots, R_2^{n_2}, \ldots, R_m^1, R_m^2, \ldots, R_m^{n_m}$
-   Peticions de recursos: Arestes del graf \blueArrow $P_i \rightarrow R_j$
-   Assignacions de recursos: Arestes del graf \blueArrow $R_j \rightarrow P_i$
:::
:::::

## Exemples de modelitzaci√≥ de recursos (Causa Interbloqueig)

::: {.center-container .fragment}
![](../figures/slides/05-deadlock/example-causa-inter.png){width="60%"}
:::

## Exemples de modelitzaci√≥ de recursos (Evitar Interbloqueig)

::: {.center-container .fragment}
![](../figures/slides/05-deadlock/exemple-evitar-inter.png){width="60%"}
:::

## Estrat√®gies per prevenir interbloquejos (I) {.smaller}

-   **Ignorar el problema**: Aquesta √©s una opci√≥ que generalment no es recomana, ja que pot conduir a conseq√º√®ncies negatives. No prendre accions pot resultar en un estancament permanent del sistema.
-   **Detectar i Recuperar**:
    -   **Algorisme de detecci√≥**: Utilitzar un algorisme de detecci√≥ de bloqueig: Implementar un sistema que monitoritzi l'√∫s dels recursos i detecti quan hi ha un potencial bloqueig.
    -   **Algorisme de recuperaci√≥**: Desenvolupar un procediment per alliberar els recursos del bloqueig i permetre la continuaci√≥ del sistema. Aix√≤ podria incloure la revocaci√≥ de recursos o la reorganitzaci√≥ de les prioritats.

## Estrat√®gies per prevenir interbloquejos (II) {.smaller}

-   **Evitar el Bloqueig de Forma Din√†mica**: Implementar un algorisme predictiu: Desenvolupar un sistema que pugui preveure si l'assignaci√≥ de recursos sol¬∑licitada podria conduir a un bloqueig. Aix√≤ permetr√† prendre mesures abans que el problema esdevingui cr√≠tic.
-   **Evitar les condicions de Coffman**: Analitzar les condicions de Coffman, com l'exclusi√≥ m√∫tua, la posada en espera circular i l'espera indefinida, i prendre mesures per assegurar que aquestes condicions (*o alguna*) mai es compleixin.

## Algorisme Ostrich {.smaller}

La manera m√©s senzilla d'evitar els interbloquejos √©s l'algorisme de l'**estru√ß**: posar el cap sota la sorra i fingir que no hi ha cap problema.

-   Els matem√†tics diuen que aquesta estrat√®gia √©s inacceptable i que els interbloquejos s'han d'evitar a tota costa.
-   Els enginyers pregunten amb quina freq√º√®ncia es produeix el problema, amb quina freq√º√®ncia el sistema es bloqueja per altres motius i quan √©s greu un interbloqueig. Abans de prendre mesures per evitar els interbloquejos, els enginyers volen saber si el problema √©s greu.

## Algorisme Ostrich (II) {.smaller}

Imagina un sistema operatiu que no detecta els interbloquejos. Si un interbloqueig es produeix una vegada cada 10 anys, el sistema operatiu no hauria de preocupar-se per aquest problema. Si un interbloqueig es produeix una vegada cada 10 minuts, el sistema operatiu hauria de prendre mesures per evitar-lo.

::: {.center-container .fragment}
[**Si un proc√©s obt√© el recurs d'un USB i un altre obra la impressora i despr√©s cada proc√©s intenta obrir el recurs de l'altre i es bloqueja, tenim un interbloqueig. Pocs sistemes actuals detectaran aix√≤.**]{.alert}
:::

## Prevenir interbloquejos {.smaller}

-   **Exclusi√≥ m√∫tua**: Fer un **spooling** de tots els recursos. \blueArrow Mou el problema a un altre lloc.
    -   Aplicar de forma selectiva prioritzant els recursos cr√≠tics.
-   **Mantenir i Esperar**: Els processos demanen tots els recursos que necessiten al principi. \blueArrow No es pot predir quants recursos necessitar√† un proc√©s. A m√©s a m√©s, redueix el paral¬∑lelisme i el rendiment.
    -   Ajustar din√†micament les peticions segons les necessitats.
-   **No apropiaci√≥**: Recursos apropiatius. \blueArrow No es pot aplicar a tots els recursos.
-   **Espera Circular**: Ordenar les peticions de recursos. \blueArrow Molt dificil de fer.
    -   Implementar algorismes de gesti√≥ de recursos per minimizar les esperes circulars.

::: fragment
**Spooling**: T√®cnica de gesti√≥ de recursos que consisteix en fer una cua de peticions de recursos. Aquesta t√®cnica es pot aplicar a qualsevol recurs, per√≤ √©s m√©s comuna en els dispositius d'entrada/sortida.
:::

## Detecci√≥ & 1 recurs de cada tipus {.smaller}

Assumirem que hi ha un √∫nic recurs de cada tipus. Aix√≤ significa que nom√©s hi ha una inst√†ncia de cada recurs. Per aquest sistemes, podem utilitzar un graf d'assignaci√≥ de recursos per determinar si hi ha un interbloqueig. **Si hi ha un cicle, existeix un interbloqueig, i qualsevol proc√©s del cicle es troba involucrat**. En canvi, si no existeix cap cicle, no hi ha interbloqueig.

::::::: columns
::: {.column width="40%"}
-   $A$ t√© el recurs R i vol el recurs S.
-   $B$ vol el recurs T.
-   $C$ no t√© cap recurs i vol el recurs S.
-   $D$ t√© el recurs U i vol els recursos S i T.
-   $E$ t√© el recurs T i vol el recurs V.
-   $F$ t√© el recurs W i vol el recurs S.
-   $G$ t√© el recurs V i vol el recurs U.
:::

::::: {.column width="60%"}
![](../figures/slides/05-deadlock/ex1-graf.png){width="60%"}

::: fragment
**Existeix un interbloqueig? Quins processos estan involucrats?**
:::

::: fragment
1 cicle ‚Üí Interbloqueig. Els processos involucrats s√≥n: $D$, $E$, $G$.
:::
:::::
:::::::

## Algorisme de detecci√≥ & 1 recurs {.smaller}

::: columns
::: {.column width="40%"}
``` {.python size="smaller"}
per cada Node N en LlistaNodes:
  Inicialitzar L a la llista buida  
  Marcar tots els arcs com a no marcats
  detectar_cicle(N, LlistaArcs, L)
```
:::
::: {.column width="60%"}
``` {.python size="smaller"}
def detectar_cicle(NodeActual, LlistaArcs, L):
    Afegir NodeActual al final de L
    # Si el NodeActual ja era al cam√≠ ‚Üí hem format un cicle
    si L.count(NodeActual) > 1:
        Imprimir "El graf cont√© un cicle: ", L
        Finalitzar l'algorisme
    # Obtenir arcs de sortida no marcats
    ArcsNoMarcats = [arc per arc en LlistaArcs
        si arc.origen == NodeActual i no arc.marcat]
    si ArcsNoMarcats != []:
        # Seleccionar un arc i baixar al node dest√≠
        arc = Seleccionar_Arc_Atzar(ArcsNoMarcats)
        arc.marcat = True
        NodeSeguent = arc.desti
        detectar_cicle(NodeSeguent, LlistaArcs, L)
    sin√≥:  
        # No hi ha m√©s arcs: cal retrocedir
        # Retirem el NodeActual del cam√≠ i tornem enrere
        L.pop()
        si L == []:
            Imprimir "El subgraf explorat no cont√© cicles"
            retornar
        NodeAnterior = L[-1]
        detectar_cicle(NodeAnterior, LlistaArcs, L)
```
:::
:::

::: notes
Aquest algorisme pren cada node, successivament, com a arrel del que espera que sigui un arbre i realitza una recerca en profunditat. Si en algun moment torna a un node que ja ha trobat, aix√≤ indica que ha trobat un cicle. Si esgotem totes les arestes des d'un node donat, retrocedim al node anterior. Si retrocedim fins a l'arrel i no podem continuar, el subgraf accessible des del node actual no cont√© cap cicle. Si aquesta propietat es compleix per a tots els nodes, tot el graf no cont√© cicles, de manera que el sistema no es troba en un estat d'encallament (deadlock).

En resum, l'algorisme fa una exploraci√≥ en profunditat des de cada node comen√ßant pel seu suposat arbre, rastrejant camins i detectant cicles si torna a trobar un node ja visitat. Aquesta exploraci√≥ en profunditat permet analitzar la connexi√≥ entre els nodes i determinar si hi ha cicles.
:::

## Exemple d'execuci√≥ de l'algorisme (I) {.smaller}

Assumeix que tenim un graf dirigit amb 4 nodes (A,B,C,D) i 4 arestes (A‚ÜíB, B‚ÜíC, C‚ÜíD, D‚ÜíA). Si comen√ßem amb el **Node A** com a node inicial:

-   Inicialitzem L a \[\].
-   Marquem tots els arcs com a no marcats.
-   Executem detectar_cicle(A, LlistaArcs, \[A\]).
-   Dins de detectar_cicle amb NodeActual = A:
    -   No hi ha cicles ja que A no apareix dues vegades a L.
    -   Seleccionem l'arc (A, B) i el marquem.
    -   Anem al node B, i tornem a executar detectar_cicle(B, LlistaArcs, \[A, B\]).
-   Dins de detectar_cicle amb NodeActual = B:
    -   No hi ha cicles ja que B no apareix dues vegades a L.
    -   Seleccionem l'arc (B, C) i el marquem.
    -   Anem al node C, i tornem a executar detectar_cicle(C, LlistaArcs, \[A, B, C\]).

## Exemple d'execuci√≥ de l'algorisme (II) {.smaller}

-   Dins de detectar_cicle amb NodeActual = C:
    -   No hi ha cicles ja que C no apareix dues vegades a L.
    -   Seleccionem l'arc (C, D) i el marquem.
    -   Anem al node D, i tornem a executar detectar_cicle(D, LlistaArcs, \[A, B, C, D\]).
-   Dins de detectar_cicle amb NodeActual = D:
    -   No hi ha cicles ja que D no apareix dues vegades a L.
    -   Seleccionem l'arc (D, A) i el marquem.
    -   Anem al node A, i tornem a executar detectar_cicle(A, LlistaArcs, \[A, B, C, D, A\]).
-   Dins de detectar_cicle amb NodeActual = A:
    -   Afegim A a L, ara L √©s \[A, B, C, D, A\].
    -   Aquesta vegada A apareix dues vegades a L, indicant que hi ha un cicle.
    -   Imprimim *El graf cont√© un cicle: \[A, B, C, D, A\]* i finalitzem l'algorisme.

## Consideracions sobre l'algorisme {.smaller}

-   Aquest algorisme no √©s eficient, ja que pot haver-hi molts camins per explorar.
-   Aquest algorisme nom√©s funciona per sistemes amb un √∫nic recurs de cada tipus. Per sistemes amb m√∫ltiples inst√†ncies de cada recurs, caldria utilitzar un altre algorisme.
-   Hi ha altres algorismes m√©s eficients per detectar cicles en un graf dirigit, com ara l'algorisme de *Tarjan*. **Tarjan**: Mitjan√ßant un recorregut en profunditat (*DFS*), assigna n√∫meros de baixada i d'arribada als nodes i actualitza els valors *low* que indiquen el n√∫mero de baixada m√©s petit accessible des del subarbre d'un node, incloent les arestes de retroc√©s. **Quan es troba un cicle**, els nodes del cicle tenen els mateixos valors de n√∫mero de baixada i *low*, revelant components fortes. Aquesta informaci√≥ jer√†rquica ajuda a identificar de manera eficient les relacions de depend√®ncia entre els nodes del graf.


## Graf d'espera {.smaller}

Un graf d'espera es construeix a partir d'un graf d'assignaci√≥ de recursos. Els nodes del graf d'espera s√≥n els processos, i les arestes s√≥n les peticions de recursos. Una aresta del graf d'espera indica que el proc√©s que es troba a l'origen de l'aresta est√† esperant un recurs que t√© el proc√©s que es troba al final de l'aresta.

1.  Eliminar tots els nodes corresponents als recursos.
2.  Ajustar els arcs perqu√® apuntin als processos en lloc dels recursos.

::: {.center-container .fragment}
![](../figures/slides/05-deadlock/graf-espera.png){width="60%"}
:::

::: {.center-container .fragment}
**Si el graf d'espera cont√© un cicle, hi ha un interbloqueig.**
:::

## Detecci√≥ & graf d'espera {.smaller}

Si creem una matriu $A$ de mida $N \times N$ on $N$ √©s el nombre de processos, i $A_{ij}$ √©s el nombre d'arestes del graf d'espera que connecten el proc√©s $P_i$ amb el proc√©s $P_j$, podem utilitzar aquesta matriu per detectar interbloquejos.

::: fragment
Per fer-ho, inicialitzarem $A$ a 0. Si existeix un arc del proc√©s $P_i$ al proc√©s $P_j$, incrementarem $A_{ij}$ en 1. Multipliquem la matriu $A$ per ella mateixa: $A^k = A^{k-1} \times A$. Aquesta operaci√≥ es pot realitzar de manera eficient utilitzant l'algorisme de **Strassen**. *Si apareix un nombre diferent a 0 a la diagonal de la matriu* $A^k$, hi ha un interbloqueig.
:::

::::::::: columns
:::: {.column width="30%"}
::: fragment
$$
A =
\begin{bmatrix}
  0 & 1 & 0 \\
  0 & 0 & 1 \\
  1 & 1 & 0 \\
\end{bmatrix}
$$
:::
::::

:::: {.column width="35%"}
::: fragment
$$
A^2 = A \cdot A =
\begin{bmatrix}
  0 & 0 & 1 \\
  1 & 1 & 0 \\
  0 & 1 & 1 \\
\end{bmatrix}
$$

P2 i P3 tenen un interbloqueig de longitud 2.
:::
::::

:::: {.column width="35%"}
::: fragment
$$
A^3 = A \cdot A^2 =
\begin{bmatrix}
  1 & 1 & 0 \\
  0 & 1 & 1 \\
  1 & 1 & 1 \\
\end{bmatrix}
$$

P1,P2 i P3 tenen un interbloqueig de longitud 3.
:::
::::
:::::::::

::: notes
Per multiplicar dues matrius cal multiplicar cada element de la fila de la primera matriu per cada element de la columna de la segona matriu. El resultat de cada multiplicaci√≥ es suma i es col¬∑loca a la posici√≥ corresponent de la matriu resultant.
:::

## Detecci√≥ & M recursos de cada tipus (I) {.smaller}

-   Assumirem:

    -   $n$ processos $P_1, P_2, \ldots, P_n$.
    -   $m$ recursos de diferents tipus $R_1, R_2, \ldots, R_m$.
    -   Cada recurs $R_i$ t√© $e$ inst√†ncies $R_i^{1}, R_i^{2}, \ldots, R_i^{e}$.

-   Definirem:

    -   $A$ √©s un vector que representa la disponibilitat de recursos, on $A_j$ √©s el nombre d'inst√†ncies disponibles del recurs $R_j$.
    -   $C$ √©s una matriu que representa l'estat del sistema, on $C_{ij}$ √©s el nombre d'inst√†ncies del recurs $R_j$ que estan assignades al proc√©s $P_i$.
    -   $R$ √©s una matriu que representa les peticions de recursos, on $R_{ij}$ √©s el nombre d'inst√†ncies del recurs $R_j$ que el proc√©s $P_i$ est√† sol¬∑licitant.
    -   $E$ √©s un vector que representa el nombre total d'inst√†ncies de cada recurs, on $E_i$ √©s el nombre total d'inst√†ncies del recurs $R_i$.

## Detecci√≥ & M recursos de cada tipus (II) {.smaller}

Definirem la **disponibilitat** de recursos es pot calcular com $A_j = E_j - \sum_{i=0}^{n}C_{ij}$.

::: {.center-container .fragment}
**Si** $R_{ij} > A_j$, el proc√©s $P_i$ no pot obtenir el recurs $R_j$ i es bloqueja.
:::

::: {.center-container .fragment}
![Representaci√≥ de les estructures de dades](../figures/slides/05-deadlock/deteccio-alg-m.png){width="90%"}
:::

## Algorisme detecci√≥ M recursos {.smaller}

L'algorisme de detecci√≥ d'interbloquejos es basa en la **comparaci√≥ de vectors**. Definirem la relaci√≥ $A \leq B$ en dos vectors $A$ i $B$ per indicar que cada element de $A$ √©s menor o igual que el corresponent element de $B$. Matem√†ticament, $A \leq B$ es compleix **si i nom√©s si** $A_i \leq B_i$ per a tots els valors de $i$ entre 1 i $m$ ($1 \leq i \leq m$).

1.  Cada proc√©s es considera inicialment no marcat.
2.  Buscar un proc√©s no marcat, $P_i$, per al qual la fila $i$-√®ssima de $R$ sigui menor o igual a $A$ (√©s a dir, $R_i \leq A$).
3.  Si es troba un proc√©s com aquest, sumar la fila $i$-√®ssima de $C$ a $A$ (√©s a dir, $A = A + C_i$), marcar el proc√©s i tornar a 2.
4.  Si no existeix cap proc√©s com aquest, l'algorisme finalitza.
5.  Quan l'algorisme finalitza, qualsevol proc√©s no marcat es coneix com interbloquejat.

::: {.center-container .fragment}
Aquest algorisme assumeix un escenari de pitjor cas: tots els processos mantenen tots els recursos adquirits fins que surten.
:::

## Exemple d'execuci√≥ (I) {.smaller}

:::::: columns
::: {.column width="33%"}
$$
A =
\begin{bmatrix}
  2 & 1 & 0 & 0
\end{bmatrix}
$$

$$
E =
\begin{bmatrix}
  4 & 2 & 3 & 1
\end{bmatrix}
$$
:::

::: {.column width="33%"}
$$
C =
\begin{bmatrix}
  0 & 0 & 1 & 0 \\
  2 & 0 & 0 & 1 \\
  0 & 1 & 2 & 0 \\
\end{bmatrix}
$$
:::

::: {.column width="33%"}
$$
R =
\begin{bmatrix}
  2 & 0 & 0 & 1 \\
  1 & 0 & 1 & 0 \\
  2 & 1 & 0 & 0 \\
\end{bmatrix}
$$
:::
::::::

-   Pas 1: Buscar un proc√©s que es pugui satisfer totes les seves sol¬∑licituts.
    -   $P1$ no es pot satisfer ja que sol¬∑licita 1 instancia de $R4$ i no ni ha cap disponible.
    -   $P2$ no es pot satifer ja que sol¬∑licita 1 instancia de $R3$ i no ni ha cap disponible.
    -   $P3$ es pot satisfer ja que sol¬∑licita 2 instancies de $R1$ i 1 de $R2$ i aquestes estan disponibles a $A$.

## Exemple d'execuci√≥ (I) {.smaller}

:::::: columns
::: {.column width="33%"}
$$
A =
\begin{bmatrix}
  2 & 1 & 0 & 0
\end{bmatrix}
$$

$$
E =
\begin{bmatrix}
  4 & 2 & 3 & 1
\end{bmatrix}
$$
:::

::: {.column width="33%"}
$$
C =
\begin{bmatrix}
  0 & 0 & 1 & 0 \\
  2 & 0 & 0 & 1 \\
  0 & 1 & 2 & 0 \\
\end{bmatrix}
$$
:::

::: {.column width="33%"}
$$
R =
\begin{bmatrix}
  2 & 0 & 0 & 1 \\
  1 & 0 & 1 & 0 \\
  2 & 1 & 0 & 0 \\
\end{bmatrix}
$$
:::
::::::

-   Pas 2: Sumar la fila $i$-√®ssima de $C$ a $A$.
    -   $A = A + C_3 = [2,1,0,0] + [0,1,2,0] = [2,2,2,0]$
    -   Marquem el proc√©s $P3$. En aquest moment, $P3$ pot finalitzar i alliberar els recursos que t√© assignats. $A = [4,3,2,0]$

::: fragment
Amb aquests recursos alliberats, podem satisfer les sol¬∑licituds de $P1$ i $P2$. Per tant no hi ha interbloqueig. Si $P3$ hagu√©s sol¬∑licitat 1 instacia de $R4$ llavors no es podria satisfer cap sol¬∑licitud i tindr√≠em un interbloqueig.
:::

## Quan s'ha de fer la detecci√≥ d'interbloquejos? {.smaller}

::: {.cemter-container .fragment}
Ara que sabem com detectar interbloquejos, assumint que coneixem amb **antelaci√≥ la sol¬∑licitud de recursos (est√†tic)**, la pregunta √©s quan haur√≠em de buscar-los.
:::

::: fragment
Una possibilitat √©s comprovar-ho cada vegada que es fa una sol¬∑licitud de recursos. Aix√≤ assegura detectar-los tan aviat com sigui possible, per√≤ pot ser potencialment costos en termes de temps de CPU. ‚Üí **Sobrec√†rrega del sistema**.
:::

::: fragment
Una estrat√®gia alternativa √©s comprovar-ho cada *k minuts*, o quan la utilitzaci√≥ de la CPU hagi baixat per sota d'un cert llindar $\theta$. ‚Üí **Pot ser que no es detectin interbloquejos immediatament, si existeixen cicles diferents, pot ser dif√≠cil determinar quin proc√©s est√† involucrat en cada cicle.**
:::

::: {.fragment .center-container}
La ra√≥ per considerar la utilitzaci√≥ de la CPU √©s que si suficients processos estan interbloquejats, hi haur√† pocs processos executables, i la CPU sovint estar√† inactiva.
:::

## Recuperaci√≥ d'interbloquejos {.smaller}

Suposeu que un sistema operatiu detecta un interbloqueig. Qu√® hauria de fer el sistema operatiu? Hi ha dues possibilitats:

1.  **Recuperaci√≥ manual**: El sistema operatiu pot demanar a l'usuari que seleccioni un proc√©s per finalitzar-lo. Aix√≤ alliberar√† els recursos que el proc√©s t√© assignats i permetr√† que altres processos continu√Øn.
2.  **Recuperaci√≥ autom√†tica**: El sistema operatiu pot seleccionar un proc√©s per finalitzar-lo. Aix√≤ alliberar√† els recursos que el proc√©s t√© assignats i permetr√† que altres processos continu√Øn.

## Recuperaci√≥ amb apropiaci√≥ (I) {.smaller}

La recuperaci√≥ amb apropiaci√≥ de recursos √©s una t√®cnica que permet prendre temporalment un recurs d'un proc√©s, permetre que un altre proc√©s el faci servir i despr√©s tornar-lo al proc√©s original sense que aquest se'n adoni. No obstant aix√≤, aquesta capacitat de recuperaci√≥ dep√®n en gran mesura de la naturalesa espec√≠fica del recurs.

::: {.fragment}
**Met√†fora**:
Imaginem que tenim una impressora compartida entre diversos usuaris. Un usuari est√† realitzant una gran tasca d'impressi√≥, mentre que un altre usuari necessita imprimir un document urgent. El sistema operatiu pot prendre temporalment la impressora del primer usuari i donar-la al segon usuari. Quan el segon usuari acabi d'imprimir, el sistema operatiu pot tornar la impressora al primer usuari.
:::

:::{.fragment .center-container}
A la realitat la impressora no es pot apropiar d'un usuari a un altre sense que l'usuari original se n'adoni.
:::

## Recuperaci√≥ amb apropiaci√≥ (II) {.smaller}

-   Recuperar amb aquesta t√®cnica √©s complex. No sempre √©s senzill determinar quin proc√©s √©s el m√©s adequat per ser susp√®s i si aquesta t√®cnica √©s aplicable dep√®n de la naturalesa espec√≠fica del recurs i del context de la situaci√≥.
-   Podria comportar inanici√≥. Si un proc√©s √©s susp√®s repetidament, pot ser que mai pugui completar la seva tasca.

## Recuperaci√≥ per **rollback** {.smaller}

La recuperaci√≥ per **rollback** es basa en l'√∫s de **checkpoints**.

-   Un **checkpoint** √©s un punt en el temps en qu√® es guarda l'estat d'un proc√©s. Per exemple, es pot guardar en un fitxer l'estat d'un proc√©s (mem√≤ria, recursos asignats,...) en un moment determinat.
-   Un **rollback** √©s una operaci√≥ que restaura l'estat d'un proc√©s a un punt anterior en el temps.

::: fragment
Quan es detecta un interbloqueig, s'observen els recursos necessaris i es selecciona un proc√©s que els tingui assignats. A continuaci√≥, es realitza un rollback d'aquest proc√©s a un punt anterior en el temps, abans que adquir√≠s els recursos. Aix√≤ allibera els recursos i permet que altres processos els utilitzin.
:::

::: {.fragment .center-container}
Es perden totes les instruccions executades des del checkpoint, ja que el proc√©s es reinicia a un estat anterior.
:::

## Recuperaci√≥ per finalitzaci√≥ de processos {.smaller}

La manera m√©s simple de recuperar-se d'un interbloqueig √©s finalitzar un proc√©s. Aix√≤ alliberar√† els recursos que el proc√©s t√© assignats i permetr√† que altres processos continu√Øn. De forma dr√†stica, es pot finalitzar tots els processos que estan involucrats en el cicle d'interbloqueig.

-   **Selecci√≥ de Processos en el Cicle**: S'ha de seleccionar un dels processos involucrats en el cicle i finalitzar-lo. Aquest proc√©s pot ser reinitiat despr√©s per evitar l'interbloqueig.
-   **Finalitzaci√≥ de Processos Amb Recursos Necessaris**: Finalitzar un proc√©s que tingui recursos assignats que necessitin els processos del cicle, encara que el proc√©s no estigui directament involucrat en el cicle.

::: {.fragment .center-container}
En aquesta selecci√≥ es pot tenir en compte la prioritat dels processos, el temps que porten en execuci√≥, el nombre de recursos que tenen assignats, etc.
:::

::: notes
En la mesura del possible, √©s millor finalitzar un proc√©s que es pugui tornar a executar des del principi sense efectes adversos. Per exemple, una compilaci√≥ sempre es pot tornar a executar perqu√® nom√©s llegeix un fitxer font i produeix un fitxer objecte. D'altra banda, un proc√©s que actualitza una base de dades no sempre es pot executar de nou amb seguretat, ja que pot tenir efectes irreversibles, com un proc√©s que suma 1 a un camp de la taula, si el tornem a executar podem estar sumant 2 (cosa incorrecta).
:::

## Evitar interbloquejos {.smaller}

La evitaci√≥ dels interbloquejos es basa en dos algorismes. L'agorisme del **banquer** proposat per Dijkstra i l'algorisme de **seguretat** proposat per Coffman.

-   **Estat segur**: Un estat √©s **segur** si hi ha una manera de que tots els processos puguin finalitzar amb √®xit sense que es produeixi un interbloqueig.
-   **Seq√ºencia segura**: Una seq√º√®ncia de processos $P_1, P_2, \ldots, P_n$ √©s una **seq√º√®ncia segura** si el proc√©s $P_i$ pot satisfer les seves sol¬∑licituds de recursos i finalitzar amb √®xit despr√©s de la finalitzaci√≥ del proc√©s $P_{i-1}$, per a tots els valors de $i$ entre 1 i $n$ ($1 \leq i \leq n$).
-   **Estat insegur**: Un estat √©s **insegur** si no √©s segur.

## Algorisme del banquer per a 1 recurs {.smaller}

L'algorisme del banquer √©s un algorisme d'evitaci√≥ d'interbloquejos que es basa en la idea de prevenir-los. Aquest algorisme es basa en el fet que si un sistema es troba en un estat segur, no es produir√† un interbloqueig.

-   El processos (*clients*) sol¬∑liciten recursos (*diners*).
-   El sistema operatiu (*banquer*) √∫nicament concedeix els recursos si comporten un estat segur.
-   Les demandes m√†ximes de recursos (*cr√®dits*) s√≥n conegudes amb antelaci√≥.

## Exemple - Banquer & 1 recurs {.smaller}

::::::::: columns
:::: {.column width="30%"}
::: fragment
$$
\begin{bmatrix}
    & Assignat & Max \\
  A & 0        & 6 \\
  B & 0        & 5 \\
  C & 0        & 4 \\
  D & 0        & 7 \\
\end{bmatrix}
$$

Si hi ha diponibles 10 recursos. **Estat segur**, tots poden finalitzar amb √®xit.
:::
::::

:::: {.column width="30%"}
::: fragment
$$
\begin{bmatrix}
    & Assignat & Max \\
  A & 1        & 6 \\
  B & 1        & 5 \\
  C & 2        & 4 \\
  D & 4        & 7 \\
\end{bmatrix}
$$

Si hi ha diponibles 2 recursos. **Estat segur**, **C** primer i despr√©s la resta.
:::
::::

:::: {.column width="30%"}
::: fragment
$$
\begin{bmatrix}
    & Assignat & Max \\
  A & 1        & 6 \\
  B & 2        & 5 \\
  C & 2        & 4 \\
  D & 4        & 7 \\
\end{bmatrix}
$$

Si hi ha diponibles 1 recurs. **Estat insegur**, ning√∫ pot acabar.
:::
::::
:::::::::

## Algorisme del banquer per a $M$ recursos {.smaller}

L'algorisme del banquer es pot generalitzar per a sistemes amb m√∫ltiples recursos de cada tipus. En aquest cas, el sistema operatiu ha de mantenir una matriu $A$ de mida $M \times N$ on $M$ √©s el nombre de recursos i $N$ √©s el nombre de processos. Els elements de la matriu $A_{ij}$ indiquen el nombre d'inst√†ncies del recurs $R_i$ que el proc√©s $P_j$ t√© assignades.

1.  Seleccioneu un proc√©s $P_i$ que no s'hagi finalitzat i que tingui una demanda m√†xima $R_i$ que sigui menor o igual a $A$.
2.  Marqueu el proc√©s $P_i$ i afegiu la fila $i$-√®ssima de $C$ a $A$.
3.  Repeteix els passos fins acabar en un (estat segur) o un (estat insegur).

## Algorisme del banquer {.smaller}

``` {.python size="tiny"}
procedure banquer(M: integer, N: integer, C: matrix, R: matrix)
    // M: nombre de recursos, N: nombre de processos, C: matriu d'estat actual del sistema (disponibilitat dels recursos)
    // R: matriu de m√†xims requerits pels processos
    finish: array of boolean of length N // indica si un proc√©s ha finalitzat
    work: array of integer of length M   // matriu que representa els recursos disponibles
    for i := 1 to M do
        work[i] := C[0, i] // inicialitzar work amb la disponibilitat actual de recursos
    for i := 1 to N do
        finish[i] := false // inicialitzar tots els processos com a no finalitzats
    repeat
        found := false // indica si s'ha trobat un proc√©s adequat en aquesta iteraci√≥
        for i := 1 to N do
            if not finish[i] and all(R[i, j] <= work[j] for j := 1 to M) then
                // El proc√©s i no ha finalitzat i la seva demanda √©s menor o igual als recursos disponibles
                for j := 1 to M do
                    work[j] := work[j] + C[i, j] // alliberar els recursos del proc√©s i
                finish[i] := true // marcar el proc√©s com a finalitzat
                found := true // indicar que s'ha trobat un proc√©s en aquesta iteraci√≥
                break 
        until not found
    // Comprovar si tots els processos s'han finalitzat
    if all(finish[i] for i := 1 to N) then print("L'estat √©s segur")
    else print("L'estat √©s insegur")
end procedure
```

## Exemple - Concesi√≥(I) {.smaller}

:::::: columns
:::: {.column width="50%"}
$$
Disponible =
\begin{bmatrix}
  R1 & R2 & R3 \\
   3 &  3 &  2 \\
\end{bmatrix}
$$

$$
Max =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  7 &  5 &  3 \\
  P2 &  3 &  2 &  2 \\
  P3 &  9 &  0 &  2 \\
  P4 &  2 &  2 &  2 \\
  P5 &  4 &  3 &  3 \\
\end{bmatrix}
$$

::: center
**P1 sol¬∑licita una inst√†ncia de** $R1$ i dos de $R3$. Es concediran?
:::
::::

::: {.column width="50%"}
$$
Necessito =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  7 &  4 &  3 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$

$$
Assignat =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  0 &  1 &  0 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

## Exemple - Concesi√≥(II) {.smaller}

### Pas 1: Comprovaci√≥ de la sol¬∑licitud

P1 sol¬∑licita 1 inst√†ncia de R1 i 2 inst√†ncies de R3.

-   Solicito\[1,0,2\] $\leq$ Disponible \[3,3,2\].
-   Solicito\[1,0,2\] $\leq$ Necessito \[7,4,3\].

::: fragment
### Pas 2: Simulaci√≥ de l'assignaci√≥

P1 obt√© els recursos.

-   Disponible = Disponible - Solicito = \[2,3,0\]
-   Assignat = Assignat + Solicito = \[1,1,2\]
-   Necesito = Necesito - Solicito = \[6,4,1\]
:::

## Exemple - Concesi√≥(III) {.smaller}

:::::: columns
::: {.column width="30%"}
$$
D =
\begin{bmatrix}
  R1 & R2 & R3 \\
   2 &  3 &  0 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
A =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  1 &  1 &  2 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

-   *Iteraci√≥ 1*:
    -   P2: Assignats\[3,0,2\] i Necessito\[0,2,0\]. Podeu satisfer P2.
    -   P2 obt√© els recursos i els allibera. Disponible = \[5,3,2\]

## Exemple - Concesi√≥(IV) {.smaller}

:::::: columns
::: {.column width="30%"}
$$
D =
\begin{bmatrix}
  R1 & R2 & R3 \\
   2 &  3 &  0 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
A =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  1 &  1 &  2 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

-   *Iteraci√≥ 2*:
    -   P4: Assignats\[2,1,1\] i Necessito\[0,1,1\] Podeu satisfer P4.
    -   P4 obt√© els recursos i els allibera. Disponible = \[7,4,3\]

## Exemple - Concesi√≥(V) {.smaller}

:::::: columns
::: {.column width="30%"}
$$
D =
\begin{bmatrix}
  R1 & R2 & R3 \\
   2 &  3 &  0 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
A =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  1 &  1 &  2 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

-   *Iteraci√≥ 3*:
    -   P3: Assignats\[3,0,2\] i Necessito\[6,0,0\]. Podeu satisfer P3.
    -   P3 obt√© els recursos i els allibera. Disponible = \[10,4,5\]

## Exemple - Concesi√≥(VI) {.smaller}

:::::: columns
::: {.column width="30%"}
$$
D =
\begin{bmatrix}
  R1 & R2 & R3 \\
   2 &  3 &  0 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
A =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  1 &  1 &  2 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

-   *Iteraci√≥ 4*:
    -   P1: Assignats\[1,1,2\] i Necessito\[6,4,1\]. Podeu satisfer P1.
    -   P1 obt√© els recursos i els allibera. Disponible = \[11,5,7\]

## Exemple - Concesi√≥(VII) {.smaller}

:::::: columns
::: {.column width="30%"}
$$
D =
\begin{bmatrix}
  R1 & R2 & R3 \\
   2 &  3 &  0 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$
:::

::: {.column width="35%"}
$$
A =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  1 &  1 &  2 \\
  P2 &  3 &  0 &  2 \\
  P3 &  3 &  0 &  2 \\
  P4 &  2 &  1 &  1 \\
  P5 &  0 &  0 &  2 \\
\end{bmatrix}
$$
:::
::::::

-   *Iteraci√≥ 5*:
    -   P5: Assignats\[0,0,2\] i Necessito\[4,3,1\]. Podeu satisfer P5.
    -   P5 obt√© els recursos i els allibera. Disponible = \[11,5,9\]

::: {.center-container .fragment}
La sol¬∑licitud de recursos de P1 (1 inst√†ncia de R1 i 2 inst√†ncies de R3) pot ser concedida, ja que l'estat resultant √©s **segur**.
:::

## No Concesi√≥(I) {.smaller}

**En la mateixa situaci√≥ inicial anterior, P1 sol¬∑licita 1 inst√†ncies de R1, 2 inst√†ncies de R2 i 2 inst√†ncies de R3. Es concediran?**

-   Solicito\[1,2,2\] $\leq$ Disponible \[3,3,2\]
-   Solicito\[1,2,2\] $\leq$ Necessito \[7,4,3\].
-   Disponible = Disponible - Solicito = \[2,1,0\]

## No Concesi√≥(II) {.smaller}

:::::: columns
::: {.column width="60%"}
-   P2: Assignats\[3,0,2\], Necessito\[0,2,0\], Disponible\[2,1,0\] \blueArrow P2 no pot satisfer la seva sol¬∑licitud.
-   P3: Assignats\[3,0,2\], Necessito\[6,0,0\], Disponible\[2,1,0\] \blueArrow P3 no pot satisfer la seva sol¬∑licitud.
-   P4: Assignats\[2,1,1\], Necessito\[0,1,1\], Disponible\[2,1,0\] \blueArrow P4 no pot satisfer la seva sol¬∑licitud.
-   P5: Assignats\[0,0,2\], Necessito\[4,3,1\], Disponible\[2,1,0\] \blueArrow P5 no pot satisfer la seva sol¬∑licitud.
-   P1: Assignats\[1,2,2\], Necessito\[6,4,1\], Disponible\[2,1,0\] \blueArrow P1 no pot satisfer la seva sol¬∑licitud.
:::

:::: {.column width="40%"}
$$
N =
\begin{bmatrix}
     & R1 & R2 & R3 \\
  P1 &  6 &  4 &  1 \\
  P2 &  0 &  2 &  0 \\
  P3 &  6 &  0 &  0 \\
  P4 &  0 &  1 &  1 \\
  P5 &  4 &  3 &  1 \\
\end{bmatrix}
$$

::: {.center-container .fragment}
No es pot concedir la sol¬∑licitud de P1, ja que l'estat resultant √©s **insegur**.
:::
::::
::::::

## Consideracions sobre el banquer {.smaller}

-   L'algorisme del banquer √©s un algorisme de detecci√≥ d'interbloquejos que es basa en la idea de prevenir-los.
-   L'algorisme del banquer no √©s un algorisme de detecci√≥ d'interbloquejos en temps real, ja que no detecta interbloquejos immediatament.
-   La prinicipal limitaci√≥ de l'algorisme del banquer √©s que requereix con√®ixer amb antelaci√≥ la demanda m√†xima de recursos de cada proc√©s.
-   L'algoritme de Tarjan supera la limitaci√≥ de l'algorisme del banquer en la detecci√≥ eficient de cicles i √©s especialment √∫til en grafs amb relacions complexes entre els nodes.

## Realitat dels interbloquejos {.smaller}

-   Evitar els interbloquejos en sistemes reals √©s molt dif√≠cil. ‚Üí Complexitat en predir apriori les necessitats de recursos dels processos.

-   Ignora el problema: **No fer res**. ‚Üí √öltim recurs quan no hi ha altres opcions disponible.

-   **Detecci√≥ i recuperaci√≥**: Detectar interbloquejos i prendre mesures per recuperar-se d'ells. (*soluci√≥ preferida quan hi ha mecanismes adients de detecci√≥ i recuperaci√≥ disponibles*).

::: {.fragment .center-container}
**Els sistemes reals eviten interbloquejos quan no poden prevenir-los globalment.**
:::

## Protocols que EVITEN (I) {.smaller}

-   **Protocol WAIT-DIE (esperar-morir)**: Assigna a cada transacci√≥ un timestamp d‚Äôarribada. Si una transacci√≥ demana un recurs bloquejat:

    -   Si √©s m√©s antiga ‚Üí pot esperar
    -   Si √©s m√©s jove ‚Üí se la mata i es reinicia
    -   Evita cicles perqu√® els joves mai esperen pels vells.

-   **Protocol WOUND-WAIT (ferida-espera)**: Al rev√©s:

    -   Si la transacci√≥ √©s m√©s antiga ‚Üí *apunta a* la jove i la for√ßa a reiniciar-se.
    -   Si √©s m√©s jove ‚Üí espera.
    -   Evita interbloquejos perqu√® els esperes sempre van de joves cap a vells.

::: {.fragment .center-container}
Tots dos protocols trenquen l‚ÄôESPERA CIRCULAR sense necessitat d‚Äôanalitzar cicles.
:::

## Protocols que EVITEN (II) {.smaller}

-   **Timestamp Ordering (TO):** En lloc de bloquejar recursos, s‚Äôordenen totes les operacions per timestamps.

    -   Tota lectura i escriptura ha de respectar l'ordre temporal global.
    -   Si una operaci√≥ viola l'ordre ‚Üí la transacci√≥ es rebutja i es reinicia.
    -   Com que no hi ha bloquejos, tampoc hi ha interbloquejos.

-   **Multiversi√≥ Concurrency Control (MVCC):** Mant√© m√∫ltiples versions de les dades.

    -   Les transaccions poden llegir versions antigues sense bloquejar les escriptures.
    -   Les escriptures creen noves versions.
    -   Aix√≤ redueix la necessitat de bloquejos i, per tant, els interbloquejos s√≥n poc freq√ºents.

## Realitat en Sistemes Operatius (I) {.smaller}

En sistemes operatius generalistes com **Linux**, **Windows** o **Android**, *no s‚Äôutilitzen algorismes d‚Äôevitaci√≥ com l‚Äôalgorisme del banquer*.\
Aquests SO gestionen centenars o milers de processos amb patrons de consum de recursos **imprevisibles**, cosa que fa que els m√®todes basats en **demandes m√†ximes conegudes** siguin inviables.

::: {.callout-important title="Per qu√® NO s‚Äôutilitza el banquer?"}
-   **No es pot predir** quants recursos necessitar√† un proc√©s real.
-   El cost de comprovar cont√≠nuament si l‚Äôestat √©s *segur* seria **massa alt**.
-   Les aplicacions modernes tenen comportaments **din√†mics i no deterministes**.
-   Prioritat del SO: **rendiment i interactivitat**, no garantir abs√®ncia absoluta d'interbloquejos.
:::

:::{.fragment .center-container}
A Linux, els interbloquejos d‚Äôespai d‚Äôusuari acostumen a ser causats per competici√≥ sobre fitxers, sockets o mutexos en aplicacions, mentre que al kernel normalment provenen de spinlocks i ordres incorrectes d‚Äôadquisici√≥ de locks.
:::

## Realitat en Sistemes Operatius (II) {.smaller}

### Detecci√≥ d‚Äôinterbloquejos (parcial o basada en heur√≠stiques)

-   Supervisi√≥ de recursos (fitxers, sockets, dispositius‚Ä¶).
-   Eines del sistema (`lsof`, `fuser`, `ps`, *timeouts*, *hung task detector* a Linux).
-   Identificaci√≥ de processos que no progressen (*stalls*, *hung tasks*).

::: fragment
### 2. Recuperaci√≥

-   **Finalitzaci√≥ del proc√©s** que causa o pateix l‚Äôinterbloqueig.
-   Alliberament for√ßat de descriptors, fitxers, sockets o connexions.
-   En Android: el *low memory killer* pot acabar aplicacions per recuperar el sistema.
:::

## Realitat en Sistemes Operatius (III) {.smaller}

### Protocols i pol√≠tiques que redueixen la probabilitat d‚Äôinterbloquejos

(No els eliminen, per√≤ els fan molt poc freq√ºents.)

-   Ordenaci√≥ d‚Äôadquisici√≥ de recursos a nivell del kernel.
-   Locks no bloquejants (*trylock*).
-   Timeouts a bloquejos i I/O.
-   Estructures de dades lock-free en subsistemes cr√≠tics (per ex. RCU a Linux).
-   Model de *capabilities* en Android/iOS: redueix el nombre de recursos globalment compartits.

::: {.fragment .center-container}
**No els eliminen, per√≤ els fan molt poc freq√ºents.**
:::

## Problema amb la CPU AMD Threadripper PRO 7985WX {.smaller}

La **AMD Ryzen Threadripper PRO 7985WX** fa servir el subsistema CPPC (Collaborative Processor Performance Control) per coordinar amb el firmware (UEFI) quina freq√º√®ncia o estat de rendiment ha de tenir la CPU. Un kthread del kernel de Linux √©s l'encarregat de llegir i actualitzar aquesta informaci√≥ de manera cont√≠nua.

::: columns
:::: {.column width="33%"}

### S√≠mptoma

Un servidor de c√≤mput quedava bloquejat cada cert temps, sense missatges d‚Äôerror aparents, i nom√©s es podia recuperar amb un reinici manual. A efectes pr√†ctics: un *deadlock*.

:::
:::: {.column width="33%"}

### Causa

El kthread responsable del CPPC quedava atrapat en un estat d‚Äôespera o en un bucle infinit perqu√® el firmware proporcionava taules CPPC incompletes o inconsistents. En quedar bloquejat aquest fil del kernel, la gesti√≥ de freq√º√®ncies i altres subsistemes quedaven afectats fins paralitzar el sistema.

:::
:::: {.column width="33%"}

### Soluci√≥

Personalitzar i adaptar els parametres CPPC i de la CPU al firmware espec√≠fic de la placa base, evitant aix√≠ les condicions que provocaven el bloqueig del kthread.

:::
:::
