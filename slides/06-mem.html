<!DOCTYPE html>
<html lang="en"><head>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.26">

  <meta name="author" content="Jordi Mateo Fornés">
  <title>SO - Fall 2025 – Gestió de la Memòria</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-534cd8e3a96973385dffff3f4709048d.css">
  <link rel="stylesheet" href="styles.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
  <script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
  <link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Gestió de la Memòria</h1>
  <p class="subtitle">Unitat 6 · Sistemes Operatius (SO)</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Jordi Mateo Fornés 
</div>
</div>
</div>

</section>
<section id="necessitat-de-la-gestió-de-la-memòria" class="slide level2 smaller">
<h2>Necessitat de la gestió de la Memòria</h2>
<p>Imaginem un sistema operatiu sense cap mecanisme per gestionar la memòria. Quan un programa s’executa, pot executar una instrucció com <code>MOV REG1, 1000</code>, que mou el contingut de la memòria física 1000 a REG1.</p>
<p>En aquesta situació, <strong>què passaria si executéssim dos programes simultàniament?</strong></p>
<ul>
<li class="fragment">No podríem tenir dos programes a la memòria simultàniament.</li>
<li class="fragment">Si el primer programa executa <code>MOV REG1, 1000</code>, i després el segon programa executa <code>MOV REG1, 1000</code>, el contingut de la memòria escrita pel primer programa seria sobreescrit pel segon programa.</li>
<li class="fragment">Això provocaria un comportament erratic i el primer programa no funcionaria correctament.</li>
</ul>
<div class="fragment center-container">
<p>Una possible solució seria utilitzar memòria secundària i anar fent <span class="alert">swapping</span> de la memòria principal a la secundària. Però, això seria molt lent i poc viable.</p>
</div>
</section>
<section id="gestió-de-la-memòria" class="slide level2 smaller">
<h2>Gestió de la Memòria</h2>
<div class="cell" data-reveal="true" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    A[Gestor de Memòria] --&gt; B[Molts processos]
    B --&gt; C[Ubicats a Memòria]
    C --&gt; D[De forma simultània]
    D --&gt; E[S'ha de compartir Memòria física]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="columns">
<div class="column fragment" style="width:45%;">
<h3 id="objectius">Objectius</h3>
<ul>
<li class="fragment">Traducció d’adreces.</li>
<li class="fragment">Reubicació de dades.</li>
<li class="fragment">Protecció de la Memòria.</li>
<li class="fragment">Compartició.</li>
</ul>
</div><div class="column fragment" style="width:45%;">
<h3 id="funcionalitats">Funcionalitats</h3>
<ul>
<li class="fragment">Mòdul que gestiona el mapa de Memòria de cada procés i les seves regions.</li>
<li class="fragment">Mòdul que reparteix la Memòria física disponible entre els processos existents.</li>
</ul>
</div></div>
</section>
<section id="què-és-el-mapa-de-memòria" class="slide level2 smaller">
<h2>Què és el mapa de Memòria?</h2>
<p>El <strong>mapa de memòria d’un procés</strong> és una representació lògica de com la memòria està organitzada per a un programa en execució. Normalment conté diferents regions o segments que es creen a partir de la seva execució.</p>
<div class="fragment">
<h3 id="què-és-una-regió">Què és una regió?</h3>
<p>Una zona contigua de memòria amb un punt inicial i una mida definida.</p>
<ul>
<li class="fragment"><strong>Suport a la regió</strong>: Es guarda el contingut inicial de la regió.
<ul>
<li class="fragment"><em>Fitxer</em>: Regió guardada en un fitxer.</li>
<li class="fragment"><em>Anònima</em>: Sense suport.</li>
</ul></li>
<li class="fragment"><strong>Ús</strong>: Privat, Compartit entre processos.</li>
<li class="fragment"><strong>Protecció</strong>: Lectura, Escriptura, Execució.</li>
<li class="fragment"><strong>Mida</strong>: Fixa o variable.</li>
</ul>
</div>
</section>
<section id="regions-del-mapa-de-memòria" class="slide level2 smaller">
<h2>Regions del mapa de Memòria?</h2>
<div class="columns">
<div class="column" style="width:70%;">
<ol type="1">
<li class="fragment"><strong>Codi</strong>: Regió compartida de lectura i execució. Mida fixa. Conté el codi del programa.</li>
<li class="fragment"><strong>Dades inicialitzades</strong>: Regió privada on cada procés té una còpia pròpia de les variables. Lectura, escriptura i mida fixa. Conté variables globals, estàtiques i inicialitzades.</li>
<li class="fragment"><strong>Dades no inicialitzades</strong>: Regió privada de lectura i escriptura. Mida fixa.</li>
<li class="fragment"><strong>Heap</strong>: Regió privada de lectura i escriptura. Mida variable. Aquesta regió creixarà amb l’assignació dinàmica de memòria i decreixerà amb la seva alliberació. Normalment, creix cap a les direccions més altes del mapa.</li>
<li class="fragment"><strong>Stack</strong>: Regió privada de lectura i escriptura. Mida variable. Aquesta regió creixerà amb les crides a funcions, i decreixerà quan aquestes retornin. Normalment, creix cap a les direccions més baixes del mapa.</li>
</ol>
</div><div class="column" style="width:30%;">
<p><img data-src="../figures/slides/06-mem/memory_map_proc.png"></p>
</div></div>
</section>
<section id="observacions-i" class="slide level2 smaller">
<h2>Observacions (I)</h2>
<p>Suposem que tenim un programa que realitza la multiplicació de dues matrius. Aquestes matrius s’introdueixen per teclat en temps d’execució, i el programa no pot determinar la mida de les matrius fins que l’usuari les introdueixi. Per tant, necessitem un model de memòria dinàmic.</p>
<div class="fragment">
<p>Suposem que el programa necessita emmagatzemar dades d’un fitxer que no es coneix prèviament. En aquest cas, el sistema operatiu pot crear noves regions en el mapa de memòria per aquestes dades a mesura que el procés llegeix el fitxer, <strong>adaptant-se dinàmicament a la demanda</strong>.</p>
</div>
</section>
<section id="observacions-ii" class="slide level2 smaller">
<h2>Observacions (II)</h2>
<p>A més, els SOs utilitzen <strong>biblioteques dinàmiques</strong> que impliquen la creació de regions associades a la mateixa i que contenen les diferents seccions de la biblioteca (codi i dades globals). Per exemple, quan carreguem una biblioteca dinàmica comuna, el sistema operatiu pot crear noves regions en el mapa de memòria del procés per al codi executable i les variables globals de la biblioteca.</p>
<div class="fragment center-container">
<p>Els Sistemes Operatius <strong><span class="alert">ofereixen un model de memòria dinàmic</span></strong> i necessiten <strong><span class="alert">mantenir una taula de regions per cada procés</span></strong> format per un nombre variable de regions que es poden afegir o eliminar durant la seva execució.</p>
</div>
</section>
<section id="ex-memòria-dun-procés-i" class="slide level2">
<h2>Ex: Memòria d’un procés (I)</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource c number-lines code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-3"><a></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb1-4"><a></a></span>
<span id="cb1-5"><a></a><span class="dt">int</span> global<span class="op">;</span></span>
<span id="cb1-6"><a></a></span>
<span id="cb1-7"><a></a><span class="dt">int</span></span>
<span id="cb1-8"><a></a>main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a></a>    <span class="dt">int</span> private<span class="op">;</span></span>
<span id="cb1-10"><a></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"argc at   : 0x</span><span class="sc">%12lX\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)&amp;</span>argc<span class="op">);</span> </span>
<span id="cb1-11"><a></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"argv at   : 0x</span><span class="sc">%12lX\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)&amp;</span>argv<span class="op">);</span></span>
<span id="cb1-12"><a></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"private at: 0x</span><span class="sc">%12lX\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)&amp;</span>private<span class="op">);</span></span>
<span id="cb1-13"><a></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"global at : 0x</span><span class="sc">%12lX\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)&amp;</span>global<span class="op">);</span></span>
<span id="cb1-14"><a></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"main at   : 0x</span><span class="sc">%12lX\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)&amp;</span>main<span class="op">);</span></span>
<span id="cb1-15"><a></a></span>
<span id="cb1-16"><a></a>    <span class="cf">return</span> EXIT_SUCCESS<span class="op">;</span></span>
<span id="cb1-17"><a></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>En aquest exemple, el programa defineix variables amb diferents àmbits (global, local i arguments de la funció main). A continuació, mostra les adreces de memòria d’aquestes variables utilitzant l’operador &amp; per obtenir la seva adreça. Les adreces de memòria es mostren en format hexadecimal.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="ex-memòria-dun-procés-ii" class="slide level2">
<h2>Ex: Memòria d’un procés (II)</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource c number-lines code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-2"><a></a>    <span class="dt">int</span> stackVar <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb2-3"><a></a>    printf<span class="op">(</span><span class="st">"stackVar at: 0x</span><span class="sc">%p\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)&amp;</span>stackVar<span class="op">);</span></span>
<span id="cb2-4"><a></a>    <span class="dt">int</span><span class="op">*</span> heapVar <span class="op">=</span> malloc<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb2-5"><a></a>    printf<span class="op">(</span><span class="st">"Malloced Area Begins at:  0x</span><span class="sc">%p\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)</span>heapVar<span class="op">);</span></span>
<span id="cb2-6"><a></a>    printf<span class="op">(</span><span class="st">"Malloced Area Ends at:    0x</span><span class="sc">%p\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)(</span>heapVar <span class="op">+</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb2-7"><a></a>    free<span class="op">(</span>heapVar<span class="op">);</span></span>
<span id="cb2-8"><a></a><span class="op">}</span></span>
<span id="cb2-9"><a></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-10"><a></a>    <span class="dt">int</span> mainVar <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb2-11"><a></a>    printf<span class="op">(</span><span class="st">"Stack Frame of main at:  0x</span><span class="sc">%p\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)&amp;</span>mainVar<span class="op">);</span></span>
<span id="cb2-12"><a></a>    f<span class="op">();</span></span>
<span id="cb2-13"><a></a>    printf<span class="op">(</span><span class="st">"End of Stack Frame:      0x</span><span class="sc">%p\n</span><span class="st">"</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)&amp;</span>mainVar<span class="op">);</span></span>
<span id="cb2-14"><a></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="quins-tipus-dadreces-existeixen" class="slide level2 smaller">
<h2>Quins tipus d’adreces existeixen?</h2>
<ol type="1">
<li class="fragment"><p><strong>Espai lògic d’un procés (Relatives):</strong> Adreces de la memòria que contenen el codi, les dades (inicialitzades i no inicialitzades) i la pila del procés. Aquest espai es crea en el moment d’execució del programa. Per exemple, una variable pot ser referenciada com <em>a 10 bytes des de l’inici de les dades</em>.</p></li>
<li class="fragment"><p><strong>Espai físic d’un procés (Absolutes)</strong>: Adreces de la memòria on es carrega l’espai lògic del procés. Aquestes adreces són les adreces reals a la memòria física on resideixen el codi, les dades i la pila del procés. Quan el sistema operatiu carrega un programa a la memòria RAM, l’espai lògic d’aquest procés es mapeja a adreces físiques específiques, que són les adreces reals on resideixen les instruccions del codi i les dades.</p></li>
<li class="fragment"><p><strong>Adreces generades per la CPU</strong> (adreces virtuals): Quan un procés executa codi, la CPU genera adreces virtuals (també anomenades adreces lògiques) per accedir a variables, instruccions o la pila. Aquestes adreces no són adreces físiques, sinó referències dins l’espai d’adreces del procés. Aquestes adreces virtuals no poden accedir directament a la memòria RAM; han de ser traduïdes a adreces físiques mitjançant algun mecanisme de reubicació.</p></li>
</ol>
</section>
<section id="repte-traducció-dadreces" class="slide level2 smaller">
<h2>Repte: Traducció d’adreces</h2>
<div class="columns">
<div class="column" style="width:60%;">
<div class="fragment center-container">
<p><img data-src="../figures/slides/06-mem/introduccio2.png"></p>
</div>
</div><div class="column fragment" style="width:40%;">
<ul>
<li class="fragment"><strong>Adreça simbòlica</strong>: etiqueta del codi font (funció X, variable Y)</li>
<li class="fragment"><strong>Adreça lògica</strong>: la que produeix el compilador (offset dins del segment)</li>
<li class="fragment"><strong>Adreça física</strong>: la RAM real, assignada pel carregador o la MMU</li>
</ul>
</div></div>
<div class="fragment center-container">
<p><strong><span class="alert">Repte del SO: Com es tradueixen les adreces lògiques a físiques?</span></strong></p>
</div>
<aside class="notes">
<ul>
<li>El compilador només sap offsets: a 24 bytes d’aquí.</li>
<li>El sistema operatiu decideix on col·locar el programa.</li>
<li>Per tant, hem de traduir adreces lògiques en físiques.</li>
<li>Això ho fa el loader o la MMU, i és el cor de la gestió de memòria. L’adreça simbòlica = <em>La cuina de casa de la Maria</em> L’adreça lògica = <em>Habitació número 3 del pis</em> L’adreça física = <em>Carrer Major 24, 2n 1a</em> Quan portes el pis a un altre lloc l’adreça física canvia, però l’habitació 3 segueix sent l’habitació 3.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="repte-reubicació-de-la-memòria" class="slide level2 smaller">
<h2>Repte: Reubicació de la Memòria</h2>
<p>Suposem que tenim dos programes carregats en zones de memòria diferents:</p>
<div class="columns">
<div class="column" style="width:45%;">
<p><img data-src="../figures/slides/06-mem/reubicacio-necessitat.jpg"></p>
</div><div class="column" style="width:45%;">
<p>El programa A espera que la instrucció <code>MOV</code> estigui a la posició 24 de la memòria, i el programa B espera que la instrucció <code>CMP</code> estigui a la posició 28 de la memòria. Si no tenim un mecanisme de reubicació de la memòria, les seves expectatives es veuran compromeses. Fixeu-vos que cada programa té la seva zona de 16KB però es poden solapar. <strong><span class="alert">Necesitem un mecanisme que ens permeti reubicar la memòria</span></strong>.</p>
</div></div>
</section>
<section id="què-és-la-reubicació" class="slide level2 smaller">
<h2>Què és la reubicació?</h2>
<p>L’espai d’adreçament d’un programa s’ha de reubicar (traduir) segons on el sistema operatiu decideixi carregar-lo a Memòria, sense modificar-ne el comportament. Aquesta traducció pot fer-se en <strong>compilació, càrrega o execució</strong>.</p>
<ul>
<li class="fragment">Reubicació <strong>estàtica</strong> en temps de compilació. Les <em>adreces físiques</em> es generen en temps de compilació. El lloc de la Memòria on es carregarà el procés es conegut. Les <em>adreçes que genera el processador (execució)</em> <strong>coincideixen</strong> amb les <em>@ físiques</em>.</li>
<li class="fragment">Reubicació <strong>estàtica</strong> en temps de càrrega. En carregar un procés en memòria es realitza la <em>traducció d’adreces lògiques a físiques.</em> Si no podem saber on es carregarà el procés, el codi generat pel compilador únicament pot contenir <em>@ lògiques</em>. El <strong>carregador</strong> farà la traducció <em>@ lògiques a físiques</em>.</li>
<li class="fragment">Reubicació <strong>dinàmica</strong> en temps d’execució. La <em>traducció d’adreces lògiques a físiques</em> es realitza en temps d’execució. Permet que els processos es puguin moure d’un lloc de Memòria a un altre. Facilita el <em>swapping</em> i la compactació. Alenteix la execució i complica el màquinari.</li>
</ul>
</section>
<section id="reubicació-estàtica-en-temps-de-compilació" class="slide level2 smaller">
<h2>Reubicació estàtica en temps de compilació</h2>
<p>Les adreces físiques del programa es generen durant la compilació. El lloc on el procés s’executarà és conegut i fix.</p>
<ul>
<li class="fragment">El codi conté adreces físiques directes.</li>
<li class="fragment">Les adreces que genera la CPU durant l’execució coincideixen amb les adreces físiques.</li>
<li class="fragment">No permet moure el procés ni protegir-lo.</li>
<li class="fragment">Avui dia pràcticament no s’utilitza.</li>
</ul>
</section>
<section id="reubicació-estàtica-en-temps-de-càrrega" class="slide level2 smaller">
<h2>Reubicació estàtica en temps de càrrega</h2>
<p>El programa conté adreces lògiques.</p>
<ul>
<li class="fragment">Quan el SO carrega el procés en memòria:
<ul>
<li class="fragment">El loader substitueix les adreces lògiques per adreces físiques, segons on decideixi ubicar el procés.</li>
<li class="fragment">La traducció es fa una sola vegada en carregar el programa.</li>
<li class="fragment">Durant l’execució, la CPU utilitza adreces ja reubicades.</li>
<li class="fragment">El procés no pot canviar de posició un cop carregat.</li>
</ul></li>
</ul>
</section>
<section id="reubicació-dinàmica-temps-execució" class="slide level2 smaller">
<h2>Reubicació dinàmica temps execució</h2>
<p>La CPU genera sempre adreces virtuals. La traducció a adreces físiques es fa cada vegada que hi ha un accés a memòria, per hardware:</p>
<ul>
<li class="fragment">Amb un règim simple: registre base + registre límit.</li>
<li class="fragment">O amb una MMU: paginació, segmentació, TLB, proteccions.</li>
</ul>
<h3 class="fragment" id="avantatges">Avantatges</h3>
<ul>
<li class="fragment">Els processos es poden moure a memòria (compactació, swapping).</li>
<li class="fragment">Permet implementar memòria virtual, protecció, COW, mapatge de fitxers, etc.</li>
</ul>
<h3 class="fragment" id="inconvenients">Inconvenients</h3>
<ul>
<li class="fragment">Necessita suport hardware (MMU).</li>
<li class="fragment">Hi ha un cost per accés (mitigat pel TLB).</li>
</ul>
</section>
<section id="exemple-de-reubicació-de-la-memòria" class="slide level2 smaller">
<h2>Exemple de reubicació de la Memòria</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/rel.png"></p>
</div>
<aside class="notes">
<ol type="1">
<li><p>Compilació: Traducció de lògiques a físiques (Reubicació estàtica - Compilació) Quan el programa es compila, el compilador converteix les adreces simbòliques (com x i la crida a la funció) en adreces lògiques. Aquestes adreces lògiques no corresponen directament a la memòria física de l’ordinador; són llocs genèrics on el codi fa referència a variables i funcions.</p></li>
<li><p>Enllaç i càrrega: Traducció de lògiques a físiques (Reubicació estàtica - Càrrega) Durant la fase d’enllaç (linking), els enllaçadors assignen les adreces físiques concretes al programa objecte generat pel compilador. Aquestes adreces físiques (com 5010 i 5200) es corresponen amb ubicacions físiques dins de la memòria de l’ordinador, però encara no són les que es fan servir directament en l’execució del programa. Després, el carregador carrega el programa a la memòria, assignant les adreces físiques a ubicacions específiques (per exemple, 100 i 362).</p></li>
<li><p>Execució: Traducció de lògiques a físiques durant l’execució (Reubicació dinàmica) Quan el programa s’executa, utilitza adreces lògiques per referir-se a la memòria. Aquestes adreces lògiques (com 34 i 526) es tradueixen en adreces físiques per accedir a la memòria real. Aquesta traducció la fa el sistema operatiu mitjançant tècniques de reubicació dinàmica o gestió de memòria (com paginació o segmentació). Així, les adreces lògiques que utilitza el programa durant l’execució (com 34 i 526) no corresponen directament a les adreces físiques que es van assignar en el moment de la càrrega (100 i 362), sinó que el sistema les tradueix a mesura que el programa es va executant.</p></li>
</ol>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="mecanismes-de-protecció" class="slide level2 smaller">
<h2>Mecanismes de protecció</h2>
<ul>
<li class="fragment">El sistema de gestió de memòria ha de garantir la protecció del codi i les dades dels processos contra accessos accidentals o malintencionats d’altres processos.</li>
<li class="fragment">Es requereix la verificació en temps d’execució de totes les referències a la memòria generades per un procés.</li>
</ul>
<div class="fragment center-container">
<p><img data-src="../figures/slides/06-mem/proteccio.png" style="width:80.0%"></p>
</div>
</section>
<section id="protecció-a-nivell-de-pàgina" class="slide level2 smaller">
<h2>Protecció a nivell de pàgina</h2>
<p>Cada pàgina del procés té associats diversos bits de protecció dins la seva Page Table Entry (PTE):</p>
<ul>
<li class="fragment">R (Read) — permet lectura</li>
<li class="fragment">W (Write) — permet escriptura</li>
<li class="fragment">X (Execute) — permet execució de codi</li>
<li class="fragment">U/S (User/Supervisor) — indica si la pàgina és accessible des de mode usuari</li>
<li class="fragment">A (Accessed) — marcat quan s’ha accedit</li>
<li class="fragment">D (Dirty) — marcat quan s’ha modificat</li>
</ul>
</section>
<section id="exceptions-per-page-fault" class="slide level2 smaller">
<h2>Exceptions per page fault</h2>
<p>Quan la CPU accedeix a una adreça virtual:</p>
<ul>
<li class="fragment">La MMU busca la PTE corresponent.</li>
<li class="fragment">Si l’accés no compleix els permisos (p.&nbsp;ex. escriure en una pàgina R/X), o la pàgina no està present, la MMU genera una page fault exception.</li>
<li class="fragment">El control passa al sistema operatiu:
<ul>
<li class="fragment">Si és un page-in (pàgina no present), el SO la carrega de disc i actualitza la PTE.</li>
<li class="fragment">Si és un accés il·legal (violació W, X, U/S…), el SO termina el procés (segmentation fault).</li>
</ul></li>
</ul>
<div class="fragment center-container">
<p>Aquest procediment el veurem en detall quan parlem de memòria virtual.</p>
</div>
</section>
<section id="privilegi-de-nucli-vs.-usuari" class="slide level2 smaller">
<h2>Privilegi de nucli vs.&nbsp;usuari</h2>
<p>La CPU funciona en dos modes:</p>
<ul>
<li class="fragment"><strong>Mode usuari (ring 3)</strong>:
<ul>
<li class="fragment">Només pot accedir a pàgines marcades com User (U).</li>
<li class="fragment">No pot accedir a memòria del kernel ni modificar taules de pàgines.</li>
</ul></li>
<li class="fragment"><strong>Mode nucli (ring 0)</strong>:
<ul>
<li class="fragment">Pot accedir a qualsevol pàgina etiquetada com Supervisor (S).</li>
<li class="fragment">Gestiona PTEs, TLB flush, interrupcions, drivers…</li>
</ul></li>
</ul>
<div class="fragment center-container">
<p>La protecció per pàgines garanteix que un procés d’usuari no pugui llegir ni modificar memòria del SO.</p>
</div>
</section>
<section id="mecanismes-de-compartició" class="slide level2 smaller">
<h2>Mecanismes de compartició</h2>
<ul>
<li class="fragment">Hi ha blocs de programes (ja sigui codi o dades) que poden ser compartits entre processos per reduir els requisits de memòria.</li>
<li class="fragment">Per permetre la compartició d’un bloc de memòria entre processos, és necessari establir mecanismes de comunicació i sincronització, garantint que diversos processos puguin accedir-hi de manera segura i coherent.</li>
</ul>
<div class="fragment center-container">
<p><img data-src="../figures/slides/06-mem/comparticio.png" style="width:80.0%"></p>
</div>
</section>
<section id="supermario-land-2-glitch" class="slide level2 smaller">
<h2>SuperMario Land 2: Glitch</h2>
<div class="center">
<p><a href="https://www.youtube.com/watch?v=FPzuYWbnln4">Super Mario Land 2 - Memory Exploration</a></p>
</div>
<ul>
<li class="fragment">Quan Mario surt dels límits del nivell en una àrea que aparentment hauria d’estar buida, aquesta zona no està realment desocupada. En realitat, conté dades assignades a altres recursos.</li>
<li class="fragment">Manca de mecanismes de protecció de memòria durant l’execució.</li>
<li class="fragment">Permet accés il·legal a zones no destinades a ser visibles o utilitzables.</li>
</ul>
<div class="fragment center-container">
<p>El glitch es produeix perquè l’adreçament directe a la memòria no està subjecte a cap traducció o verificació en temps d’execució, i el motor del joc tracta adreces fora del rang del nivell com a accessibles, interpretant-les erròniament com a dades vàlides.</p>
</div>
<aside class="notes">
<p>Imagineu que el joc és com un full quadriculat on els desenvolupadors han dibuixat el nivell.</p>
<p>Quan el Mario surt dels límits del dibuix, el joc no té cap mecanisme per dir: Ei! Aquí no hi ha res, no pots passar.</p>
<p>En comptes d’això, el joc comença a llegir memòria que conté altres coses, com dades d’enemics, de gràfics o variables internes.</p>
<p>El motor del joc interpreta aquestes dades com si fossin blocs, parets o plataformes, i per això apareixen formes rares i comportaments estranys.</p>
<p>És com si entréssiu en una habitació on no hi hauria d’haver res… però el joc interpreta escombraries com a mobiliari.”</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section>
<section id="sistemes-de-gestió-de-la-memòria" class="title-slide slide level1 center">
<h1>Sistemes de gestió de la Memòria</h1>

</section>
<section id="models-dorganització-de-la-memòria-física" class="slide level2 smaller">
<h2>Models d’organització de la Memòria física</h2>

<img data-src="../figures/slides/06-mem/no-mem-abstraction.jpg" class="r-stretch"><ul>
<li class="fragment"><ol type="a">
<li class="fragment">El SO es pot ubicar a la part baixa de la memòria en forma de RAM (Random Access Memory).</li>
</ol></li>
<li class="fragment"><ol start="2" type="a">
<li class="fragment">El SO es pot ubicar a la part alta de la memòria en forma de ROM (Read Only Memory).</li>
</ol></li>
<li class="fragment"><ol start="3" type="a">
<li class="fragment">El SO es pot ubicar a la part baixa en forma de RAM i els drivers a la part alta en forma de ROM.</li>
</ol></li>
</ul>
</section>
<section id="assignació-contigua-màquina-nua" class="slide level2 smaller">
<h2>Assignació contigua: <em>Màquina nua</em></h2>
<ul>
<li class="fragment">No existeix un sistema de gestió de la Memòria definit.</li>
<li class="fragment">L’usuari té control complet de tot l’espai de Memòria.</li>
<li class="fragment">L’espai d’adreces lògiques és identic al espai d’adreçament físic.</li>
</ul>
<div class="columns">
<div class="column fragment" style="width:45%;">
<h3 id="avantatges-1">Avantatges</h3>
<ul>
<li class="fragment">Flexible</li>
<li class="fragment">Simple</li>
<li class="fragment">NO necessita hardware/software específic.</li>
</ul>
</div><div class="column fragment" style="width:45%;">
<h3 id="desavantatges">Desavantatges</h3>
<ul>
<li class="fragment">Els processos i el kernel del SO comparteixen el mateix espai d’adreçament.</li>
<li class="fragment">No existeix protecció.</li>
<li class="fragment">Poca eficiència.</li>
</ul>
</div></div>
</section>
<section id="assignació-contigua-monitor-resident" class="slide level2 smaller">
<h2>Assignació contigua: <em>Monitor resident</em></h2>
<div class="columns">
<div class="column" style="width:45%;">
<ul>
<li class="fragment">Divideix la Memòria en dues seccions diferents.</li>
<li class="fragment">Una àrea de memòria específica pel monitor resident (nucli del SO).</li>
<li class="fragment">Es pot situar a la part alta o baixa de la Memòria.</li>
<li class="fragment">Una zona per l’usuari, on únicament es pot ubicar un procés.</li>
<li class="fragment">El procés d’usuari únicament pot utilitzar adreces de Memòria que no sigui del Monitor.</li>
</ul>
</div><div class="column" style="width:45%;">
<div class="center">
<p><img data-src="../figures/slides/06-mem/maquina-resident-proteccio.png"></p>
</div>
</div></div>
</section>
<section id="assignació-contigua-particions-múltiples" class="slide level2 smaller">
<h2>Assignació contigua: <em>Particions múltiples</em></h2>
<div class="columns">
<div class="column" style="width:45%;">
<ul>
<li class="fragment">La memòria es troba dividida en regions.</li>
<li class="fragment">Cada partició pot contenir un procés en execució.</li>
<li class="fragment">Quan un procés acaba la seva execució allibera la partició, que pot ser utilitzada per un altre procés de la cua de treballs.</li>
</ul>
</div><div class="column" style="width:45%;">
<div class="center">
<p><img data-src="../figures/slides/06-mem/part-mida-fixa.png"></p>
</div>
</div></div>
</section>
<section id="hardware-de-protecció-de-particions-múltiples" class="slide level2">
<h2>Hardware de protecció de particions múltiples</h2>

<img data-src="../figures/slides/06-mem/hard-part-multiples.png" class="r-stretch"></section>
<section id="polítiques-de-selecció-de-partició" class="slide level2 smaller">
<h2>Polítiques de selecció de partició</h2>
<ul>
<li class="fragment"><strong>First-Fit</strong>. Seleccionem la primera partició disponible amb espai suficient pel procés.</li>
<li class="fragment"><strong>Best-fit-only</strong>. Seleccionem la partició que millor s’ajusta a la mida del procés. Si esta ocupada, esperem.</li>
<li class="fragment"><strong>Best-available-fit</strong>. Seleccionem la partició que desaprofita menys espai de Memòria.</li>
</ul>
<div class="columns">
<div class="column fragment" style="width:45%;">
<h3 id="una-cua">Una cua</h3>
<p><img data-src="../figures/slides/06-mem/cua.png"></p>
</div><div class="column fragment" style="width:45%;">
<h3 id="múltiples-cues">Múltiples cues</h3>
<p><img data-src="../figures/slides/06-mem/cues.png"></p>
</div></div>
</section>
<section id="fragmentació-de-memòria" class="slide level2 smaller">
<h2>Fragmentació de Memòria</h2>
<p>La <strong>fragmentació</strong> es refereix a les àrees de memòria no utilitzades, i pot ser causada pel tipus de mecanisme de gestió de la memòria.</p>
<ul>
<li class="fragment"><p><strong>Interna</strong>. Porció de Memòria d’una partició que no utilitza el procés té menys requeriments. <em>Suposem que assignem una partició de memòria de 1000 bytes a un procés, però el procés només necessita 800 bytes. Els 200 bytes restants es considerarien fragmentació interna</em>.</p></li>
<li class="fragment"><p><strong>Externa</strong>. Es produeix quan existeix espai de Memòria lliure per satisfer els requeriments, però no és contigua i per tant no el podem utilitzar. <em>Imagineu que tenim dues àrees de memòria lliure de 300 bytes cada una, però estan separades per una àrea ocupada de 200 bytes, no podem satisfer una sol·licitud de 500 bytes, tot i que hi ha prou memòria lliure en total</em>.</p></li>
</ul>
<div class="fragment center-container">
<p><strong>La fragmentació és un problema que afecta l’eficiència de l’ús de la memòria en els sistemes informàtics.</strong></p>
</div>
</section>
<section id="exemple-fragmentació" class="slide level2 smaller">
<h2>Exemple: Fragmentació</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/exemple_fragmentacio.png"></p>
</div>
<aside class="notes">
<p>En aquest exemple el primer procés a planificar ocupa 98K per tant la Regió 1 (64K) no ens serveix, però si la regió 2 (128K). En aquesta regió es desaprofiten 30K. El segon procés (264k) no pot anar a la 3er (256K) però si a la 4rt (512K). En aquesta regió es desaprofiten 248K. En total tenim 278K de fragmentació externa.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="particions-de-mida-variable" class="slide level2 smaller">
<h2>Particions de mida variable</h2>
<p>A diferència de les particions de mida fixa, les particions de mida variable permeten que la mida de la partició s’adapti a les necessitats del procés.</p>
<h3 class="fragment" id="avantatges-2">Avantatges</h3>
<ul>
<li class="fragment">No hi ha fragmentació interna.</li>
<li class="fragment">Millor aprofitament de la Memòria.</li>
<li class="fragment">Incrementa el nombre de processos que poden estar en Memòria.</li>
</ul>
<div class="fragment" title="Observació">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Observació</strong></p>
</div>
<div class="callout-content">
<p>El nombre de processos pot augmentar si es fa compactació periòdica per reduir la fragmentació externa.</p>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>Per exemple, si tenim una partició de 100KB i un procés de 50KB, la partició de mida fixa tindrà 50KB de fragmentació interna, mentre que la partició de mida variable tindrà 0KB de fragmentació interna.</p>
</div>
</section>
<section id="planificació-de-particions-de-mida-variable" class="slide level2 smaller">
<h2>Planificació de particions de mida variable</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/particions_variables.png" style="width:80.0%"></p>
</div>
</section>
<section id="fragmentació-externa-en-particions-de-mida-variable" class="slide level2 smaller">
<h2>Fragmentació externa en particions de mida variable</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/fragmetacio_externa.png"></p>
</div>
</section>
<section id="assignació-no-contigua-paginació" class="slide level2 smaller">
<h2>Assignació no contigua: <em>Paginació</em></h2>
<p>La <strong>paginació</strong> implica que el <em>mapa de Memòria es divideix en pàgines</em> i la <em>Memòria principal es divideix en un marc de pàgines</em>. Un <strong>marc</strong> de pàgina conté en un moment determinat una <em>pàgina en memòria d’un procés</em>. Aquesta estructura de dades que <strong>relaciona</strong> <strong>pàgines</strong> amb <em>marcs</em> es coneix com a <strong>taula de pàgines</strong> i s’utilitza en la <strong>traducció</strong>.</p>
<h3 class="fragment" id="traducció">Traducció</h3>
<ol type="1">
<li class="fragment">L’adreça lògica es descompon en número de pàgina (p) i desplaçament (d) dins de la pàgina.</li>
<li class="fragment">Amb el número de pàgina s’indexa en la taula de la pàgina del procés.</li>
<li class="fragment">Aquest està ubicat a partir de l’adreça guardada al registre base de taula de pàgines (RBTP).</li>
<li class="fragment">Es realitzen els controls d’accessos a la pàgina.</li>
<li class="fragment">Es calculen les adreces físiques (a partir de l’índex de la cel·la física multiplica per la mida de pàgina més el desplaçament).</li>
</ol>
</section>
<section id="esquema-i-maquinari-paginació" class="slide level2 smaller">
<h2>Esquema i Maquinari: paginació</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/paginacio.png"></p>
</div>
<div title="Què representa ×n en aquests diagrames?">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Què representa ×n en aquests diagrames?</strong></p>
</div>
<div class="callout-content">
<p>El símbol <strong>×n</strong> indica que cada entrada d’una taula (segmentació, paginació o similar) ocupa <strong>n bytes</strong>. Per accedir a una entrada concreta, cal calcular la seva adreça amb: <span class="math inline">\(\text{adreça_física} = \text{base_taula} + (\text{índex} \times n)\)</span></p>
</div>
</div>
</div>
</div>
</section>
<section id="format-taula-de-pàgines" class="slide level2 smaller">
<h2>Format Taula de pàgines</h2>
<table class="caption-top">
<thead>
<tr class="header">
<th>cel·la pàgina física</th>
<th>V</th>
<th>R</th>
<th>W</th>
<th>X</th>
<th>M</th>
<th>Ref</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li class="fragment">V: Entrada vàlida.</li>
<li class="fragment">R: Permisos de lectura.</li>
<li class="fragment">W: Permisos d’escriptura.</li>
<li class="fragment">X: Permisos d’execució.</li>
<li class="fragment">M: Pàgina en Memòria Principal.</li>
<li class="fragment">Ref: Pàgina referenciada.</li>
</ul>
</section>
<section id="problema-1-paginació" class="slide level2 smaller">
<h2>Problema 1: Paginació</h2>
<h3 id="enunciat">Enunciat</h3>
<p>Disposem d’un sistema de gestió de Memòria paginat amb els paràmetres següents:</p>
<ul>
<li class="fragment">Espai d’adreçament lògic de processos: <em>2MB</em>.</li>
<li class="fragment">Mida Memòria Principal: <em>128KB</em>.</li>
<li class="fragment">Mida pàgina: <em>4KB</em>.</li>
</ul>
<div class="fragment">
<p>Calcular:</p>
<ul>
<li class="fragment">Adreça i longitud</li>
<li class="fragment">Mida de la taula de pàgines</li>
<li class="fragment">Número de cel·les.</li>
</ul>
</div>
</section>
<section id="problema-1-paginació-solució" class="slide level2 smaller">
<h2>Problema 1: Paginació (Solució)</h2>
<p>L’adreça lògica és dividida en dues parts: el desplaçament i el número de pàgina.</p>
<ul>
<li class="fragment"><strong>Desplaçament</strong>: La mida de la pàgina és de 4 KB (<span class="math inline">\(2^{12}\)</span> bytes), i per representar qualsevol desplaçament a l’interior d’una pàgina, necessitem 12 bits.</li>
<li class="fragment"><strong>Número de Pàgina</strong>: Per a una adreça lògica total de 2 MB (<span class="math inline">\(2^{21}\)</span> bytes), el número màxim de pàgines és la raó entre l’espai d’adreçament lògic total i el desplaçament (<span class="math inline">\(\dfrac{2^{21}}{2^{12}}=2^9\)</span>), per tant, requerim 9 bits per representar el número de pàgina.</li>
</ul>
</section>
<section id="problema-1-paginació-solució-1" class="slide level2 smaller">
<h2>Problema 1: Paginació (Solució)</h2>
<p>L’adreça lògica és dividida en dues parts: el desplaçament i el número de pàgina.</p>
<ul>
<li class="fragment"><strong>Mida de la Taula de Pàgines</strong>: La mida de la taula de pàgines es determina pel nombre màxim de pàgines que pot tenir un procés. Si l’espai d’adreçament lògic total és de 2 MB, i la mida de la pàgina és de 4 KB, el nombre màxim de pàgines és de 512 (<span class="math inline">\(\dfrac{2^{21}}{2^{12}}=2^9\)</span>). Per tant, la taula de pàgines tindrà 512 entrades.</li>
<li class="fragment"><strong>Número de Cel·les de la Memòria</strong>: El nombre de cel·les a la memòria es calcula igualment, considerant la mida de la pàgina. Si la mida de la Memòria Principal és de 128 KB, i la mida de la pàgina és de 4 KB, el nombre de cel·les és de 32 (<span class="math inline">\(\dfrac{2^{17}}{2^{12}}=2^5\)</span>).</li>
</ul>
</section>
<section id="problema-1-paginació-ii" class="slide level2 smaller">
<h2>Problema 1: Paginació (II)</h2>
<p>Quina és l’adreça física de les adreçes lògiques: 015253H, 003204H, 0H, 017253H, 005100H. Quines són vàlides? Assumeix la següent taula de pàgines:</p>
<div class="columns">
<div class="column" style="width:50% .smaller;">
<div title="Taula de pàgines">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Taula de pàgines</strong></p>
</div>
<div class="callout-content">
<table class="caption-top">
<thead>
<tr class="header">
<th>Index</th>
<th>Cel·la</th>
<th>V</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>09H</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>01H</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>03H</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>0FH</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>02H</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>0CH</td>
<td>0</td>
</tr>
<tr class="odd">
<td>21</td>
<td>0AH</td>
<td>1</td>
</tr>
<tr class="even">
<td>22</td>
<td>05H</td>
<td>1</td>
</tr>
<tr class="odd">
<td>23</td>
<td>0DH</td>
<td>1</td>
</tr>
<tr class="even">
<td>24</td>
<td>04H</td>
<td>0</td>
</tr>
<tr class="odd">
<td>25</td>
<td>00H</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div><div class="column" style="width:50%;">
<div title="Solució">
<div class="callout callout-warning callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Solució</strong></p>
</div>
<div class="callout-content">
<table class="caption-top">
<thead>
<tr class="header">
<th>Adreça lògica</th>
<th>Cel·la</th>
<th>Desplaçament</th>
<th>Adreça física</th>
<th>Vàlida</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>015253H</td>
<td>???</td>
<td>???</td>
<td>???</td>
<td>???</td>
</tr>
<tr class="even">
<td>003204H</td>
<td>???</td>
<td>???</td>
<td>???</td>
<td>???</td>
</tr>
<tr class="odd">
<td>0H</td>
<td>???</td>
<td>???</td>
<td>???</td>
<td>???</td>
</tr>
<tr class="even">
<td>017253H</td>
<td>???</td>
<td>???</td>
<td>???</td>
<td>???</td>
</tr>
<tr class="odd">
<td>005100H</td>
<td>???</td>
<td>???</td>
<td>???</td>
<td>???</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div></div>
</section>
<section id="problema-1-paginació-iii" class="slide level2 smaller">
<h2>Problema 1: Paginació (III)</h2>
<p>Donada una adreça lògica amb 9 bits per al número de pàgina i 12 bits per al desplaçament, com ara l’adreça <code>015253H</code>, podem descomposar-la de la següent manera:</p>
<ol type="1">
<li class="fragment"><strong>Número de Pàgina (9 bits):</strong>
<ul>
<li class="fragment"><code>015253H</code> en binari: <code>0 0001 0101 0010 0101 0011</code></li>
<li class="fragment">El primer 9 bits formen el número de pàgina: <code>0 0001 0101</code> que en decimal és el 21 (<span class="math inline">\(2^0+2^2+2^4\)</span>).</li>
</ul></li>
<li class="fragment"><strong>Desplaçament (12 bits):</strong>
<ul>
<li class="fragment"><code>015253H</code> en binari: <code>0 0001 0101 0010 0101 0011</code></li>
<li class="fragment">Bits del 10 al 21 (de dreta a esquerra): <code>0010 0101 0011</code> (253H).</li>
</ul></li>
</ol>
<div class="fragment center-container">
<p>Per tant, cercarem la pàgina nº 21 a la taula de pàgines, aquesta entrada conté el número de cel·la 0AH. Per tant, l’adreça física és <code>0A253H</code> i és vàlida.</p>
</div>
</section>
<section id="problema-1-paginació-iv" class="slide level2 smaller">
<h2>Problema 1: Paginació (IV)</h2>
<p>Quina és l’adreça física de les adreçes lògiques: 015253H, 003204H, 0H, 017253H, 005100H. Quines són vàlides? Assumeix la següent taula de pàgines:</p>
<div class="columns">
<div class="column" style="width:50%;">
<div title="Taula de pàgines">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Taula de pàgines</strong></p>
</div>
<div class="callout-content">
<table class="caption-top">
<thead>
<tr class="header">
<th>Index</th>
<th>Cel·la</th>
<th>V</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>09H</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>01H</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>03H</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>0FH</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>02H</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>0CH</td>
<td>0</td>
</tr>
<tr class="odd">
<td>21</td>
<td>0AH</td>
<td>1</td>
</tr>
<tr class="even">
<td>22</td>
<td>05H</td>
<td>1</td>
</tr>
<tr class="odd">
<td>23</td>
<td>0DH</td>
<td>1</td>
</tr>
<tr class="even">
<td>24</td>
<td>04H</td>
<td>0</td>
</tr>
<tr class="odd">
<td>25</td>
<td>00H</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div><div class="column" style="width:50%;">
<div title="Solució">
<div class="callout callout-warning callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Solució</strong></p>
</div>
<div class="callout-content">
<table class="caption-top">
<thead>
<tr class="header">
<th>Adreça lògica</th>
<th>Cel·la</th>
<th>Desplaçament</th>
<th>Adreça física</th>
<th>Vàlida</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>015253H</td>
<td>0AH</td>
<td>253H</td>
<td>0A253H</td>
<td>Sí</td>
</tr>
<tr class="even">
<td>003204H</td>
<td>0FH</td>
<td>204H</td>
<td>0F204H</td>
<td>Sí</td>
</tr>
<tr class="odd">
<td>0H</td>
<td>09H</td>
<td>0H</td>
<td>09000H</td>
<td>Sí</td>
</tr>
<tr class="even">
<td>017253H</td>
<td>0DH</td>
<td>253H</td>
<td>0D253H</td>
<td>Sí</td>
</tr>
<tr class="odd">
<td>005100H</td>
<td>0CH</td>
<td>100H</td>
<td>0CH10H</td>
<td>No</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div></div>
</section>
<section id="anàlisi-de-la-paginació" class="slide level2 smaller">
<h2>Anàlisi de la paginació</h2>
<p>Assumeix que tenim un sistema on la mida de la pàgina és de 4 KB. Si un procés ocupa 10 KB de memòria, aquest s’allotjarà en tres pàgines (4 KB + 4 KB + 2 KB). Això implica que el procés ocuparà 3 cel·les de la Memòria Principal. Si el procés necessita 10 KB de memòria, però la mida de la pàgina és de 8 KB, el procés s’allotjarà en dues pàgines (8 KB + 2 KB). Això implica que el procés ocuparà 2 cel·les de la Memòria Principal. Per tant:</p>
<div class="fragment center-container">
<p><strong>La paginació no evita la fragmentació interna, però la redueix.</strong></p>
</div>
</section>
<section id="característiques-de-la-paginació" class="slide level2 smaller">
<h2>Característiques de la paginació</h2>
<p>La paginació és una tècnica de gestió de memòria que presenta certes característiques:</p>
<ol type="1">
<li class="fragment"><p><strong>Eliminació de la Fragmentació Externa:</strong> Cada pàgina pot ser assignada independentment, permetent a les pàgines ser ubicades en qualsevol ordre a la memòria física. Això elimina la dependència de tenir àrees contigües per allotjar processos.</p></li>
<li class="fragment"><p><strong>Fragmentació Interna:</strong> Tot i que elimina la fragmentació externa, la paginació pot introduir fragmentació interna, ja que l’última pàgina pot no estar plena. Aquest espai no utilitzat dins de l’última pàgina indueix a fragmentació interna.</p></li>
<li class="fragment"><p><strong>Transparència a l’Usuari:</strong> Aquest esquema de gestió de memòria és totalment transparent a l’usuari. L’usuari no necessita saber res sobre la paginació.</p></li>
<li class="fragment"><p><strong>Taula de Pàgines per Procés:</strong> Es necessita mantenir una taula de pàgines per a cada procés per gestionar la traducció d’adreces lògiques a adreces físiques.</p></li>
</ol>
</section>
<section id="observacions-sobre-la-paginació" class="slide level2 smaller">
<h2>Observacions sobre la paginació</h2>
<p>La paginació elimina la fragmentació externa des del punt de vista del procés. Tanmateix, en implementacions modernes pot aparèixer una certa fragmentació al gestor de frames (<em>buddy allocator</em>), tot i que molt menor que en particions variables.</p>
</section>
<section id="segmentació" class="slide level2 smaller">
<h2>Segmentació</h2>
<p>La <strong>segmentació</strong> és un mètode de maquinari que intenta donar suport a les regions. Considera el <em>mapa de memòria d’un procés</em> com un <em>conjunt de segments</em>. <span class="alert">Cada regió es guarda en un segment diferent</span>. El <strong>maquinari</strong> del gestor necessita una <strong>taula de segments</strong>. <em>Una direcció lògica</em> es forma per un <em>número de segment</em> i una <em>direcció dins del segment</em>. La <strong>traducció</strong> consisteix a accedir al número de segment i utilitzar els <em>registre base i límit per comprovar que l’entrada és correcta</em>.</p>
<h3 class="fragment" id="observacions">Observacions</h3>
<ul>
<li class="fragment"><strong>Obs1.</strong> La segmentació divideix l’espai lògic del procés en unitats lògiques (segments) de mides diferents.</li>
<li class="fragment"><strong>Obs2.</strong> Aquest esquema de gestió coincideix amb la visió que l’usuari té de la Memòria. (Dades, Pila, Codi, Llibreries).</li>
</ul>
</section>
<section id="esquema-i-hardware-segmentació" class="slide level2 smaller">
<h2>Esquema i Hardware: Segmentació</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/segmentacio2.png"></p>
</div>
</section>
<section id="problemes-de-la-segmentació" class="slide level2 smaller">
<h2>Problemes de la segmentació</h2>
<p>La segmentació és molt semblant amb l’esquema de gestió de Memòria per particions múltiples de mida variable. Té els mateixos problemes que aquest esquema.</p>
<ul>
<li class="fragment"><p><strong>Fragmentació Externa</strong>. L’espai de memòria física d’un segment ha de ser contigu en memòria i pot provocar fragmentació externa. <em>Imaginem que tenim 3 segments de 1KB, 2KB i 2KB. La nostra taula de segments ens portarà a 3 zones de memòria física de 1KB, 2KB i 2KB. Assumirem que ambdos segments de 2KB no estan utilitzats, per tant, tenim 4KB de memòria lliure. No obstant això, no podem allotjar un segment de 3KB, ja que no hi ha cap regió contigua de 3KB</em>.</p></li>
<li class="fragment"><p>Requereix mètodes de compactació de la Memòria. Per gestionar la fragmentació, es poden utilitzar mètodes de compactació que moguin els segments i redueixin la fragmentació. Es poden moure segments després d’un ús continuat o quan es detecta que hi ha fragmentació.</p></li>
<li class="fragment"><p>Polítiques de selecció per ubicar els segments en Memòria física: S’han d’escollir algoritmes eficients per ubicar els segments a la memòria física, com ara First-Fit o Best-Fit.</p></li>
</ul>
</section>
<section id="avantatges-de-la-segmentació" class="slide level2 smaller">
<h2>Avantatges de la segmentació</h2>
<ul>
<li class="fragment"><p><strong>Absència de Fragmentació Interna</strong>: Cada segment pot tenir la seva pròpia mida, i això significa que no hi ha fragmentació interna dins dels segments mateixos. Cada segment utilitza exactament l’espai que necessita sense desperdiciar memòria.</p></li>
<li class="fragment"><p><strong>Flexibilitat per compartir i protegir segments</strong>: Cada segment pot ser protegit individualment i compartir-se amb altres processos si és necessari. Aquesta capacitat de gestionar diferents parts de la memòria amb polítiques específiques proporciona un alt grau de control i eficàcia en la gestió del sistema.</p></li>
</ul>
<div class="fragment center-container">
<p>Per exemple, un segment de codi pot ser compartit per diferents processos, mentre que un segment de dades pot ser protegit per un procés específic.</p>
</div>
</section>
<section id="segmentació-paginada" class="slide level2 smaller">
<h2>Segmentació Paginada</h2>
<p>La segmentació paginada proporciona suport directe a les regions d’un procés i la paginació permet un millor aprofitament de la Memòria i una base per construir un esquema de Memòria virtual.</p>
<h3 class="fragment" id="observacions-1">Observacions</h3>
<ul>
<li class="fragment">La segmentació paginada intenta reduir la fragmentació externa associada als segments i millorar l’eficiència de la Memòria.</li>
<li class="fragment">Cada segment està paginat, de manera que la Memòria física associada amb un segment no ha d’estar contigua a la Memòria.</li>
<li class="fragment">Descomposició adreça lògica:
<ul>
<li class="fragment"><strong>Segment</strong> + <strong>Desplaçament 1</strong> (<strong>Pàgina</strong> + <strong>Desplaçament 2</strong>)
<ul>
<li class="fragment"><strong>Pàgina</strong>: Entrada a la taula de pàgines del segment.</li>
<li class="fragment"><strong>Desplaçament 2</strong>: Desplaçament de la cel·la a la Memòria física.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="hardware-segmentació-paginada" class="slide level2">
<h2>Hardware segmentació-paginada</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/seg-paginada1.png"></p>
</div>
<div title="Observació">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Observació</strong></p>
</div>
<div class="callout-content">
<p>Aquest model és molt útil per entendre conceptes, però no és el que implementen els sistemes operatius moderns com Linux o Windows.</p>
</div>
</div>
</div>
</div>
</section>
<section id="problema-2-segmentació-paginada" class="slide level2 smaller">
<h2>Problema 2: Segmentació paginada</h2>
<p>Dissenyar un sistema de segmentació paginada amb les característiques següents:</p>
<ul>
<li class="fragment">Memòria física: 8MB.</li>
<li class="fragment">Número màxim de segments per procés: 16.</li>
<li class="fragment">Mida màxima segment: 1MB.</li>
<li class="fragment">Mida pagina: 4KB.</li>
</ul>
<div class="fragment">
<p>Calcular:</p>
<ol type="1">
<li class="fragment">Esquema de traducció.</li>
<li class="fragment">Taula de segments per un procés amb:
<ul>
<li class="fragment">Codi: 128KB, Dades: 4KB, Dades: 256B, Pila 16KB</li>
</ul></li>
<li class="fragment">Calcular l’adreça física per 1:01100h si les entrades a la taula de segments del procés anterior són: 0h, 1000h, 2000h i 1500h.</li>
</ol>
</div>
</section>
<section id="problema-2-càlculs" class="slide level2 smaller">
<h2>Problema 2: Càlculs</h2>
<ul>
<li class="fragment"><p><strong>Nº de segments</strong>: 16 segments per procés. Per tant, necessitem 4 bits per representar el número de segment (<span class="math inline">\(2^4\)</span>).</p></li>
<li class="fragment"><p><strong>Mida màxima segment</strong>: 1MB. Per tant, necessitem 20 bits per representar el desplaçament dins del segment (<span class="math inline">\(2^{20}\)</span>).</p></li>
<li class="fragment"><p><strong>Mida de la pàgina</strong>: 4KB. Per tant, necessitem 12 bits per representar el desplaçament dins de la pàgina (<span class="math inline">\(2^{12}\)</span>).</p></li>
<li class="fragment"><p><strong>Adreça lògica</strong>: Segment (4 bits) + Desplaçament 1 (20 bits).</p></li>
<li class="fragment"><p><strong>Adreça lògica</strong>: Segment (4 bits) + Pàgina (8 bits) + Desplaçament 2 (12 bits).</p></li>
<li class="fragment"><p><strong>Adreça física</strong>: Cel·la (11 bits) + Desplaçament 2 (12 bits). La mida de la Memòria Principal és de 8MB, per tant, necessitem 23 bits per representar el número de cel·la (<span class="math inline">\(2^{23}\)</span>). La raó entre la mida de la Memòria Principal i la mida de la pàgina és: (<span class="math inline">\(\dfrac{2^{23}}{2^{12}}=2^{11}\)</span>).</p></li>
</ul>
</section>
<section id="problema-2-esquema-de-traducció" class="slide level2">
<h2>Problema 2: Esquema de Traducció</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/ex2-seg-pag.png"></p>
</div>
</section>
<section id="paginació-segmentada" class="slide level2 smaller">
<h2>Paginació segmentada</h2>
<p>La paginació segmentada primer divideix en taula de pàgines i després cada pàgina es divideix en segments.</p>

<img data-src="../figures/slides/06-mem/paginacio-segmentada.png" class="r-stretch"><div class="center-container fragment">
<p>En l’únic cas que pot ser eficient es quan tenim processos molt grans</p>
</div>
</section></section>
<section>
<section id="exercicis" class="title-slide slide level1 center">
<h1>Exercicis</h1>

</section>
<section id="enuciat-i" class="slide level2 smaller">
<h2>Enuciat (I)</h2>
<p>Disposem d’un sistema de gestió de memòria on la mida de la pàgina és de 512 bytes, la de Memòria és de 2 MB, i la d’una paraula 1 byte. Un procés consta de com a molt 4 segments. La mida màxima d’un segment és 4K. Totes les taules s’implementen en memòria principal. Donats els dos processos següents:</p>
<table class="caption-top">
<thead>
<tr class="header">
<th></th>
<th>P1</th>
<th>P2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(P_{A}\)</span> (512 bytes)</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P_{B}\)</span> (2560 bytes)</td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(Dades_{L}\)</span> (1024 bytes)</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>Les X’s en la taula indiquen quins procediments i dades estan assignats a cada procés. Una fila amb dos o més X’s indica que el procediment o dades estan compartits. A més, cada procés està format per un <em>segment d’stack de 1 KB</em>. Les primeres 50 primeres cel·les estan ocupades, i de les restants, les parells també ho estan.</p>
</section>
<section id="enuciat-ii" class="slide level2 smaller">
<h2>Enuciat (II)</h2>
<p>Doneu un exemple, sempre que sigui possible, que mostri quina és la informació i la seva mida (en bytes), que ha de guardar el s.o. per tal de poder fer la traducció d’adreces dels dos processos quan aquests executen dins de la CPU pels sistemes de gestió de memòria següents:</p>
<ul>
<li class="fragment">Paginació (<strong>3 punts</strong>)</li>
<li class="fragment">Segmentació. (<strong>3 punts</strong>)</li>
<li class="fragment">Segmentació Paginada (<strong>4 punts</strong>)</li>
</ul>
</section>
<section id="paginació-i" class="slide level2">
<h2>Paginació (I)</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/problema/2.png" style="width:70.0%"></p>
</div>
</section>
<section id="paginació-ii" class="slide level2 smaller">
<h2>Paginació (II)</h2>
<p>Pàgines per procés:</p>
<table class="caption-top">
<thead>
<tr class="header">
<th></th>
<th>P1</th>
<th>P2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(P_{A}\)</span> (512 bytes)</td>
<td>?</td>
<td>?</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P_{B}\)</span> (2560 bytes)</td>
<td>?</td>
<td>?</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(Dades_{L}\)</span> (1024 bytes)</td>
<td>?</td>
<td>?</td>
</tr>
<tr class="even">
<td>Stack (1024 bytes)</td>
<td>?</td>
<td>?</td>
</tr>
<tr class="odd">
<td><strong>TOTAL</strong></td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</section>
<section id="paginació-iii" class="slide level2 smaller">
<h2>Paginació (III)</h2>
<p>Pàgines per proés:</p>
<table class="caption-top">
<thead>
<tr class="header">
<th></th>
<th>P1</th>
<th>P2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(P_{A}\)</span> (512 bytes)</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><span class="math inline">\(P_{B}\)</span> (2560 bytes)</td>
<td>5</td>
<td>-</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(Dades_{L}\)</span> (1024 bytes)</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>Stack (1024 bytes)</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td><strong>TOTAL</strong></td>
<td>10</td>
<td>5</td>
</tr>
</tbody>
</table>
</section>
<section id="esquema-de-traducció-paginació" class="slide level2">
<h2>Esquema de traducció (Paginació)</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/problema/1.png" style="width:70.0%"></p>
</div>
</section>
<section id="taules-de-pàgines-paginació" class="slide level2">
<h2>Taules de pàgines (Paginació)</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/problema/3.png" style="width:85.0%"></p>
</div>
</section>
<section id="segmentació-i" class="slide level2">
<h2>Segmentació (I)</h2>
<div class="center-container fragment">
<p><strong><span class="alert">No es pot aplicar la segmentació</span></strong></p>
</div>
<ul>
<li class="fragment">La segmentació requereix totes les pàgines d’un segment en una regió contigua de Memòria.</li>
<li class="fragment">El procediment B, les dades i la pila ocupen més d’una pàgina (5,2 i 2 respectivament).</li>
<li class="fragment">No hi ha més d’una cel·la contigua lliure; ja que les cel·les, parells estan ocupades.</li>
</ul>
</section>
<section id="segmentació-paginada-esquema" class="slide level2 smaller">
<h2>Segmentació Paginada (Esquema)</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/problema/4.png" style="width:50.0%"></p>
</div>
</section>
<section id="segmentació-paginada-pàgines-i-segments" class="slide level2 smaller">
<h2>Segmentació Paginada (pàgines i segments)</h2>
<div class="center-container">
<p><img data-src="../figures/slides/06-mem/problema/5.png" style="width:85.0%"></p>
</div>
</section>
<section id="reflexió-final-i" class="slide level2 smaller">
<h2>Reflexió final (I)</h2>
<p>En els sistemes operatius moderns (Linux, Windows, macOS), la gestió de la memòria es basa principalment en <strong>paginació</strong> amb suport de la <strong>MMU</strong>, <strong>TLB</strong> i <strong>taules de pàgines multinivell</strong>. Aquest és el mecanisme central de traducció d’adreces en arquitectures modernes com x86-64 i ARM.</p>
<p>La <strong>segmentació clàssica</strong> i la <strong>segmentació paginada</strong> són models teòrics o històrics que permeten entendre els fonaments de la gestió de la memòria, però <strong>ja no s’utilitzen com a mecanisme general</strong> en arquitectures actuals.</p>
</section>
<section id="reflexió-final-ii" class="slide level2 smaller">
<h2>Reflexió final (II)</h2>
<p>Tot i això, <strong>Linux sí que utilitza segmentació en casos puntuals</strong>, especialment: - per accedir a informació específica de cada procés o fil (<strong>FS/GS base</strong>, TLS), - en modes de compatibilitat de 32 bits, - i en fases inicials del procés d’arrencada.</p>
</section>
<section id="properes-parts" class="slide level2 smaller">
<h2>Properes parts</h2>
<ul>
<li class="fragment"><p><strong>Part 2 — Sistemes moderns: el cas del Kernel de Linux</strong><br>
Traducció d’adreces real, TLB, multilevel paging, ASLR, estructura <code>/proc/&lt;pid&gt;/maps</code>, ELF, <code>mmap()</code>, COW, i assignació física (buddy allocator).</p></li>
<li class="fragment"><p><strong>Part 3 — Memòria virtual</strong><br>
Demand paging, page faults, swapping, working set, thrashing, polítiques de reemplaçament i gestió dinàmica de la memòria virtual.</p></li>
</ul>


</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<p><img src="../figures/corporative/institute.png" class="slide-logo"></p>
<div class="footer footer-default">
<p>Unitat 6 · Sistemes Operatius (SO) <a href="../index.html">🏠</a></p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'pdfMaxPagesPerSlide': 1,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'fade',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp("https:\/\/os-gei-udl-2526-105012\.github\.io\/course\/");
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>