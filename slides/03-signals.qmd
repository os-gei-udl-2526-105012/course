---
title: "Senyals"
subtitle: "Unitat 3 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Qu√® s√≥n els senyals? 

Un **senyal** √©s una notificaci√≥ as√≠ncrona enviada pel nucli a un proc√©s per informar d‚Äôun esdeveniment (*com una excepci√≥ o acci√≥ de l‚Äôusuari*).

```c
int x = 0;
int y = 5 / x;
```

- El proc√©s A s‚Äôexecuta en mode usuari.
- Es produeix una excepci√≥ (divisi√≥ per zero).
- El nucli detecta l‚Äôerror i envia al proc√©s un senyal SIGFPE.
- El proc√©s pot tenir una rutina de tractament o seguir l‚Äôacci√≥ per defecte (**acabar**).
- El proc√©s A es finalitza, degut al Gestor de senyals.


## Flux dels esdeveniments {.smaller}

```{mermaid}
%%| echo: false
sequenceDiagram 
    participant U as Usuari
    participant K as Nucli
    participant A as Proc√©s A

    U->>K: Excepci√≥ (divisi√≥ per zero)
    K->>K: Detecta excepci√≥
    K->>A: Envia senyal SIGFPE al proc√©s A
    A->>A: T√© rutina de gesti√≥ de senyal?
    alt S√≠
        A->>A: Executa rutina de gesti√≥ de senyal
    else No
        A->>A: Executa acci√≥ per defecte
        K->>K: Finalitza proc√©s A
    end
```

## Tipus d'esdeveniments {.smaller}

Els esdeveniments que generen senyals poden provenir de maquinari o programari.

| Tipus              | Origen                 | Gesti√≥                 | Exemple                   | Destinaci√≥         |
| ------------------ | ---------------------- | ---------------------- | ------------------------- | ------------------ |
| **Interrupci√≥ HW** | Dispositiu extern      | Gestor d‚Äôinterrupcions | Tick del temporitzador    | Nucli              |
| **Excepci√≥ SW**    | Instrucci√≥ err√≤nia     | Nucli ‚Üí envia senyal   | Divisi√≥ per zero ‚Üí SIGFPE | Proc√©s causant     |
| **Senyal**         | Usuari, proc√©s o nucli | `kill()`, `signal()`   | `kill(pid, SIGTERM)`      | Proc√©s destinatari |


## Exemple pr√†ctic {.smaller}

Quants senyals estem enviant? Quines? Quina acci√≥ fa el proc√©s quan rep els senyals?

::: columns
::: {.column width="20%"}
```bash
yes > /dev/null
ctrl+z
bg
ctrl+c
```
:::
::: {.column width="5%"}
:::
::: {.column width="75%"}
| Combinaci√≥ | Senyal  | Efecte per defecte      | Estat   |
| ---------- | ------- | ----------------------- | ------- |
| **Ctrl+C** | SIGINT  | Terminar proc√©s         | Mort    |
| **Ctrl+Z** | SIGTSTP | Aturar proc√©s           | Stopped |
| **bg**     | SIGCONT | Reprendre en segon pla  | Running |
| **fg**     | SIGCONT | Reprendre en primer pla | Running |
:::
:::

* *Quants senyals estem enviant?* 3
* *Quines?* SIGTSTP, SIGINT, SIGCONT
* *Quina acci√≥ fa el proc√©s quan rep les senyals?* Aturar l'execuci√≥ en primer pla i portar el proc√©s a segon pla. Arrancar l'execuci√≥ en segon pla. Acabar el proc√©s.


## Exemple pr√†ctic: Pas a Pas {.smaller}

- La comanda *yes>/dev/null* crear√† un **proc√©s A** i s'executa al *primer pla*, quan un usuari pitj√† el **ctrl-z**, el kernel autom√†ticament envia un senyal *SIGSTOP* al **proc√©s A,** que modifica el seu estat d'execuci√≥ a parat i tamb√© marxa del primer pla al segon pla. 

- Despr√©s amb la comanda **bg**, el kernel tramet al proc√©s el senyal *SIGCONT* i continua la seva execuci√≥ en segon pla quan la rep. Una altra manera equivalent per realitzar aquest proc√©s √©s **yes>/dev/null &** on *&* ens envia l'ordre directament en execuci√≥ al background.

- Observeu tamb√© com de  forma similar la comanda **fg**; en aquest cas el kernel tramet *SIGCONT* i el proc√©s quan rep *SIGCONT*; torna a executar-se al primer pla.  Noteu que amb ctrl-c tenim un comportament similar; i el proc√©s en primer pla √©s acabat en rebre el senyal *SIGINT* (**ctrl+c**).

## Diagrama de canvis d'estat

:::{.center-container}
![](../figures/slides/03-signals/signals-state.png)
:::


## Esdeveniments s√≠ncrons i as√≠ncrons {.smaller}

| Tipus d‚Äôesdeveniment       | Exemple          | Sincronia                                  |
| -------------------------- | ---------------- | ------------------------------------------ |
| **Excepci√≥ (SIGFPE)**      | Divisi√≥ per zero | S√≠ncron amb l‚Äôexecuci√≥                     |
| **Senyal extern (SIGINT)** | Ctrl+C           | As√≠ncron (pot arribar en qualsevol moment) |

- Un esdeveniment √©s **s√≠ncron** quan est√† relacionat amb l'execuci√≥ del proc√©s, per exemple una excepci√≥ com la divisi√≥ per zero o un error de segmentaci√≥. En aquest cas el proc√©s que ha causat l'esdeveniment √©s el mateix que rep el senyal.

- Un esdeveniment √©s **as√≠ncron** quan no est√† relacionat amb l'execuci√≥ del proc√©s, per exemple una interrupci√≥ de maquinari o una acci√≥ de l'usuari com un **ctrl+c**. En aquest cas el proc√©s que ha causat l'esdeveniment √©s diferent del proc√©s que rep el senyal.
  

## Esquema general

:::{.center-container}
![](../figures/slides/03-signals/signals-flow.png)
:::


## Rutines de Tractament de senyals 

Quan el proc√©s rebi el senyal *signum* executar√† *gestor*, que
pot ser una **funci√≥** o **SIG_DFL**, acci√≥ per defecte, o **SIG_IGN** per ignorar el senyal.

```c
#include <signal.h> 
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t gestor);
```
<br>

#### Valors de retorn
* En cas d'√®xit retorna un **punter a la anterior funci√≥ gestora del senyal**.
* En cas d'error, retorna **SIG_ERR**.

## `pause()`

La crida a sistema `pause()` s'utilitza per posar en espera un proc√©s fins que rep un senyal.

```c
#include <unistd.h> 
int pause(void);
```

* Sempr√© **retorna -1**.
* Es **bloqueja** fins que el proc√©s rep un senyal (qualsevol).

## Gesti√≥ interna de senyals (Kernel)

Quan el nucli genera o rep un senyal destinat a un proc√©s, no interromp immediatament el proc√©s en execuci√≥.
El senyal es marca com a pendent dins del PCB i es comprova abans de tornar a mode usuari.

```{mermaid}
%%| echo: false
sequenceDiagram
    participant U as CPU ¬∑ Mode Usuari
    participant K as Nucli
    participant P as PCB del Proc√©s

    U->>K: Interrupci√≥ / Excepci√≥ / Syscall
    K->>P: Marca senyal SIGINT com a pendent ¬∑ signal_pending |= SIGINT
    K->>P: Actualitza cua de senyals i m√†scara
    K->>U: Retorna del mode nucli ‚Üí mode usuari
    U->>P: Comprova senyals pendents ¬∑ signal_pending & ~signal_mask
    alt Senyal amb handler
        U->>P: Executa rutina del senyal user handler
    else Acci√≥ per defecte
        U->>K: Finalitza proc√©s (SIG_DFL)
    end
```

## Crides a sistema {.smaller}

| Crida                                                                          | Funci√≥                                       | Acci√≥ sobre el PCB         |
| ------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------- |
| `sigprocmask(int how, const sigset_t *set, sigset_t *oldset)`                  | Bloqueja o desbloqueja senyals.              | Modifica `signal_mask`.    |
| `sigpending(sigset_t *set)`                                                    | Consulta els senyals pendents.               | Llegeix `signal_pending`.  |
| `sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)` | Defineix un manejador per un senyal concret. | Modifica `handlers[]`.     |
| `sigqueue(pid_t pid, int sig, const union sigval value)`                       | Envia un senyal amb una dada associada.      | Afegeix entrada a `queue`. |
| `alarm(unsigned int sec)`                                                      | Programa l‚Äôenviament de `SIGALRM`.           | Configura `alarm_timer`.   |


## Gesti√≥ de senyals en C

```c 
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int sig) {
    printf("Rebut senyal %d\n", sig);
}

int main() {
    signal(SIGINT, handler);
    while (1) pause();
}
```

:::{.center-container}
Aquesta √©s la sintaxis tradicional per incloure la gesti√≥ de senyals en C.
:::

## `sigaction`

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int sig) {
    write(1, "SIGINT rebut\n", 13);
}

int main(void) {
    struct sigaction sa;
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);

    while (1) pause();
}
```

:::center-container
Aquesta √©s la sintaxis recomanada per incloure la gesti√≥ de senyals en C. M√©s modern i segura.
:::

## Accions per defecte

Cada senyal t√© una acci√≥ per defecte. Algunes possibles accions s√≥n:

* **Ignorar el senyal** (SIG_IGN).
* **Finalitzar el proc√©s** (abnormal termination).
* **Finalitzar el proc√©s i generar un core dump** (abnormal termination with core dump).
* **Aturar el proc√©s** (aturar el proc√©s).
* **Reprendre el proc√©s** (continuar el proc√©s).

## Senyals que no es poden capturar

Els senyals **SIGKILL** i **SIGSTOP** no poden ser capturats ni ignorats. Per tant, no podreu modificar el comportament per defecte per raons √≤bvies de seguretat. Aix√≤ garanteix que el nucli i l‚Äôusuari sempre puguin aturar o matar un proc√©s mal comportat.

- **SIGKILL**: Finalitza el proc√©s immediatament. `kill -SIGKILL pid`
- **SIGSTOP**: Atura el proc√©s immediatament. `kill -SIGSTOP pid`

## Enviament de senyals {.smaller}

Per enviar senyals a altres processos s'utilitza la crida a sistema `kill()`.

```c
#include <signal.h>
int kill(pid_t pid, int sig);
```

Envia el senyal *sig* al/s proc√©s/ssos segons pid:

* **pid > 0** : S'envia al proc√©s receptor.
* **pid = 0** : S'envia als processos del mateix grup que l'emissor.
* **pid = -1** : S'envia a tots els processos als quals el proc√©s t√© perm√≠s per enviar senyals.
* **pid < -1** : S'envia a tots els processos l'id del grup que coincideixi amb el valor absolut de pid.

::: {.fragment}
#### Valors de retorn

* En cas d'√®xit, s'ha enviat com a m√≠nim un senyal, es retorna **zero**.
* En cas d'error, retorna **SIG_ERR**
:::



## Cas pr√†ctic: Problema t√≠pic

```c 
int main(void) {
   FILE *f = fopen("temp.txt", "w");
   fprintf(f, "Hola\n");
   fclose(f);
   remove("temp.txt");
}
```

- Si el proc√©s s'executa sense interrupcions, el fitxer temporal **temp.txt** es crea, s'escriu "Hola\n", es tanca i s'elimina correctament.
- Si el proc√©s rep un **SIGINT** (Ctrl+C) abans de tancar el fitxer, el fitxer temporal **temp.txt** no es tancar√† correctament o no s'eliminar√†. Aix√≤ pot provocar p√®rdua de dades o corrupci√≥ del fitxer.


## Soluci√≥ amb gesti√≥ de senyals

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

FILE *f;
void cleanup(int sig) {
    fclose(f);
    remove("temp.txt");
    exit(1);
}

int main(void) {
    struct sigaction sa = {.sa_handler = cleanup};
    sigaction(SIGINT, &sa, NULL);
    f = fopen("temp.txt", "w");
    pause();
}
```

## Cas pr√†ctic: Error t√≠pic {.smaller}

Les rutines de senyals s‚Äôexecuten de forma **as√≠ncrona**: √∫nicament han de fer operacions **async-signal-safe**, √©s a dir, mai es poden cridar funcions com `malloc()`, `printf()`, etc.

```c
void handler(int sig) {
    // ‚ùå Error t√≠pic: malloc() no √©s async-signal-safe
    char *buf = malloc(100);  
    write(1, "SIGINT rebut\n", 13);  // ‚úÖ write() √©s segura dins del handler
    free(buf);
}
```

Una funci√≥ √©s **async-signal-safe** si no provoca comportament indefinit o corrupci√≥ de mem√≤ria.Nom√©s es poden cridar funcions que no depenguin de recursos globals compartits que puguin estar en un estat inconsistent. En aquest cas, `malloc()` i `free()` no s√≥n segures perqu√® poden modificar l'estat intern del gestor de mem√≤ria, acabant en corrupci√≥ de mem√≤ria **heap**.



## Taula resum de senyals {.smaller}

| Senyal  | ID | Descripci√≥                  | Acci√≥ per defecte |
| ------- | -- | --------------------------- | ----------------- |
| SIGABRT | 6  | Abort                       | Terminaci√≥        |
| SIGALRM | 14 | Temporitzador               | Terminaci√≥        |
| SIGCONT | 25 | Reprendre                   | Continuar         |
| SIGFPE  | 8  | Error aritm√®tic             | Terminaci√≥        |
| SIGKILL | 9  | Finalitzaci√≥ for√ßada        | No capturable     |
| SIGINT  | 2  | Interrupci√≥ usuari (Ctrl+C) | Terminaci√≥        |
| SIGUSR1 | 16 | Senyal definit per l‚Äôusuari | Terminaci√≥        |

## Timers al nucli {.smaller}

El nucli mant√© un repositor de timers (estructures internes, sovint per PCB o grup de processos) que compta el temps restant per a cada proc√©s o alarm.

::: center-container
```{mermaid}
%%| echo: false
sequenceDiagram
    participant Kernel
    participant Proc√©s

    Kernel->>Kernel: Compta temps timers
    alt Timer expira
        Kernel->>Proc√©s: Envia SIGALRM
    end
```
:::

Quan expira un timer, el nucli genera un senyal **SIGALRM** i el posa a la cua de senyals del proc√©s destinatari.

## Alarm() i PCB (Process Control Block)

Quan un proc√©s crida `alarm(sec)`, el kernel:

- Guarda el temps restant al PCB del proc√©s (`pcb->alarm_timer`).
- Programa el timer al scheduler o al timer interrupt handler.
- Quan el temps expira, el kernel envia **SIGALRM** al proc√©s.

`alarm()` a *userspace*
------------------------

El proc√©s s'envia a si mateix despr√©s de *sec* segons un senyal **SIGALRM**. Retorna el nombre de segons pendents si hi havia una crida a *alarm* anterior, o zero en altre cas.

```c
#include <unistd.h> C
unsigned int alarm(unsigned int sec);
```

::: {.callout-note title="Desactivar alarmes"}
Per desactivar una alarma pendent, es pot cridar a `alarm(0)`, aquesta comanda cancel¬∑la qualsevol alarma pendent.
:::

## Resum

:::center-container
![](https://wizardzines.com/images/uploads/signals.png){width=70%}
:::


## Aix√≤ √©s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE 
* Els senyals s√≥n una eina de notificaci√≥ entre el nucli i els processos.
* Els senyals poden ser enviats per l'usuari, per altres processos o pel mateix proc√©s.
* Els senyals poden ser gestionats pel proc√©s o executar l'acci√≥ per defecte.
* Els senyals es poden enviar amb la crida a sistema *kill()*.
* Els processos poden definir rutines de tractament de senyals amb la crida a sistema *signal()*.
* Els processos poden esperar senyals amb la crida a sistema
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::


