---
title: "Gesti√≥ de la Mem√≤ria"
subtitle: "Unitat 6 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    pdf-separate-fragments: false
    pdf-max-pages-per-slide: 1
    pdf-page-height: 900
    pdf-page-width: 1600
    footer: "Unitat 6 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Necessitat de la gesti√≥ de la Mem√≤ria {.smaller}

Imaginem un sistema operatiu sense cap mecanisme per gestionar la mem√≤ria. Quan un programa s'executa, pot executar una instrucci√≥ com `MOV REG1, 1000`, que mou el contingut de la mem√≤ria f√≠sica 1000 a REG1.

En aquesta situaci√≥, **qu√® passaria si execut√©ssim dos programes simult√†niament?**

- No podr√≠em tenir dos programes a la mem√≤ria simult√†niament.
- Si el primer programa executa `MOV REG1, 1000`, i despr√©s el segon programa executa `MOV REG1, 1000`, el contingut de la mem√≤ria escrita pel primer programa seria sobreescrit pel segon programa.
- Aix√≤ provocaria un comportament erratic i el primer programa no funcionaria correctament.

:::{.fragment .center-container}
Una possible soluci√≥ seria utilitzar mem√≤ria secund√†ria i anar fent [swapping]{.alert} de la mem√≤ria principal a la secund√†ria. Per√≤, aix√≤ seria molt lent i poc viable.
:::

## Gesti√≥ de la Mem√≤ria {.smaller}

```{mermaid}
flowchart LR
    A[Gestor de Mem√≤ria] --> B[Molts processos]
    B --> C[Ubicats a Mem√≤ria]
    C --> D[De forma simult√†nia]
    D --> E[S'ha de compartir Mem√≤ria f√≠sica]
```

::: columns
::: {.column width="45%" .fragment}

### Objectius

- Traducci√≥ d'adreces.
- Reubicaci√≥ de dades.
- Protecci√≥ de la Mem√≤ria.
- Compartici√≥.

:::
::: {.column width="45%" .fragment}

### Funcionalitats

- M√≤dul que gestiona el mapa de Mem√≤ria de cada proc√©s i les seves regions.
- M√≤dul que reparteix la Mem√≤ria f√≠sica disponible entre els processos existents.

:::
:::

## Qu√® √©s el mapa de Mem√≤ria? {.smaller}

El **mapa de mem√≤ria d'un proc√©s** √©s una representaci√≥ l√≤gica de com la mem√≤ria est√† organitzada per a un programa en execuci√≥. Normalment cont√© diferents regions o segments que es creen a partir de la seva execuci√≥.

:::{.fragment}
### Qu√® √©s una regi√≥?

Una zona contigua de mem√≤ria amb un punt inicial i una mida definida.

* **Suport a la regi√≥**: Es guarda el contingut inicial de la regi√≥.
  * *Fitxer*: Regi√≥ guardada en un fitxer.
  * *An√≤nima*: Sense suport.
* **√ös**: Privat, Compartit entre processos.
* **Protecci√≥**: Lectura, Escriptura, Execuci√≥.
* **Mida**: Fixa o variable.
:::

## Regions del mapa de Mem√≤ria? {.smaller}

::: columns
::: {.column width="70%"}

1. **Codi**: Regi√≥ compartida de lectura i execuci√≥. Mida fixa. Cont√© el codi del programa.
2. **Dades inicialitzades**: Regi√≥ privada on cada proc√©s t√© una c√≤pia pr√≤pia de les variables. Lectura, escriptura i mida fixa. Cont√© variables globals, est√†tiques i inicialitzades.
3. **Dades no inicialitzades**: Regi√≥ privada de lectura i escriptura. Mida fixa.
4. **Heap**: Regi√≥ privada de lectura i escriptura. Mida variable. Aquesta regi√≥ creixar√† amb l'assignaci√≥ din√†mica de mem√≤ria i decreixer√† amb la seva alliberaci√≥. Normalment, creix cap a les direccions m√©s altes del mapa.
5. **Stack**: Regi√≥ privada de lectura i escriptura. Mida variable. Aquesta regi√≥ creixer√† amb les crides a funcions, i decreixer√† quan aquestes retornin. Normalment, creix cap a les direccions m√©s baixes del mapa.

:::
::: {.column width="30%"}

![](../figures/slides/06-mem/memory_map_proc.png)

:::
:::

## Observacions (I) {.smaller}

Suposem que tenim un programa que realitza la multiplicaci√≥ de dues matrius. Aquestes matrius s'introdueixen per teclat en temps d'execuci√≥, i el programa no pot determinar la mida de les matrius fins que l'usuari les introdueixi. Per tant, necessitem un model de mem√≤ria din√†mic.

:::{.fragment}
Suposem que el programa necessita emmagatzemar dades d'un fitxer que no es coneix pr√®viament. En aquest cas, el sistema operatiu pot crear noves regions en el mapa de mem√≤ria per aquestes dades a mesura que el proc√©s llegeix el fitxer, **adaptant-se din√†micament a la demanda**.
:::

## Observacions (II) {.smaller}

A m√©s, els SOs utilitzen **biblioteques din√†miques** que impliquen la creaci√≥ de regions associades a la mateixa i que contenen les diferents seccions de la biblioteca (codi i dades globals). Per exemple, quan carreguem una biblioteca din√†mica comuna, el sistema operatiu pot crear noves regions en el mapa de mem√≤ria del proc√©s per al codi executable i les variables globals de la biblioteca.

:::{.fragment .center-container}
Els Sistemes Operatius **[ofereixen un model de mem√≤ria din√†mic]{.alert}** i necessiten **[mantenir una taula de regions per cada proc√©s]{.alert}** format per un nombre variable de regions que es poden afegir o eliminar durant la seva execuci√≥.
:::

##  Ex: Mem√≤ria d'un proc√©s (I)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int global;

int
main(int argc, char **argv) {
	int private;
	(void) printf("argc at   : 0x%12lX\n", (unsigned long)&argc); 
	(void) printf("argv at   : 0x%12lX\n", (unsigned long)&argv);
	(void) printf("private at: 0x%12lX\n", (unsigned long)&private);
	(void) printf("global at : 0x%12lX\n", (unsigned long)&global);
	(void) printf("main at   : 0x%12lX\n", (unsigned long)&main);

	return EXIT_SUCCESS;
}
```

::: notes
En aquest exemple, el programa defineix variables amb diferents √†mbits (global, local i arguments de la funci√≥ main). A continuaci√≥, mostra les adreces de mem√≤ria d'aquestes variables utilitzant l'operador & per obtenir la seva adre√ßa. Les adreces de mem√≤ria es mostren en format hexadecimal.
:::

##  Ex: Mem√≤ria d'un proc√©s (II)

```c
void f() {
    int stackVar = 42;
    printf("stackVar at: 0x%p\n", (void*)&stackVar);
    int* heapVar = malloc(4);
    printf("Malloced Area Begins at:  0x%p\n", (void*)heapVar);
    printf("Malloced Area Ends at:    0x%p\n", (void*)(heapVar + 1));
    free(heapVar);
}
void main() {
    int mainVar = 0; 
    printf("Stack Frame of main at:  0x%p\n", (void*)&mainVar);
    f();
    printf("End of Stack Frame:      0x%p\n", (void*)&mainVar);
}
```

## Quins tipus d'adreces existeixen? {.smaller}

1. **Espai l√≤gic d'un proc√©s (Relatives):** Adreces de la mem√≤ria que contenen el codi, les dades (inicialitzades i no inicialitzades) i la pila del proc√©s. Aquest espai es crea en el moment d'execuci√≥ del programa. Per exemple, una variable pot ser referenciada com *a 10 bytes des de l'inici de les dades*.

2. **Espai f√≠sic d'un proc√©s (Absolutes)**: Adreces de la mem√≤ria on es carrega l'espai l√≤gic del proc√©s. Aquestes adreces s√≥n les adreces reals a la mem√≤ria f√≠sica on resideixen el codi, les dades i la pila del proc√©s. Quan el sistema operatiu carrega un programa a la mem√≤ria RAM, l'espai l√≤gic d'aquest proc√©s es mapeja a adreces f√≠siques espec√≠fiques, que s√≥n les adreces reals on resideixen les instruccions del codi i les dades.

3. **Adreces generades per la CPU** (adreces virtuals): Quan un proc√©s executa codi, la CPU genera adreces virtuals (tamb√© anomenades adreces l√≤giques) per accedir a variables, instruccions o la pila. Aquestes adreces no s√≥n adreces f√≠siques, sin√≥ refer√®ncies dins l‚Äôespai d‚Äôadreces del proc√©s. Aquestes adreces virtuals no poden accedir directament a la mem√≤ria RAM; han de ser tradu√Ødes a adreces f√≠siques mitjan√ßant algun mecanisme de reubicaci√≥.

## Repte: Traducci√≥ d'adreces {.smaller}

::: columns
::: {.column width="60%"}

:::{.fragment .center-container}

![](../figures/slides/06-mem/introduccio2.png)

:::

:::
::: {.column width="40%" .fragment}

- **Adre√ßa simb√≤lica**: etiqueta del codi font (funci√≥ X, variable Y)
- **Adre√ßa l√≤gica**: la que produeix el compilador (offset dins del segment)
- **Adre√ßa f√≠sica**: la RAM real, assignada pel carregador o la MMU

:::
:::

:::{.fragment .center-container}
**[Repte del SO: Com es tradueixen les adreces l√≤giques a f√≠siques?]{.alert}**
:::

::: notes
- El compilador nom√©s sap offsets: a 24 bytes d‚Äôaqu√≠.
- El sistema operatiu decideix on col¬∑locar el programa.
- Per tant, hem de traduir adreces l√≤giques en f√≠siques.
- Aix√≤ ho fa el loader o la MMU, i √©s el cor de la gesti√≥ de mem√≤ria.
L‚Äôadre√ßa simb√≤lica = *La cuina de casa de la Maria*
L‚Äôadre√ßa l√≤gica = *Habitaci√≥ n√∫mero 3 del pis*
L‚Äôadre√ßa f√≠sica = *Carrer Major 24, 2n 1a*
Quan portes el pis a un altre lloc l‚Äôadre√ßa f√≠sica canvia, per√≤ l‚Äôhabitaci√≥ 3 segueix sent l‚Äôhabitaci√≥ 3.
:::

## Repte: Reubicaci√≥ de la Mem√≤ria {.smaller}

Suposem que tenim dos programes carregats en zones de mem√≤ria diferents:

::: columns
::: {.column width="45%"}

![](../figures/slides/06-mem/reubicacio-necessitat.jpg)

:::
::: {.column width="45%"}

El programa A espera que la instrucci√≥ `MOV` estigui a la posici√≥ 24 de la mem√≤ria, i el programa B espera que la instrucci√≥ `CMP` estigui a la posici√≥ 28 de la mem√≤ria. Si no tenim un mecanisme de reubicaci√≥ de la mem√≤ria, les seves expectatives es veuran compromeses. Fixeu-vos que cada programa t√© la seva zona de 16KB per√≤ es poden solapar. **[Necesitem un mecanisme que ens permeti reubicar la mem√≤ria]{.alert}**.

:::
:::

## Qu√® √©s la reubicaci√≥? {.smaller}

L‚Äôespai d‚Äôadre√ßament d‚Äôun programa s‚Äôha de reubicar (traduir) segons on el sistema operatiu decideixi carregar-lo a Mem√≤ria, sense modificar-ne el comportament. Aquesta traducci√≥ pot fer-se en **compilaci√≥, c√†rrega o execuci√≥**.

- Reubicaci√≥ **est√†tica** en temps de compilaci√≥. Les *adreces f√≠siques* es generen en temps de compilaci√≥. El lloc de la Mem√≤ria on es carregar√† el proc√©s es conegut. Les *adre√ßes que genera el processador (execuci√≥)* **coincideixen** amb les *\@ f√≠siques*.
- Reubicaci√≥ **est√†tica** en temps de c√†rrega. En carregar un proc√©s en mem√≤ria es realitza la *traducci√≥ d'adreces l√≤giques a f√≠siques.* Si no podem saber on es carregar√† el proc√©s, el codi generat pel compilador √∫nicament pot contenir *\@ l√≤giques*.  El **carregador** far√† la traducci√≥ *\@ l√≤giques a f√≠siques*.
- Reubicaci√≥ **din√†mica** en temps d'execuci√≥. La *traducci√≥ d'adreces l√≤giques a f√≠siques* es realitza en temps d'execuci√≥. Permet que els processos es puguin moure d'un lloc de Mem√≤ria a un altre. Facilita el *swapping* i la compactaci√≥. Alenteix la execuci√≥ i complica el m√†quinari.

## Reubicaci√≥ est√†tica en temps de compilaci√≥ {.smaller}

Les adreces f√≠siques del programa es generen durant la compilaci√≥. El lloc on el proc√©s s‚Äôexecutar√† √©s conegut i fix.

- El codi cont√© adreces f√≠siques directes.
- Les adreces que genera la CPU durant l‚Äôexecuci√≥ coincideixen amb les adreces f√≠siques.
- No permet moure el proc√©s ni protegir-lo.
- Avui dia pr√†cticament no s‚Äôutilitza.

## Reubicaci√≥ est√†tica en temps de c√†rrega {.smaller}

El programa cont√© adreces l√≤giques.

- Quan el SO carrega el proc√©s en mem√≤ria:
  - El loader substitueix les adreces l√≤giques per adreces f√≠siques, segons on decideixi ubicar el proc√©s.
  - La traducci√≥ es fa una sola vegada en carregar el programa.
  - Durant l‚Äôexecuci√≥, la CPU utilitza adreces ja reubicades.
  - El proc√©s no pot canviar de posici√≥ un cop carregat.

## Reubicaci√≥ din√†mica temps execuci√≥ {.smaller}

La CPU genera sempre adreces virtuals. La traducci√≥ a adreces f√≠siques es fa cada vegada que hi ha un acc√©s a mem√≤ria, per hardware:

- Amb un r√®gim simple: registre base + registre l√≠mit.
- O amb una MMU: paginaci√≥, segmentaci√≥, TLB, proteccions.

### Avantatges {.fragment}

- Els processos es poden moure a mem√≤ria (compactaci√≥, swapping).
- Permet implementar mem√≤ria virtual, protecci√≥, COW, mapatge de fitxers, etc.

### Inconvenients {.fragment}

- Necessita suport hardware (MMU).
- Hi ha un cost per acc√©s (mitigat pel TLB).

## Exemple de reubicaci√≥ de la Mem√≤ria {.smaller}

::: {.center-container}
![](../figures/slides/06-mem/rel.png)
:::



::: notes
1. Compilaci√≥: Traducci√≥ de l√≤giques a f√≠siques (Reubicaci√≥ est√†tica - Compilaci√≥)
Quan el programa es compila, el compilador converteix les adreces simb√≤liques (com x i la crida a la funci√≥) en adreces l√≤giques. Aquestes adreces l√≤giques no corresponen directament a la mem√≤ria f√≠sica de l'ordinador; s√≥n llocs gen√®rics on el codi fa refer√®ncia a variables i funcions.

1. Enlla√ß i c√†rrega: Traducci√≥ de l√≤giques a f√≠siques (Reubicaci√≥ est√†tica - C√†rrega)
Durant la fase d'enlla√ß (linking), els enlla√ßadors assignen les adreces f√≠siques concretes al programa objecte generat pel compilador. Aquestes adreces f√≠siques (com 5010 i 5200) es corresponen amb ubicacions f√≠siques dins de la mem√≤ria de l'ordinador, per√≤ encara no s√≥n les que es fan servir directament en l'execuci√≥ del programa.
Despr√©s, el carregador carrega el programa a la mem√≤ria, assignant les adreces f√≠siques a ubicacions espec√≠fiques (per exemple, 100 i 362).

1. Execuci√≥: Traducci√≥ de l√≤giques a f√≠siques durant l'execuci√≥ (Reubicaci√≥ din√†mica)
Quan el programa s'executa, utilitza adreces l√≤giques per referir-se a la mem√≤ria. Aquestes adreces l√≤giques (com 34 i 526) es tradueixen en adreces f√≠siques per accedir a la mem√≤ria real. Aquesta traducci√≥ la fa el sistema operatiu mitjan√ßant t√®cniques de reubicaci√≥ din√†mica o gesti√≥ de mem√≤ria (com paginaci√≥ o segmentaci√≥).
Aix√≠, les adreces l√≤giques que utilitza el programa durant l'execuci√≥ (com 34 i 526) no corresponen directament a les adreces f√≠siques que es van assignar en el moment de la c√†rrega (100 i 362), sin√≥ que el sistema les tradueix a mesura que el programa es va executant.
:::

## Mecanismes de protecci√≥ {.smaller}

- El sistema de gesti√≥ de mem√≤ria ha de garantir la protecci√≥ del codi i les dades dels processos contra accessos accidentals o malintencionats d'altres processos.
- Es requereix la verificaci√≥ en temps d'execuci√≥ de totes les refer√®ncies a la mem√≤ria generades per un proc√©s.

:::{.fragment .center-container}
![](../figures/slides/06-mem/proteccio.png){width="80%"}
:::

## Protecci√≥ a nivell de p√†gina {.smaller}

Cada p√†gina del proc√©s t√© associats diversos bits de protecci√≥ dins la seva Page Table Entry (PTE):

- R (Read) ‚Äî permet lectura
- W (Write) ‚Äî permet escriptura
- X (Execute) ‚Äî permet execuci√≥ de codi
- U/S (User/Supervisor) ‚Äî indica si la p√†gina √©s accessible des de mode usuari
- A (Accessed) ‚Äî marcat quan s‚Äôha accedit
- D (Dirty) ‚Äî marcat quan s‚Äôha modificat

## Exceptions per page fault {.smaller}

Quan la CPU accedeix a una adre√ßa virtual:

- La MMU busca la PTE corresponent.
- Si l‚Äôacc√©s no compleix els permisos (p. ex. escriure en una p√†gina R/X), o la p√†gina no est√† present, la MMU genera una page fault exception.
- El control passa al sistema operatiu:
    - Si √©s un page-in (p√†gina no present), el SO la carrega de disc i actualitza la PTE.
    - Si √©s un acc√©s il¬∑legal (violaci√≥ W, X, U/S‚Ä¶), el SO termina el proc√©s (segmentation fault).

:::{.fragment .center-container}
Aquest procediment el veurem en detall quan parlem de mem√≤ria virtual.
:::

## Privilegi de nucli vs. usuari {.smaller}

La CPU funciona en  dos modes:

- **Mode usuari (ring 3)**:
  - Nom√©s pot accedir a p√†gines marcades com User (U).
  - No pot accedir a mem√≤ria del kernel ni modificar taules de p√†gines.

- **Mode nucli (ring 0)**:
  - Pot accedir a qualsevol p√†gina etiquetada com Supervisor (S).
  - Gestiona PTEs, TLB flush, interrupcions, drivers‚Ä¶
  
:::{.fragment .center-container}
La protecci√≥ per p√†gines garanteix que un proc√©s d‚Äôusuari no pugui llegir ni modificar mem√≤ria del SO.
:::

## Mecanismes de compartici√≥ {.smaller}

- Hi ha blocs de programes (ja sigui codi o dades) que poden ser compartits entre processos per reduir els requisits de mem√≤ria.
- Per permetre la compartici√≥ d'un bloc de mem√≤ria entre processos, √©s necessari establir mecanismes de comunicaci√≥ i sincronitzaci√≥, garantint que diversos processos puguin accedir-hi de manera segura i coherent.

:::{.fragment .center-container}
![](../figures/slides/06-mem/comparticio.png){width="80%"}
:::

## SuperMario Land 2: Glitch {.smaller}

::: center
[Super Mario Land 2 - Memory Exploration](https://www.youtube.com/watch?v=FPzuYWbnln4)
:::

- Quan Mario surt dels l√≠mits del nivell en una √†rea que aparentment hauria d‚Äôestar buida, aquesta zona no est√† realment desocupada. En realitat, cont√© dades assignades a altres recursos.
- Manca de mecanismes de protecci√≥ de mem√≤ria durant l‚Äôexecuci√≥.
- Permet acc√©s il¬∑legal a zones no destinades a ser visibles o utilitzables.

::: {.fragment .center-container}
El glitch es produeix perqu√® l‚Äôadre√ßament directe a la mem√≤ria no est√† subjecte a cap traducci√≥ o verificaci√≥ en temps d‚Äôexecuci√≥, i el motor del joc tracta adreces fora del rang del nivell com a accessibles, interpretant-les err√≤niament com a dades v√†lides.
:::

::: notes
Imagineu que el joc √©s com un full quadriculat on els desenvolupadors han dibuixat el nivell.

Quan el Mario surt dels l√≠mits del dibuix, el joc no t√© cap mecanisme per dir:
Ei! Aqu√≠ no hi ha res, no pots passar.

En comptes d‚Äôaix√≤, el joc comen√ßa a llegir mem√≤ria que cont√© altres coses, com dades d‚Äôenemics, de gr√†fics o variables internes.

El motor del joc interpreta aquestes dades com si fossin blocs, parets o plataformes, i per aix√≤ apareixen formes rares i comportaments estranys.

√âs com si entr√©ssiu en una habitaci√≥ on no hi hauria d‚Äôhaver res‚Ä¶ per√≤ el joc interpreta escombraries com a mobiliari.‚Äù
:::


# Sistemes de gesti√≥ de la Mem√≤ria

## Models d'organitzaci√≥ de la Mem√≤ria f√≠sica {.smaller}

![](../figures/slides/06-mem/no-mem-abstraction.jpg)

- (a) El SO es pot ubicar a la part baixa de la mem√≤ria en forma de RAM (Random Access Memory).
- (b) El SO es pot ubicar a la part alta de la mem√≤ria en forma de ROM (Read Only Memory).
- (c) El SO es pot ubicar a la part baixa en forma de RAM i els drivers a la part alta en forma de ROM.


## Assignaci√≥ contigua: *M√†quina nua* {.smaller}

* No existeix un sistema de gesti√≥ de la Mem√≤ria definit.
* L'usuari t√© control complet de tot l'espai de Mem√≤ria.
* L'espai d'adreces l√≤giques √©s identic al espai d'adre√ßament f√≠sic.

::: columns
::: {.column width="45%" .fragment}

### Avantatges

* Flexible
* Simple
* NO necessita hardware/software espec√≠fic.

:::
::: {.column width="45%" .fragment}

### Desavantatges

* Els processos i el kernel del SO comparteixen el mateix espai d'adre√ßament.
* No existeix protecci√≥.
* Poca efici√®ncia.

:::
:::

## Assignaci√≥ contigua: *Monitor resident* {.smaller}

::: columns
::: {.column width="45%"}

* Divideix la Mem√≤ria en dues seccions diferents.
* Una √†rea de mem√≤ria espec√≠fica pel monitor resident (nucli del SO).
* Es pot situar a la part alta o baixa de la Mem√≤ria.
* Una zona per l'usuari, on √∫nicament es pot ubicar un proc√©s.
* El proc√©s d'usuari √∫nicament pot utilitzar adreces de Mem√≤ria que no sigui del Monitor.

:::
::: {.column width="45%"}

::: center
![](../figures/slides/06-mem/maquina-resident-proteccio.png)
:::

:::
:::

## Assignaci√≥ contigua: *Particions m√∫ltiples* {.smaller}

::: columns
::: {.column width="45%"}

* La mem√≤ria es troba dividida en regions. 
* Cada partici√≥ pot contenir un proc√©s en execuci√≥.
* Quan un proc√©s acaba la seva execuci√≥ allibera la partici√≥, que pot ser utilitzada per un altre proc√©s de la cua de treballs.

::: 
::: {.column width="45%"}

::: center
![](../figures/slides/06-mem/part-mida-fixa.png)
:::

:::
:::

## Hardware de protecci√≥ de particions m√∫ltiples


![](../figures/slides/06-mem/hard-part-multiples.png)

## Pol√≠tiques de selecci√≥ de partici√≥ {.smaller}


* **First-Fit**. Seleccionem la primera partici√≥ disponible amb espai suficient pel proc√©s.
* **Best-fit-only**. Seleccionem la partici√≥ que millor s'ajusta a la mida del proc√©s. Si esta ocupada, esperem.
* **Best-available-fit**. Seleccionem la partici√≥ que desaprofita menys espai de Mem√≤ria.

::: columns
::: {.column width="45%" .fragment}

### Una cua

![](../figures/slides/06-mem/cua.png)

:::
::: {.column width="45%" .fragment}

### M√∫ltiples cues

![](../figures/slides/06-mem/cues.png)

:::
:::


## Fragmentaci√≥ de Mem√≤ria {.smaller}

La **fragmentaci√≥** es refereix a les √†rees de mem√≤ria no utilitzades, i pot ser causada pel tipus de mecanisme de gesti√≥ de la mem√≤ria.

- **Interna**. Porci√≥ de Mem√≤ria d'una partici√≥ que no utilitza \blueArrow el proc√©s t√© menys requeriments. *Suposem que assignem una partici√≥ de mem√≤ria de 1000 bytes a un proc√©s, per√≤ el proc√©s nom√©s necessita 800 bytes. Els 200 bytes restants es considerarien fragmentaci√≥ interna*.

- **Externa**. Es produeix quan existeix espai de Mem√≤ria lliure per satisfer els requeriments, per√≤ no √©s contigua i per tant no el podem utilitzar. *Imagineu que tenim dues √†rees de mem√≤ria lliure de 300 bytes cada una, per√≤ estan separades per una √†rea ocupada de 200 bytes, no podem satisfer una sol¬∑licitud de 500 bytes, tot i que hi ha prou mem√≤ria lliure en total*.

:::{.fragment .center-container}
**La fragmentaci√≥  √©s un problema que afecta l'efici√®ncia de l'√∫s de la mem√≤ria en els sistemes inform√†tics.**
:::

## Exemple: Fragmentaci√≥ {.smaller}

:::{.center-container}
![](../figures/slides/06-mem/exemple_fragmentacio.png)
:::

::: notes
En aquest exemple el primer proc√©s a planificar ocupa 98K per tant la Regi√≥ 1 (64K) no ens serveix, per√≤ si la regi√≥ 2 (128K). En aquesta regi√≥ es desaprofiten 30K. El segon proc√©s (264k) no pot anar a la 3er (256K) per√≤ si a la 4rt (512K). En aquesta regi√≥ es desaprofiten 248K. En total tenim 278K de fragmentaci√≥ externa.
:::

## Particions de mida variable {.smaller}

A difer√®ncia de les particions de mida fixa, les particions de mida variable permeten que la mida de la partici√≥ s'adapti a les necessitats del proc√©s.

### Avantatges {.fragment}

- No hi ha fragmentaci√≥ interna.
- Millor aprofitament de la Mem√≤ria.
- Incrementa el nombre de processos que poden estar en Mem√≤ria.

:::{.callout-note title="Observaci√≥" .fragment}
 El nombre de processos pot augmentar si es fa compactaci√≥ peri√≤dica per reduir la fragmentaci√≥ externa.
:::

:::{.fragment}
Per exemple, si tenim una partici√≥ de 100KB i un proc√©s de 50KB, la partici√≥ de mida fixa tindr√† 50KB de fragmentaci√≥ interna, mentre que la partici√≥ de mida variable tindr√† 0KB de fragmentaci√≥ interna.
:::

## Planificaci√≥ de particions de mida variable {.smaller}

:::{.center-container}

![](../figures/slides/06-mem/particions_variables.png){width="80%"}

:::

## Fragmentaci√≥ externa en particions de mida variable {.smaller}

:::{.center-container}

![](../figures/slides/06-mem/fragmetacio_externa.png)

:::

## Assignaci√≥ no contigua: *Paginaci√≥* {.smaller}

La **paginaci√≥** implica que el *mapa de Mem√≤ria es divideix en p√†gines* i la *Mem√≤ria principal es divideix en un marc de p√†gines*. Un **marc** de p√†gina cont√© en un moment determinat una *p√†gina en mem√≤ria d'un proc√©s*. Aquesta estructura de dades que **relaciona** **p√†gines** amb *marcs* es coneix com a **taula de p√†gines** i s'utilitza en la **traducci√≥**.

### Traducci√≥ {.fragment}

1. L'adre√ßa l√≤gica es descompon en n√∫mero de p√†gina (p) i despla√ßament (d) dins de la p√†gina.
2. Amb el n√∫mero de p√†gina s'indexa en la taula de la p√†gina del proc√©s.
3. Aquest est√† ubicat a partir de l'adre√ßa guardada al registre base de taula de p√†gines (RBTP).
4. Es realitzen els controls d'accessos a la p√†gina.
5. Es calculen les adreces f√≠siques (a partir de l'√≠ndex de la cel¬∑la f√≠sica multiplica per la mida de p√†gina m√©s el despla√ßament).

## Esquema i Maquinari: paginaci√≥ {.smaller}

::: {.center-container}
![](../figures/slides/06-mem/paginacio.png)
:::

:::{.callout-note title="Qu√® representa √ón en aquests diagrames?"}

El s√≠mbol **√ón** indica que cada entrada d‚Äôuna taula (segmentaci√≥, paginaci√≥ o similar)  ocupa **n bytes**. Per accedir a una entrada concreta, cal calcular la seva adre√ßa amb: $\text{adre√ßa_f√≠sica} = \text{base_taula} + (\text{√≠ndex} \times n)$

:::

## Format Taula de p√†gines {.smaller}

|cel¬∑la p√†gina f√≠sica | V | R | W | X | M| Ref |
|---|---|---|---|---|---|---|

* V: Entrada v√†lida.
* R: Permisos de lectura.
* W: Permisos d'escriptura.
* X: Permisos d'execuci√≥.
* M: P√†gina en Mem√≤ria Principal.
* Ref: P√†gina referenciada.


## Problema 1: Paginaci√≥ {.smaller}

### Enunciat

Disposem d'un sistema de gesti√≥ de Mem√≤ria paginat amb els par√†metres seg√ºents:

* Espai d'adre√ßament l√≤gic de processos: *2MB*.
* Mida Mem√≤ria Principal: *128KB*.
* Mida p√†gina: *4KB*.

:::{.fragment}
Calcular:

* Adre√ßa i longitud
* Mida de la taula de p√†gines
* N√∫mero de cel¬∑les.
:::

## Problema 1: Paginaci√≥ (Soluci√≥) {.smaller}

L'adre√ßa l√≤gica √©s dividida en dues parts: el despla√ßament i el n√∫mero de p√†gina.

- **Despla√ßament**: La mida de la p√†gina √©s de 4 KB ($2^{12}$ bytes), i per representar qualsevol despla√ßament a l'interior d'una p√†gina, necessitem 12 bits.
- **N√∫mero de P√†gina**: Per a una adre√ßa l√≤gica total de 2 MB ($2^{21}$ bytes), el n√∫mero m√†xim de p√†gines √©s la ra√≥ entre l'espai d'adre√ßament l√≤gic total i el despla√ßament ($\dfrac{2^{21}}{2^{12}}=2^9$), per tant, requerim 9 bits per representar el n√∫mero de p√†gina.

## Problema 1: Paginaci√≥ (Soluci√≥) {.smaller}

L'adre√ßa l√≤gica √©s dividida en dues parts: el despla√ßament i el n√∫mero de p√†gina.

- **Mida de la Taula de P√†gines**: La mida de la taula de p√†gines es determina pel nombre m√†xim de p√†gines que pot tenir un proc√©s. Si l'espai d'adre√ßament l√≤gic total √©s de 2 MB, i la mida de la p√†gina √©s de 4 KB, el nombre m√†xim de p√†gines √©s de 512 ($\dfrac{2^{21}}{2^{12}}=2^9$). Per tant, la taula de p√†gines tindr√† 512 entrades.
- **N√∫mero de Cel¬∑les de la Mem√≤ria**: El nombre de cel¬∑les a la mem√≤ria es calcula igualment, considerant la mida de la p√†gina. Si la mida de la Mem√≤ria Principal √©s de 128 KB, i la mida de la p√†gina √©s de 4 KB, el nombre de cel¬∑les √©s de 32 ($\dfrac{2^{17}}{2^{12}}=2^5$).

## Problema 1: Paginaci√≥ (II) {.smaller}

Quina √©s l'adre√ßa f√≠sica de les adre√ßes l√≤giques: 015253H, 003204H, 0H, 017253H, 005100H. Quines s√≥n v√†lides? Assumeix la seg√ºent taula de p√†gines:

::: columns
::: {.column width="50% .smaller"}

:::{.callout-note title="Taula de p√†gines"}
|Index|Cel¬∑la| V |
|---|---|---|
| 0 |09H| 1 |
| 1 |01H| 1 |
| 2 |03H| 0 |
| 3 |0FH| 1 |
| 4 |02H| 1 |
| 5 |0CH| 0 |
| 21 |0AH| 1 |
| 22 |05H| 1 |
| 23 |0DH| 1 |
| 24 |04H| 0 |
| 25 |00H| 0 |
:::

::: 
::: {.column width="50%"}


:::{.callout-warning title="Soluci√≥"}
| Adre√ßa l√≤gica | Cel¬∑la | Despla√ßament | Adre√ßa f√≠sica | V√†lida |
|---|---|---|---|---|
|015253H|???|???|???|???|
|003204H|???|???|???|???|
|0H|???|???|???|???|
|017253H|???|???|???|???|
|005100H|???|???|???|???|
:::

:::
:::

## Problema 1: Paginaci√≥ (III) {.smaller}

Donada una adre√ßa l√≤gica amb 9 bits per al n√∫mero de p√†gina i 12 bits per al despla√ßament, com ara l'adre√ßa `015253H`, podem descomposar-la de la seg√ºent manera:

1. **N√∫mero de P√†gina (9 bits):**
   - `015253H` en binari: `0 0001 0101 0010 0101 0011`
   - El primer 9 bits formen el n√∫mero de p√†gina: `0 0001 0101` que en decimal √©s el 21 ($2^0+2^2+2^4$).

2. **Despla√ßament (12 bits):**
   - `015253H` en binari: `0 0001 0101 0010 0101 0011`
   - Bits del 10 al 21 (de dreta a esquerra): `0010 0101 0011` (253H).

:::{.fragment .center-container}
Per tant, cercarem la p√†gina n¬∫ 21 a la taula de p√†gines, aquesta entrada cont√© el n√∫mero de cel¬∑la 0AH. Per tant, l'adre√ßa f√≠sica √©s `0A253H` i √©s v√†lida.
:::

## Problema 1: Paginaci√≥ (IV) {.smaller}

Quina √©s l'adre√ßa f√≠sica de les adre√ßes l√≤giques: 015253H, 003204H, 0H, 017253H, 005100H. Quines s√≥n v√†lides? Assumeix la seg√ºent taula de p√†gines:

::: columns
::: {.column width="50%"}

:::{.callout-note title="Taula de p√†gines"}
Index|Cel¬∑la | V |
|---|---|---|
| 0 |09H| 1 |
| 1 |01H| 1 |
| 2 |03H| 0 |
| 3 |0FH| 1 |
| 4 |02H| 1 |
| 5 |0CH| 0 |
| 21 |0AH| 1 |
| 22 |05H| 1 |
| 23 |0DH| 1 |
| 24 |04H| 0 |
| 25 |00H| 0 |
:::

::: 
::: {.column width="50%"}

:::{.callout-warning title="Soluci√≥"}

| Adre√ßa l√≤gica | Cel¬∑la | Despla√ßament | Adre√ßa f√≠sica | V√†lida |
|---------------|--------|--------------|---------------|--------|
| 015253H       | 0AH    | 253H         | 0A253H        | S√≠     |
| 003204H       | 0FH    | 204H         | 0F204H        | S√≠     |
| 0H            | 09H    | 0H           | 09000H        | S√≠     |
| 017253H       | 0DH    | 253H         | 0D253H        | S√≠     |
| 005100H       | 0CH    | 100H         | 0CH10H        | No     |

:::

:::
:::

## An√†lisi de la paginaci√≥ {.smaller}

Assumeix que tenim un sistema  on la mida de la p√†gina √©s de 4 KB. Si un proc√©s ocupa 10 KB de mem√≤ria, aquest s'allotjar√† en tres p√†gines (4 KB + 4 KB + 2 KB). Aix√≤ implica que el proc√©s ocupar√† 3 cel¬∑les de la Mem√≤ria Principal. Si el proc√©s necessita 10 KB de mem√≤ria, per√≤ la mida de la p√†gina √©s de 8 KB, el proc√©s s'allotjar√† en dues p√†gines (8 KB + 2 KB). Aix√≤ implica que el proc√©s ocupar√† 2 cel¬∑les de la Mem√≤ria Principal. Per tant:

::: {.fragment .center-container}
**La paginaci√≥ no evita la fragmentaci√≥ interna, per√≤ la redueix.**
:::

## Caracter√≠stiques de la paginaci√≥ {.smaller}


La paginaci√≥ √©s una t√®cnica de gesti√≥ de mem√≤ria que presenta certes caracter√≠stiques:

1. **Eliminaci√≥ de la Fragmentaci√≥ Externa:** Cada p√†gina pot ser assignada independentment, permetent a les p√†gines ser ubicades en qualsevol ordre a la mem√≤ria f√≠sica. Aix√≤ elimina la depend√®ncia de tenir √†rees contig√ºes per allotjar processos.

2. **Fragmentaci√≥ Interna:** Tot i que elimina la fragmentaci√≥ externa, la paginaci√≥ pot introduir fragmentaci√≥ interna, ja que l'√∫ltima p√†gina pot no estar plena. Aquest espai no utilitzat dins de l'√∫ltima p√†gina indueix a fragmentaci√≥ interna.

3. **Transpar√®ncia a l'Usuari:** Aquest esquema de gesti√≥ de mem√≤ria √©s totalment transparent a l'usuari. L'usuari no necessita saber res sobre la paginaci√≥.

4. **Taula de P√†gines per Proc√©s:** Es necessita mantenir una taula de p√†gines per a cada proc√©s per gestionar la traducci√≥ d'adreces l√≤giques a adreces f√≠siques.

## Observacions sobre la paginaci√≥ {.smaller}

La paginaci√≥ elimina la fragmentaci√≥ externa des del punt de vista del proc√©s. Tanmateix, en implementacions modernes pot apar√®ixer una certa fragmentaci√≥ al gestor de frames (*buddy allocator*), tot i que molt menor que en particions variables.
  
## Segmentaci√≥ {.smaller}

La **segmentaci√≥** √©s un m√®tode de maquinari que intenta donar suport a les regions. Considera el *mapa de mem√≤ria d'un proc√©s* com un *conjunt de segments*. [Cada regi√≥ es guarda en un segment diferent]{.alert}. El **maquinari** del gestor necessita una **taula de segments**. *Una direcci√≥ l√≤gica* es forma per un *n√∫mero de segment* i una *direcci√≥ dins del segment*. La **traducci√≥** consisteix a accedir al n√∫mero de segment i utilitzar els *registre base i l√≠mit per comprovar que l'entrada √©s correcta*.

### Observacions {.fragment}

* **Obs1.** La segmentaci√≥ divideix l'espai l√≤gic del proc√©s en unitats l√≤giques (segments) de mides diferents.
* **Obs2.** Aquest esquema de gesti√≥ coincideix amb la visi√≥ que l'usuari t√© de la Mem√≤ria. (Dades, Pila, Codi, Llibreries).


## Esquema i Hardware: Segmentaci√≥ {.smaller}

::: {.center-container}
![](../figures/slides/06-mem/segmentacio2.png)
:::



## Problemes de la segmentaci√≥ {.smaller}

La segmentaci√≥ √©s molt semblant amb l'esquema de gesti√≥ de Mem√≤ria per particions m√∫ltiples de mida variable. \blueArrow T√© els mateixos problemes que aquest esquema.

- **Fragmentaci√≥ Externa**. L'espai de mem√≤ria f√≠sica d'un segment ha de ser contigu en mem√≤ria i pot provocar fragmentaci√≥ externa. *Imaginem que tenim 3 segments de 1KB, 2KB i 2KB. La nostra taula de segments ens portar√† a 3 zones de mem√≤ria f√≠sica de 1KB, 2KB i 2KB. Assumirem que ambdos segments de 2KB no estan utilitzats, per tant, tenim 4KB de mem√≤ria lliure. No obstant aix√≤, no podem allotjar un segment de 3KB, ja que no hi ha cap regi√≥ contigua de 3KB*.

- Requereix m√®todes de compactaci√≥ de la Mem√≤ria. Per gestionar la fragmentaci√≥, es poden utilitzar m√®todes de compactaci√≥ que moguin els segments i redueixin la fragmentaci√≥. Es poden moure segments despr√©s d'un √∫s continuat o quan es detecta que hi ha fragmentaci√≥.
  
- Pol√≠tiques de selecci√≥ per ubicar els segments en Mem√≤ria f√≠sica:  S'han d'escollir algoritmes eficients per ubicar els segments a la mem√≤ria f√≠sica, com ara First-Fit o Best-Fit.

## Avantatges de la segmentaci√≥ {.smaller}

- **Abs√®ncia de Fragmentaci√≥ Interna**: Cada segment pot tenir la seva pr√≤pia mida, i aix√≤ significa que no hi ha fragmentaci√≥ interna dins dels segments mateixos. Cada segment utilitza exactament l'espai que necessita sense desperdiciar mem√≤ria.
  
- **Flexibilitat per compartir i protegir segments**:  Cada segment pot ser protegit individualment i compartir-se amb altres processos si √©s necessari. Aquesta capacitat de gestionar diferents parts de la mem√≤ria amb pol√≠tiques espec√≠fiques proporciona un alt grau de control i efic√†cia en la gesti√≥ del sistema.

:::{.fragment .center-container}
Per exemple, un segment de codi pot ser compartit per diferents processos, mentre que un segment de dades pot ser protegit per un proc√©s espec√≠fic.
:::

## Segmentaci√≥ Paginada {.smaller}

La segmentaci√≥ paginada proporciona suport directe a les regions d'un proc√©s i la paginaci√≥ permet un millor aprofitament de la Mem√≤ria i una base per construir un esquema de Mem√≤ria virtual.

### Observacions {.fragment}

- La segmentaci√≥ paginada intenta reduir la fragmentaci√≥ externa associada als segments i millorar l'efici√®ncia de la Mem√≤ria.
- Cada segment est√† paginat, de manera que la Mem√≤ria f√≠sica associada amb un segment no ha d'estar contigua a la Mem√≤ria.
- Descomposici√≥ adre√ßa l√≤gica:
  - **Segment** + **Despla√ßament 1** (**P√†gina** + **Despla√ßament 2**)
    - **P√†gina**: Entrada a la taula de p√†gines del segment.
    - **Despla√ßament 2**: Despla√ßament de la cel¬∑la a la Mem√≤ria f√≠sica.

## Hardware segmentaci√≥-paginada

::: {.center-container}
![](../figures/slides/06-mem/seg-paginada1.png)
:::

:::{.callout-note title="Observaci√≥"}
Aquest model √©s molt √∫til per entendre conceptes, per√≤ no √©s el que implementen els sistemes operatius moderns com Linux o Windows.
:::

## Problema 2: Segmentaci√≥ paginada {.smaller}

Dissenyar un sistema de segmentaci√≥ paginada amb les caracter√≠stiques seg√ºents:

- Mem√≤ria f√≠sica: 8MB.
- N√∫mero m√†xim de segments per proc√©s: 16.
- Mida m√†xima segment: 1MB.
- Mida pagina: 4KB.

:::{.fragment}
Calcular: 

1. Esquema de traducci√≥.
2. Taula de segments per un proc√©s amb:
   - Codi: 128KB, Dades: 4KB, Dades: 256B, Pila 16KB
3. Calcular l'adre√ßa f√≠sica per 1:01100h si les entrades a la taula de segments del proc√©s anterior s√≥n: 0h, 1000h, 2000h i 1500h.
:::


## Problema 2: C√†lculs {.smaller}

- **N¬∫ de segments**: 16 segments per proc√©s. Per tant, necessitem 4 bits per representar el n√∫mero de segment ($2^4$).

- **Mida m√†xima segment**: 1MB. Per tant, necessitem 20 bits per representar el despla√ßament dins del segment ($2^{20}$).

- **Mida de la p√†gina**: 4KB. Per tant, necessitem 12 bits per representar el despla√ßament dins de la p√†gina ($2^{12}$).

- **Adre√ßa l√≤gica**: Segment (4 bits) + Despla√ßament 1 (20 bits).

- **Adre√ßa l√≤gica**: Segment (4 bits) + P√†gina (8 bits) + Despla√ßament 2 (12 bits).

- **Adre√ßa f√≠sica**: Cel¬∑la (11 bits) + Despla√ßament 2 (12 bits). La mida de la Mem√≤ria Principal √©s de 8MB, per tant, necessitem 23 bits per representar el n√∫mero de cel¬∑la ($2^{23}$). La ra√≥ entre la mida de la Mem√≤ria Principal i la mida de la p√†gina √©s: ($\dfrac{2^{23}}{2^{12}}=2^{11}$).

## Problema 2: Esquema de Traducci√≥

::: {.center-container}
![](../figures/slides/06-mem/ex2-seg-pag.png)
:::

## Paginaci√≥ segmentada {.smaller}

La paginaci√≥ segmentada primer divideix en taula de p√†gines i despr√©s cada p√†gina es divideix en segments.

![](../figures/slides/06-mem/paginacio-segmentada.png)

:::{.center-container .fragment}
En l'√∫nic cas que pot ser eficient es quan tenim processos molt grans
:::

# Exercicis


## Enuciat (I) {.smaller}


Disposem d‚Äôun sistema de gesti√≥ de mem√≤ria on la mida de la p√†gina √©s de 512 bytes, la de Mem√≤ria √©s de 2 MB, i la d‚Äôuna paraula 1 byte. Un proc√©s consta de com a molt 4 segments. La mida m√†xima d‚Äôun segment √©s 4K. Totes les taules s‚Äôimplementen en mem√≤ria principal. Donats els dos processos seguÃàents:

||P1|P2|
|------------------------------|---------------|-------------|
|$P_{A}$ (512 bytes)             |X|X| 
|$P_{B}$ (2560 bytes)            |X||
|$Dades_{L}$ (1024 bytes)        |X|X|

Les X‚Äôs en la taula indiquen quins procediments i dades estan assignats a cada proc√©s. Una fila amb dos o m√©s X‚Äôs indica que el procediment o dades estan compartits. A m√©s, cada proc√©s est√† format per un *segment d‚Äôstack de 1 KB*. Les primeres 50 primeres cel¬∑les estan ocupades, i de les restants, les parells tamb√© ho estan.

## Enuciat (II) {.smaller}


Doneu un exemple, sempre que sigui possible, que mostri quina √©s la informaci√≥ i la seva mida (en bytes), que ha de guardar el s.o. per tal de poder fer la traducci√≥ d‚Äôadreces dels dos processos quan aquests executen dins de la CPU pels sistemes de gesti√≥ de mem√≤ria seg√ºents:

- Paginaci√≥ (**3 punts**)
- Segmentaci√≥. (**3 punts**)
- Segmentaci√≥ Paginada (**4 punts**)

## Paginaci√≥ (I)

::: {.center-container}
![](../figures/slides/06-mem/problema/2.png){width="70%"}
:::

## Paginaci√≥ (II) {.smaller}

P√†gines per proc√©s:

||P1|P2|
|------------------------------|---------------|-------------|
|$P_{A}$ (512 bytes)            | ?|?| 
|$P_{B}$ (2560 bytes)          | ?|?| |
|$Dades_{L}$ (1024 bytes)  | ?|?| 
|Stack  (1024 bytes)             | ?|?| 
|**TOTAL**                           | ?|?| 

## Paginaci√≥ (III) {.smaller}

P√†gines per pro√©s:

||P1|P2|
|------------------------------|---------------|-------------|
|$P_{A}$ (512 bytes)            | 1|1| 
|$P_{B}$ (2560 bytes)          | 5|-| |
|$Dades_{L}$ (1024 bytes)  | 2|2| 
|Stack  (1024 bytes)             | 2|2| 
|**TOTAL**                           | 10|5| 


## Esquema de traducci√≥ (Paginaci√≥)

::: {.center-container}
![](../figures/slides/06-mem/problema/1.png){width="70%"}
:::

## Taules de p√†gines (Paginaci√≥)

::: {.center-container}
![](../figures/slides/06-mem/problema/3.png){width="85%"}
:::

## Segmentaci√≥ (I)

::: {.center-container .fragment}
**[No es pot aplicar la segmentaci√≥]{.alert}**
:::

- La segmentaci√≥ requereix totes les p√†gines d'un segment en una regi√≥ contigua de Mem√≤ria.
- El procediment B, les dades i la pila ocupen m√©s d'una p√†gina (5,2 i 2 respectivament).
- No hi ha m√©s d'una cel¬∑la contigua lliure; ja que les cel¬∑les, parells estan ocupades.

## Segmentaci√≥ Paginada (Esquema) {.smaller}

::: {.center-container}
![](../figures/slides/06-mem/problema/4.png){width="50%"}
:::

## Segmentaci√≥ Paginada (p√†gines i segments) {.smaller}

::: {.center-container}
![](../figures/slides/06-mem/problema/5.png){width="85%"}
:::

## Reflexi√≥ final  (I){.smaller}

En els sistemes operatius moderns (Linux, Windows, macOS), la gesti√≥ de la mem√≤ria es basa principalment en **paginaci√≥** amb suport de la **MMU**, **TLB** i **taules de p√†gines multinivell**. Aquest √©s el mecanisme central de traducci√≥ d‚Äôadreces en arquitectures modernes com x86-64 i ARM.


La **segmentaci√≥ cl√†ssica** i la **segmentaci√≥ paginada** s√≥n models te√≤rics o hist√≤rics que permeten entendre els fonaments de la gesti√≥ de la mem√≤ria, per√≤ **ja no s‚Äôutilitzen com a mecanisme general** en arquitectures actuals.

## Reflexi√≥ final  (II){.smaller}

Tot i aix√≤, **Linux s√≠ que utilitza segmentaci√≥ en casos puntuals**, especialment:
- per accedir a informaci√≥ espec√≠fica de cada proc√©s o fil (**FS/GS base**, TLS),
- en modes de compatibilitat de 32 bits,
- i en fases inicials del proc√©s d‚Äôarrencada.


## Properes parts {.smaller}

- **Part 2 ‚Äî Sistemes moderns: el cas del Kernel de Linux**  
  Traducci√≥ d‚Äôadreces real, TLB, multilevel paging, ASLR, estructura `/proc/<pid>/maps`, ELF, `mmap()`, COW, i assignaci√≥ f√≠sica (buddy allocator).

- **Part 3 ‚Äî Mem√≤ria virtual**  
  Demand paging, page faults, swapping, working set, thrashing, pol√≠tiques de reempla√ßament i gesti√≥ din√†mica de la mem√≤ria virtual.


