---
title: "Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
subtitle: "Unitat 1 ¬∑ Sistemes Operatius (SO)"
author: "Jordi Mateo Forn√©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 1 ¬∑ Sistemes Operatius (SO) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

# Introducci√≥

## Desenvolupament en sistemes Linux/UNIX

El desenvolupament de programari de sistema el realitzarem amb els llenguatge **C** i basa en els compiladors **GNU gcc**.

``` sh
#!/bin/sh
# ./check.sh
gcc -v
if [ $? != 0 ]; then
       echo "GCC is not installed!"
fi
ld -v
if [ $? != 0 ]; then
        echo "Please install binutils!"
fi
```

::: center-container
Fitxer: [scripts/check.sh](./01-sources/scripts/check.sh)
:::

::: notes
Per poder desenvolupar en C en un sistema Linux/UNIX necessitem tenir instal¬∑lat el compilador **GCC** i les eines de **binutils**. Aquestes eines s√≥n necess√†ries per a la compilaci√≥ i enlla√ßat dels programes. Per comprovar si tenim instal¬∑lat aquestes eines podem executar el script anterior. Si no tenim instal¬∑lat aquestes eines, podem instal¬∑lar-les amb la comanda `sudo apt-get install build-essential` en sistemes basats en Debian o `sudo dnf groupinstall "Development Tools"` en sistemes basats en RedHat.
:::

## Navegant a les entranyes del compilador GCC

::::: columns
::: {.column width="60%"}
![](../figures/slides/01-c/compiler.png){width="80%"}
:::

::: {.column width="30%"}
![](../figures/slides/01-c/c-sample.png){width="90%"}
:::
:::::

::: notes
Els llenguatges de programaci√≥ compilats s√≥n aquells que es tradueixen a codi m√†quina abans de l'execuci√≥. Aquest proc√©s de traducci√≥ es realitza per un programa anomenat compilador. El compilador √©s un programa que tradueix el codi font d'un programa escrit en un llenguatge de programaci√≥ de nivell alt a codi m√†quina. En el cas de C, hi ha diferents etapes codi, ensamblador i enlla√ßador. El compilador GCC √©s un compilador de codi obert que es pot utilitzar per a la compilaci√≥ de programes en C, C++, Fortran, Ada, etc. Aquest compilador √©s molt potent i permet la compilaci√≥ de programes en diferents plataformes. A m√©s, el compilador GCC √©s molt flexible i permet la configuraci√≥ de diferents opcions de compilaci√≥.
:::

## Etapes de la compilaci√≥ i l'enlla√ß (I)

### Preprocessador

-   El preprocessador processa el codi font, buscant instruccions que comencen amb un hash (#), com **#include, #define, i #ifdef**.
-   Inclou fitxers d'encap√ßalament (**headers**) i substitueix *macros i definicions*. [Tamb√© elimina els comentaris]{.alert}.
-   Genera un fitxer de codi font amb les instruccions del preprocessador processades, preparat per a la compilaci√≥.

## Etapes de la compilaci√≥ i l'enlla√ß (II)

### Compilador

-   Tradu√Øx el codi font al assemblador equivalent. En alguns compiladors, el codi es pot convertir directament en codi m√†quina en aquesta etapa.
-   Traduir el codi de nivell alt a codi de nivell baix i optimitzar-lo per al maquinari subjacent.
-   Genera un fitxer de codi assemblador amb l'extensi√≥ **.s**. Per exemple, si el fitxer de codi font √©s *hola.c*, el fitxer generat seria *hola.s*.

## Etapes de la compilaci√≥ i l'enlla√ß (III)

### Assemblador

-   Converteix el codi assemblador en **codi objecte** o codi de m√†quina.
-   Produir codi binari que pugui ser ent√®s per la CPU.
-   Genera un fitxer de codi objecte amb l'extensi√≥ **.o**. Per exemple, el fitxer resultant seria `hola.o`.

## Etapes de la compilaci√≥ i l'enlla√ß (IV)

### Enlla√ßador (Linker)

-   Enlla√ßa el codi **objecte** amb les **biblioteques** necess√†ries per crear l'executable final.
-   Organitzar i combinar el codi objecte i les biblioteques, *resolent les refer√®ncies externes*.
-   Genera l'executable final, que √©s el fitxer que podeu executar. Per exemple, **hola**.

## Exemple: Etapes {.smaller}

:::::: columns
:::: {.column width="50%"}
``` c
#include <stdio.h>

#define x 10
#define y 5

int 
main(){
  printf("El resultat de l'opearci√≥: 
      %d + %d = %d\n", x,y,x+y);
    return 0;
}
```

::: center-container
Fitxer: [sources/ex1.c](./01-sources/sources/ex1.c)
:::
::::

::: {.column width="50%"}
-   **Executable**: `gcc -o ex1 ex1.c`
-   **Assemblador**: `gcc -S -o ex1.s ex1.c`
-   **Codi objecte**: `gcc -c -o ex1.o ex1.c`
-   **Preprocessador**: `gcc -E -o ex1.i ex1.c`
-   **Desensamblador**: `objdump -d ex1.o` o `objdump -d -M intel ex1`
:::
::::::

::: {.callout-tip title="Notes"}
-   `-M intel` indica l'√∫s de la sintaxi Intel per a una millor llegibilitat.
-   Tots aquests fitxers generats els posarem al .gitignore.
:::

## Com funciona el compilador GCC? {.smaller}

``` bash
gcc <codi> -g -c <codi> -o <executable> -I <dirIncludes> -L <dirLibs>
```

-   **-g**: Genera informaci√≥ de depuraci√≥.
-   **-c**: Enlla√ßa nom√©s el fitxer especificat.
-   **-o**: Fitxer executable de sortida (per defecte a a.out).
-   **-I**: Directoris on es cercaran els fitxers **.h**.
-   **-L**: Directoris on es cercaran les biblioteques.
-   **-l**: Biblioteques a enlla√ßar.
-   **-Wall**: Mostra tots els missatges d'advert√®ncia.
-   **-Werror**: Converteix els missatges d'advert√®ncia en errors.
-   **-Wextra**: Mostra missatges d'advert√®ncia addicionals.
-   **...**: Altres opcions.

## El nostre primer programa: Hola m√≥n

::::: columns
::: {.column width="60%"}
1.  **Preprocessador**: El fitxer *stdio* proporciona la definici√≥ de la funci√≥ **printf**.
2.  **main()**: Funci√≥ principal i obligat√≤ria. Aquesta no rep cap argument i retorna un enter.
3.  La funci√≥ **printf** rep un argument del tipus `char *`.
4.  **return 0**: Indica que tot ha anat b√© i acaba la funci√≥ *main()*.
:::

::: {.column width="40%"}
``` c
#include <stdio.h>
/* This is a comment */
int main()
{
    printf("Hola m√≥n!\n");
    return 0;
}
```

------------------------------------------------------------------------

``` sh
# Compilem hola.c
gcc -o hola hola.c 
# Executem hola
./hola 
```
:::
:::::

::: notes
La funci√≥ **printf** es troba a la biblioteca est√†ndard de C, podem consultar `man s3 printf` per obtenir m√©s informaci√≥. Aquesta funci√≥ permet mostrar text per pantalla. Els arguments que rep s√≥n una cadena de car√†cters i els valors que volem mostrar. Els valors es substitueixen a la cadena de car√†cters mitjan√ßant el format `%d` per a enters, `%f` per a nombres en punt flotant, `%c` per a car√†cters i `%s` per a cadenes de car√†cters. Els car√†cters `\n` indiquen un salt de l√≠nia.
:::

## El nostre primer programa amb llibreries externes

``` c
#include <math.h>
#include <stdio.h>
int main (void)
{
  double x = 2.0;
  double y = sqrt (x);
  printf ("La rai¬≠z cuadrada de %f es %f\n", x, y);
  return 0;
}
```

::: center-container
Fitxer: [sources/arrel.c](./01-sources/sources/arrel.c)
:::

``` bash
// Complilaci√≥ amb ruta global a la llibreria
gcc -Wall SO_usingLibraries.c /usr/lib/x86_64-linux-gnu/libm.a -o calc
// Compilaci√≥ utilitzant la forma abreujada
gcc -Wall SO_usingLibraries.c -lm -o calc
```

::: notes
Per obtenir informaci√≥ sobre la funci√≥ **sqrt** podeu consultar la p√†gina de manual amb la comanda `man -s3 sqrt`. Aquesta funci√≥ es troba a la biblioteca matem√†tica, per aix√≤ cal enlla√ßar-la amb el programa. Per aix√≤ s'utilitza l'opci√≥ **-lm**. Quan compilem un programa en C, el compilador pot incorporar certes funcions de la biblioteca est√†ndard de forma autom√†tica perqu√® s√≥n part de les especificacions del llenguatge (com printf, scanf, etc.). No obstant aix√≤, altres funcions, com les de la biblioteca matem√†tica, no es troben dins d'aquest conjunt i, per tant, cal especificar manualment que volem enlla√ßar-les amb el programa.
:::

## Activitat: Calculadora (I)

:::::: columns
::: {.column width="33%"}
``` c
// calc.h
#ifndef CALC_H
#define CALC_H

double suma(
  double a, 
  double b);

#ifndef CALC_H
```
:::

::: {.column width="33%"}
``` c
// calc.c
#include "calc.h"

double suma(
  double a, 
  double b) 
  {
    return a + b;
  }
```
:::

::: {.column width="33%"}
``` c
#include <stdio.h>
#include "calc.h"

int main() {
  double a = 2.0;
  double b = 3.0;
  suma(a, b);
  return 0;
}
```
:::
::::::

<br>

``` bash
gcc -c calc.c -o calc.o
gcc -c main.c -o main.o
gcc calc.o main.o -o calc
./calc
```

## Activitat: Calculadora (II)

:::::: columns
::: {.column width="33%"}
``` c
// calc.h
#ifndef CALC_H
#define CALC_H

double potencia(
  double a, 
  double b);

#ifndef CALC_H
```
:::

::: {.column width="33%"}
``` c
// calc.c
#include "calc.h"
#include <math.h>
double potencia(
  double a, 
  double b) 
  {
    return pow(a, b);
  }
```
:::

::: {.column width="33%"}
``` c
#include <stdio.h>
#include "calc.h"

int main() {
  double a = 2.0;
  double b = 3.0;
  potencia(a, b);
  return 0;
}
```
:::
::::::

<br>

``` bash
gcc -c calc.c -o calc.o
gcc -c main.c -o main.o
gcc calc.o main.o -o calc -lm
./calc
```

# Esquelet d'un programa en C

## Els arguments d'entrada

\onslide<1->

La funci√≥ **main()** t√© dos arguments que tradicionalment s'anomenen **argc** (Longitud del vector d'argument) i **argv** (Matriu de punters de car√†cters).

::::: columns
::: {.column width="60%"}
#### Retorna un enter

-   0: En cas d'√®xit.
-   -1 (negatiu): en cas de fallada.
:::

::: {.column width="40%"}
``` c
int 
main(int argc, 
     char *argv[]) 
{...}
```

------------------------------------------------------------------------

``` sh
./a.out -o foo -vv
argv = [ "/path/to/a.out", 
  "-o" "foo", "-vv" ];
```
:::
:::::

-   **Argv** √©s una representaci√≥ tokenitzada.
-   **Argv\[0\]** mai est√† buit i sempre cont√© la ruta completa a l'executable.

::: notes
Com ja hem vist la funci√≥ **main()** √©s la primera funci√≥ del vostre programa que s'executa quan comen√ßa a executar-se. Aquesta funci√≥ crida a \*\*\_start()\*\*, que normalment proporciona la biblioteca de temps d'execuci√≥ *C,* enlla√ßat autom√†ticament quan es compila el programa.

La funci√≥ **main()** t√© dos arguments que tradicionalment s'anomenen **argc** (Longitud del vector d'argument) i argv (Matriu de punters de car√†cters) i retorna un nombre enter amb signe. La majoria dels entorns Unix esperen que els programes tornin 0 (zero) en cas d'√®xit i -1 (negatiu) en cas de fallada.

Argv √©s una representaci√≥ tokenitzada de la l√≠nia d'ordres que va invocar el vostre programa. Argv\[0\] mai est√† buit i sempre cont√© la ruta completa a l'executable.
:::

## Exemple: `check_args.c`

::::: columns
::: {.column width="45%"}
``` c
#include <stdio.h>

int
main(int argc, char **argv) {

  int i;

  for (i=0; i<argc; i++) {
    printf("%s\n", argv[i]);
  }

  return 0;
}
```

------------------------------------------------------------------------

``` sh
gcc check_args.c -o check_args
./check_args a.out
./check_args *.c
./check_args $USER $PWD $SHELL
```
:::

::: {.column width="55%"}
-   Aquest programa ens permet observa com es capturen els arguments.
-   Ara executarem aquest programa amb els diferents tipus de shell que tenim instal¬∑lades.
-   Per modificar la shell: `chsh -s /bin/sh jordi`.
:::
:::::

::: center-container
Fitxer: [sources/check_args.c](./01-sources/sources/check_args.c)
:::

## Include

En el llenguatge de programaci√≥ C, la directiva **#include** diu al preprocessador que insereixi el contingut d'un altre fitxer al codi font en el punt on es trobi la directiva **#include**.

-   `#include <header_file>`: El preprocessador cercar√† una ruta de directori predeterminada per localitzar el fitxer de cap√ßalera. Normalment, els fitxers s√≥n: **/usr/include**.

-   `#include "header_file"`: El preprocessador buscar√† el fitxer de cap√ßalera al mateix directori que el fitxer font

## Include: Header m√©s improtants {.smaller}

| Header | Funcionalitat |
|--------------|----------------------------------------------------------|
| stdio | Subministra entrada i sortida: funcions *FILE, stdin, stdout, stderr i fprint()*. |
| stdlib | Subministra funcions d'utilitat: *malloc(), calloc() i realloc()*. |
| unistd | Subministraments *EXIT_FAILURE, EXIT_SUCCESS*. |
| errno | Defineix la variable errno externa i tots els valors que pot prendre. |
| assert | Subministra funcions de diagn√≤stic. |
| time | Subministraments Funcions de data i hora. |
| math | Proporciona funcions de suport matem√†tiques. |
| string | Proporciona funcions *memcpy(), memset() i strlen()*. |
| getopt | Proporciona *optarg, opterr i getopt()* externs. |

## Define {.smaller}

La directiva **#define** permet la definici√≥ de macros dins del codi font. Aquestes definicions de macro permeten declarar valors constants per utilitzar-los en tot el codi. Les definicions de macro no s√≥n variables i el programa no les pot canviar. Utilitzeu aquesta sintaxi quan creeu constants que representen nombres, cadenes o expressions.

::::: columns
::: {.column width="50%"}
``` c
#definir el valor CNAME
#definir CNAME (expressi√≥)
```

------------------------------------------------------------------------

``` c
#define DEFAULT_PROGNAME "myProgName"
#define BUFSIZE 4096
```
:::

::: {.column width="40%"}
-   L'expressi√≥ s'ha d'entregar entre par√®ntesis si cont√© operadors.
-   NO poseu [**;**]{.alert} al final de les sent√®ncies **#define**.
-   Quan s'anomena un **#define** per distingir-lo dels noms de variables i funcions, utilitzeu maj√∫scules.
:::
:::::

## External declarations

Una declaraci√≥ externa porta aquest nom a l'espai de noms de la unitat de compilaci√≥ actual (tamb√© conegut com *fitxer*) i permet al programa accedir a aquesta variable. La paraula clau **extern** amplia la visibilitat de la funci√≥ a tot el programa, la funci√≥ es pot utilitzar (anomenar) a qualsevol lloc de qualsevol dels fitxers de tot el programa, sempre que aquests fitxers continguin una declaraci√≥ de la funci√≥.

``` c
extern int errno;
// errno s'utilitza com a canal de comunicaci√≥ per la  biblioteca 
// C est√†ndard per comunicar el motiu de fallada d'una funci√≥ determinada.
```

## Llibreria errno

La variable global **errno** √©s defineix a la biblioteca *errno.h*.

-   Aquest valor de variable nom√©s √©s rellevant quan la trucada retorna un error (normalment el codi [-1]{.alert}).
-   Per m√©s informaci√≥: `$ man errno`
-   Es pot veure un missatge d'error descriptiu identificat per **errno** utilitzant la funci√≥ `perror` de la biblioteca `<stdio.h>`. Funci√≥: `void perror(const char*);` Aquesta funci√≥ primer mostra el missatge i despr√©s l'error. `#include <stdio.h>`.

::: center-container
Fitxer: [sources/errno_example.c](./01-sources/sources/errno_example.c)
:::

## Activitat: `echo` amb c

\onslide<2->

``` c

#include <stdio.h>

int main(int argc, char *argv[]) {
  int i;
  if (argc < 2) {
    fprintf(stderr, "Usage: %s <string>\n", argv[0]);
    return -1;
  }
  for (i = 1; i < argc; i++) {
    printf("%s ", argv[i]);
  }
  printf("\n");
  return 0;
}
```

::: center-container
Fitxer: [sources/echo.c](./01-sources/sources/echo.c)
:::

## Activitat: `cd` amb c

``` c
#include <stdio.h>  // Per fprintf() i perror()
#include <unistd.h> // Per chdir()

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <directory>\n", argv[0]);
        return 1;
    }
    if (chdir(argv[1]) == -1) {
        perror("chdir");
        return 1;  
    }
    return 0;  
}
```

::: center-container
Fitxer: [sources/cd.c](./01-sources/sources/cd.c)
:::

# Makefile

## Qu√® √©s un Makefile?

Un fitxer Makefile √©s un fitxer de text que cont√© un conjunt de regles utilitzades per construir un programa. Aquestes regles indiquen al sistema com compilar i enlla√ßar el programa.

-   **Automatitzaci√≥**: Simplifica el proc√©s de compilaci√≥ i enlla√ßat.
-   **Efici√®ncia**: Nom√©s es compilen els fitxers modificats, no tot el projecte.
-   **Organitzaci√≥**: Organitza el codi i les depend√®ncies de manera estructurada.

## Organitzaci√≥ del Makefile

``` makefile
target: dependencies
    command
```

-   **target**: Nom de l'objectiu (executable o fitxer objecte).
-   **dependencies**: Fitxers necessaris per a generar l'objectiu.
-   **command**: Comandaments per a compilar o generar l'objectiu.

## Plantilla per compilar un programa

``` makefile
CC = gcc
CFLAGS = -Wall -O2
TARGET = programa

all: $(TARGET)

$(TARGET): programa.c
    $(CC) $(CFLAGS) -o $(TARGET) programa.c

clean:
    rm -f $(TARGET)
```

::: notes
La opci√≥ `-O2` √©s un nivell d'optimitzaci√≥ per al compilador. Indica al compilador que optimitzi el codi generat per a un millor rendiment. Inclou un conjunt d'optimitzacions per millorar la velocitat i la grand√†ria del codi. Tenim diferents nivells d'optimitzaci√≥, per exemple `-O0`, `-O1`, `-O2`, `-O3`, `-Os`, `-Og`, `-Ofast`.
:::

# Gesti√≥ Entrada/Sortida

## Com gestiona l'entrada i sortida el SO? {.smaller}

Uns dels objectius del SO √©s proporcionar una m√†quina virtual que uniformitzi la complexitat dels dispositius d'E/S, \blueArrow necessitem independitzar les operacions i els dispositius.

-   **Dispositius reals**: Existeix en el m√≥n real. Combinaci√≥ de diferents elements *harwdare* i *software*.

-   **Dispositius f√≠sics**: Formats pel perif√®ric i pel seu hardware de control i el programari que el gestiona (**drivers**).

-   **Dispositius l√≤gics**: El resultat d'un programari del sistema que crea aquest dispositiu.

    -   **Null**: Dispositiu d'E/S sobre el qual podem escriure tot el que vulguem i sempre √©s buit.
    -   **Finestra**: Dispositiu *l√≤gic* d'E/S que combina 4 dispositius *f√≠sics*: pantalla, teclat, mem√≤ria i un apuntador (ratol√≠).

::: notes
L'espai l√≤gic √©s una agrupaci√≥ d'informaci√≥ emmagatzemada a la mem√≤ria f√≠sica utilitzant la mem√≤ria virtual. Per tant, l'espai l√≤gic d¬¥'un proc√©s es pot veure com un dispositiu entrada/sortida. Us podeu imaginar aquest espai l√≤gic com un fitxer.
:::

## Esquema de dispositius

![](../figures/slides/01-c/esquema-dispositius.png){width="85%"}

## Dispositius virtuals {.smaller}

Un **dispositiu virtual** √©s un dispositiu que a priori no est√† associat a cap **dispositiu real**. *En temps d'execuci√≥ el sistema operatiu associar√† el dispositiu virtual amb el dispositiu real*.

-   **Associaci√≥ impl√≠cita**: El sistema i el proc√©s que ha iniciat l'execuci√≥ s√≥n els encarregats de fer l'associaci√≥. Els dispositius virtuals associats de manera impl√≠cita s√≥n els dispositius est√†ndard, en el cas d'Unix tenim entrada est√†ndard (**stdin**), sortida est√†ndard(**stdout**) i sortida est√†ndard d'errors (**stderr**).
-   **Associaci√≥ expl√≠cita**: Aquesta associaci√≥ es dona entre un dispositiu virtual i un dispositiu real pel mateix programa durant l'execuci√≥. Per efectuar-la el programa necessita realitzar una operaci√≥ espec√≠fica que donat un dispositiu real generi un dispositiu virtual associat. A partir d'aquest moment el programa realitzar√† les operacions d'E/S del dispositiu mitjan√ßant el dispositiu virtual.

## Operacions E/S {.smaller}

El processos utilitzen els descriptors de fitxers per accedir als dispositius un cop ja han estat oberts per llegir i escriure informaci√≥.

::::: columns
::: {.column width="50%"}
### Operacions

-   **llegir**(dispositiu,buffer de lectura,posici√≥)
-   **escriure**(dispositiu,buffer escriptura,posici√≥)
-   **obrir**(dispositiu, operaci√≥)
-   **tancar**(dispositiu)
-   **posicionar**(dispositiu, posici√≥)
:::

::: {.column width="40%"}
### Descriptors

-   0: Entrada est√†ndard (**stdin**)
-   1: Sortida est√†ndard(**stdout**)
-   2: Sortida est√†ndard d'errors (**stderr**)
:::
:::::

::: notes
Fixeu-vos que el fet d'utilitzar dispositius virtuals no soluciona el problema de la independ√®ncia si el sistema operatiu √∫nicament utilitza els dispositius virtuals i aquests han de con√®ixer les peculiaritats dels dispositius reals per poder operar-hi. Per tant, necessitem una nova capa per damunt dels drivers que uniformitzi les operacions.
:::

## Descriptors de fitxer

![](../figures/slides/01-c/descriptors-fitxers.png){width="80%"}

## Fitxers {.smaller}

::::: columns
::: {.column width="40%"}
-   Un fitxer √©s una seq√º√®ncia contigua de bytes.
-   El sistema operatiu no imposa cap format espec√≠fic.
-   Cada byte es pot adre√ßar individualment.
-   Un descriptor de fitxer √©s un nombre enter positiu espec√≠fic que identifica els seus fixers oberts.
-   Tots els fitxers oberts per una aplicaci√≥ es tanquen autom√†ticament quan el proc√©s acaba.
:::

::: {.column width="60%"}
| Valor   | Significat               | Defecte |
|---------|--------------------------|---------|
| 0       | stdin (teclat)           | SI      |
| 1       | stdout (pantalla)        | SI      |
| 2       | stderr (pantalla)        | SI      |
| $3...N$ | disponibles pels usuaris | NO      |

-   **open()** : obre fitxers per llegir i/o escriure o per crear-los.
-   **creat()** : crea un fitxer buit.
-   **read()** : llegeix informaci√≥ d'un fitxer.
-   **write()** : escriu informaci√≥ en un fitxer.
-   **lseek()** : aneu a un byte espec√≠fic del fitxer.
-   **unlink()** : elimina un fitxer.
-   **fcntl()** : controla els atributs d'un fitxer.
:::
:::::

## Obrint fitxers {.smaller}

Per crear o obrir un fitxer fem anar les crides a sistema *open()* i *creat()*. Aquestes retornen la seva descripci√≥, o retornen -1 si hi ha hagut algun error.

::::: columns
::: {.column width="40%"}
``` c
#include < sys/types.h> 
#include < sys/stat.h> 
#include < fcntl.h> 

int open ( const char *path, 
  int flags [, mode_t mode ]);
int creat (const char *path, 
  mode_t mode);
```
:::

::: {.column width="60%"}
-   **path**: cadena amb el cam√≠ relatiu o absolut al fitxer.
-   **flags**: m√®tode d'obertura de fitxer:
    -   *O_RDONLY* - nom√©s lectura.
    -   *O_WRONLY* - nom√©s escriptura.
    -   *O_RDWR* - lectura i escriptura.
    -   *O_CREAT* - crea el fitxer si no existeix.
    -   *O_TRUNC* - si existeix, l'obre i es trunca a 0 bytes.
    -   *O_APPEND* - escriu al final del fitxer.
-   **mode**: especifica els permisos si es crea un fitxer nou (0644: -rw-r--r--)
:::
:::::

::: notes
Podeu consultar la p√†gina de manual de les crides a sistema per obtenir m√©s informaci√≥:

-   `man -s2 fcntl`
-   `man -s2 stat`
-   `man -s2 open`
-   `man creat`
:::

## Tancant fitxers

Per tancar un fitxer utilitzarem *close()*. Aquesta crida a sistema desassocia el fitxer del proc√©s. Retorna 0 si tot funciona correctament, en ca d'error [-1]{.alert}.

``` c
#include <unistd.h> 
int close(int fd);
```

-   **fd**: Descriptor de fitxer que volem tancar.

## Descriptors de fitxers (I)

``` c
int main() {
 
 int fd1, fd2, fd3;
 FILE *f;
 printf("STDIN_FILENO: %d\n", STDIN_FILENO); 
 printf("stdout: %d\n", fileno(stdout)); 
 printf("STDERR_FILENO: %d\n", STDERR_FILENO);

 printf("\nOpening /dev/zero...\n");
 if ((fd1 = open("/dev/zero", O_RDONLY)) < 0) {
  fprintf(stderr, "Unable to open /dev/zero: %s\n", strerror(errno));
 } else {
  printf("fd1: %d\n", fd1);
 }
```

::: center-container
Fitxer: [sources/descriptors.c](./01-sources/sources/descriptors.c)
:::

## Descriptors de fitxers (II)

``` c
 printf("\nOpening /dev/zero a second time...\n");
 if ((fd2 = open("/dev/zero", O_RDONLY)) < 0) {
  fprintf(stderr, "Unable to open /dev/zero: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
 }
 printf("fd2: %d\n", fd2);

 printf("\nNow closing fd1, but keeping fd2 open..\n");
 (void)close(fd1);

 printf("\nOpening /dev/zero a third time...\n");
 if ((fd3 = open("/dev/zero", O_RDONLY)) < 0) {
  fprintf(stderr, "Unable to open /dev/zero: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
 }
 printf("fd3: %d\n", fd3);
```

## Descriptors de fitxers (III)

``` c
 printf("\nNow closing fd2 and fd3.\n");
 (void)close(fd2);
 (void)close(fd3);

 printf("Now opening /dev/zero as a stream.\n");
 if ((f = fopen("/dev/zero", "r")) == NULL) {
  fprintf(stderr, "Unable to open /dev/zero: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
 }
 printf("f: %d\n", fileno(f));
 (void)fclose(f);

 return EXIT_SUCCESS;
}
```

## Llegint fitxers (I) {.smaller}

::::: columns
::: {.column width="30%"}
``` c
#include <unistd.h> 
ssize_t read
(int fd, 
 void *buf, size_t);

ssize_t write
(int fd, 
 void *buf, size_t);
```
:::

::: {.column width="70%"}
`read()`: Intenta llegir/escriure fins a **nbytes** bytes del fitxer especificat per **fd** i emmagatzemar-los a l'√†rea de mem√≤ria que comen√ßa a **buf**. Par√†metres:

-   **fd**: descriptor del fitxer que es llegir√†/escriur√†.
-   **nbytes**: nombre de bytes a llegir/escriure.
-   **buf** : apunta a la mem√≤ria interm√®dia on es desar√† la informaci√≥ de lectura/escriptura. Retorna:
    -   Si t√© √®xit, retorna el nombre de bytes de lectura/escriptura (0 significa final del fitxer).
    -   Si hi ha error, retorna [-1]{.alert} i especifica el motiu en **errno**.
:::
:::::

## Llegint fitxer (II)

``` c
int main(int argc, char* argv[]) {
  char string[11]; int b_read;
  int file = open ("my_file", O_RDONLY); 
  if(file == -1) { 
    perror("Error while opening file");
    exit(1);
  }
  b_read = read(file, string, 10);
  close(file);
  string[10] = 0;
  printf("%d B have been read. The obtained string is: %s\n", 
    b_read, string);
  return 0;
}
```

::: center-container
Fitxer: [sources/llegir_fitxer.c](./01-sources/sources/llegir_fitxer.c)
:::

::: notes
Per generar un fitxer amb dades aleat√≤ries: `head -c 1024 </dev/urandom > my_file`.
:::

## Escrivint fitxers

``` c
int main(int argc, char* argv[]) {

  const char* string = "\nWinter is coming\n\n";

  int file = open("new_file", O_CREAT|O_WRONLY, 0644);

  if(file == -1) { 
    perror("Error when opening file");
    exit(1);
  }

  write(file, string, strlen(string));
  close(file);

  exit(0);
}
```

::: center-container
Fitxer: [sources/escriure_fitxer.c](./01-sources/sources/escriure_fitxer.c)
:::

## Llegint/Escrivint en llocs espec√≠fics {.smaller}

::::: columns
::: {.column width="40%"}
``` c
#include < sys/types.h> 
#include < unistd.h> 
off_t lseek( int fd,
 off_t offset, 
 int whence)
```
:::

::: {.column width="60%"}
-   **fd**: descriptor de fitxer.
-   **offset**: despla√ßament relatiu del punter en bytes.
-   **whence**: directiva de despla√ßament:
    -   *SEEK_SET*: el punter es col¬∑loca **offset** bytes.
    -   *SEEK_CUR*: el punter es mou **offset** bytes des de la seva posici√≥ actual.
    -   *SEEK_END*: el punter es mou **offset** bytes des del final del fitxer.
-   Si t√© √®xit, retorna la posici√≥ absoluta del punter (en bytes).
-   Si hi ha error, retorna [-1]{.alert} i especifica el motiu en errno.
:::
:::::

## Llegint fitxers en llocs espec√≠fics

``` {.c size="footnotesize"}
int main(int argc, char* argv[]) {
  char string[11];
  int b_read;

  int file = open ("my_file", O_RDONLY); 

  lseek(file, 46, SEEK_SET);
  b_read = read(file, string, 10); // Read 10 bytes
  close(file);

  string[10] = 0;
  printf("%d B have been read. The obtained string is: %s\n", 
  b_read, string);

  return 0;
}
```

::: center-container
Fitxer: [sources/llegir_fitxer2.c](./01-sources/sources/llegir_fitxer2.c)
:::

## Escrivint en llocs espec√≠fics

``` c
char buf1[] = "abcdefghij";
char buf2[] = "ABCDEFGHIJ";

int main() {
  int fd;
  if((fd = creat("new_file2", 0644)) < 0) {
    perror("new_file2"); exit(-1);
  }

  if(write(fd, buf1, 10) != 10)       perror("buf1");    // offset == 10
  if(lseek(fd, 4, SEEK_SET) == -1)    perror("lseek");   // offset == 4
  if(write(fd, buf2, 10) != 10)       perror("buf2");    // offset == 14

  return 0;
}
```

::: center-container
Fitxer: [sources/escriure_fitxer2.c](./01-sources/sources/escriure_fitxer2.c)
:::

# Punters

## Qu√® s√≥n els punters? {.smaller}

::::: columns
::: {.column width="45%"}
### Concepte

-   Totes les dades (variables, constants,...) **s'emmagatzemen** des d'una determinada **adre√ßa de mem√≤ria** i utilitzant tants **bytes** com sigui necessari.
-   Un punter √©s una **variable** guardada en una [adre√ßa de m√®moria]{.alert} que cont√© un altra **adre√ßa de mem√≤ria**.
:::

::: {.column width="45%"}
### Operadors

-   **&**: Retorna l'adre√ßa de l'apuntador. Per exemple `&x` ens d√≥na l'adre√ßa de la variable `x`.
-   **\*** Retorn el valor de la variable situada a l'adre√ßa especificada pel seu operand (**dereferencing**).
:::
:::::

::: {.fragment .center-container}
El valor que retorna l'operador **&** dep√®n de la posici√≥ del seu operand i, per tant, no est√† sota el control del programador.
:::

## Com funcionen els punters? (I)

``` c
int main (int argc, char * argv[]){
int s=10,n,m;
int *ptr=&s;
};
```

![](../figures/slides/01-c/pointer1.png){width="60%"}

## Com funcionen els punters? (II)

::::: columns
::: {.column width="40%"}
``` c
int 
main (int argc, 
    char * argv[]){
    int s=10;
    float f=10.5;
    char a='a';

    int *pt1 = &s;
    float *pt2 = &f;
    char *pt3= &a;
};
```
:::

::: {.column width="60%"}
![](../figures/slides/01-c/pointer2.png){width="90%"}
:::
:::::

::: center-container
Fitxer: [sources/punters_diapos.c](./01-sources/sources/punters_diapos.c)
:::

## Operacions amb punters (I)

-   **Assignaci√≥ (=)**: Assigna una adre√ßa a un punter.
-   **Comparaci√≥ (==, !=)**: Igualtat o desigualtat.
-   **Inicialitzaci√≥ (NULL)**: Indica que el punter no cont√© cap adre√ßa.
-   **Increment (++), decrement (--)**: Canviar un punter a l'element seg√ºent/anterior d'una s√®rie (per exemple, una matriu).
-   **Indexat (\[\])**: acc√©s a l'element n d'una s√®rie.

## Operacions amb punters (II)

``` c
int n = 2;
int *ptr1 = NULL;
ptr1 = &n;
(*ptr1)++        //Modifiquem el valor de la variable a la que apunta
ptr1++           //Modifiquem l'adre√ßa de mem√≤ria on apunta
```

## Pas de par√†metres (valor)

``` c
#include <stdio.h>

int sumar_per_valor(int a, int b) {
    a = a + b;
    return a;
}

int main() {
    int x = 5;int y = 3;
    printf("Abans de la crida per valor: x = %d, y = %d\n", x, y);
    int resultat = sumar_per_valor(x, y);
    printf("Despr√©s de la crida per valor: x = %d, y = %d\n", x, y);
    printf("Resultat de la suma: %d\n", resultat);

    return 0;
}
```

::: center-container
Fitxer: [sources/pas_valor.c](./01-sources/sources/pas_valor.c)
:::

## Pas de par√†metres (refer√®ncia)

``` c
#include <stdio.h>

void sumar_per_referencia(int *a, int *b) {
    *a = *a + *b;
}

int main() {
    int x = 5; int y = 3;
    printf("Abans de la crida per refer√®ncia: x = %d, y = %d\n", x, y);
    sumar_per_referencia(&x, &y);
    printf("Despr√©s de la crida per refer√®ncia: x = %d, y = %d\n", x, y);
    return 0;
}
```

::: center-container
Fitxer: [sources/pas_referencia.c](./01-sources/sources/pas_referencia.c)
:::

## Exemple: Ordenaci√≥ d'un array

``` c
void ordenar(int n, int* ptr)
{
    int i, j, t;
    for (i = 0; i < n; i++) {
        for (j = i + 1; j < n; j++) {
            if (*(ptr + j) < *(ptr + i)) {
                t = *(ptr + i);
                *(ptr + i) = *(ptr + j);
                *(ptr + j) = t;
            }
        }
    }
}
```

## Qu√® √©s la **Stack**? {.smaller}

√âs una estructura **LIFO** (Last-In,First-Out). La pila √©s una regi√≥ especial de mem√≤ria i la gestiona autom√†ticament la CPU, de manera que no cal assignar ni desassignar mem√≤ria. La mem√≤ria de pila es divideix en trames successives on cada vegada que es crida una funci√≥, s'assigna una nova trama de pila.

### Caracter√≠stiques de la Stack

-   **Ordre seq√ºencial**: Les variables s'empilen i desempilen en ordre seq√ºencial.
-   **Gesti√≥ autom√†tica**: No cal que el programador assigni o alliberi mem√≤ria manualment.
-   **Limitaci√≥ de mida**: La pila √©s limitada, i si es supera el seu l√≠mit, es produeix un desbordament de pila.
-   **Variables locals**: Les variables de la pila nom√©s existeixen mentre la funci√≥ est√† en execuci√≥.
-   **Eficient**: L'acc√©s a la mem√≤ria de la pila √©s molt r√†pid, ja que segueix un ordre seq√ºencial i clar.

## Qu√® √©s la **Heap**? {.smaller}

La heap √©s una √†rea de mem√≤ria on s'assigna mem√≤ria de manera din√†mica durant el temps d'execuci√≥. Aquesta mem√≤ria es gestiona a trav√©s de funcions espec√≠fiques com `malloc()`, `calloc()` i `free()`, i √©s responsabilitat del programador garantir que la mem√≤ria s'alliberi quan ja no sigui necess√†ria.

### Caracter√≠stiques de la Heap

-   **Gesti√≥ manual**: El programador ha de controlar l'assignaci√≥ i alliberament de la mem√≤ria.
-   **Flexibilitat**: √âs √∫til per a grans blocs de mem√≤ria o per a objectes que han de romandre en mem√≤ria m√©s temps que una funci√≥ espec√≠fica.
-   **Limitaci√≥ per mem√≤ria f√≠sica**: La mida de la heap est√† limitada per la quantitat de mem√≤ria f√≠sica disponible al sistema.
-   **Cost d'execuci√≥**: Les operacions amb la heap s√≥n m√©s lentes comparades amb la pila, a causa de la gesti√≥ din√†mica i la fragmentaci√≥.

## Exemple: Heap vs Stack

::::: columns
::: {.column width="65%"}
``` c
int main() {     
    int y;   
    char *str; 
    y = 4;
    printf("stack memory: %d\n", y);
    str = malloc(100*sizeof(char)); 
    str[0] = 'm';
    printf("heap memory:%c\n", str[0]); 
    free(str);         
    return 0;
}
```
:::

::: {.column width="35%"}
![](../figures/slides/01-c/stackmemory.jpg)
:::
:::::

::: center-container
Fitxer: [sources/zones_mem.c](./01-sources/sources/zones_mem.c)
:::

## StackOverflow

::::: columns
::: {.column width="40%"}
### Exemple

``` c
void func() {
    int vector[1000];
    func();
}

int main() {
    func();
    return 0;
}
```
:::

::: {.column width="60%"}
### Qu√® √©s un StackOverflow?

Un **stack overflow** es produeix quan la pila del programa supera la seva capacitat m√†xima. Aix√≤ pot passar quan es criden funcions recursives de manera infinita o quan s'assignen grans quantitats de mem√≤ria a la pila.
:::
:::::

## Exemple: Ordenar amb mem√≤ria din√†mica (I)

``` c
int main() {
    int* nums = NULL;  
    int n = 0, max_elements = 10, num;

    nums = (int*)malloc(max_elements * sizeof(int));
    if (nums == NULL) {
        printf("Error en l'assignaci√≥ de mem√≤ria.\n");
        return 1;
    }

    capta_dades(n, nums);
    ordenar(n, nums);
    free(nums);
    return 0;
}
```

::: center-container
Fitxer: [sources/pas_referencia.c](./01-sources/sources/ordenar.c)
:::

## Exemple: Ordenar amb mem√≤ria din√†mica (II)

``` c

capta_dades(int n, int* nums) {
  while (scanf("%d", &num) != EOF) {
    if (n >= max_elements) {
      max_elements *= 2;
      int* temp = (int*)realloc(nums, max_elements * sizeof(int));
      if (temp == NULL) {
        printf("Error en l'assignaci√≥ de mem√≤ria.\n");
        free(nums);
        return 1;
      }
      nums = temp;
    }
  nums[n] = num;
  n++;
  }
}
```

# Structs i TypeDef

## Qu√© s√≥n els structs?

Una estructura √©s un tipus de dades derivats format per membres que s√≥n tipus de dades fonamentals o derivats. Una √∫nica estructura emmagatzemaria les dades d'un objecte. Una matriu d'estructures emmagatzemaria les dades de diversos objectes.

::::: columns
::: {.column width="45%"}
### Senser reserva espai de Mem√≤ria

``` c
struct user {
int pid;
char * name;
}
```
:::

::: {.column width="45%"}
### Reservant espai de Mem√≤ria

``` c
struct user {
int pid;
char * name;
} user;
```
:::
:::::

## Qu√© s√≥n els Typedef?

Typedef s'utilitza per crear sin√≤nims per a noms de tipus de dades definits pr√®viament.

::::: columns
::: {.column width="50%"}
``` c
typedef int L;
int a;
L a;
```
:::

::: {.column width="50%"}
``` c
typedef struct {
int pid;
char * name;
} User; 
```
:::
:::::

<br>

::::: columns
::: {.column width="50%"}
``` c
User user;
user.name="
Jordi Mateo";
user.pid=5000;
```
:::

::: {.column width="50%"}
``` c
User * user1;
user1->name="Jack 
sparrow";
*(user1).pid=5001;
User *user2 = &user;
```
:::
:::::

## Calculant la distancia entre 2 punts

``` c
typedef struct {
  float x; float y;
} point ;
 
float dist( point A, point B) {
  return(sqrt((A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y)));
}
 
int main(){
  float d; point A, B;
  printf("The coordinates of the point A are: ");
  scanf("%f %f",&A.x,&A.y);
  printf("\nThe coordinates of the point B are: ");
  scanf("%f %f",&B.x,&B.y);
  printf("\nThe distance between A and B is %f\n", dist(A,B));
  exit (0);
}
```

## Exercicis

1.  [DebianBin](../activities/unit00/01-debianbin.qmd)

## Aix√≤ √©s tot per avui

::::: columns
::: {.column width="60%"}
#### Preguntes?

Tot el codi i exemples addicionals els trobareu a la carpeta `01-sources` del repositori GitHub del curs.

<br>

#### TAKE HOME MESSAGE

El kernel de Linux s'ha escrit en C, per tant, √©s important con√®ixer aquest llenguatge de programaci√≥ si volem entendre com funciona el sistema operatiu.
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::