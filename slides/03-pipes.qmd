---
title: "Pipes i redirecci贸 d'entrada/sortida"
subtitle: "Unitat 3 路 Sistemes Operatius (SO)"
author: "Jordi Mateo Forn茅s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 路 Sistemes Operatius (SO) [](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## Implementaci贸 de les Pipes {.smaller}

Les pipes es poden implementar com a buffers circulars basats en mem貌ria assignada pel sistema operatiu. Aquestes pipes es coneixen com a pipes sense nom i s贸n transit貌ries. Una pipe *sense nom* deixa d'existir quan tots els processos que la tenen assiganda **acaben** o **tanquen** els seus descriptors associats a la pipe.

::: center-container
![](../figures/slides/03-pipes/pipe.png){width="30%"}
:::

Els pipes es creen en el moment que s'obren mitjan莽ant la crida a sistema `pipe()` *(unistd.h)* o amb la sintaxis `|`.

## Creaci贸 de Pipes

``` c
int pipe(int desc[2]);                                                                                                
RETORNA:  0 on success                                                       
         -1 on error:    errno = EMFILE (no free descriptors)                  
                                 EMFILE (system file table is full)            
                                 EFAULT (fd array is not valid)                
```

-   La crida a sistema `pipe()`, crea dos descriptors de fitxer. Un de *lectura* **(desc\[0\])** i un d'*escriptura* **(desc\[1\])**.
-   La informaci贸 que s'escriu per **desc\[1\]** es llegeix per **desc\[0\]**.
-   Una vegada el `pipe()` s'ha creat; per poder utilitzar-lo els processos han d'heretar aquests descriptors del proc茅s pare.

## Comunicaci贸 unidireccional (I)

::: center-container
![](../figures/slides/03-pipes/pipe0.png)
:::

## Comunicaci贸 unidireccional (II)

::: center-container
![](../figures/slides/03-pipes/pipe1.png)
:::

## Comunicaci贸 unidireccional (III)

::: center-container
![](../figures/slides/03-pipes/pipe2.png){width="65%"}
:::

## Comunicaci贸 unidireccional (IV)

``` c
void main(){
   int fd[2]; // Descriptors associats a una pipe  
   pid_t   pidFill;
    /* El primer element de la matriu (fd[0]) est configurat i obert per 
    a la lectura, mentre que el segon element est configurat i obert per 
    escriure (fd[1]. Totes les dades que viatgen per la pipe es mouen 
    pel nucli. */
    pipe(fd); pidFill = fork();
     if (pidFill == -1){
        perror("fork"); exit(1);
     } else if (pidFill == 0){
         /*El proc茅s fill tanca la escriptura per la pipe*/ close(fd[1]);
     } else {
         /* El proc茅s pare tanca la lectura per la pipe */ close(fd[0]);
     }
 }
```

## Comunicaci贸 bidireccional (V)

-   El **proc茅s pare** necessitar dues pipes (una per cada direcci贸).
-   El **pare** fa un `fork()` creant una c貌pia del pare i duplicant els descriptors de fitxers associats a les dues **pipes**.
-   El proc茅s **pare** *tanca la lectura de la sortida del pipe1*.
-   El proc茅s **fill** *tanca lescriptura a lentrada del pipe1*.
-   El proc茅s **fill** *tanca la lectura de la sortida del pipe2*.
-   El proc茅s **pare** *tanca lescriptura a lentrada del pipe2*.

## Comunicaci贸 bidireccional (Pipes)

::::: columns
::: {.column width="45%"}
### Pipe 1

![](../figures/slides/03-pipes/pipe-bi-1.png)
:::

::: {.column width="45%"}
### Pipe2

![](../figures/slides/03-pipes/pipe-bi-2.png)
:::
:::::

## Escriptura en les pipes

-   L'escriptura a les *pipes* es realitza utilitzant la crida a sistema: **write()** o la funci贸 **fprintf()**.
-   Si un proc茅s **escriu** en un *pipe* que tingui el **descriptor de lectura tancat**, [**write() falla i s'envia un senyal SIGPIPE**]{.alert}.
-   Si un proc茅s escriu *menys bytes* dels que admet el *pipe*, **l'escriptura es realitza de forma at貌mica**.
-   Si s'intenta escriure sobre un *pipe* **ple**; **el proc茅s** es queda *bloquejat* fins que el *pipe es buidi* **(un altre proc茅s ha llegit les dades)** i *llavors s'acaba l'escriptura*.

## Lectura de les pipes

-   La lectura dels *pipes* es fan mitjan莽ant la crida a sistema: **read()** o la funci贸 **fscanf()**.
-   Si un proc茅s **llegeix** en un *pipe* que tingui el **descriptor tancat**, [**retorna un 0, indicant la condici贸 de final de fitxer**]{.alert}.
-   Si un proc茅s **llegeix** dun **pipe** *buit es bloqueja fins que les dades estiguin disponibles*.
-   Si un proc茅s intenta **llegir** *m茅s dades que les disponibles* en un pipe, *es llegeixen els disponibles i es retorna el nombre de bytes llegits*.

## Exemple: Lector-Escriptor (I)

::::: columns
::: {.column width="50%"}
#### Lector

``` c
int main() {
    int fd[2];
    pid_t p1 = fork();

    if (p1 > 0) {
    {
      close(fd[1]);  
      char buf[100];
      read(fd[0], buf, sizeof(buf));
      printf("MSG: %s\n",buf);
      close(fd[0]);  
    }
```
:::

::: {.column width="50%"}
#### Escriptor

``` c
else if (p1 == 0) {
    close(fd[0]);  
    char msg[5];
    sprintf(msg, "msg1");
    write(fd[1], msg, strlen(msg));
    close(fd[1]);  
    exit(0);
  }
}
```
:::
:::::

## Exemple: Lector-Escriptor (II)

::::: columns
::: {.column width="55%"}
#### Pare

``` c
int main() {
  int fd[2]; int r = pipe(fd);
  pid_t p1 = fork();
  if (p1 == 0) { /*Fill*/ }
  close(fd[1]);
  char buf[100];
  while(read(fd[0],&buf,sizeof(buf))){
    printf("I got a message! 
      It was %s\n", buf);
    }
  printf("No more messages :(\n");
  close(fd[0]);
}
```
:::

::: {.column width="45%"}
#### Fill

``` c
close(fd[0]);
char msg[5];
sprintf(msg,"msg1");
ssize_t nw = write(fd[1], 
    msg, strlen(msg));
sprintf(msg,"msg2");
nw = write(fd[1], 
    msg, strlen(msg));
close(fd[1]); 
while(1);
exit(0);
```
:::
:::::

## Exemple: Lector-Escriptor (III)

::::: columns
::: {.column width="55%"}
#### Pare

``` c
int main() {
  int fd[2]; int r = pipe(fd);
  pid_t p1 = fork();
  if (p1 == 0) { /*Fill*/ }
  close(fd[1]);
  char buf[100];
  while(read(fd[0],&buf,sizeof(buf))){
    printf("I got a message! 
      It was %s\n", buf);
    }
  printf("No more messages :(\n");
  close(fd[0]);
}
```
:::

::: {.column width="45%"}
#### Fill

``` c
close(fd[0]);
char msg[5];
sprintf(msg,"msg1");
ssize_t nw = write(fd[1], 
    msg, strlen(msg));
sprintf(msg,"msg2");
nw = write(fd[1], 
    msg, strlen(msg));
//close(fd[1]);  <-
while(1);
exit(0);
```
:::
:::::

## Exemple: Lector-Escriptor (IV)

::::: columns
::: {.column width="60%"}
#### Pare

``` c
void sigpipe_handler(int signum) {
    printf("SIGPIPE...\n");
    exit(EXIT_SUCCESS);
}
int main() {
  int fd[2]; int r = pipe(fd);
  pid_t p1 = fork();
  if (p1 == 0) { /*Fill*/ }
    close(fd[1]);  
    signal(SIGPIPE, sigpipe_handler);
    write(fd[1], "Hello", 5);
}
```
:::

::: {.column width="40%"}
#### Fill

``` c
close(fd[0]);  
sleep(2);  
close(fd[1]);  
exit(EXIT_SUCCESS);
```
:::
:::::

## Redirecci贸 i duplicats {.smaller}

Per utilitzar *pipes* amb la crida a sistema *exec* i simular el comportament del sistema operatiu quan interactuem amb la *shell*, necessitem redireccionar la sortida i l'entrada de la pipe a *descriptors de fitxers* predefinits assignats a cada proc茅s.

::: center-container
![](../figures/slides/03-pipes/red_pipe.png){width="55%"}
:::

-   Tancant els descriptors estndard.
-   Duplicant els descriptors de fitxer utilitzant la crida a sistema `dup()`*(unistd.h)*.

## `dup()` i `dup2()` {.smaller}

``` c
int dup(int fdold)
int dup2(int fdold, int fdnew)
```

-   *dup*: utilitza el descriptor de fitxer lliure m茅s petit per duplicar el descriptor de fitxer *fdold*.
-   *dup2*: fa que *fdnew* sigui una c貌pia de *fdold*, tancant *fdold* si 茅s necessari.

## Exemple a linux: `ls | wc -l` (I)

![](../figures/slides/03-pipes/ls-wc.png)

## Exemple a linux: `ls | wc -l` (II) {.smaller}

-   El *proc茅s 1* far un **recobriment de la comanda ls** i l'**executar**. Per defecte la comanda *ls* imprimeix per *stdout* el llistat de fitxers i directoris del directori actual.
-   En aquest cas *la pipe (\|)* indica que `ls` no escriur per **stdout** i ho far per la **pipe**. D'aquesta manera no veurem el llista de fitxers a la terminal, seran enviats a la *pipe*.
-   El *proc茅s 2* far un **recobriment de la comanda wc -l**, aquesta comanda *compta el nombre de l铆nies rebudes per* **stdin**. En aquest cas, com tenim la comanda precedida d'una pipe... El proc茅s *redireccionar* **stdin** a la **pipe**. Per tant, llegir el contingut escrit per la comanda `ls`.
-   Per defecte la comanda `wc -l` escriu a **stdout**, com ara no hi ha cap m茅s **pipe**. Aquesta sortida [**no es redirecciona**]{.alert} i per tant 煤nicament veurem el resultat per **stdout**. s a dir, el nombre de fitxers i directoris del directori actual.

## Exemple a linux: `ls | wc -l` (III)

![](../figures/slides/03-pipes/ls-wc2.png)

## Implementaci贸 amb C `ls | wc -l` {.smaller}

``` c
int main(int argc, char *argv[]){
int fd[2];
char *p1[] = {"ls", NULL};
char *p2[] = {"wc", "-l", NULL};
if (pipe(fd)<0){ perror("Error de creaci贸 del pipe fd[]");exit(-1);}

int pid1;int pid2;
switch (pid1 = fork()){
    case -1: perror("Error fork()"); exit(-2); break;
    case 0: //@TODO
}
switch (pid2 = fork()){
    case -1: perror("Error fork()"); exit(-2); break;
    case 0: //@TODO
}
waitpid(pid1,0,0); 
waitpid(pid2,0,0);
}
```

## Implementaci贸 amb C `ls | wc -l` {.smaller}

#### Fill 1 (`ls`)

``` c
if (close(pfd[0]) == -1)                    
    perror("close 1");

    /* Duplicate stdout on write end of pipe; 
    close duplicated descriptor */

    if (fd[1] != STDOUT_FILENO) {              
        if (dup2(fd[1], STDOUT_FILENO) == -1)
            perror("dup2 1");
        if (close(fd[1]) == -1)
            perror("close 2");
    }

    execlp("ls", "ls", (char *) NULL);          
    perror("execlp ls");
```

## Implementaci贸 amb C `ls | wc -l` {.smaller}

#### Fill 2 (`wc -l`)

``` c
   if (close(fd[1]) == -1)                    
        perror("close 3");

    /* Duplicate stdin on read end of pipe; 
    close duplicated descriptor */

    if (fd[0] != STDIN_FILENO) {              
        if (dup2(fd[0], STDIN_FILENO) == -1)
            perror("dup2 2");
        if (close(fd[0]) == -1)
            perror("close 4");
    }

    execlp("wc", "wc", "-l", (char *) NULL);
    perror("execlp wc");
```

## Implementaci贸 amb C `ls | wc -l` {.smaller}

::: center-container
Com 茅s que el programa no acaba mai?
:::

El proc茅s pare ha de tancar els descriptors de fitxer que no utilitza. Si no els proc茅s fill lector de la pipe no acaba mai. Ja que no tots els processos han tancat els descriptors de fitxer associats a la **pipe**.

``` c
// Pare
if (close(fd[0]) == -1)
    perror("close");
if (close(fd[1]) == -1)
    perror("close");

waitpid(pid1,0,0);
waitpid(pid2,0,0);
```

## Aix貌 茅s tot per avui {.smaller}

::::: columns
::: {.column width="60%"}
#### TAKE HOME MESSAGE

Les pipes s贸n mecanismes de comunicaci贸 entre processos que permeten la transmissi贸 de dades d'un proc茅s a un altre. Es poden utilitzar per a comunicaci贸 unidireccional o bidireccional. Cal comprendre com crear pipes, escriure i llegir dades en elles, i com utilitzar-les en la redirecci贸 d'entrada/sortida de processos en execuci贸.
:::

::: {.column width="40%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg)
:::
:::::