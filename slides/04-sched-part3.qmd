---
title: "PlanificaciÃ³ de processos Â· Linux"
subtitle: "Unitat 4 Â· Sistemes Operatius (SO)"
author: "Jordi Mateo FornÃ©s"
logo: "/figures/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 4 Â· Sistemes Operatius (SO) [ğŸ ](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

## EvoluciÃ³ de la PlanificaciÃ³ a Linux

- **Linux 1.2**:  
  - PlanificaciÃ³ simple: cua circular + *Round Robin (RR)*.
  - Adequat per sistemes amb poques tasques.

- **Linux 2.2**:  
  - S'introdueixen **classes de planificaciÃ³**:
    ```c
    #define SCHED_OTHER 0 // Processos normals d'usuari (per defecte)
    #define SCHED_FIFO  1 // Temps real, no preemptiu
    #define SCHED_RR    2 // Temps real, Round Robin
    ```

## `SCHED_FIFO`

- **Temps real**, prioritat fixa.
- El procÃ©s actual:
  - Continua execuciÃ³ fins que acaba
  - O bÃ© fins que apareix un procÃ©s amb major prioritat
- Si hi ha diversos processos amb mateixa prioritat:
  - ExecuciÃ³ FIFO 

## `SCHED_RR`

- Igual que `SCHED_FIFO`, perÃ² amb *quantum* (slice) de temps.
- Processos de la mateixa prioritat sâ€™alternen:
  - Cada procÃ©s utilitza la CPU durant el seu *quantum*
  - DesprÃ©s passa al final de la cua
- Els processos amb menor prioritat nomÃ©s sâ€™executen si no hi ha cap de mÃ©s alta

## Linux 2.4 â€“ Planificador O(n)

- **Epochs**: cicles de planificaciÃ³
- **Slices**: quota de temps assignada per epoch
- Si un procÃ©s dorm o es bloqueja, recupera part del *slice* per al segÃ¼ent epoch

::: {.center-container .fragment}
Amb molts processos la selecciÃ³ Ã©s $O(n)$ â†’ poc escalable.
:::

## Linux 2.6 â€“ Planificador O(1)

- Les tasques es gestionen en llistes per prioritat (0â€“139):
  - `0-99`: temps real (`SCHED_FIFO`, `SCHED_RR`)
  - `100-139`: processos dâ€™usuari (`SCHED_NORMAL`)
- SelecciÃ³ de tasca: O(1)
- MÃ©s escalable que O(n), perÃ²:

::: {.center-container .fragment}
 **Prioritats rÃ­gides** â†’ pot degradar la justicia real
:::

## `SCHED_NORMAL`

- Ã‰s la polÃ­tica per defecte per a processos d'usuari
- Cada procÃ©s tÃ©:
  - **Prioritat estÃ tica**: basada en el `nice` (âˆ’20 â€¦ +19)
  - **Prioritat dinÃ mica**: ajustada segons el comportament (p.ex. interactiu o CPU-bound)

## HeurÃ­stica de `SCHED_NORMAL` {.smaller}

:::center-container
Com una prioritat dinÃ mica es tradueix en accÃ©s a CPU?
:::

$$bonus=min(10, (\frac{\text{avg.sleep time}}{100}) \text{ ms})$$

$$ \text{Prioritat}=max(100, min( \text{estatica} - \text{bonus} +5,139))$$

:::{.center-container .fragment}
Prioritat alta â†’ Quantum mÃ©s llarg â†’ mÃ©s temps de CPU
:::

- 100 Ã©s la prioritat mÃ­nima per a processos d'usuari.
- 139 Ã©s la prioritat mÃ xima.
- Permet que aplicacions interactives tinguin menys latÃ¨ncia
- Evita la fam per part dels processos I/O-bound

## Limitacions de `SCHED_NORMAL` i planificador O(1)

- DepÃ¨n de gestiÃ³ manual dâ€™heurÃ­stiques
- ContinuÃ¯tat i equitat amb cÃ rregues mixtes no sempre garantides
- LatÃ¨ncia elevada per aplicacions interactives
- Complexitat creixent quan augmenta nombre de processos

::: {.center-container .fragment}
Cal un planificador mÃ©s just i adaptatiu â†’ CFS
:::

## Completely Fair Scheduler (CFS)

- Ã‰s l'algorisme de planificaciÃ³ per defecte a Linux des de l'any 2007 (kernel 2.6).
- L'objectiu: ser **just**, evitar fam, reduir latÃ¨ncia.
- Modela un **sistema ideal** on tots els processos reben CPU simultÃ niament (**Proporcional al seu pes**).
- Com aixÃ² no Ã©s possible, simula el que *hauria passat* amb la mÃ¨trica **vruntime** (temps virtual).
- Sempre s'executa el procÃ©s amb **menys vruntime acumulat**.

## `vruntime` en CFS

El `vruntime` (virtual runtime) Ã©s una mesura del temps de CPU que ha utilitzat un procÃ©s, ajustat pel seu pes (prioritat).

$$ vt_{i}(t) = \int_{0}^{t} \frac{dt}{w_i} $$

on:

- $vt_i(t)$: temps virtual del procÃ©s $i$ en el temps $t$.
- $w_i$: pes del procÃ©s $i$ (derivat de la seva prioritat).
- $dt$: increment de temps real.

## Exemple ilustratiu de CFS {.smaller}

Suposem tres tasques A, B i C.

- Suposem tres processos amb diferents prioritats:

  - A: `nice` = 0 â†’ factor 1.0
  - B: `nice` = +5 â†’ penalitzaciÃ³, factor 2.0
  - C: `nice` = +10 â†’ penalitzaciÃ³ addicional, factor 3.0

- Cada procÃ©s acumula vruntime segons el seu factor:

  - A: +1 unitat per tick
  - B: +2 unitats per tick
  - C: +3 unitats per tick

- El planificador **sempre escull la tasca amb menor VT**.

:::{.center-container .fragment}
Quina fracciÃ³ de CPU acabarÃ  rebent cada tasca?
:::

## SoluciÃ³ de l'exemple CFS  {.smaller}

::: columns
::: {.column width="50%"}  
- Q01: sâ€™executa **A**  
  - `VT={A: 1, B: 0, C: 0}`
- Q02: sâ€™executa **B** (tÃ© VT=0, el mÃ©s petit)  
  - `VT={A: 1, B: 2, C: 0}`
- Q03: sâ€™executa **C** (tÃ© VT=0)  
  - `VT={A: 1, B: 2, C: 3}`
- Q04: sâ€™executa **A** (VT=1, el mÃ©s petit)  
  - `VT={A: 2, B: 2, C: 3}`
- Q05: sâ€™executa **B** (A i B empaten, triem B)  
  - `VT={A: 2, B: 4, C: 3}`
- Q06: sâ€™executa **A** (VT=2)  
  - `VT={A: 3, B: 4, C: 3}`
:::
::: {.column width="50%"}

- Q07: sâ€™executa **A** (A i C: VT=3, triem A)  
  - `VT={A: 4, B: 4, C: 3}`
- Q08: sâ€™executa **C** (VT=3)  
  - `VT={A: 4, B: 4, C: 6}`
- Q09: sâ€™executa **A** (VT=4)  
  - `VT={A: 5, B: 4, C: 6}`
- Q10: sâ€™executa **B** (VT=4)  
  - `VT={A: 5, B: 6, C: 6}`
- Q11: sâ€™executa **A** (VT=5)  
  - `VT={A: 6, B: 6, C: 6}`
:::
:::

## Observacions de l'exemple CFS {.smaller}

- El CFS intenta repartir la CPU de manera equitativa, en funciÃ³ de les prioritats (pesos) dels processos.
- Cada procÃ©s tÃ© un vruntime (temps virtual) que creix mentre sâ€™executa.
- El planificador sempre tria el procÃ©s amb el vruntime mÃ©s petit, Ã©s a dir, el que va **mÃ©s endarrerit** respecte al que li tocaria.
- Els processos amb `nice` mÃ©s alt (menys prioritat) fan crÃ©ixer el seu vruntime mÃ©s de pressa i, per tant, sÃ³n desprogramats abans i corren menys sovint.


::: columns
::: {.column width="50%"}

| | A | B | C |
|-|---|---|---|
| Execucions| 6 | 3 | 2 |
| FracciÃ³ de CPU | 54.5% | 27.3% | 18.2% |
| Pes | 1.0 | 0.5 | 0.33 |

:::
::: {.column width="50%"}
- A acumula vruntime mÃ©s lentament â†’ pot cÃ³rrer mÃ©s sovint.
- C acumula vruntime mÃ©s rÃ pid â†’ es veu desprogramat abans i rep menys CPU.
:::
:::

## ImplementaciÃ³ de CFS {.smaller}

- El CFS necessita una estructura de dades que permeti:
  - Trobar rÃ pidament quin procÃ©s tÃ© el menor `vruntime` (el segÃ¼ent a executar).
  - Modificar rÃ pidament la posiciÃ³ dâ€™un procÃ©s dins lâ€™ordre quan canvia el seu `vruntime`.
  - Mantenir ordenats els processos per `vruntime` de manera eficient si en tenim molts

::: {.fragment}
| AcciÃ³                   | Llista ordenada | Arbre RB     |
| ----------------------- | --------------- | ------------ |
| Buscar procÃ©s mÃ­nim     | O(1) o O(n)     | **O(log n)** |
| Inserir/eliminar procÃ©s | O(n)            | **O(log n)** |
| Reubicar procÃ©s         | O(n)            | **O(log n)** |
:::

## Arbre Red-Black (RB) {.smaller}

- Un arbre RB Ã©s un tipus dâ€™arbre binari dâ€™autoequilibri que garanteix:
  - Operacions de cerca, inserciÃ³ i eliminaciÃ³ en O(log n).

- Lâ€™arbre sempre es mantÃ© equilibrat en alÃ§ada, mantenint unes regles simples:
  - Cada node Ã©s vermell o negre.
  - El node arrel Ã©s sempre negre.
  - Dos nodes vermells no poden ser consecutius (un node vermell no pot tenir un pare vermell).
  - Tots els camins des de la arrel fins a les fulles tenen el mateix nombre de nodes negres.
  - La part dreta Ã©s sempre mÃ©s gran que lâ€™esquerra (ordenaciÃ³ per vruntime).


## ConstrucciÃ³ de lâ€™arbre RB en el CFS

Tenim aquests quatre processos:

| ProcÃ©s | Pes (nice) | `vruntime` inicial |
| ------ | ---------- | ------------------ |
| P1     | 1          | 10                 |
| P2     | 2          | 5                  |
| P3     | 3          | 15                 |
| P4     | 1          | 8                  |

Inserim els processos a lâ€™arbre RB per ordre de `vruntime`.

## Dibuixem lâ€™arbre RB pas a pas

### Inserim P2 (vruntime = 5)

Ã‰s el primer node â†’ esdevÃ© arrel, color negre.

```c
    [5B] (P2)
```

::: {.fragment}
### Inserim P4 (vruntime = 8)

- $8 > 5$ â†’ va a la dreta. Ã‰s vermell.

::: {.fragment}
```.c 
    [5B] (P2)
       \
       [8R] (P4)
```
:::

:::

- Cap violaciÃ³ de regles.

## Inserim P1 (vruntime = 10) {.smaller}

- $10 > 5$ â†’ anem a la dreta.
- $10 > 8$ â†’ va a la dreta de P4. Es pinta vermell.

:::{.fragment}
```c
    [5B] (P2)
       \
       [8R] (P4)
           \
           [10R] (P1)
```
:::

:::{.center-container .fragment}
**VIOLACIÃ“**: dos vermells consecutius (8R i 10R). Cal fer rotaciÃ³ **esquerra**
:::

::: columns
::: {.column width="50%"}
- Per mantenir l'ordre i garantir equilibri, fem una rotaciÃ³ a lâ€™esquerra sobre P4 (elevaciÃ³ de P1):
  - Baixem P4 com a fill de P1 a lâ€™esquerra. 
  - P1 ascendeix i esdevÃ© negre.
  - P4 descendeix i resta en vermell.

:::
::: {.column width="50%"}

::: {.fragment}
```c
    [5B] (P2)
         \
         [10B] (P1)
         /
      [8R] (P4)
```
:::

:::
:::

## Inserim P3 (vruntime = 15) {.smaller}

- $15 > 5$ â†’ dreta, $15 > 10$ â†’ dreta â†’ Ã©s vermell

::: {.fragment}
```c
    [5B] (P2)
       \
       [10B] (P1)
       /   \
     [8B] [15R]
     (P4)  (P3)

```
:::

- El arbre no esta equilibrat en alÃ§ada P2 dreta tÃ© alÃ§ada 3, esquerra 0 â†’ fem rotaciÃ³ a lâ€™esquerra sobre P2.
- P2 descendeix com a fill esquerre de P1. P1 ascendeix i esdevÃ© lâ€™arrel.
- P4 es recolÂ·loca com a fill dret de P2. 

::: {.fragment}
```c
      [10B] (P1)
     /     \
  [5R]     [15R]
  (P2)     (P3)
     \
     [8B]
     (P4)
```
:::


## Limitacions del CFS 

| ProcÃ©s | Pes (`nice`) | Comportament                        |
| ------ | ---------- | ------------ | ----------------------------------- |
| A      |  1024         | Tasques curtes, apareix sovint      |
| B      |  1024         | Processa grans blocs, no interactiu |
| C      |  1024         | Tasques curtes, arriba mÃ©s tard     |

## Limitacions del CFS  {.smaller}

| Temps   | ProcÃ©s actiu | Context                                   |
| ------- | ------------ | ----------------------------------------- |
| 0â€“50ms  | B            | A encara no ha arribat                    |
| 50ms    | A arriba     | A tÃ© vruntime=0, B tÃ© vruntime alt        |
| 50â€“60ms | A            | CFS tria A pel vruntime baix              |
| 60ms    | C arriba     | C tÃ© vruntime=0, A i B tenen vruntime>0   |
| 60â€“70ms | C            | Tria C ara (just, basat en vruntime baix) |
| 70â€“80ms | A            | Torn a A, perÃ²...                         |
| â‹®       | ...          | ...                                       |

## Limitacions del CFS 

- A i C es beneficien nomÃ©s perquÃ¨ arriben tard â†’ `vruntime=0`.
- Els processos interactius que tornen sovint (com A) no sÃ³n tan prioritzats desprÃ©s.
- Pot provocar latÃ¨ncies no Ã²ptimes en sistemes interactius o aplicacions UI.

:::{.center-container .fragment}
El CFS considera nomÃ©s el **temps virtual acumulat**, perÃ² no tÃ© en compte la urgÃ¨ncia o deadlines virtuals de les tasques.
:::

## Del CFS a EEVDF: per quÃ¨ canviar? {.smaller}

Hem vist que el **CFS**:

- Reparteix la CPU de forma **justa i proporcional** al pes (`nice`).
- Utilitza el **`vruntime`** per decidir quin procÃ©s va â€œendarreritâ€.
- MantÃ© els processos ordenats per `vruntime` amb un **arbre Red-Black**.

::: {.fragment}
PerÃ² el CFS tÃ© **limitacions**:

- No modela explÃ­citament **deadlines** ni temps dâ€™espera **desitjats**.
- El comportament amb **workloads interactius** o molt canviants pot tenir
  latÃ¨ncies no Ã²ptimes.
- Ã‰s complicat ajustar-lo a **nous requisits** (jocs, temps real tou, UI molt responsiva).
:::


## EEVDF: una evoluciÃ³ del CFS

Linux introdueix **EEVDF (Earliest Eligible Virtual Deadline First)** com a
evoluciÃ³ de CFS:

- MantÃ© la idea de **temps virtual** i **justÃ­cia**.
- Introdueix el concepte de **deadline virtual** per a cada tasca.
- Prioritza la tasca amb la **deadline virtual mÃ©s urgent** (i *elegible*).

:::{.center-container .fragment}
Ara que entenem bÃ© **pesos** i **`vruntime`**,
podem veure com EEVDF afegeix les **deadlines virtuals** al model.
:::


## QuÃ¨ Ã©s la quota d'un procÃ©s actiu?

La quota d'un procÃ©s $i$ representa la seva fracciÃ³ de temps en comparaciÃ³ amb els altres processos actius:

$$f_i(t) = \frac{w_i}{\sum_{j \in A(t)} w_j}$$

On:

- $w_i$ = pes del procÃ©s $i$ (importÃ ncia relativa).
- $A(t)$ = conjunt de processos actius en el temps $t$.

## QuÃ¨ Ã©s el temps de servei acumulat?

El temps de servei d'un procÃ©s $i$ en un interval $[t_0, t_1]$ Ã©s:

$$S_i(t_0, t_1) = \int_{t_0}^{t_1} f_i(t) dt$$

Aquesta integral representa el temps total que el procÃ©s hauria d'haver rebut segons la seva quota en l'interval de temps especificat. *En un sistema ideal, el temps de servei acumulat hauria de coincidir amb el temps real que el procÃ©s ha estat en execuciÃ³*.

## QuÃ¨ Ã©s la deadline virtual? {.smaller}

El Virtual Deadline (deadline virtual) d'un procÃ©s es defineix com el temps virtual en quÃ¨ un procÃ©s hauria de completar la seva execuciÃ³ segons la seva quota. Per a una solÂ·licitud de servei de durada $r$, la deadline virtual es calcula com:

$$D_i = ve_i + \frac{r_i}{w_i}$$

on:

- $ve_i$ = Temps virtual en quÃ¨ el procÃ©s $i$ esdevÃ© elegible.
- $r_i$ = durada de la solÂ·licitud de servei.
- $w_i$ = pes del procÃ©s.

:::{.center-container .fragment}
El deadline virtual Ã©s una mesura que permet al planificador determinar quins processos han de ser executats primer per a garantir que es compleixin les seves quotes.
:::

## Recordatori: Lag d'un procÃ©s {.smaller}

L'objectiu de l'EEVDF Ã©s mantenir el lag el mÃ©s proper possible a zero per a garantir una assignaciÃ³ justa del temps de CPU.

$$L_i(t) = S_i(t_0, t) - s_i(t_0,t)$$

on:

- $L_i(t)$ = lag del procÃ©s $i$ en el temps $t$.
- $S_i(t_0, t)$ = temps de servei acumulat fins al temps $t$.
- $s_i(t_0, t)$ = temps real d'execuciÃ³ del procÃ©s en l'interval $[t_0, t]$.

:::{ .fragment}
Si:
- $L_i(t) > 0$, el procÃ©s ha rebut menys temps del que li correspondria. 
- $L_i(t) < 0$, el procÃ©s ha rebut mÃ©s temps del que li pertoca. 
:::

## Com funciona l'algorisme EEVDF? {.smaller}

1. AssignaciÃ³ de quotes: Cada procÃ©s rep una quota de temps de CPU proporcional al seu pes.

2. CÃ lcul del temps virtual i deadlines virtuals: Es calcula el temps virtual $V(t)$ i es determina el deadline virtual $D_i$ per a cada procÃ©s.

3. CÃ lcul del lag: Es calcula el lag $L_i(t)$ per a cada procÃ©s, comparant el temps de servei rebut amb el temps de servei esperat.

4. SelecciÃ³ del procÃ©s:

   - Si hi ha processos amb lag positiu, es prioritzen per a garantir que reben el temps de CPU que els falta.
   - Es selecciona el procÃ©s amb el deadline virtual mÃ©s proper per a ser executat.

5. ExecuciÃ³: El procÃ©s seleccionat s'executa fins que es completa la seva quota o fins que es produeix una interrupciÃ³.

## Exemple EEVDF: pas a pas

Tres processos, amb pesos i deadlines virtuals:

| ProcÃ©s | Pes ($w_i$) | Quota | Deadline inicial ($D_i$) |
|--------|-------------|-------|--------------------------|
| **A**  | 10          | 25%   | 3                        |
| **B**  | 20          | 50%   | 1.5                      |
| **C**  | 10          | 25%   | 3                        |

- Suma de pesos: 40
- Quota ideal: A = 25%, B = 50%, C = 25%
- Seleccionem el prcocÃ©s amb la deadline virtual mÃ©s proper i elegible (**B**).

## Interval 1: 0â€“10ms {.smaller}

- El temps virtual $V(t)$ = 0
- Deadline mÃ©s urgent: **B** (D = 1.5)
- Sâ€™executa **B** durant 10ms (1 quÃ ntum)

:::{.fragment}
```text
Temps:    |-------|
ProcÃ©s:     B
V(t):       0 â†’ 0.25
Lag(B):     0 â†’ -5ms
```
:::

- $V(t) = V(0) + \frac{10ms}{\sum w_i} = 0 + \frac{10}{40} = 0.25$
- **Ideal**: $S_B = f_B \cdot \Delta t = 0.5 \cdot 10ms = 5ms$
- **Real**: $s_B = 10ms$
- **Lag**: $L_B = S_B - s_B = 5ms - 10ms = -5ms$
- $V(t)$ augmenta a 0.25 (B tÃ© el 50% de quota).
- El lag de B Ã©s -5ms (ha rebut mÃ©s temps del que li tocava).

  
## Interval 2: 10â€“20ms {.smaller}

- Recalcula $V(t)$: 0.25 â†’ 0.5
- A i C tenen el **mateix deadline (3)**
- Sâ€™ha de triar un: agafem **A** (per FIFO)
  
:::{.fragment}
```text
Temps:    |-------|-------|
ProcÃ©s:     B       A
V(t):       0 â†’ 0.25 â†’ 0.50
Lag(A):     0 â†’ -5ms
```
:::

- $V(t) = V(10) + \frac{10ms}{40} = 0.25 + 0.25 = 0.5$
- **Ideal**: $S_A = f_A \cdot 20ms = 0.25 \cdot 20ms = 5ms$
- **Real**: $s_A = 10ms$
- **Lag**: $L_A = S_A - s_A = 5ms - 10ms = -5ms$


## Interval 3: 20â€“30ms {.smaller}

- $V(t)$: 0.5 â†’ 0.75
- Queda **C** per executar
- C fa un quÃ ntum de 10ms

:::{.fragment}
```text
Temps:    |-------|-------|-------|
ProcÃ©s:     B       A       C
V(t):       0 â†’ 0.25 â†’ 0.5 â†’ 0.75
Lag(C):     0 â†’ -2.5ms
```
:::

- $V(t) = V(20) + \frac{10ms}{40} = 0.5 + 0.25 = 0.75$
- **Ideal**: $S_C = f_C \cdot 30ms = 0.25 \cdot 30 = 7.5ms$
- **Real**: $s_C = 10ms$
- **Lag**: $L_C = S_C - s_C = 7.5 - 10 = -2.5ms$

## Resultats desprÃ©s de 30ms {.smaller}

| ProcÃ©s | ExecuciÃ³ real | Ideal segons quota | Lag final |
|--------|----------------|--------------------|-----------|
| A      | 10ms           | 7.5ms              | -2.5ms    |
| B      | 10ms           | 15ms               | 5ms      |
| C      | 10ms           | 7.5ms              | -2.5ms    |


::: notes
$S_A(30)=0.25 \cdot 30=7.5ms$, $s_A(30)=10ms$ â†’ $L_A(30)=7.5-10=-2.5ms$
$S_B(30)=0.5 \cdot 30=15ms$, $s_B(30)=10ms$ â†’ $L_B(30)=15-10=+5ms$
$S_C(30)=0.25 \cdot 30=7.5ms$, $s_C(30)=10ms$ â†’ $L_C(30)=7.5-10=-2.5ms$
:::

## ComparaciÃ³ CFS vs EEVDF {.smaller}

| CaracterÃ­stica          | CFS                         | EEVDF                       |
|-------------------------|-----------------------------|-----------------------------|
| JustÃ­cia proporcional   | Basada en `nice` i pes   |  Basada en pes i deadlines|
| Temps virtual (`V(t)`)  | SÃ­, com a mÃ¨trica central   | SÃ­, ampliat amb deadline    |
| Deadlines               | No tÃ©                    |  SÃ­, virtuals             |
| Control del `lag`       | ImplÃ­cit, no explÃ­cit     | MÃ¨trica explÃ­cita        |
| Responsivitat           | Bona, perÃ² millorable    |  Millor per interactius    |
| EficiÃ¨ncia computacional| $O(log n)$                    | $O(log n)$                   |
| Casos dâ€™Ãºs Ã²ptims       | Servidors generals          | Temps real, UI, jocs    |
