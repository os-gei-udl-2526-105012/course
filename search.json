[
  {
    "objectID": "slides/01-introduction.html#qui-soc",
    "href": "slides/01-introduction.html#qui-soc",
    "title": "Introducció",
    "section": "Qui soc?",
    "text": "Qui soc?\n\n\nCurrículum\n\nEnginyer i Doctor en Informàtica per la UdL.\n\nDocència\n\nProfessor agregat a la UdL des de 2019.\nSistemes Operatius (GTIDIC, GEI).\nAdministració de Sistemes (GTIDIC, GEI).\nDesenvolupament d’Aplicacions per a dispositus mòvils (GTIDIC).\nCloud Compunting (Master in Health Data Science)\nHigh Performance Computing (Màster en Enginyeria Informàtica)\n\n\nRecerca\n\nMembre del grup de recerca Grup de computació distribuïda des de 2012 (Universitat de Lleida).\nMembre del grup de recerca Essence: Data Engineering & Distributed Computing Systems des de 2022 (Universitat de Glasgow).\nComputació distribuïda: Cloud, Edge i Fog Computing.\nCamps d’aplicació: Salut electrònica i Energia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qui-sou",
    "href": "slides/01-introduction.html#qui-sou",
    "title": "Introducció",
    "section": "Qui sou?",
    "text": "Qui sou?\nQuè us ha portat fins aquí?\n\n\n\n\nPer conèixer-vos una mica millor, m’agradaria que responguéssiu 4 preguntes de forma breu i concisa, que m’ajudaran a entendre les vostres motivacions i expectatives respecte a aquesta assignatura. Us deixo 5 minuts per respondre-les.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#presentació",
    "href": "slides/01-introduction.html#presentació",
    "title": "Introducció",
    "section": "Presentació",
    "text": "Presentació\n\nBenvinguts a Sistemes Operatius\n\n\n\nchar text[] = \"Aquesta NO és una assignatura\\n\\\n      centrada en la  programació\\n\\\n      PERÒ programarem MOLT!\\n\";\nssize_t bytes = write(1, text, sizeof(text) - 1);\n\ntext=\"Aquesta assignatura NO és un MONÒLEG.\" \necho $text\n\n\nVull sessions interactives, participatives,… pregunteu, interrompeu-me…\n\n\n\n\n\nSi bé aquesta assignatura no se centra exclusivament en l’aprenentatge de la programació, la pràctica de codificació serà fonamental. Un sistema operatiu és, en essència, un programa extremadament complex, i per entendre’n el funcionament, cal aprofundir en el seu codi font.\nPer això, la nostra eina principal serà el llenguatge de programació C, ja que és el llenguatge amb què s’han construït sistemes operatius històrics i de referència com Linux i Unix. A més, per comprendre com el codi d’alt nivell es comunica amb el maquinari, és crucial entendre com es tradueix a codi màquina; aquí és on la comprensió del llenguatge Assembler es torna imprescindible.\nTot i que llenguatges més moderns com Rust o Go s’utilitzen cada vegada més en el desenvolupament de sistemes, el C continua sent el pilar sobre el qual es construeix la major part del nostre món digital.\nFinalment, vull que aquestes sessions siguin realment interactives i participatives. Si us plau, no dubteu a interrompre’m i a plantejar qualsevol pregunta o dubte que tingueu en el moment. La meva intenció no és fer un monòleg, sinó crear un diàleg constructiu i col·laboratiu entre tots.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#coneixement-previ-i",
    "href": "slides/01-introduction.html#coneixement-previ-i",
    "title": "Introducció",
    "section": "Coneixement previ (I)",
    "text": "Coneixement previ (I)\nQuin sistema operatiu utilitzeu/coneixeu?\n\n\n\n\nPer començar, m’agradaria saber quin sistema operatiu utilitzeu o coneixeu. Això ens ajudarà a entendre el nivell de familiaritat que teniu amb diferents sistemes i ens permetrà adaptar millor el contingut del curs a les vostres necessitats. Escaneja el codi QR i introdueix les vostres respostes, podeu respondre més d’una opció si coneixeu diversos sistemes operatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-globals",
    "href": "slides/01-introduction.html#objectius-globals",
    "title": "Introducció",
    "section": "Objectius (Globals)",
    "text": "Objectius (Globals)\n\nEntendre els Sistemes Operatius: Com estan dissenyats i quins components (o mòduls) els formen.\nConeixer els seus serveis: Quines funcions proporcionen a usuaris i aplicacions.\nAprendre a programar amb ells: Com utilitzar els serveis del sistema operatiu per crear aplicacions de manera eficient.\nAvaluar críticament les seves polítiques: Analitzar com el sistema operatiu gestiona els seus recursos, com la memòria, i comparar diferents mètodes per fer-ho.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-específics",
    "href": "slides/01-introduction.html#objectius-específics",
    "title": "Introducció",
    "section": "Objectius (Específics)",
    "text": "Objectius (Específics)\n\nConèixer els sistemes operatius Unix/Linux (en concret Debian).\nInterioritza les bases de programació C per millora les vostres habilitats en altres llenguatges.\nDesenvolupar programari a nivell de sistema en el llenguatge de programació C comprenent al mateix temps com funcionen els Sistemes Operatius basats en Unix.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#temari",
    "href": "slides/01-introduction.html#temari",
    "title": "Introducció",
    "section": "Temari",
    "text": "Temari\n\nIntroducció als Sistemes Operatius.\nEstructura dels Sistemes Operatius.\nGestió i comunicació de processos i threads.\nSincronització i Planificador de tasques.\nInterbloqueig.\nGestió de Memòria.\nScripting.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#metodologia",
    "href": "slides/01-introduction.html#metodologia",
    "title": "Introducció",
    "section": "Metodologia",
    "text": "Metodologia\n\nBasada en Aprenentatge SIGNIFICATIU, GUIAT i ACTIU.\n\n\nSessions teòriques: S’introdueixen continguts teòrics de l’assignatura i als estudiants, i també s’hi discuteixen les implicacions pràctiques.\nSessions pràctiques: sessions autoguiades de laboratori, sessions de live coding o resolució de problemes.\nTreball autònom: els estudiants han d’aplicar els coneixements adquirits a les sessions teòriques i pràctiques per acabar els problemes, laboratoris i projectes proposats. A més, han de realitzar les lectures dels apunts i consultar la bibliografia recomanada.\n\n\nLes sessions teòriques i pràctiques estan combinades en les sessions de 3h de durada.\n\n\nLa idea és que no us dediqueu només a memoritzar conceptes, sinó que connecteu la nova informació amb el que ja sabeu. Tot i que a la pràctica fareu moltes coses per vosaltres mateixos, jo seré aquí per guiar-vos. Us donaré les eines, el suport i les indicacions necessàries per anar avançant.Volem que sigueu protagonistes del vostre procés d’aprenentatge. No us limitareu a escoltar-me, sinó que fareu coses, resoldreu problemes i creareu projectes.\n\nSessions teòriques: Aquí introduirem els conceptes clau i els fonaments teòrics. Però no ens quedarem només amb la teoria; també discutirem com s’apliquen aquests conceptes al món real.\nSessions pràctiques: Farem sessions de laboratori on programareu, farem exercicis de live coding junts per resoldre problemes en directe i practicareu les habilitats que necessiteu.\nTreball autònom: La major part de l’aprenentatge real es farà fora de l’aula. Us demanaré que acabeu els laboratoris, resolgueu els exercicis pendents i treballeu en els projectes. També serà important que reviseu els apunts i, si cal, consulteu la bibliografia recomanada.\n\nLes sessions teòriques i pràctiques estaran combinades. La idea és que no hi hagi una desconnexió entre la teoria i la pràctica. Com tenim sessions de 3 hores, podrem dedicar una part a la teoria i l’altra a la pràctica, tot integrat en una sola experiència d’aprenentatge.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#criteris-davaluació",
    "href": "slides/01-introduction.html#criteris-davaluació",
    "title": "Introducció",
    "section": "Criteris d’Avaluació",
    "text": "Criteris d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nAcr.\nActivitat d’avaluació\nPes\nNota mínima\nEn grup\nRecuperable\n\n\n\n\nE1\n1er Parcial\n35%\nNO\nNO\nSI\n\n\nE2\n2on Parcial\n35%\nNO\nNO\nSI\n\n\nP\nPràctiques\n25%\nNO\nSI \\(\\leq 2\\)\nNO\n\n\nPart\nSeguiment i Participació\n5%\nNO\nNO\nNO\n\n\n\n\nAquesta assignatura s’avaluara de forma tradicional mitjançant dos exàmens parcials (E1 i E2) que representen el 70% de la nota final. A més, hi haurà pràctiques que contribuiran amb un 25% a la nota final, i un component de seguiment i participació que valdrà un 5%.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exàmens",
    "href": "slides/01-introduction.html#exàmens",
    "title": "Introducció",
    "section": "Exàmens",
    "text": "Exàmens\nEls exàmens parcials (E1 i E2) són proves escrites que avaluen els coneixements teòrics i pràctics adquirits durant el curs.\n\nSón proves individuals i presencials.\nEs realitzaran en les dates establertes al calendari acadèmic.\nNo es permet l’ús de cap dispositiu electrònic (telèfons mòbils, ordinadors portàtils o tauletes).\nSi es permet l’ús d’un resum de continguts, que ha de ser un document escrit a mà i no pot excedir una fulla DIN A4 (per davant i per darrere).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#recuperació",
    "href": "slides/01-introduction.html#recuperació",
    "title": "Introducció",
    "section": "Recuperació",
    "text": "Recuperació\n\nEls parcials són recuperables mitjançant proves escrites addicionals que es realitzaran durant la setmana de recuperació.\nSi un estudiant necessita recuperar un únic parcial (E1 o E2), podrà fer una prova específica per a aquest parcial. La qualificació obtinguda en aquesta recuperació substituirà la nota del parcial corresponent.\nSi un estudiant necessita recuperar ambdós parcials, haurà de realitzar dues proves separades, una per a cada parcial (E1 i E2). Les qualificacions obtingudes en cadascuna d’aquestes proves de recuperació substituiran les notes originals dels parcials respectius.\nÉs important notar que no hi haurà un model d’examen unificat per a la recuperació; cada prova de recuperació se centrarà exclusivament en els continguts del parcial al qual correspon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#pràctiques",
    "href": "slides/01-introduction.html#pràctiques",
    "title": "Introducció",
    "section": "Pràctiques",
    "text": "Pràctiques\n\nLes pràctiques de l’assignatura impliquen treball fora de l’aula i s’han de lliurar de forma estricta en les dates establertes.\nLa seva avaluació es farà mitjançant rúbriques de correcció, que estaran disponibles per als estudiants amb antelació.\nEl professorat pot entrevistar els estudiants per verificar l’autoria. Si es detecta que una activitat no ha estat realitzada per l’estudiant la seva qualificació serà 0.\nQualsevol entrega fora del termini establert es considerarà no vàlida i es qualificarà amb un 0.\nCadascuna pot tenir una ponderació específica indicada a la descripció de l’activitat.\nAquestes pràctiques no són recuperables.\nTot i ser activitats en grup, cada estudiant pot obtenir una nota diferent en funció de la seva participació i aportacions individuals al grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#seguiment-i-participació",
    "href": "slides/01-introduction.html#seguiment-i-participació",
    "title": "Introducció",
    "section": "Seguiment i Participació",
    "text": "Seguiment i Participació\n\n\n\n\n\n\n\nRúbrica d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nPunts\nParticipació Presencial\nParticipació en Fòrums\nActivitats Sessió\n\n\n\n\n10\nContribucions excepcionals,enriqueix la discussió.\nLíder en discussions, promou debat.\nQualitat excepcional, supera expectatives.\n\n\n9\nComentaris rellevants, mostra comprensió, escolta activament.\nRespostes significatives.\nAlta qualitat, treball precís.\n\n\n8\nContribucions regulars, interactua amb companys.\nPublicacions rellevants, contribueix constructivament.\nCompleix tots requisits amb precisió.\n\n\n7\nParticipa amb una comprensió bàsica.\nCompleix mínims, contribucions breus.\nQualitat inconsistent però acceptable.\n\n\n5-6\nPoca freqüència, comentaris superficials.\nPublicacions rares, poc profundes.\nAlgunes activitats incompletes.\n\n\n1-4\nNomés participa si se li demana.\nPublicacions irrellevants.\nRarament completa activitats.\n\n\n0\nEvita participar, distret.\nPublicacions fora de tema.\nNo lliura activitats.\n\n\n\n\n\n\n\n\nL’assistència passiva no es puntua.\n\n\nAquest component d’avaluació està dissenyat per fomentar la participació activa i el compromís amb l’assignatura. La participació no es limita només a l’assistència a classe, sinó que també inclou la contribució en discussions, fòrums en línia i activitats relacionades amb les sessions. Tota participació ha de ser rellevant i constructiva per ser valorada positivament. En aquesta rúbrica, es detallen els criteris específics que s’utilitzaran per avaluar la participació dels estudiants en diferents àmbits.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-1",
    "href": "slides/01-introduction.html#bonus-1",
    "title": "Introducció",
    "section": "Bonus 1",
    "text": "Bonus 1\n\n\n\nObjectiu: Fomentar la reflexió i l’autoavaluació dels continguts treballats a classe.\nMetodologia: Cada setmana, els estudiants han de fer un commit al seu repositori d’apunts amb les notes de les sessions de teoria i pràctiques.\nAvaluació: Es valorarà la qualitat de les notes, la seva coherència i la seva relació amb els continguts treballats, així com les reflexions i opinions personals incloses.\nPer participar cal crear un repositori a Github (públic) i fer-me arribar l’enllaç.\n\n\n\n\nExemple de Notes\n## Setmana X\n\n# Resum teòric\n\n# Exemples pràctics\n\n# Dubtes i preguntes\n\n# Reflexions personals\n\n\n\n\n\n\n\nNo es permet cap altre forma\n\n\nLes notes han de ser escrites en format Markdown i mantingudes en un repositori Git i Github.\n\n\n\n\n\n\nAquest bonus està dissenyat per incentivar els estudiants a mantenir un registre organitzat i reflexiu dels continguts treballats a classe. En fer un commit setmanal amb les seves notes, els estudiants no només reforcen el seu aprenentatge, sinó que també desenvolupen habilitats de documentació i autoavaluació. La qualitat de les notes serà clau en l’avaluació, ja que es valorarà no només la precisió dels continguts, sinó també la capacitat de reflexionar sobre el que s’ha après i com s’ha aplicat aquest coneixement. Es tracta d’una oportinitat per als estudiants per crear el seu diari d’aprenentatge al llarg del curs. Per participar, els estudiants han de crear un repositori públic a Github i compartir l’enllaç amb el professorat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-2",
    "href": "slides/01-introduction.html#bonus-2",
    "title": "Introducció",
    "section": "Bonus 2",
    "text": "Bonus 2\n\n\n\nEls materials són Open Source.\nQualsevol estudiant pot detectar errors, millorar els materials o afegir continguts nous.\nS’avaluarà la quantitat i qualitat.\n\n\n\n\n\nUn altre bonus que oferim és la possibilitat de contribuir als materials de l’assignatura seguint la metodologia de Open Source. Això significa que qualsevol estudiant pot detectar errors, suggerir millores o afegir continguts nous als materials proporcionats. Per participar, els estudiants poden fer un fork del repositori de l’assignatura, treballar en una branca separada i després obrir una pull request amb les seves propostes de canvi. La quantitat i qualitat de les contribucions seran avaluades, oferint així una oportunitat per als estudiants de participar activament en la millora dels recursos educatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gestió-del-curs",
    "href": "slides/01-introduction.html#gestió-del-curs",
    "title": "Introducció",
    "section": "Gestió del curs",
    "text": "Gestió del curs\n\nEs demana que els estudiants arribin puntuals a les sessions. L’entrada tardana pot interrompre la dinàmica de la classe i el treball dels companys.\nEs demana que els estudiants respectin les normes de convivència i respecte mutu durant les sessions de classe. Això inclou evitar interrupcions innecessàries, escoltar activament als companys i al professor, i mantenir un ambient de treball positiu i constructiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#comunicació-amb-el-professorat",
    "href": "slides/01-introduction.html#comunicació-amb-el-professorat",
    "title": "Introducció",
    "section": "Comunicació amb el professorat",
    "text": "Comunicació amb el professorat\n\nIntenteu comunicar-vos a través del correu electrònic i no per l’eina del campus virtual per assegurar una resposta més ràpida.\nLes sessions de tutoria es realitzaran de manera presencial o virtual, segons les necessitats dels estudiants. És important que els estudiants sol·licitin cita prèvia per a les tutories utilitzant el correu electrònic jordi.mateo@udl.cat indicant el motiu de la consulta i la disponibilitat horària i afegint l’assumpte [SO]: Sol·licitud de Tutoria.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#treball-individual",
    "href": "slides/01-introduction.html#treball-individual",
    "title": "Introducció",
    "section": "Treball individual",
    "text": "Treball individual\n\nCada estudiant és responsable de la seva pròpia feina i de com gestiona el seu temps.\nL’assistència a classe no és obligatòria.\nCada alumne ha de presentar evidències pròpies del treball realitzat, encara que es col·labori en grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#ús-de-la-iag",
    "href": "slides/01-introduction.html#ús-de-la-iag",
    "title": "Introducció",
    "section": "Ús de la IAG",
    "text": "Ús de la IAG\n\nPots utilitzar eines d’IAG per generar idees, entendre conceptes complexos o esbossar l’estructura inicial del teu codi o projecte. No obstant això, la implementació i la versió final han de ser sempre de la teva autoria.\nEstà estrictament prohibit presentar codi o solucions generades directament per una IAG com a treball propi (és a dir, mitjançant un simple copiar i enganxar).\nSi incorpores material assistit per una IAG, has de declarar-ho explícitament. Això implica identificar clarament les seccions generades per IAG i proporcionar el prompt exacte utilitzat per crear-les.\n\n\nL’incompliment d’aquestes directrius es considerarà una violació de la integritat acadèmica.\n\n\nQualificació de zero en la tasca.\nConseqüències disciplinàries que estableix la Normativa de Convivència de la UdL per frau acadèmic.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#eines-necessàries",
    "href": "slides/01-introduction.html#eines-necessàries",
    "title": "Introducció",
    "section": "Eines necessàries",
    "text": "Eines necessàries\n\nOrdinador portàtil amb connexió a Internet.\n\nEs recomana portar el vostre propi ordinador per cursar l’assignatura.\nSi no disposeu d’ordinador, podreu utilitzar els ordinadors de la classe durant les sessions de laboratori.\n\nDistribucions Linux (Debian )\n\nÉs obligatori utilitzar la distribució Debian per a les pràctiques de laboratori.\n\nSoftware de virtualització (VMWare)\n\nEs recomana utilitzar VMWare, però podeu optar per altres opcions de virtualització. Heu de ser capaços d’adaptar el material al vostre programari de virtualització.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#programari-necessari",
    "href": "slides/01-introduction.html#programari-necessari",
    "title": "Introducció",
    "section": "Programari necessari",
    "text": "Programari necessari\nLlenguatges de programació i compiladors\n\nC\nGCC\n\nEines de control de versions\n\nGit\nGithub\n\nIDE\n\nVisual Studio (Recomanat)\nVi, Vim, NeoVim, Emacs, CLion, Eclipse …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#materials-i-recursos",
    "href": "slides/01-introduction.html#materials-i-recursos",
    "title": "Introducció",
    "section": "Materials i Recursos",
    "text": "Materials i Recursos\n\nApunts de l’assignatura i materials proporcionats pel professor.\nDocumentació oficial de les eines i tecnologies utilitzades.\nFòrums tècnics a la xarxa com Stack Overflow, Reddit, etc.\nLlibres de referència en Sistemes Operatius:\n\nOperating System Concepts; Abraham Silberschatz\nModern Operating Systems; Andrew S. Tanenbaum",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bones-pràctiques",
    "href": "slides/01-introduction.html#bones-pràctiques",
    "title": "Introducció",
    "section": "Bones pràctiques",
    "text": "Bones pràctiques\n\nDRY (Do not repeat yourself).\nCodi fàcil de reutilitzar.\nTesteja aviat, testeja sovint, testeja de forma automàtica.\nNo assumeixis res, prova-ho.\nUtilitza assertions per prevenir l’impossible.\nUtilitza excepcions per problemes excepcionals.\nEstima l’ordre de complexitat dels teus algorismes.\nUtilitza patrons de disseny.\nUtilitza eines de control de versions.\n\n\nDurant el curs, us animaré a seguir aquestes bones pràctiques de programació per assegurar que el vostre codi sigui net, eficient i fàcil de mantenir. Aquestes pràctiques no només us ajudaran a desenvolupar millor programari, sinó que també us prepararan per treballar en equips de desenvolupament professionals on aquestes normes són estàndard. Es important que el vostre codi sigui fàcil de llegir i entendre per altres persones, inclòs el vostre jo futur!",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bibliografia-recomanada",
    "href": "slides/01-introduction.html#bibliografia-recomanada",
    "title": "Introducció",
    "section": "Bibliografia recomanada",
    "text": "Bibliografia recomanada\n(per la vida… no pel curs)\n\n\nThe Pragmatic Programmer, Andrew Hunt David Thomas\n\n\n\n\nUs aconsello molt aquests dos llibres. Són llibres que no només us ajudaran en aquest curs, sinó que també us seran útils al llarg de tota la vostra carrera com a desenvolupadors de programari. Aquests llibres ofereixen consells pràctics i principis fonamentals que us ajudaran a escriure codi utiltizant bones pràctiques. Són dos llibres que tot programador hauria de llegir almenys un cop a la vida.\n\nClean Code, (A Handbook of Agile Software Craftsmanship),Robert C. Martin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#societat-actual",
    "href": "slides/01-introduction.html#societat-actual",
    "title": "Introducció",
    "section": "Societat actual",
    "text": "Societat actual\n\n\nQuè tenen en comú?\n\nCotxe\nRellotge\nPortàtil\nRentadora\nNevera\nTelevisió\n…\n\nVivim en un gran sistema paral·lel i distribuït!\n\n\n\n\n\n\nPer començar, m’agradaria que reflexionéssiu sobre què tenen en comú tots aquests dispositius que fem servir en el nostre dia a dia. Des de cotxes fins a rellotges, portàtils, tauletes, rentadores, neveres i televisors, tots aquests aparells semblen molt diferents entre si. Però si mirem més a fons, veurem que tots compartixen dos característiques fonamentals: tots són dispositius electrònics que interactuen amb nosaltres i tots estan connectats a internet. Aquesta connexió a internet és el que els permet comunicar-se entre si i amb nosaltres. Això ens porta a la següent reflexió: vivim en un món on tot està interconnectat, podem dir que vivim en un món distribuït on tots aquests dispositius treballen junts per fer-nos la vida més fàcil i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#món-connectat",
    "href": "slides/01-introduction.html#món-connectat",
    "title": "Introducció",
    "section": "Món connectat",
    "text": "Món connectat\n\nAvui en dia tothom parla de IoT, BigData, Cloud, AI, Blockchain, Metavers\n\n\n\n\nMicroprocessador a tot arreu.\nXarxes i Connectivitat.\nServeis escalables, confiables i segurs.\nGran volum de dades, Sensor i Digitalització.\n\n\n\n\n\nCasa connectada (Font: Extret de SemanticScholar)\n\n\n\n\nLa barrera que separa el món físic i el món virtual cada cop es mes estreta.\n\n\nEn la societat actual es parla constatant de noves tecnologies disruptives com IoT, BigData, Cloud, AI, Blockchain, Metavers,… Per tant, com a societat tenim la capacitat d’interactuar amb el nostre entorn i ambient. Això implica que tenim microprocessadors a tot arreu, disposem de xarxes i connectivitat que ens permeten estar sempre connectats, podem accedir a serveis escalables, confiables i segurs, i gestionem un gran volum de dades gràcies a la digitalització i els sensors.\nAra, pensem un moment en el nostre dia a dia: - Quants teniu un cotxe? Quants processadors creieu que té un cotxe? - Més de 50! - Qui utilitza un smartphone? Quants processadors/cores té el vostre smartphone? - El meu un Poco X4 GT té un MediaTek Dimensity 8100 amb 8 nuclis.\nLa capacitat de computació està present a tot arreu, i la majoria dels dispositius que utilitzem diàriament estan equipats amb microprocessadors que funcionen de manera paral·lela i interactuen entre ells. Per tant, el món físic i el món virtual estan cada cop més interconnectats, i la barrera que els separa es fa cada cop més estreta.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-tenen-en-comú-1",
    "href": "slides/01-introduction.html#què-tenen-en-comú-1",
    "title": "Introducció",
    "section": "Què tenen en comú?",
    "text": "Què tenen en comú?\n\nUna interfície (Sistema Operatiu) capaç d’integrar una gran diversitat de maquinari i programari i comunicar-se a través de la xarxa.\n\n\n\n\n\nPerò, que tenen en comú aquests progressos tecnològics? Requereixen un cervell que permeti a tots els diferents aparells i màquines interactua amb nosaltres, tant per generar, processar o guardar. Tots els dispositius i servidors requereixen un sistema operatiu que permeti maquinari i programari comunicar-se.\nEn aquest curs tractarem els cervells d’aquests sistemes i analitzarem de quines estructures podem dotar aquests sistemes perquè funcionin correctament i permeti que maquinari tan heterogeni sigui capaç de fer funcionar infinitat de programes i serveis per gestionar eficientment les dades i la informació del nostre entorn.\nPer tant, a la pregunta inicial què tenen en comú? podem afirmar:\n\nTenen en comú que tots són sistemes informàtics.\nTots tenen un sistema operatiu.\nTots es communiquen per internet amb altres sistemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-bell",
    "href": "slides/01-introduction.html#llei-de-bell",
    "title": "Introducció",
    "section": "Llei de Bell",
    "text": "Llei de Bell\n\n\n\n\nEs pot observar com la mida i les classes de computadors han evolucionat cada 10 anys. Venim de la dècada dels anys 60 i 70, on es van desenvolupar els primers microprocessadors i la informàtica personal estava en les seves primeres etapes. En aquesta època, es feien servir pocs processadors que eren compartits per moltes persones. Els avanços en la capacitat de processament eren més lents, i la tecnologia era més limitada. Ara, en l’actualitat, cada persona fa servir molts processadors de manera habitual. Això es deu a l’augment de la potència de processament dels dispositius que utilitzem, com els telèfons intel·ligents i les tauletes, així com als ordinadors personals i altres tecnologies. Venim de pocs processadors fets servir per a moltes persones (anys 60-70) i ara cada persona fa servir molts processadors. Com ha canviat la tendència… on ens portarà el futur?",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-moore",
    "href": "slides/01-introduction.html#llei-de-moore",
    "title": "Introducció",
    "section": "Llei de Moore",
    "text": "Llei de Moore\n\n\n\n\nUs recordeu la llei de Moore? Aquesta llei, formulada per Gordon Moore el 1965, predia que el nombre de transistors en un microprocessador es duplicaria aproximadament cada dos anys, cosa que implicava un augment exponencial de la potència de càlcul dels ordinadors. Aquesta predicció s’ha mantingut sorprenentment precisa durant dècades, impulsant avanços tecnològics i transformant la manera com vivim i treballem. No obstant això, a mesura que ens acostem als límits físics de la miniaturització dels transistors, hi ha un debat continu sobre si aquesta tendència continuarà en el futur o si necessitarem noves tecnologies per mantenir el ritme d’innovació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-un-sistema-informàtic",
    "href": "slides/01-introduction.html#què-és-un-sistema-informàtic",
    "title": "Introducció",
    "section": "Què és un sistema informàtic?",
    "text": "Què és un sistema informàtic?\nUn sistema informàtic és la interconnexió d’elements de maquinari per exemple d’1 o més CPU, memòria i components E/S … Amb la finalitat d’executar programes i accions (en sèrie o de forma concurrent) per 1 o múltiples usuaris.\n\n\n\n\n\n\n\nSi us recordeu d’Estructura de Computadors, un sistema informàtic és la interconnexió d’elements de maquinari com ara una o més CPU, memòria i components d’entrada/sortida. Tenim els registres, la memòria cau, la memòria principal, els dispositius d’entrada/sortida i els canals de comunicació que permeten que tots aquests components treballin junts per executar programes i accions.\nCom heu vist el mon real actua com un gran sistema paral·lel. Per tant, tots els sistemes de temps real son inherentment concurrents i lògicament els nostres sisteme informàtics també han de poder actuar en paral·lel. En la figura, podeu observar com una tasca es descomposa en diferents parts per poder aprofitar els diferents processadors i nuclis de cada processador.L’execució concurrent recull un conjunt de tècniques informàtiques usades per representar i gestionar el paral·lelisme i les eines de sincronització i comunicació entre programes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gestió-dun-sistema-informàtic-i",
    "href": "slides/01-introduction.html#gestió-dun-sistema-informàtic-i",
    "title": "Introducció",
    "section": "Gestió d’un sistema informàtic (I)",
    "text": "Gestió d’un sistema informàtic (I)\n\nImagineu que sou un sistema informàtic i us envien l’ordre de llegir un fitxer\n\n\nQuin és el procediment per fer aquesta acció?\n\nEngegar motor del disc.\nBuscar posició al disc a llegir (pista, cara, sector).\nLlegir.\nApagar el motor.\n\nQuantes vegades com a usuaris d’un sistema informàtic llegiu un fitxer?\n\n\nMoltes vegades…!\n\n\nCom a usuaris d’un sistema informàtic llegim fitxers moltes vegades al dia. Per exemple, quan obrim un document de text, una imatge, un vídeo o qualsevol altre tipus d’arxiu, el sistema operatiu ha de llegir aquest fitxer des del disc dur o una altra unitat d’emmagatzematge. Però, us heu preguntat alguna vegada quin és el procediment que segueix el sistema informàtic per llegir aquest fitxer? Hauriam d’engegar el motor del disc, buscar la posició correcta al disc on es troba el fitxer, llegir les dades i finalment apagar el motor. Té sentit que un usuari cada cop que llegeix un fitxer hagi de tenir en compte aquest procediment i realitzar-lo de forma rutinària? Necessitem un programari que ens permeti efectuar accions rutinàries de forma automàtica i transparent a l’usuari. Si no els sistemes informàtics no serien usables.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-i",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-i",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (I)",
    "text": "Complexitat sistemes informàtics (I)\n\nCada peça de hardware és diferent. \\(\\Rightarrow\\) La complexitat per gestionar els recursos és molt elevada.\n\n\nArquitectures diferents de processadors i també de generacions (x86, ARM, RISC-V, MIPS, PowerPC,…).\nDiferents tipus de memòries (RAM DDR3, DDR4, DDR5, NAND,…).\nDiferents tipus de discs (HDD, SSD, NVM…).\nDiferents dispositius entrada/sortida.\nDiferents entorns de xarxa.\n\n\n… entre moltes altres …\n\n\nUs imagineu haver d’escriure software per cada permutació d’elements diferents del sistema informàtic? Això seria un desastre… Quantes permutacions de diferents components podem tenir avui en dia? OMG! Necessitem alguna cosa que ens permeti superar aquest obstacle de forma intel·ligent i ens permeti desenvolupar software de forma independent al hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-iii",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-iii",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (III)",
    "text": "Complexitat sistemes informàtics (III)\nTots els programes necessiten accedir a tot el hardware?\n\nPer suposat que no! Això podria causar problemes de seguretat com:\n\nPèrdua de confidencialitat: Accés no autoritzat a dades sensibles.\nAccés a informació restringida: Usuaris no autoritzats podrien veure dades privades.\nDenegació de serveis: Un programa podria bloquejar l’accés a recursos per a altres programes.\n\n\n\nQuè pot passar si un programa pot accedir a tota la RAM?\n\n\nUn programa de l’usuari Jordi amb accés a tota la RAM podria veure les dades del programa de l’usuari Pere.\nSi el programa falla, podria afectar tot el sistema i requerir un reinici.\n\n\nNo, clar que no! Seguretat: - Si un programa controla tot el sistema, els altres no poden accedir-hi (Denegació de serveis). - Diferents usuaris poden tenir diferents dades; si un programa pot accedir a tot, podria veure informació restringida. - No necessitem accés a tot el hardware per realitzar les nostres tasques. - Un usuari malintencionat podria danyar el sistema amb un procés defectuós.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-iv",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-iv",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (IV)",
    "text": "Complexitat sistemes informàtics (IV)\nSi un sistema informàtic no està ben dissenyat, un programa mal escrit pot fer fallar tot el sistema, per exemple:\nBucle infinit\nint main(){\n    while(1);\n}\nFork bomb\nint main(){\n    while(1);\n    fork();\n}\n\nUn programa o procés pot fer fallar tot el sistema si no està ben dissenyat. Per tant, és important tenir en compte aquelles situacions per evitar-les. En el primer exemple, tenim un bucle infinit. Aquesta situació en els sistemes linux actuals no és un problema, ja que el sistema operatiu pot gestionar aquest tipus de situacions. No obstant això, en sistemes més antics, aquest tipus de bucles podrien fer que el sistema no respongués. En el segon exemple, tenim un bucle infinit i una crida a la funció fork(). Aquesta funció crea un nou procés que és una còpia exacta del procés pare. Això podria fer que el sistema es saturés amb molts processos i no pogués respondre. Aquesta situació podria requerir un reinici del sistema per recuperar-lo i es un problema en els sistemes actuals. Fixeu-vos com un simple programa pot fer fallar tot el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-un-sistema-operatiu",
    "href": "slides/01-introduction.html#què-és-un-sistema-operatiu",
    "title": "Introducció",
    "section": "Què és un sistema operatiu?",
    "text": "Què és un sistema operatiu?\nUn sistema operatiu (SO) és una capa de software que permet la comunicació i la gestió del maquinari habilitant als usuaris l’execució de programes. El SO actua d’intermediari (interfície) entre els usuaris i el maquinari.\n\n\nUn sistema operatiu (SO) és una capa de software que permet la comunicació i la gestió del maquinari habilitant als usuaris l’execució de programes. El SO actua d’intermediari (interfície) entre els usuaris i el maquinari.\nPer tant, és un programa que controla el maquinari i permet als usuaris interactuar amb ell. Aquesta interacció pot ser a través d’una interfície gràfica d’usuari (GUI) o una interfície de línia de comandes (CLI). També, gestiona els recursos del sistema, com la memòria, el disc dur i els dispositius d’entrada/sortida. A més, el SO proporciona funcionalitats com la gestió de fitxers, la seguretat i la xarxa.\nPodem dir que el SO és el cervell del sistema informàtic,ja que controla tots els components i permet als usuaris interactuar amb ells. Sense un SO, els usuaris no podrien utilitzar el maquinari del sistema de manera eficient i segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-volen-els-programadors",
    "href": "slides/01-introduction.html#què-volen-els-programadors",
    "title": "Introducció",
    "section": "Què volen els programadors?",
    "text": "Què volen els programadors?\n\n\nUna plataforma…\n\nper executar aplicacions.\ntransparent per evitar la complexitat del hardware.\neficient per utilitzar els recursos de forma òptima.\nportable per utilitzar-ho indepedentment del hardware.\n\n\n\n\n\nDes del punt de vista dels programadors, el que volen és una plataforma per executar les seves aplicacions. Aquesta plataforma ha de ser transparent per evitar la complexitat del hardware, eficient per utilitzar els recursos de forma òptima i portable per utilitzar-ho indepedentment del hardware.El kernel és la capa intermèdia que connecta el programari de l’usuari amb el maquinari físic de l’ordinador. A la imatge es pot veure com el kernel actua com un pont entre l’aplicació i el maquinari. Quan un programador escriu una aplicació, no necessita preocupar-se per com funciona el maquinari a nivell de circuits. En canvi, pot utilitzar les funcions proporcionades pel kernel per interactuar amb el maquinari de manera més senzilla i eficient. Els usuaris finals també es beneficien d’aquesta abstracció, ja que poden utilitzar aplicacions sense necessitat de conèixer els detalls tècnics del maquinari. El kernel permet que el mateix codi pugui funcionar en diferents ordinadors amb maquinari diferent. Un programador pot escriure una aplicació (com un navegador web) una sola vegada, i el kernel s’encarregarà de traduir les seves instruccions per al maquinari específic de cada màquina. També gestiona de manera eficient els recursos del sistema, com el temps de processador, l’ús de la memòria o l’accés al disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-ofereix-el-sistema-operatiu",
    "href": "slides/01-introduction.html#què-ofereix-el-sistema-operatiu",
    "title": "Introducció",
    "section": "Què ofereix el sistema operatiu?",
    "text": "Què ofereix el sistema operatiu?\n\n\nServeis\n\nControlar/Gestionar usuaris i aplicacions.\nGestionar la Memòria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n\n\nGaranties\n\nSeguretat.\nTransparència.\nEficiència.\nPortabilitat.\nEstabilitat al llarg del temps.\n\n\n\n\n\n\nObserveu que el kernel ens ofereix una interfície d’usuari amb serveis com el sistema de fitxers, la gestió de la memòria, la planificació de processos i les eines de xarxa. I per sota d’aquestes capes, tenim els drivers que ens permeten interactuar amb el maquinari físic de l’ordinador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "href": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "title": "Introducció",
    "section": "Com s’organitza el sistema operatiu?",
    "text": "Com s’organitza el sistema operatiu?\n\n\n\n\n\n\nMaquina virtual\nÉs la visió que té l’usuari del sistema operatiu durant una sessió de treball.\n\nDualitat\nEl sistema operatiu divideix el programari que té tots els privilegis(kernel) del programari que no pot accedir a tots els recursos (programes, llibreries, intèrpret de comandes,…).\n\n\n\nAquest concepte descriu la visió que tenim nosaltres, els usuaris, del sistema. Quan treballem amb un ordinador, veiem una interfície amigable: icones, finestres, aplicacions. Aquesta és la màquina virtual que el sistema operatiu ens crea. És una capa abstracta que simplifica les tasques complexes del maquinari i ens permet centrar-nos en el nostre treball. Penseu-hi com una il·lusió: l’OS ens amaga la complexitat del maquinari i ens mostra una versió simplificada, fàcil de gestionar.\nSota aquesta interfície amigable hi ha un principi de seguretat fonamental. El sistema operatiu divideix el programari en dos grans grups per qüestions de seguretat i estabilitat. El nucli del sistema operatiu, amb accés total al maquinari, i és responsable de la gestió de recursos. Penseu-hi com el cervell de l’ordinador, que pren totes les decisions importants. La resta de programari, com les aplicacions que utilitzem diàriament, té accés limitat als recursos del sistema. Durant una sessió de treball, el sistema operatiu canvia entre aquests dos modes segons sigui necessari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-una-màquina-virtual",
    "href": "slides/01-introduction.html#què-és-una-màquina-virtual",
    "title": "Introducció",
    "section": "Què és una Màquina Virtual?",
    "text": "Què és una Màquina Virtual?\nLa virtualització presentar una visió abstracta dels recursos del sistema. Diversos processos creuen (tenen l’il·lusió) de disposar sempre d’un conjunt de recursos (màquinaria).\n\nSimplicitat Il·lusió de propietat de recursos\nAïllament Els bugs es donen en un entorn virtual i no físic.\nProtecció Els processos no es poden fer mal entre ells.\nPortabilitat Podem executar a totes les plataformes.\n\n\nImagineu-vos que organitzem una LAN-party amb assistents, però només hi ha 1 pizza per alimentar-los. Com podem mostrar a cada un el seu propi tros de pizza i mantenir-los compromesos amb el nostre esdeveniment. Fàcil, creem 1 pizza virtual basada en la pizza real i donem a cada encarregat un tros de pizza virtual. Però, aquí ve un problema si tots els assistents mengen la pizza alhora, no funcionarà, alguns participants notarien el truc. Tanmateix, si programem els esdeveniments perquè molts participants s’ocupin de les activitats i no mengin la pizza, els organitzadors poden intercanviar en temps real la pizza real i la virtual a les taules on els participants descansen, perquè són els únics candidats a menjar i descobrir el truc, així que Si mengen, la pizza ha de ser real.Java té un sandbox que permet utilitzar el Java independentment d’on executem.VirtualBox i VMWare ens permeten executar sistemes operatius dins de sistemes operatius. Tenim un sistema operatiu amfitrió (màquina física) i un o més sistemes operatius virtuals (hostes).També és possible virtualitzar sobre el hardware sense la necessitat d’un sistema operatiu (amfitrió).També tenim virtualització per contenidors (Docker).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#models-de-virtualització-dalt-nivell",
    "href": "slides/01-introduction.html#models-de-virtualització-dalt-nivell",
    "title": "Introducció",
    "section": "Models de Virtualització d’alt nivell",
    "text": "Models de Virtualització d’alt nivell\n\n\n\nVirtualització Nativa: Hipervisor s’executa directament sobre el maquinari físic sense cap sistema operatiu intermedi. Exemples d’aquesta tecnologia inclouen VMware ESXi o Microsoft Hyper-V. Això ofereix un rendiment molt elevat, ja que no hi ha cap capa addicional entre el maquinari i l’hipervisor, ideal per a entorns de producció.\nVirtualització Allotjada: Hipervisor s’executa sobre un sistema operatiu ja existent. Per exemple, en KVM, s’utilitza Linux com a sistema operatiu base, i sobre aquest es creen les màquines virtuals.\nParavirtualització: El sistema operatiu convidat sap que està sent virtualitzat i coopera amb l’hipervisor per millorar el rendiment. Un exemple destacat és Xen, que és molt utilitzat en entorns cloud per la seva eficiència.\nVirtualització Assistida per Hardware: Aquest model aprofita les capacitats del processador per accelerar el procés de virtualització. Processadors moderns com els d’Intel (VT-x) o AMD (AMD-V) ofereixen suport per a aquest tipus de virtualització (VMware o Hyper-V).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-la-memòria-virtual",
    "href": "slides/01-introduction.html#què-és-la-memòria-virtual",
    "title": "Introducció",
    "section": "Què és la Memòria Virtual?",
    "text": "Què és la Memòria Virtual?\n\nLa memòria virtual permet que cada procés tingui la il·lusió que té accés exclusiu a l’espai complet d’adreces de memòria del processador.\nEn realitat els processos utilitzen diferents regions de la memòria de l’ordinador, amb algunes regions traslladades al disc si no hi ha prou memòria per a tothom.\n\n\nLa unitat de gestió de memòria (MMU) d’un processador, que tradueix les adreces virtuals utilitzades pel programa en adreces físiques que representen ubicacions de memòria reals.\n\n\nUn exemple de virtualització és la memòria virtual. La memòria virtual és una tècnica que permet als sistemes operatius utilitzar la memòria de manera més eficient i segura. Aquesta tècnica crea una il·lusió per als processos que els fa creure que tenen accés exclusiu a l’espai complet d’adreces de memòria del processador. En realitat, els processos utilitzen diferents regions de la memòria de l’ordinador, amb algunes regions traslladades al disc si no hi ha prou memòria per a tothom. Aquesta tècnica permet que els processos s’executin de manera aïllada, evitant que un procés pugui accedir a la memòria d’un altre procés. Això és important per garantir la seguretat i la estabilitat del sistema. La unitat de gestió de memòria (MMU) d’un processador és la responsable de traduir les adreces virtuals utilitzades pel programa en adreces físiques que representen ubicacions de memòria reals. Aquesta traducció es fa mitjançant taules de pàgines que mapejen les adreces virtuals a les adreces físiques. Aquest procés l’estudiarem més endavant en detall.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-i",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-i",
    "title": "Introducció",
    "section": "Quins són els rols SO? (I)",
    "text": "Quins són els rols SO? (I)\nIl·lusionista\nOfereix una interfície simple i fàcil d’utilitzar per als recursos físics d’una màquina o sistema, ocultant la complexitat tècnica.\n\n\n\n\n\n\n\nExemple\n\n\nPermet als usuaris utilitzar una impressora (hardware) sense conèixer els detalls tècnics d’aquesta impresora, com la interfície de comunicació, els controladors o els protocols de comunicació, disposem d’una funció (imprimir) que ens permet enviar un document a la impressora.\n\n\n\n\n\nEl sistema operatiu actua com un il·lusionista que ens ofereix una interfície simple i fàcil d’utilitzar per als recursos físics d’una màquina o sistema, ocultant la complexitat tècnica. Per exemple, quan utilitzem una impressora, no necessitem conèixer els detalls tècnics d’aquesta impressora, com la interfície de comunicació, els controladors o els protocols de comunicació. En canvi, podem utilitzar una funció simple com “imprimir” que ens permet enviar un document a la impressora sense preocupar-nos pels detalls tècnics. Això fa que l’ús de la tecnologia sigui més accessible i fàcil per als usuaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-ii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-ii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (II)",
    "text": "Quins són els rols SO? (II)\nIl·lusionista\nProporciona una abstracció que permet a una aplicació tenir ús exclusiu dels recursos quan sigui necessari, sense interferències d’altres aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nPermet utilitzar un programa de videoconferència que utilitza la càmera i el micròfon i ens garantitza que cap altre programa pugui utiltizar-los al mateix temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-iii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-iii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (III)",
    "text": "Quins són els rols SO? (III)\nIl·lusionista\nOferir una il·lusió d’infinitat per als recursos de maquinari, assegurant que les aplicacions puguin continuar funcionant sense problemes.\n\n\n\n\n\n\n\nExemple\n\n\n\nPermet a un usuari tenir múltiples aplicacions obertes alhora, tot i que només una estigui en primer pla.\n\nCrea una il·lusió on cada procés creu que és propietari dels recursos hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-v",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-v",
    "title": "Introducció",
    "section": "Quins són els rols SO? (V)",
    "text": "Quins són els rols SO? (V)\nÀrbitre\nResponsable de distribuir els recursos disponibles entre usuaris i aplicacions de manera eficient i justa.\n\n\n\n\n\n\n\nExemple\n\n\nUn sistema amb múltiples usuaris, el temps de processador s’ha de repartir de manera equitativa entre tots els usuaris que executen aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-vi",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-vi",
    "title": "Introducció",
    "section": "Quins són els rols SO? (VI)",
    "text": "Quins són els rols SO? (VI)\nÀrbitre\nGaranteix la segregació i la protecció d’usuaris i aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nImpedint que una aplicació bloquegi o afecti el funcionament d’altres aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-vii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-vii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (VII)",
    "text": "Quins són els rols SO? (VII)\nPega\nProporciona un conjunt de serveis i funcionalitats comunes que poden ser compartits i reutilitzats per diverses parts d’un sistema.\n\nCompartició: Simplifica \\(\\Rightarrow\\) s’assumeixen sempre les mateixes primitives bàsiques.\nReutilització: Evita torna a implementar funcionalitats comunes. Permet evolucionar de forma independent els components.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#el-sistema-de-fitxers",
    "href": "slides/01-introduction.html#el-sistema-de-fitxers",
    "title": "Introducció",
    "section": "El Sistema de Fitxers",
    "text": "El Sistema de Fitxers\nUn exemple de la funció de pega del sistema operatiu és el sistema de fitxers:\n\nProporciona una interfície estàndard per a la creació, lectura, escriptura i eliminació de fitxers de format transparent (read, write, open, close, …)\nEns permet implementar libc que proporciona funcions d’entrada/sortida d’alt nivell (fopen, fread, fwrite, fclose, …)",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-i",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-i",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (I)",
    "text": "Anàlisi: Què fa aquest programa? (I)\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog H\n\nH  H  …\n\n\n./prog H & ./prog O\n???",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (II)",
    "text": "Anàlisi: Què fa aquest programa? (II)\n\n\nEn primer lloc, el programa c s’ha de compilar amb un compilador i enllaçar amb les llibreries del sistema que ens proporciona el sistema operatiu.\nUn cop tenim un executable, si l’executem el sistema operatiu crearà una estructura anomenada procés on es guardarà un identificador, un espai de memòria,… aquesta estructura és una de les abstraccions essencials per la funció d’il·lusionisme.\nFixeu-vos que el mateix programa pot ser executat dos cops i el sistema operatiu generarà 2 processos diferents. Amb identificadors diferents i espai de memoria diferent.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (III)",
    "text": "Anàlisi: Què fa aquest programa? (III)\n\n\nPer tant, el sistema operatiu utilitzant el planificador assignarà el processador (assumimim que només tenim 1 core) a 1 procés durant un temps determinat i anirà intercanviant (canvi de context) aquest procés cada X temps, d’aquesta manera cada procés creu tenir tots els recursos per ells (il·lusió).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iv",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iv",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (IV)",
    "text": "Anàlisi: Què fa aquest programa? (IV)\n\n\nPer fer-ho, el sistema operatiu guardà una foto de l’estat actual del procés a memòria i la recuperarà més endavant quan li torni a donar dret d’execució.\nNoteu també que s’ha creat en mèmoria una subregió independent per cada procés. Quan un procés intenta accedir una zona de memòria forà de la seva subregió o inexistent es dona el famós SEGMENTATION FAULT.\nCom en l’últim exemple on el procés intenta accedir a una zona de memòria que no li pertany. Això és una de les funcions de protecció que ens ofereix el sistema operatiu. Al llarg del curs veurem amb més detall com funcionen tots aquests mecanismes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-v",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-v",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (V)",
    "text": "Anàlisi: Què fa aquest programa? (V)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\nDepenen de la prioritat dels procesesos A o B poden tenir més temps de CPU que l’altre i sortir els missatges de forma desordenada.\n./prog H & ./prog O\n\n\n\n\nH  H  H  …\n\nH  O  H  …\n\nO  O  H  …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vi",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vi",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VI)",
    "text": "Anàlisi: Què fa aquest programa? (VI)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\n?????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VII)",
    "text": "Anàlisi: Què fa aquest programa? (VII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \nchar *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\nSegmentation Fault  O  O  …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-viii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-viii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VIII)",
    "text": "Anàlisi: Què fa aquest programa? (VIII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\n./prog1\n\n(611) p: 0x5570014a02a0\n(611) p: 1\n(611) p: 2\n(611) p: 3\n(611) p: 4\n\n\n./prog1 & ./prog1\n????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ix",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ix",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (IX)",
    "text": "Anàlisi: Què fa aquest programa? (IX)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\nAquest programa crea un procés que reserva memòria dinàmica per a un enter i imprimeix l’adreça de memòria i el valor de l’enter en un bucle infinit. Si executem aquest programa dues vegades en paral·lel, cada procés tindrà la seva pròpia còpia de la variable p i, per tant, les adreces de memòria seran diferents. Això és gràcies a la memòria virtual que ens proporciona el sistema operatiu, que aïlla els processos entre si i els permet utilitzar les mateixes adreces de memòria sense interferir-se. El %p en la funció printf s’utilitza per imprimir l’adreça de memòria en format hexadecimal veure més informació sobre els especificadors de format en C a printf.\n\n./prog1 & ./prog1\n(611) p: 0x5570014a02a0\n(612) p: 0x5570014a02a0\n(611) p: 1\n(612) p: 1\n(611) p: 2\n(612) p: 2\n\n\n\n\n\n\n\nExplicació\n\n\nLes adreçes virtuals protegeixen els processosos entre ells i permeten que tots dos processos puguin fer servir la mateixa adreça sense afectar-se.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "title": "Introducció",
    "section": "Reptes en el disseny dels SO (I)",
    "text": "Reptes en el disseny dels SO (I)\n\nComplexitat de la programació distribuïda (concurrent i paral·lela).\nComplexitat pel context (mòbil, IoT, servidors, centres de dades, …).\nComplexitat per la gran varietat d’elements de maquinari (heterogeneïtat).\nComplexitat en la portabilitat i la compatibilitat.\nEquilibri entre funcionalitat i rendiment.\nEquilibri entre rendiment i ús d’energia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "title": "Introducció",
    "section": "Reptes en el disseny dels SO (II)",
    "text": "Reptes en el disseny dels SO (II)\n\nMaximitzar la fiabilitat: Els sistemes han de fer el que estan dissenyats per fer en tots els casos, fins i tot en cas d’errors inesperats.\nMaximitzar la disponibilitat: Els sistemes han d’estar disponibles per a l’ús quan els usuaris ho necessiten, minimitzant el temps d’aturada i reparació causat per fallades.\nSeguretat: Els sistemes han de protegir-se contra accions malicioses i accidents involuntaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "title": "Introducció",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nVehicle\n\nUn vehicle autònom ha de ser segur per als passatgers i per a la gent que hi ha al seu voltant. Ha de garantir que el vehicle no es pugui controlar de forma remota per un atacant. També ha de ser tolerant a fallades i recuperar-se d’errors sense posar en perill la seguretat dels passatgers.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "title": "Introducció",
    "section": "Reptes en el disseny dels so (III)",
    "text": "Reptes en el disseny dels so (III)\n\nEscalables: Els sistemes han de funcionar bé quan s’afegeixen recursos (usuaris, processos, …) o quan es redueixen.\nMantenibles: Els sistemes han de ser fàcils de mantenir i evolucionar al llarg del temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "title": "Introducció",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nTelèfon mòbil\n\nEscalable perquè el nombre d’usuaris pot augmentar molt ràpidament.\nMantenible perquè els usuaris esperen actualitzacions periòdiques del sistema operatiu.\nA més a més, aquestes actualitzacions s’han de poder instal·lar de forma transparent i sense afectar el funcionament del telèfon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-què-estudiar-so-i",
    "href": "slides/01-introduction.html#per-què-estudiar-so-i",
    "title": "Introducció",
    "section": "Per què estudiar SO? (I)",
    "text": "Per què estudiar SO? (I)\n\nSón la base dels sistemes informàtics. (IoT, Servidors, Mòbils, PC, …).\nEns permeten entendre com funciona realment un sistema informàtic.\nEls conceptes són aplicables a altres sistemes i problemes quotidians (planificació de tasques).\nOptimitzar el rendiment de les aplicacions.\nCompendre les vulnerabilitats, proteccions i mitigacions de riscos de seguretat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-què-estudiar-so-ii",
    "href": "slides/01-introduction.html#per-què-estudiar-so-ii",
    "title": "Introducció",
    "section": "Per què estudiar SO? (II)",
    "text": "Per què estudiar SO? (II)\n\n\nLa comprensió en les decisions de disseny dels sistemes operatius i el raonament sobre els pros/contra us permetrà rescatar idees obsoletes que poden ser útils en el futur dels nous sistemes informàtics.\n\n\nEn particular, sovint passa que un canvi en la tecnologia fa que alguns idea obsoleta i ràpidament desapareix. No obstant això, un altre canvi tecnològic podria tornar-lo a reviure. Això és especialment cert quan el canvi té a veure amb el rendiment relatiu de les diferents parts del sistema. Per exemple, quan les CPUs es van fer molt més ràpides que les Memòries les caches van gaunyar molta importancia, però que passa si en un futur les memòries són molt més ràpides que les CPUs? En aquest cas, les caches ja no serien necessàries. En biologia, l’extinció és per sempre, però en informàtica, de vegades només és per uns quants anys.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#conclusions",
    "href": "slides/01-introduction.html#conclusions",
    "title": "Introducció",
    "section": "Conclusions",
    "text": "Conclusions\n\nEls sistemes operatius estan presents en tots els dispositius que fem servir.\nEl disseny es complex i requereix integrar dispositius diferents (forma,espai,temps).\nEns proporciones una il·lusió d’una màquina virtual infinita.\nÉs il·lusionista, árbrit i proporciona un conjunt de serveis comuns per permetre la interacció entre programari i maquinari.\nTé cura del rendiment, seguretat, portabilitat i fiabilitat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#això-és-tot-per-avui",
    "href": "slides/01-introduction.html#això-és-tot-per-avui",
    "title": "Introducció",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nPreguntes?\n\nTAKE HOME MESSAGE\nEls sistemes operatius ajuden als programadors a desenvolupar programari robust de forma independent del maquinari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html",
    "href": "labs/01-introduction/lab01.html",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "",
    "text": "Instal·lar el programari de virtualització VMWare Workstation Pro o VMWare Fusion.\nInstal·lar una màquina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#objectius",
    "href": "labs/01-introduction/lab01.html#objectius",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "",
    "text": "Instal·lar el programari de virtualització VMWare Workstation Pro o VMWare Fusion.\nInstal·lar una màquina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installació-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "href": "labs/01-introduction/lab01.html#installació-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Instal·lació del Hypervisor (VMWare Workstation Pro o VMWare Fusion)",
    "text": "Instal·lació del Hypervisor (VMWare Workstation Pro o VMWare Fusion)\nAquestes instruccions et guiaran a través del procés per crear un compte a Broadcom i descarregar una de les versions gratuïtes de VMware Workstation Pro (per a Windows) o VMware Fusion (per a macOS).\n\nRegistra’t per a un compte gratuït a Broadcom: Per accedir a les descàrregues de programari de VMware, necessites un compte a la plataforma de Broadcom.\n\nDirigeix-te a la pàgina de registre de Broadcom: https://profile.broadcom.com/web/registration\nIntrodueix la teva adreça de correu electrònic, realitza la verificació de seguretat i fes clic a Next \nIntrodueix el codi de verificació que has rebut al teu correu electrònic. Fes clic a Verify per continuar. \nCompleta el formulari de registre amb la teva informació personal i crea una contrasenya. Fes clic a Create Account per completar el registre. \nUn cop completat el registre, visualitzaràs un missatge de registre correcte. I us demanarà si voleu completar el perfil. Seleccioneu, I will do it later per continuar. \n\nAccedeix a les descàrregues gratuïtes de VMware:\n\nVes a la pàgina de login de Broadcom: https://profile.broadcom.com/web/login\nInicia sessió amb el teu correu electrònic i la contrasenya que has creat.\nVes directament a la secció de descàrregues a (https://support.broadcom.com/group/ecx/free-downloads). \nSelecciona VMware Workstation Pro o VMware Fusion segons el teu sistema operatiu (Windows o macOS). En el meu cas, utiltizo Mac, així que seleccionaré VMware Fusion.\nSeleccioneu la versió que voleu descarregar. En aquest cas, podem seleccionar la versió més recent. \nEn la pàgina següent:\n\nFes clic a l’enllaç de termes i condicions per que s’activi el checkbox de l’acceptació.\nAcceptar els termes i condicions.\nFes clic a descàrrega per començar a descarregar el fitxer d’instal·lació. \n\n\nInstal·la VMware Workstation Pro o VMware Fusion.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "href": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Descarrega de la imatge ISO de Debian 12.5.0",
    "text": "Descarrega de la imatge ISO de Debian 12.5.0\n\nVes a la pàgina de descàrrega de Debian 12.5.0: https://get.debian.org/images/archive/12.5.0/\nSelecciona la imatge ISO per a la teva arquitectura (amd64 o arm64). La majoria dels vostres ordinadors tenen processadors amd64 (Intel o AMD). Els processadors ARM són més comuns en dispositius mòbils i en els nous Mac amb xips M.\nSeleccioneu la carpeta iso-cd.\nSeleccioneu el fitxer debian-12.5.0-x-netinst.iso. On x és l’arquitectura del vostre sistema (amd64 o arm64).\n\n💡 Nota:\nLa imatge netinst és una imatge d’instal·lació mínima que descarrega els paquets necessaris durant la instal·lació. Això permet personalitzar la instal·lació i seleccionar els paquets que voleu instal·lar.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#configuració-de-la-màquina-virtual-amb-vmware",
    "href": "labs/01-introduction/lab01.html#configuració-de-la-màquina-virtual-amb-vmware",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Configuració de la màquina virtual amb VMWare",
    "text": "Configuració de la màquina virtual amb VMWare\n\nSelecciona l’opció Create a New Virtual Machine a VMWare Workstation Pro o VMWare Fusion.\nSelecciona Install from disc or image. \nSelecciona la imatge ISO de Debian 12. \nConfigura els recursos de la màquina virtual. \nAnomena la màquina virtual i selecciona la ubicació on es guardarà. Per exemple, podeu posar el nom vm-curs0-debian12 i seleccionar una ubicació al vostre directori d’usuari.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installació-del-sistema-operatiu",
    "href": "labs/01-introduction/lab01.html#installació-del-sistema-operatiu",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Instal·lació del sistema operatiu",
    "text": "Instal·lació del sistema operatiu\n\nUn cop iniciada la màquina virtual, podeu seleccionar la opció Install o bé Graphical install. \nEn aquest tutoriral, seleccionarem la opció Graphical install per a una instal·lació més amigable. La principal diferència entre les dues opcions és l’entorn gràfic.\nSelecciona l’idioma d’instal·lació. \nPodeu seleccionar l’idioma que vulgueu per a la instal·lació. En aquest cas, seleccionarem l’idioma Català.\nSelecciona la ubicació geogràfica. \nEn aquest cas, seleccionarem la ubicació Espanya.\nSelecciona la disposició del teclat. \nEn aquest cas, seleccionarem la disposició de teclat Català. Això ens asegurarà un mapeig correcte del teclat.\nEspereu que el sistema carregui els components necessaris. \nConfigura la xarxa.\n\nEl primer pas és configurar el nom d’amfitrió o hostname. Aquest nom permet identificar de forma única el vostre sistema. Podeu deixar el nom per defecte o canviar-lo al vostre gust.\n\n\nEn aquest cas, hem canviat el nom d’amfitrió a vm-curs0-debian12, però podeu posar el nom que vulgeu com debianlab, etc.\n\nEl segon pas és configurar el domini de la xarxa. Aquest pas el podeu deixar en blanc si no teniu un domini específic. O bé, podem utilitzar .local com a domini local per identicar que el servidor pertany a la xarxa local.\n\n\nConfigura l’usuari administrador.\n\nEn aquest punt, heu de tenir en compte que si no poseu cap contrasenya, es crearà l’usuari normal amb permisos de sudo i això us permetra executar comandes amb privilegis d’administrador.\nSi poseu una contrasenya, aquesta serà la contrasenya de l’usuari root i no es crearà un usuari normal amb permisos de sudo. I tampoc s’instal·larà el paquet sudo.\n\n⚠️ Compte\nCom utilitzarem les màquines virtuals com a laboratoris de pràctiques, no cal que poseu una contrasenya molt segura. Podeu utilitzar una com a 1234. Però, recordeu que en un entorn real, la seguretat és molt important i cal utilitzar contrasenyes segures.\n\nConfigura un usuari normal.\n\nNom complet: Podeu posar el vostre nom complet o el que vulgueu.\n\n\n\nNom d’usuari: Podeu posar el vostre nom d’usuari o el que vulgueu.\n\n\n\nContrasenya: El mateix que per l’usuari root.\n\n\nConfigura la zona horària.\n\nEn aquest cas, seleccionarem la zona horària de Madrid.\nConfigura el disc dur.\n\nParticionament: En aquest curs, el tema del particionament no és molt important. Per tant, podeu fer servir la configuració per defecte més senzilla (Guiat - utilitzar el disc sencer). Aquesta configuració crearà les particions necessàries per a l’instal·lació del sistema.\n\n\n\nSelecciona el disc on instal·lar el sistema. En el meu cas, només tinc un disc virtual amb l’etiqueta /dev/nvme0n1. L’etiqueta indica el tipus de disc (NVMe) i el número de disc (1). Es possible tenir altres etiquetes com /dev/sda per discos SATA o /dev/vda per discos virtuals.\n\n\n\nParticions: Podeu seleccionar (Tots els fitxers en una partició) per simplificar la gestió i evitar problemes podeu seleccionar aquesta opció. Aquesta opció crearà una sola partició per a tot el sistema.\n\n\n\nConfirmeu els canvis. En aquest punt, el sistema crearà les particions necessàries:\n\nLa primera partició serà la partició /boot on es guardaran els fitxers per arrancar el sistema.\nLa segona partició serà la partició / on es guardaran els fitxers del sistema.\nLa tercera partició serà la partició de swap on es guardaran les dades de la memòria virtual.\n\n\n\nℹ️ Què és la partició swap?\nLa swap és una partició especial que s’utilitza com a memòria virtual quan la memòria RAM s’omple. Aquesta partició permet alliberar memòria RAM i evitar que el sistema es bloquegi.\n\n\n\nEscriu els canvis al disc.\n\n\nEspera que s’instal·li el sistema.\n\nConfigura el gestor de paquets.\n\nAnalitzar els discos de la instal·lació. Aquest pas permet seleccionar els discos on es troben els paquets d’instal·lació. Normalment, aquest pas no cal modificar-lo.\n\n\n\nConfigura el gestor de paquets. En aquest cas, seleccionarem el servidor de paquets més proper a la nostra ubicació.\n\nFiltrar els servidors de paquets per ubicació. \nSeleccionar el servidor de paquets. \n\n\n👀 Nota:\nA vegades, els servidors de paquets poden estar saturats o no funcionar correctament. En aquest cas, podeu seleccionar un servidor alternatiu o provar més tard.\n\nConfigura el proxy. Si esteu darrere d’un proxy, podeu configurar-lo en aquest pas.\n\n\nℹ️ Què és un proxy?\nUn proxy és un servidor intermediari entre el vostre sistema i Internet. Aquest servidor pot ser utilitzat per controlar l’accés a Internet, per protegir la vostra privacitat o per accelerar la connexió a Internet. Les peticions de connexió a Internet es fan a través del servidor proxy, que actua com a intermediari i reenvia les peticions al servidor de destinació. Per exemple, en una empresa, el proxy pot ser utilitzat per controlar l’accés a Internet dels empleats i protegir la xarxa interna de possibles amenaces.\n\n\nEspera que s’instal·lin els paquets.\n\nConfigura el paquet popularity-contest.\n\nAquest paquet permet enviar informació anònima sobre els paquets instal·lats al servidor de Debian per millorar la selecció de paquets i la qualitat dels paquets. Podeu seleccionar si voleu participar en aquest programa o no.\n\n\nSelecció de programari. En aquest punt podeu seleccionar si voleu un servidor en mode text o amb interfície gràfica. També us permet seleccionar si voleu instal·lar els serveis web i ssh al servidor i finalment si voleu les utilitats estàndard del sistema. Seleccionarem el servidor en mode text, el servei SSH activat i les utilitats estàndard del sistema.\n\n\nℹ️ Què és un servidor en mode text?\nUn servidor en mode text és un servidor que no té una interfície gràfica. Això significa que tota la interacció amb el servidor es fa a través de la línia de comandes. Aquest tipus de servidor és molt comú en entorns de producció, ja que consumeix menys recursos i és més segur que un servidor amb interfície gràfica.\n\n\n\nℹ️ Què és el servei SSH?\nEl servei SSH (Secure Shell) és un protocol de xifratament que permet connectar-se de forma segura a un servidor remot. Aquest servei és molt utilitzat per administrar servidors a distància, ja que permet accedir al servidor de forma segura i xifratada.\n\nEspera que s’instal·li el programari.\n\nInstal·la el gestor d’arrancada GRUB. \nInstal·lació acabada. Un cop finalitzada la instal·lació, el sistema es reiniciarà i podreu accedir al GRUB per seleccionar el sistema operatiu. \nEl GRUB us permet accedir al sistema operatiu. En aquest cas, seleccionarem Debian GNU/Linux. La resta d’opcions les veurem més endavant en el curs.\n\n\nℹ️ Què és el GRUB?\nEl GRUB és un gestor d’arrencada que permet seleccionar el sistema operatiu que volem iniciar. Aquest gestor és molt útil en sistemes amb múltiples sistemes operatius o múltiples versions del mateix sistema operatiu.\n\nInicieu sessió amb l’usuari i la contrasenya que heu configurat durant la instal·lació.\n\n\n\n\n\n\n\nAlerta\n\n\n\nQuan escriviu la contrasenya, no es mostrarà cap caràcter a la pantalla. Això és normal en sistemes Unix/Linux per motius de seguretat. Simplement escriviu la contrasenya i premeu Enter.\n\n\nTanqueu la sessió amb la comanda exit.\nInicieu sessió amb l’usuari root i la contrasenya que heu configurat durant la instal·lació.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "href": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Exercicis adicionals",
    "text": "Exercicis adicionals\n\nInstal·leu altres màquines virtuals amb altres sistemes operatius en mode gràfic com:\n\nUbuntu 24.04 LTS\nFedora 39",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html",
    "href": "labs/01-introduction/lab05.html",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratuït.\n\n\n\nInicia la sessió al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuració al menú desplegable.\nA la pàgina de configuració de GitHub, selecciona Configuració de desenvolupador al menú lateral esquerre.\nA la secció Tokens personals, fes clic a Genera un token personal i selecciona un Token (clássic) per a l’ús amb la línia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informació requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la màquina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions bàsiques, com ara clonar repositoris i fer push, necessitaràs almenys els permisos següents:\n\nrepo (per accedir als repositoris privats i públics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. És recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haurà acabat el curs.\n\n\n\n\n\n\nInicia una sessió a la terminal de la màquina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la següent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura’t de substituir TOKEN pel token d’accés personal que has generat a GitHub. Això emmagatzemarà el token de GitHub en la configuració global de Git al teu sistema Debian.\n\n\nVerifica que el token s’hagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat bé, veuràs el token que has configurat a la sortida d’aquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l’ús de contrasenyes per a operacions Git que requereixen autenticació. En lloc d’això, has de fer servir un token d’accés personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, és important que utilitzis el token d’accés personal que has generat en lloc de la teva contrasenya habitual quan se’t demani autenticació des d’una línia de comandes o des d’un IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#configurant-github",
    "href": "labs/01-introduction/lab05.html#configurant-github",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratuït.\n\n\n\nInicia la sessió al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuració al menú desplegable.\nA la pàgina de configuració de GitHub, selecciona Configuració de desenvolupador al menú lateral esquerre.\nA la secció Tokens personals, fes clic a Genera un token personal i selecciona un Token (clássic) per a l’ús amb la línia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informació requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la màquina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions bàsiques, com ara clonar repositoris i fer push, necessitaràs almenys els permisos següents:\n\nrepo (per accedir als repositoris privats i públics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. És recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haurà acabat el curs.\n\n\n\n\n\n\nInicia una sessió a la terminal de la màquina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la següent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura’t de substituir TOKEN pel token d’accés personal que has generat a GitHub. Això emmagatzemarà el token de GitHub en la configuració global de Git al teu sistema Debian.\n\n\nVerifica que el token s’hagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat bé, veuràs el token que has configurat a la sortida d’aquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l’ús de contrasenyes per a operacions Git que requereixen autenticació. En lloc d’això, has de fer servir un token d’accés personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, és important que utilitzis el token d’accés personal que has generat en lloc de la teva contrasenya habitual quan se’t demani autenticació des d’una línia de comandes o des d’un IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#tasques",
    "href": "labs/01-introduction/lab05.html#tasques",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "Tasques",
    "text": "Tasques\n\nCreació d’equips\n\nFormeu equips de 3 persones. Cada grup haurà d’escollir un líder, que serà el responsable de coordinar el treball, gestionar el repositori i fer el seguiment del projecte.\nTrieu un nom d’equip original.\n\n\n\nPreparació del projecte\nEnllaç de la tasca a GitHub Classroom: https://classroom.github.com/a/bxb1jFbT\n\nEl líder de l’equip haurà d’iniciar el grup a través de GitHub Classroom.\n\nIntrodueix el nom de l’equip.\n\nAccepta la tasca.\n\nUn cop acceptada la tasca, es crearà un repositori per a l’equip.\n\n\nLa resta de membres s’hi podran unir seleccionant el nom de l’equip al mateix enllaç https://classroom.github.com/a/bxb1jFbT.\nEl repositori base contindrà el codi inicial necessari i la seva estructura.\n\nEl líder és responsable d’assignar les tasques a cada membre mitjançant issues a GitHub.\nPer fer-ho:\n\nFer clic a la pestanya Issues.\n\nFer clic a New issue, i seleccionar Feature request.\n\nUs he preparat una plantilla per a les issues. Feu clic a Get started.\n\nOmplir el títol i la descripció de la tasca.\nAssignar la tasca a un membre de l’equip. Click a Assignees i seleccionar el membre.\nUn cop assignada la tasca, fer clic a Submit new issue.\n\nLlista de tasques i assignació:\n\n\n\nTasca\nAssignat a\n\n\n\n\nImplementació de la funció de suma\nlíder\n\n\nImplementació de la funció de resta\nlíder\n\n\nImplementació de la funció de multiplicació\nmembre1\n\n\nImplementació de la funció de divisió\nmembre1\n\n\nImplementació de la funció de potència\nmembre2\n\n\nImplementació de la funció de arrels quadrades\nmembre2\n\n\n\n\n\n\nTreball individual\nInstal·la el paquet build-essential, que inclou les eines i llibreries necessàries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que és comunament utilitzat per programar en C.\napt install build-essential -y\n\nCada membre de l’equip haurà de clonar el repositori al seu ordinador i crear una branca develop per les seves tasques.\ngit clone URL_DEL_REPOSITORI\ncd NOM_DEL_REPOSITORI\n\n\n\n\n\n\n\nNota\n\n\n\nSi feu clic a Code al repositori, podreu copiar la URL del repositori. \n\n\n\n\n\n\n\n\nConsellRecomanació:\n\n\n\nTanqueu la sessió de VSCode i torneu-la a obrir però indicant la ruta a la carpeta del projecte. En el meu cas, seria /home/jordi/test/projecte-0-calculadora-teacher. D’aquesta manera, podreu utilitzar les eines de VSCode per a desenvolupar el projecte.\n\n\n\n\n\nPer cada tasca assignada, el membre haurà de crear una branca amb el nom de la tasca. Per exemple, si la tasca és implementar la funció de suma, la branca es podria anomenar feature-suma.\ngit checkout -b feature-suma\nObserveu que VSCode us mostra la branca actual a la part inferior esquerra.\n\n\n\nEl codi de la funció suma podria ser:\n// calc.c\nint suma(int a, int b) {\n    return a + b;\n}\n// calc.h\nint suma(int a, int b);\nReviseu el fitxer src/main.c per a cridar la funció sumacorrectament de la llibreria calc.\nCompileu el codi i comproveu que funciona correctament.\nmake\n./bin/calc\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nSi tot funciona correctament, el codi s’executarà i mostrarà el resultat de la suma.\n\n\n\nUn cop finalitzada la tasca, fer un commit amb els canvis realitzats indicant la tasca realitzada. Teniu dos opcions per fer el commit:\n\nAmb les eines de VSCode: Feu clic a la icona de la branca a la part inferior esquerra i seleccioneu Commit. Després, introduïu el missatge de commit i confirmeu-lo.\n\n\n\nAmb la terminal.\ngit add src/calc.c src/calc.h src/main.c\ngit commit -m \"@feat: Implementació de la funció de suma\"\n\n\n\n\n\n\n\n\n\nAlerta\n\n\n\nSi no feu git add abans de fer el commit, no es pujaran els canvis al repositori. Així que assegureu-vos de fer git add abans de fer el commit.\n\n\n\n\n\n\n\n\n\nConsell\n\n\n\nUtilitza els missatges de commit per tancar les issues relacionades amb la tasca. Per exemple, si la tasca és implementar la funció de suma, el missatge de commit podria ser: git commit -m \"@feat: Implementació de la funció de suma. Closes #1\". Si la tasca 1 és la implementació de la funció de suma.\n\n\nRepeteix els passos 2 i 3 per a cada tasca assignada. Sempre creant la branca des de main. Per tornar a la branca main, feu git checkout main. O bé, click a la branca a la part inferior esquerra de VSCode i seleccioneu main. Un cop finalitzades les seves tasques ajuntarem totes les branques a la nostra branca local main.\ngit checkout -b main\ngit merge feature-suma \n\n\n\n\n\n\n\nAlertaImportant:\n\n\n\nSi hi ha conflictes, caldrà resoldre’ls abans de fer el commit.\n\nPer fer-ho amb VSCode, farem clic a la icona de la branca a la part inferior esquerra i seleccionarem Merge branch into current. \nSeleccioneu la branca a ajuntar. \nQuan integreu la segona funcionalitat (resta, multiplicació, etc.), caldrà fer un merge ja que es detectaran conflictes. \nUn dels conflictes es el fitxer calc.c. Cada branca ha modificat aquest fitxer i caldrà resoldre els conflictes. Acceptant els canvis de les dues branques. Podeu fer-ho manualment o amb el resolutor de conflictes de VSCode. \nRepetiu el mateix procediment per tots els conflictes que apareguin.\nUn cop resolts els conflictes, feu un commit amb el missatge @feat: Merge branch feature-resta.\n\n\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nEn aquest punt, cada membre de l’equip haurà de tenir implementades les seves tasques (resta, multiplicació, divisió, potència i arrels quadrades), per poder després ajuntar-les a la branca main. Es important editar els fitxers calc.c i calc.h i també el fitxer main.c per a cridar les funcions correctament.\n\n\n\n\nAjuntar les tasques\n\nUn cop totes les tasques estiguin implementades i ajuntades a la branca main, caldrà testar que el codi funciona correctament.\nAquestes tasques estaràn en la branca main del repositori local. Ara caldrà pujar aquestes tasques al repositori remot.\n\nCrea a GitHub una branca remota anomenada develop-&lt;nom-usuari&gt; i la vincularem amb la branca main local. \n\nPrimer, caldrà actualitzar les branques remotes del repositori.\ngit fetch origin\n\nUn cop actualitzades les branques remotes, caldrà fer un push de la branca main a la branca develop-&lt;nom-usuari&gt;.\ngit push origin main:develop-&lt;nom-usuari&gt;\nUn cop pujades totes les tasques al repositori remot, el líder actualitzarà les branques remotes de tots els membres de l’equip.\ngit fetch origin\nFara un merge de totes les tasques a la seva branca main.\nFinalment, testeu que el codi funciona correctament.\nUn cop testejat, caldrà pujar la branca main al repositori remot.\ngit push origin main\n\n\n\nDocumentació\n\nEditeu el fitxer README.md i afegiu una breu descripció del projecte, el nom dels membres de l’equip i una captura de pantalla de la calculadora en funcionament.\nAfegiu també les instruccions per a compilar i executar el projecte.\n\nPodeu consultar la documentació de GitHub sobre com escriure aquest tipus de documents https://docs.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar més les vostres habilitats amb Git. Centreu-vos en els exercicis REMOTE.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab03.html",
    "href": "labs/01-introduction/lab03.html",
    "title": "Laboratori 3: Hola món en C a Debian",
    "section": "",
    "text": "Per instal·lar el llenguatge de programació C a Debian, pots seguir aquests passos:\n\nConnecta una terminal al teu sistema Debian i obra una sessió com a usuari root.\nsu -\nInstal·la el paquet build-essential, que inclou les eines i llibreries necessàries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que és comunament utilitzat per programar en C.\napt install build-essential -y\nTorna a la sessió com a usuari normal i comprova que el compilador GCC s’ha instal·lat correctament.Verifica la instal·lació comprovant la versió del compilador GCC instal·lat.\nexit\ngcc --version\n\nAra ja pots escriure i compilar programes en C al teu sistema Debian. Com anteriorment, has vinculat VSCode amb la màquina virtual debianlab ara pots escriure i compilar programes en C des de l’entorn de desenvolupament VSCode.\nAnem a crear un programa senzill en C, compilar-lo i executar-lo. Aquest programa mostrarà un missatge de benvinguda a la terminal.\n\nFer click al boto Obre la Carpeta.\n\n\n\nObre Carpeta\n\n\nSelecciona la carpeta de l’usuari. (/home/jordi). Això obrirà la carpeta de l’usuari a la barra lateral esquerra de VSCode.\n\n\n\nSelecciona Carpeta\n\n\n\nConfirmeu que confieu en l’origen de la carpeta seleccionada.\n\n\n\n\nConfia en la carpeta\n\n\n\nCom a resultat, la carpeta de l’usuari s’obrirà a la barra lateral esquerra de VSCode.\n\n\n\n\nCarpeta de l’usuari\n\n\nCrea un directori utilitzant el gestor de fitxers de VSCode. Per exemple, crea un directori anomenat hello a la carpeta de l’usuari.\n\n\n\nCrea directori\n\n\nCrear un nou fitxer anomenat hola.c dins del directori hello.\n\n\n\nCrea fitxer\n\n\nUtilitza l’editor de text de VSCode per escriure el següent codi en C al fitxer creat.\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hola, benvingut al DebianLab!\\n\");\n    return 0;\n}\n\n\n\nEscriu codi\n\n\nPodeu seleccionar instal·lar l’extensió C/C++ per a VSCode tal com us recomana l’editor.\nUn cop instal·lat, torneu a la pestanya de l’editor de hola.c i guardeu el fitxer.\n\n😵‍💫 Trobleshooting:\nSi quan guardeu el fitxer, VSCode us mostra la llibreria stdio.h amb vermell indicant que no la troba, simplement, tanqueu la sessió a VSCode i torneu-la a iniciar. Això solucionarà el problema.\n\nSi no teniu oberta la terminal, podeu obrir-ne una des de VSCode. Feu clic a Terminal i seleccioneu Nova Terminal.\n\n\n\nTerminal oberta\n\n\nAra podeu compilar el programa des de la terminal de VSCode.\nNavega fins al directori hello.\ncd hello\nCompila el programa amb la comanda gcc.\ngcc -o hola hola.c\nExecuta el programa.\n./hola\n\n\n\n\nResum de comandes",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 3 · Hola món en C a Debian"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SO 105012: Sistemes Operatius",
    "section": "",
    "text": "Benvinguts al curs de Sistemes Operatius (SO) del Grau d’Enginyeria Informàtica de la Universitat de Lleida (UdL). Aquest curs se centra en l’estudi dels principis fonamentals de disseny i implementació en l’enginyeria de sistemes operatius. Les classes es basen en l’estudi de sistemes operatius basats en UNIX i en tasques de recerca. Alguns dels temes tractats inclouen la gestió de processos, els mecanismes de comunicació, la planificació de tasques i la gestió de memòria. Les tasques de laboratori individuals requereixen codificar en C mitjançant crides al sistema i scripts de shell.\n\n\n\nCourse Title\nOperating Systems\n\n\nSemester\n1st Semester of the Bachelor’s Degree in Computer Engineering\n\n\nCourse Year\nSecond Year\n\n\nProfessor\nJordi Mateo\n\n\nSchedule\n📅\n\n\nCourse Guide\n📚\n\n\nSchool\n\n\n\nUniversity\n\n\n\nDepartment"
  },
  {
    "objectID": "notes/01-introduction.html",
    "href": "notes/01-introduction.html",
    "title": "Introducció",
    "section": "",
    "text": "Un sistema informàtic és la interconnexió d’elements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu comú.\n\nEls components hardware són els dispositius físics del sistema, com el processador, la memòria, el disc dur, el teclat, el ratolí, la impressora, etc.\nEls components software són els programes que s’executen en el sistema, com el sistema operatiu, els programes d’aplicació, els controladors de dispositius, etc.\n\nA continuació es mostra un esquema simplificat d’un sistema informàtic.\n\n\n\nSistema Informàtic (Hardware)\n\n\nEn la figura, es representen els components hardware d’un sistema informàtic, com la CPU, la memòria, el disc dur, el teclat, el ratolí o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la memòria guarda la informació temporalment, i els dispositius d’entrada/sortida (com el teclat o el ratolí) permeten la interacció amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interfície perquè les aplicacions puguin comunicar-se amb els components físics. Això permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s’encarrega d’abstreure’n la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d’un sistema informàtic.\n\n\n\nEl món es comporta com un gran sistema paral·lel, on molts processos i activitats es duen a terme simultàniament. Per tant, els nostres sistemes informàtics també han de poder actuar en paral·lel per ser eficients i competents. No ens serveix un sistema que només pugui fer una cosa alhora.\nEn informàtica, aquest comportament s’aconsegueix gràcies a la multitasca, que permet que un sistema informàtic executi múltiples processos alhora, optimitzant els recursos disponibles. Això és especialment important en entorns moderns, on un únic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes informàtics moderns són heterogenis i es componen d’una àmplia gamma de components de hardware i software, cada un amb les seves pròpies característiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb diferències significatives en els conjunts d’instruccions, mecanismes de seguretat i vulnerabilitats específiques. També s’han de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMemòria: Com RAM (memòria d’accés aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (memòria només de lectura), memòria cache (L1, L2, L3) i memòries persistents com la memòria flash. Cada tipus de memòria presenta diferents velocitats, capacitat i latència, i s’ha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d’estat sòlid), NVMe (Non-Volatile Memory Express) i dispositius de memòria externa com USB i targetes de memòria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb característiques específiques en termes de velocitat, capacitat i durabilitat. A més, si un disc falla, s’ha de poder migrar les dades a un altre disc sense perdre la informació.\nDispositius d’entrada/sortida: Com teclats, ratolins, pantalles, impressores, escàners, càmeres, micròfons, altaveus, etc. Cada dispositiu d’entrada/sortida té les seves pròpies interfícies i controladors, i s’ha de poder gestionar de manera eficient per garantir una interacció fluida amb l’usuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceleròmetres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalització, moviment i altres dades que poden ser crítiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware és el software integrat en components de hardware que controla les funcions més bàsiques del sistema, com l’arrencada, la configuració i la gestió de dispositius. Les vulnerabilitats en el firmware poden ser crítiques, ja que poden permetre als atacants accedir a les funcions més profundes del sistema.\n\n\n\n\nImagineu que un programador hagués de conèixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pràcticament impossible escriure programes eficients sense l’ajuda d’una capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagués de desenvolupar un programa diferent per a cada combinació de components hardware.\n\nAbans dels sistemes operatius moderns, això era una realitat. Ara, gràcies a l’abstracció que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en múltiples dispositius sense haver de preocupar-se per les diferències del hardware.\n\n\nPer tant, un sistema informàtic és un sistema complex format per components heterogenis i interconnectats, que funcionen en paral·lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intuïtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#introducció-als-sistemes-informàtics",
    "href": "notes/01-introduction.html#introducció-als-sistemes-informàtics",
    "title": "Introducció",
    "section": "",
    "text": "Un sistema informàtic és la interconnexió d’elements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu comú.\n\nEls components hardware són els dispositius físics del sistema, com el processador, la memòria, el disc dur, el teclat, el ratolí, la impressora, etc.\nEls components software són els programes que s’executen en el sistema, com el sistema operatiu, els programes d’aplicació, els controladors de dispositius, etc.\n\nA continuació es mostra un esquema simplificat d’un sistema informàtic.\n\n\n\nSistema Informàtic (Hardware)\n\n\nEn la figura, es representen els components hardware d’un sistema informàtic, com la CPU, la memòria, el disc dur, el teclat, el ratolí o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la memòria guarda la informació temporalment, i els dispositius d’entrada/sortida (com el teclat o el ratolí) permeten la interacció amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interfície perquè les aplicacions puguin comunicar-se amb els components físics. Això permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s’encarrega d’abstreure’n la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d’un sistema informàtic.\n\n\n\nEl món es comporta com un gran sistema paral·lel, on molts processos i activitats es duen a terme simultàniament. Per tant, els nostres sistemes informàtics també han de poder actuar en paral·lel per ser eficients i competents. No ens serveix un sistema que només pugui fer una cosa alhora.\nEn informàtica, aquest comportament s’aconsegueix gràcies a la multitasca, que permet que un sistema informàtic executi múltiples processos alhora, optimitzant els recursos disponibles. Això és especialment important en entorns moderns, on un únic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes informàtics moderns són heterogenis i es componen d’una àmplia gamma de components de hardware i software, cada un amb les seves pròpies característiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb diferències significatives en els conjunts d’instruccions, mecanismes de seguretat i vulnerabilitats específiques. També s’han de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMemòria: Com RAM (memòria d’accés aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (memòria només de lectura), memòria cache (L1, L2, L3) i memòries persistents com la memòria flash. Cada tipus de memòria presenta diferents velocitats, capacitat i latència, i s’ha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d’estat sòlid), NVMe (Non-Volatile Memory Express) i dispositius de memòria externa com USB i targetes de memòria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb característiques específiques en termes de velocitat, capacitat i durabilitat. A més, si un disc falla, s’ha de poder migrar les dades a un altre disc sense perdre la informació.\nDispositius d’entrada/sortida: Com teclats, ratolins, pantalles, impressores, escàners, càmeres, micròfons, altaveus, etc. Cada dispositiu d’entrada/sortida té les seves pròpies interfícies i controladors, i s’ha de poder gestionar de manera eficient per garantir una interacció fluida amb l’usuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceleròmetres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalització, moviment i altres dades que poden ser crítiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware és el software integrat en components de hardware que controla les funcions més bàsiques del sistema, com l’arrencada, la configuració i la gestió de dispositius. Les vulnerabilitats en el firmware poden ser crítiques, ja que poden permetre als atacants accedir a les funcions més profundes del sistema.\n\n\n\n\nImagineu que un programador hagués de conèixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pràcticament impossible escriure programes eficients sense l’ajuda d’una capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagués de desenvolupar un programa diferent per a cada combinació de components hardware.\n\nAbans dels sistemes operatius moderns, això era una realitat. Ara, gràcies a l’abstracció que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en múltiples dispositius sense haver de preocupar-se per les diferències del hardware.\n\n\nPer tant, un sistema informàtic és un sistema complex format per components heterogenis i interconnectats, que funcionen en paral·lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intuïtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#sistema-operatiu-conceptes-bàsics",
    "href": "notes/01-introduction.html#sistema-operatiu-conceptes-bàsics",
    "title": "Introducció",
    "section": "Sistema Operatiu: Conceptes bàsics",
    "text": "Sistema Operatiu: Conceptes bàsics\nUn sistema operatiu és un programa que actua com a intermediari entre l’usuari i el sistema informàtic. El seu objectiu principal és proporcionar als usuaris una interfície simple, neta i coherent del sistema, i gestionar tots els recursos del mateix.\nGràcies al sistema operatiu, els programadors poden escriure programes que s’executin en qualsevol sistema informàtic, independentment dels seus components hardware, i sense necessitat de conèixer-ne els detalls tècnics.\n\nDefinició formal d’un sistema operatiu\n\nUn programa encarregat de l’assignació dels recursos d’un sistema informàtic, així com del control i supervisió de l’execució correcta de les diferents aplicacions i programes.\nUn programa que controla tots els recursos del sistema, proporcionant la base sobre la qual es poden escriure i executar altres programes.\n\n\n\nFuncions d’un sistema operatiu\nEl sistema operatiu compleix quatre funcions essencials que podem destacar:\n\nProporcionar una interfície d’usuari: El sistema operatiu ofereix una interfície que permet als usuaris interactuar amb el sistema informàtic de manera intuïtiva i eficient. Aquesta interfície pot ser gràfica (GUI) o de línia de comandes (CLI).\nProporcionar una plataforma d’execució: El sistema operatiu actua com a plataforma per a l’execució de programes i aplicacions. Proporciona un entorn d’execució segur i aïllat per a les aplicacions.\nGestionar els recursos del sistema: El sistema operatiu gestiona els recursos del sistema, com la memòria, la CPU, el disc dur, la xarxa, etc. Això inclou la planificació de processos, la gestió de la memòria, la gestió de l’emmagatzematge i la gestió de la xarxa.\nProporcionar portabilitat: El sistema operatiu permet que els programes s’executin en diferents sistemes informàtics sense necessitat de modificacions. Això permet als programadors escriure programes una sola vegada i executar-los en múltiples plataformes.\n\n\n\nTipus de sistemes operatius\n\nPròposit general: Windows, Linux, MacOS.\n\nMultitasca, multiusuari, multiprocessador.\nExemples: Windows 11, Ubuntu, MacOS Catalina.\n\nServidors: Unix, Linux.\n\nOptimitzats per a Alt Rendiment: Dissenyats per gestionar grans volums de dades i usuaris simultanis.\nDedicats a tasques específiques com ara servidors web, servidors de correu, servidors de bases de dades, etc.\nExemples: Debian, AlmaLinux, FreeBSD.\n\nDispositius mòbils: iOS, Android.\n\nOptimitzats per a Dispositius Táctils: Interfícies i funcionalitats adaptades per a l’ús mòbil.\n\nSistemes encastats: RTOS (Real-Time Operating System).\n\nOptimitzats per a sistemes encastats i temps real.\nExemples: FreeRTOS, VxWorks, QNX.\n\nSistemes Especifics: Sistemes operatius optimitzats per a tasques específiques, com ara sistemes de control de trànsit, sistemes de navegació, sistemes de televisió digital, etc.\nUnikernels: Sistemes operatius optimitzats per a aplicacions específiques.\n\nExemples: MirageOS, OSv, ClickOS.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#nivells-en-un-sistema-informàtic",
    "href": "notes/01-introduction.html#nivells-en-un-sistema-informàtic",
    "title": "Introducció",
    "section": "Nivells en un Sistema Informàtic",
    "text": "Nivells en un Sistema Informàtic\nLa figura següent mostra les diferents capes d’un sistema informàtic. Aquestes capes es divideixen en dos grans grups:\n\nEn groc es representen els recursos físics (hardware), que inclouen components com la CPU, la memòria i els dispositius d’entrada/sortida.\nEn blau es representen els components software, amb especial atenció al sistema operatiu, que s’executa tant en mode usuari (verd) com en mode sistema (vermell), també conegut com a mode kernel.\n\n\n\n\nSistema Operatiu\n\n\n\nFunció del Mode Usuari i el Mode Sistema\nEls programes d’aplicació (com el client de correu, el navegador web o el reproductor musical) s’executen en mode usuari, que és un entorn restringit on les aplicacions no poden accedir directament al maquinari ni a altres parts crítiques del sistema. Per garantir la seguretat i estabilitat del sistema, les aplicacions han de fer crides al sistema per accedir a funcionalitats gestionades pel sistema operatiu, com la gestió de fitxers o la comunicació per xarxa.\nEl mode sistema (o mode kernel) és on s’executen les parts més crítiques del sistema operatiu, com la gestió de recursos, els controladors de dispositius i altres serveis fonamentals. Aquest mode té accés complet al maquinari, i és aquí on es prenen decisions importants sobre l’ús de recursos, l’assignació de memòria i la planificació de processos.\n\n\nComponents del Sistema Operatiu\nEl sistema operatiu es divideix en diverses capes, cadascuna responsable de funcions específiques.\n\nL’interfície d’usuari del sistema operatiu inclou serveis que poden ser utilitzats pels programes d’aplicació. Aquests serveis faciliten la interacció entre el programari d’usuari i el maquinari del sistema. Alguns exemples d’aquests serveis són:\n\nSistema de fitxers: Permet als programes crear, llegir, escriure i esborrar fitxers d’una manera organitzada. Per exemple, un programa de processament de textos que guarda un document al disc dur interactua amb el sistema de fitxers per dur a terme aquesta operació.\nPlanificació de processos: El sistema operatiu decideix quin procés s’executa en cada moment. Per exemple, en un entorn multitarea, el sistema operatiu distribueix el temps de CPU entre múltiples programes en execució com un navegador web i un editor de text, assegurant que cap d’ells bloquegi els altres.\nMemòria virtual: Aquesta funció permet que els programes utilitzin més memòria del que hi ha físicament disponible. Per exemple, si un programa necessita més memòria del que la RAM pot oferir, el sistema operatiu utilitza part del disc dur com a memòria virtual per simular un espai de memòria més gran.\nProtocol TCP/IP: Proporciona serveis de comunicació en xarxa, permetent que els programes es comuniquin a través d’internet. Per exemple, un navegador utilitza aquest servei per enviar i rebre dades d’un servidor web.\n\nCapa d’abstracció de maquinari: Proporciona una interfície que amaga la complexitat del maquinari amb l’objectiu de facilitar el desenvolupament d’aplicacions.\n\nPer exemple, un programador no necessita saber com funciona un disc dur específic; el sistema operatiu ofereix una interfície que permet als programes accedir al disc d’una manera consistent, independentment del model o fabricant del dispositiu.\n\n\n\n\nComponents en l’Espai d’Usuari\nEn l’espai d’usuari, també hi trobem diversos elements importants que faciliten la interacció amb el sistema operatiu:\n\nLes llibreries del sistema són col·leccions de funcions que permeten als programes accedir als serveis del sistema operatiu. Quan un programa necessita realitzar una operació privilegiada, com accedir a un fitxer o comunicar-se amb la xarxa, utilitza aquestes llibreries per fer una crida al sistema.\n\nExemple: Si un programa vol llegir un fitxer, pot utilitzar funcions de la llibreria stdio.h per fer-ho. Aquesta llibreria amaga els detalls tècnics i ens permet interactuar amb el maquinari de manera més senzilla. En aquest cas, fopen() és una funció de la llibreria stdio.h que obre un fitxer per a lectura o escriptura.\n\nEls programes d’usuari són els programes que els usuaris executen directament, com navegadors web, editors de text o jocs. Aquests programes fan ús dels serveis del sistema operatiu mitjançant les llibreries del sistema i poden interactuar amb l’usuari o altres programes.\n\nExemple: Un editor de text com VS Code interactua amb el sistema operatiu per obrir fitxers, mostrar contingut a la pantalla i rebre entrades de l’usuari (com tecles o clics de ratolí).\n\nEl shell és un programa especial que permet als usuaris interactuar directament amb el sistema operatiu a través d’una interfície de línia de comandes (CLI). El shell interpreta les ordres de l’usuari i les tradueix en crides al sistema operatiu per dur a terme accions com llistats de directoris, copiar fitxers o executar programes.\n\nExemple: Quan un usuari introdueix l’ordre ls en un terminal Unix, el shell tradueix aquesta ordre en una crida al sistema que llista els fitxers d’un directori.\n\n\nPer tant el sistema operatiu ens ofereix de forma transparent, usable, portable i efiicient una sèrie de serveis que ens permeten interactuar amb el sistema informàtic:\n\nControl d’usuaris i aplicacions.\nGestió d’usuaris i aplicacions.\nGestió de la memòria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n…",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "href": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "title": "Introducció",
    "section": "Funcions d’un Sistema Operatiu",
    "text": "Funcions d’un Sistema Operatiu\nEl sistema operatiu actua com a àrbitre entre els diferents programes i usuaris que competeixen pels recursos del sistema i com a il·lusionista que proporciona una abstracció dels recursos físics per simular recursos il·limitats això s’aconsegueix gràcies a la virtualització.\nLa virtualització és una tecnologia que permet crear una versió virtual d’un recurs físic o lògic, com una màquina virtual, un sistema de fitxers o una xarxa. Molts autors defineixen un Sistema Operatiu com una màquina virtual que proporciona una interfície d’abstracció del maquinari real.\n\n1. Il·lusionisme\nEl sistema operatiu proporciona una abstracció dels recursos físics. Aquesta capa d’abstracció permet als usuaris i desenvolupadors treballar amb conceptes lògics en lloc de utilitzar directament els recursos físics del sistema.\n\nInterfície per als recursos físics: El sistema operatiu crea una interfície uniforme per als recursos físics, com el disc dur, la memòria i els dispositius d’entrada/sortida. A través d’aquesta interfície, els usuaris i aplicacions poden interactuar amb els recursos del sistema sense necessitat de conèixer el funcionament intern del maquinari.\n\nPer exemple: Quan un usuari treballa amb un fitxer, no pensa en blocs de dades en un disc dur. El sistema operatiu tradueix les operacions de fitxers (com crear, llegir o escriure) en operacions de blocs de disc. Això fa que la gestió d’arxius sigui molt més intuïtiva per a l’usuari. En el codi següent, es mostra com un programa pot obrir un fitxer, escriure-hi dades i tancar-lo sense haver de preocupar-se dels detalls de com s’emmagatzemen les dades al disc dur. Utilitza funcions de la llibreria stdio.h que proporcionen una interfície FILE i funcions com fopen(), fprintf() i fclose() per interactuar amb el fitxer.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Crear i obrir un fitxer per escriptura\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Escriure dades al fitxer\n    fprintf(file, \"Hola, món!\\n\");\n\n    // Tancar el fitxer\n    fclose(file);\n\n    // Reobrir el fitxer per lectura\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Llegir i imprimir dades del fitxer\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    // Tancar el fitxer\n    fclose(file);\n    return 0;\n}\nMultiplexació de recursos (temps i espai): El sistema operatiu gestiona els recursos del sistema a través de la multiplexació, una tècnica que permet compartir un mateix recurs entre múltiples usuaris o processos de manera simultània o intercalada.\n\nMultiplexació en el temps: En un sistema monoprocessador, el sistema operatiu (SO) divideix el temps de CPU entre diversos processos. Això es fa mitjançant la tècnica de canvi de context, que permet al processador alternar ràpidament entre diferents tasques, creant la il·lusió que totes s’estan executant simultàniament.\n\n\nExemple: En un sistema amb múltiples aplicacions obertes (com un navegador web i un editor de text), el sistema operatiu gestiona el temps de CPU assignant petites fraccions de temps a cada aplicació. Aquest procés és tan ràpid que sembla que totes les aplicacions s’executin al mateix temps.\n\nUn exemple pràctic senzill de multiplexació en el temps es pot veure en un sistema operatiu que alterna l’execució de dos processos senzills (A i B). Per simular-ho en un sistema Unix/Linux, es pot utilitzar el següent codi que imprimeix informació sobre el procés actual i fa una pausa abans de continuar en un bucle infinit.\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    while (1) {\n        printf(\"Process %d is running\\n\", getpid());\n        sleep(1); // Simula una pausa abans de continuar\n    }\n    return 0;\n}\nPer compilar i executar aquest codi, seguiu aquests passos:\n$ vi process.c # Copieu el codi anterior en un fitxer process.c\n$ gcc process.c -o process\n$ ./process\nSi executeu aquest codi, veureu com el procés imprimeix informació sobre el seu PID (identificador de procés) i es pausa durant un segon abans de continuar.\n$ ./process\nProcess 1234 is running\nProcess 1234 is running\nProcess 1234 is running\n...\nSi executeu aquest codi dues vegades en el mateix terminal, obtindreu una sortida com la següent:\n$ ./process & ./process &\n[1] 1234\n[2] 1235\nProcess 1234 is running\nProcess 1235 is running\nProcess 1234 is running\nProcess 1235 is running\n...\nEn aquest cas, el sistema operatiu alterna l’execució entre els dos processos, permetent que s’executin simultàniament. Aquesta tècnica de** multiplexació en el temps** permet que múltiples processos comparteixin el temps de CPU disponible.\nLes figures següents mostren com el sistema operatiu alterna l’execució entre dos processos (A i B) mitjançant la tècnica de multiplexació en el temps.\n\nCreació de dos processos (A i B) : El sistema operatiu crea dos processos (A i B) i els carrega a la memòria.\n\n\n\n\nCreació de processos\n\n\n\nEl planificador del sistema elegeix un dels processos (A) per a l’execució i carrega les seves dades a la CPU.\n\n\n\n\nExecució de processos\n\n\n\nEl procés A s’executa durant un temps determinat (1 segon) i després es posa en estat d’espera. El planificador elegirà ara el procés B per a l’execució.\n\n\n\n\nExecució de processos\n\n\nObservació: Si elimineu la crida sleep(1) del codi, els processos s’executaran tan ràpidament que no podreu veure la sortida clara. Això és degut a la velocitat d’execució i la rapidesa amb què el sistema operatiu alterna entre els processos. A més, no es pot assegurar que el sistema operatiu alterni entre els processos en un ordre específic; això depèn de la planificació del sistema operatiu. És possible que un procés s’executi més vegades que l’altre, depenent de la càrrega del sistema i d’altres factors. Aquest fenomen es coneix com indeterminisme.\nPer tant, el sistema operatiu alterna utiltizant la tècnica de canvi de context per permetre que els dos processos s’executin simultàniament. Els dos processos creuen que tenen accés exclusiu a la CPU, però en realitat comparteixen el temps de CPU disponible.\n\nMultiplexació en l’espai: El sistema operatiu (SO) divideix l’espai de memòria entre els diferents processos que s’executen. Cada procés té assignada una part de la memòria física, però utilitza una memòria virtual que li dóna la il·lusió de tenir més memòria disponible. Això permet a cada aplicació creure que té accés exclusiu a la memòria, mentre que el SO gestiona l’accés real.\n\n\nExemple: En un sistema amb 4 GB de RAM, el sistema operatiu pot utilitzar la tècnica de paginació per permetre que múltiples programes ocupin més espai del que hi ha disponible físicament, desplaçant parts no utilitzades a un fitxer de paginació en el disc dur.\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *ptr = malloc(1024 * 1024 * sizeof(int)); // Simula una gran quantitat de memòria\n    if (ptr == NULL) {\n        perror(\"No hi ha prou memòria\");\n        return 1;\n    }\n    printf(\"Memòria assignada\\n\");\n    free(ptr); // Alliberar la memòria\n    return 0;\n}\nEn aquest codi, es reserva una gran quantitat de memòria (1 GB) mitjançant la funció malloc(). Encara que el sistema només disposi de 4 GB de RAM, el sistema operatiu pot gestionar la memòria virtual per permetre que aquesta operació s’executi sense problemes. Quan la memòria ja no es necessita, es pot alliberar amb la funció free(). Aquesta tècnica permet als programes utilitzar més memòria del que hi ha físicament disponible, millorant l’eficiència del sistema.\nUn altre exemple que il·lustra la multiplexació en l’espai és el següent codi que mostra com dos processos poden compartir la mateixa adreça de memòria:\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nint main(int argc, char *argv[]) {\n    int *p = malloc(sizeof(int)); \n    assert(p != NULL);\n    printf(\"(%d) address pointed to by p: %p\\n\", getpid(), p); \n    *p = 0; \n    while (1) {\n        *p = *p + 1;\n        printf(\"(%d) p: %d\\n\", getpid(), *p); \n        }\n    return 0;\n}\nAquest codi crea un procés que reserva memòria per a una variable p i incrementa el seu valor de manera indefinida.\nSi compiles i executes aquest codi, podràs veure com cada procés imprimeix la mateixa adreça de memòria, però amb valors que augmenten de manera independent:\n$ gcc memory.c -o memory\n$ ./memory\n(1234) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1234) p: 2\n(1234) p: 3\n...\nSi executes aquest codi dues vegades en el mateix terminal:\n$ ./memory & ./memory &\n[1] 1234\n[2] 1235\n(1234) address pointed to by p: 0x7f8b1c000010\n(1235) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1235) p: 1\n(1234) p: 2\n(1235) p: 2\n(1234) p: 3\n(1235) p: 3\n...\nEn aquest cas, els dos processos comparteixen la mateixa adreça de memòria, però cada un té la il·lusió que té accés exclusiu a la memòria. Aquesta tècnica de multiplexació en l’espai permet als processos utilitzar la memòria de manera eficient, sense interferir entre ells.\nOptimització del rendiment del hardware: Els sistemes operatius poden optimitzar l’ús dels recursos hardware per maximitzar el rendiment. Això inclou tasques com la gestió intel·ligent de la memòria, la planificació de l’ús de la CPU o la distribució de la càrrega en entorns de múltiples processadors.\n\nExemple: Els sistemes MacOS són altament optimitzats per funcionar amb components de hardware específics dels Macs, aconseguint un rendiment més eficient que sistemes com Windows, que han de suportar una gran varietat de configuracions de hardware.\n\n\n\n\n2. Arbitratge\nEl sistema operatiu actua com un àrbitre entre els diferents processos que competeixen pels recursos del sistema. Aquest arbitratge assegura que els recursos s’utilitzin de manera justa i eficient, evitant conflictes i millorant el rendiment general.\n\nGestió de recursos: El SO decideix com distribuir els recursos limitats (com la CPU, la memòria o dispositius d’E/S) entre els diferents programes que s’executen. Això inclou la planificació de processos, la gestió de la memòria i el control de l’accés als dispositius de hardware.\n\nExemple: Quan diversos processos volen accedir a la impressora simultàniament, el sistema operatiu gestiona una cua d’impressió, decidint quin procés pot utilitzar la impressora i en quin ordre, assegurant que els processos s’executen en funció de la seva prioritat o temps d’espera.\n\nEvitació de conflictes i bloquejos: Un altre aspecte important de l’arbitratge és evitar els bloquejos (deadlocks), que ocorren quan dos o més processos es queden esperant indefinidament que un recurs es faci disponible. El sistema operatiu utilitza tècniques com la prevenció de bloquejos o la detenció de bloquejos per gestionar aquests conflictes.\nExemple: Considerem un escenari on dos processos, A i B, necessiten accedir a dos recursos compartits, X i Y, per completar les seves operacions. Suposem que el recurs X és una impressora i el recurs Y és una memòria USB. El procés A necessita imprimir un document i després guardar-lo a la memòria USB, mentre que el procés B necessita guardar un document a la memòria USB i després imprimir-lo.\nSi el procés A adquireix primer la impressora (recurs X) i després intenta accedir a la memòria USB (recurs Y), i al mateix temps el procés B adquireix primer la memòria USB (recurs Y) i després intenta accedir a la impressora (recurs X), es produeix una situació de bloqueig coneguda com a “deadlock”. En aquest cas, el procés A espera indefinidament per accedir al recurs Y que el procés B ja ha bloquejat, mentre que el procés B espera indefinidament per accedir al recurs X que el procés A ja ha bloquejat. Com a resultat, ambdós processos es bloquegen mútuament i cap d’ells no pot completar la seva tasca. El SO ha de detectar aquesta situació i prendre mesures per evitar-la. Una solució, seria elimanar el procés B, esperar la finalització de A i tornar a executar B.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#mètriques-davaluació-dels-sistemes-operatius",
    "href": "notes/01-introduction.html#mètriques-davaluació-dels-sistemes-operatius",
    "title": "Introducció",
    "section": "Mètriques d’avaluació dels Sistemes Operatius",
    "text": "Mètriques d’avaluació dels Sistemes Operatius\nEls sistemes operatius són complexos i han de satisfer una sèrie de requisits en funció de les seves finalitats i entorns d’ús. Com satisfer tots aquests requisits és una tasca difícil, es fan servir una sèrie de mètriques per avaluar el rendiment i la qualitat dels sistemes operatius en funció de diferents mètriques.\n\nOverhead: Quantitat de recursos addicionals que un sistema operatiu utilitza per gestionar els recursos del sistema. Aquest overhead pot afectar el rendiment general del sistema, ja que els recursos que s’utilitzen pel sistema operatiu no estan disponibles per a les aplicacions.\nFairness: Capacitat del sistema operatiu de distribuir els recursos de manera justa entre els diferents processos. Un sistema operatiu just assegura que tots els processos tinguin accés als recursos del sistema de manera equitativa, sense privilegiar uns processos sobre altres.\nTemps de resposta: Temps que triga un sistema en respondre a una sol·licitud de l’usuari. Un sistema operatiu eficient ha de ser capaç de respondre ràpidament a les sol·licituds dels usuaris, minimitzant el temps de resposta i millorant la interactivitat del sistema.\nThroughput: Quantitat de treball que un sistema pot realitzar en una unitat de temps. Un sistema operatiu amb un alt throughput és capaç de processar un gran nombre de tasques simultàniament, millorant l’eficiència del sistema i reduint els temps d’espera dels usuaris.\nFiabilitat: Capacitat de mantenir-se operatiu durant llargs períodes de temps sense fallar. Un sistema fiable ha de ser capaç de recuperar-se de fallades inesperades i mantenir la integritat dels recursos del sistema.\nDisponibilitat: Capacitat de mantenir-se operatiu i accessible per als usuaris en tot moment. Un sistema altament disponible ha de ser capaç de gestionar càrregues de treball variables i mantenir la seva funcionalitat en situacions de sobrecàrrega o fallades.\nPredictibilitat: Capacitat de mantenir un comportament consistent i previsible en diferents situacions. Un sistema previsible ha de ser capaç de respondre de manera coherent a les sol·licituds dels usuaris i mantenir un rendiment estable en tot moment.\nIntegritat: Capacitat de protegir els recursos del sistema contra atacs i amenaces externes. Un sistema amb una bona integritat ha de ser capaç de mantenir la confidencialitat, la integritat i la disponibilitat dels recursos del sistema en tot moment.\nPrivacitat: Capacitat de protegir les dades dels usuaris i garantir la confidencialitat de la informació personal. Un sistema amb una bona privacitat ha de ser capaç de protegir les dades dels usuaris contra l’ús no autoritzat i garantir la seguretat de la informació.\nSeguretat: Capacitat de protegir els recursos del sistema contra atacs i vulnerabilitats. Un sistema segur ha de ser capaç de detectar i respondre a amenaces de seguretat, com ara virus, malware o atacs cibernètics, i mantenir la integritat del sistema en tot moment.\nEscalabilitat: Capacitat de créixer i adaptar-se a les necessitats dels usuaris. Un sistema escalable ha de ser capaç de gestionar càrregues de treball variables i augmentar la seva capacitat de processament i emmagatzematge segons sigui necessari.\nPortabilitat: Capacitat de ser executat en diferents plataformes i arquitectures de maquinari. Un sistema portàtil ha de ser capaç de funcionar en una àmplia varietat de dispositius i entorns sense necessitat de modificacions.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "href": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "title": "Introducció",
    "section": "Disseny de Sistemes Operatius",
    "text": "Disseny de Sistemes Operatius\nEl disseny d’un sistema operatiu (SO) és una tasca complexa que requereix la creació d’una sistema robust, segur i eficient per gestionar el maquinari i proporcionar serveis als usuaris i aplicacions. Els dissenyadors de sistemes operatius han de tenir en compte una varietat de factors per assegurar que el sistema compleixi amb els requisits de rendiment, seguretat i funcionalitat ,maximitzant o minimizant les mètriques d’avaluació discutides anteriorment.\n\nComplexitat de la Programació Distribuïda: Els sistemes operatius han de gestionar entorns distribuïts. Això implica coordinar múltiples nodes, mantenir la coherència de dades i gestionar les comunicacions en xarxa. Aquesta complexitat es veu amplificada en sistemes com el núvol (cloud computing).\nComplexitat de la Programació Concorrent: Els sistemes operatius han de gestionar múltiples processos i fils d’execució de manera eficient. Això implica la gestió de la sincronització, la comunicació i la compartició de recursos entre els processos.\nComplexitat pel Context (Mòbil, IoT, Servidors): Els SO per a dispositius mòbils, Internet de les Coses (IoT) i servidors tenen requisits específics que influeixen en el seu disseny. Per exemple, iOS i Android han de ser àgils i adaptatius per a diverses condicions d’ús (interficies tàctils, usuaris en constant moviment), mentre que sistemes com Linux per a servidors han de gestionar càrregues elevades i proporcionar alta disponibilitat.\nComplexitat per la Heterogeneïtat del Hardware: La diversitat en els components de maquinari presenta reptes significatius en la compatibilitat i el rendiment. Els dissenyadors han de desenvolupar sistemes operatius que puguin adaptar-se a diverses arquitectures de maquinari, cosa que pot requerir solucions innovadores per garantir un rendiment òptim. Avui en dia, tenim processadors de diferents fabricants (Intel, AMD, ARM), xarxes de comunicació diverses (Ethernet, Wi-Fi, 5G) i dispositius d’emmagatzematge amb tecnologies variades (SSD, HDD, cintes magnètiques). Els SO han de ser capaços de gestionar aquesta diversitat de manera eficient.\nPortabilitat: La capacitat d’un SO per ser executat en diferents plataformes de maquinari és essencial. Un exemple de portabilitat és Java, amb la seva màquina virtual (JVM) que permet executar aplicacions en diverses plataformes sense necessitat de recompilació. Els contenidors Docker són un altre exemple de portabilitat, ja que permeten als desenvolupadors executar aplicacions en entorns aïllats sense dependències de la plataforma.\nSeguretat: Els dissenyadors han de tenir en compte les vulnerabilitats de seguretat, com ara atacs de dia zero, malware i vulnerabilitats de xarxa. Sistemes com SELinux i AppArmor ofereixen funcions de seguretat avançades per protegir els sistemes contra amenaces. Per exemple, al 2024, va sorgir una vulnerabilitat que afectava gairebé a tots els sistemes linux. Aquesta vulnerabilitat es coneix com en xz-utils identificada com CVE-2024-3094. Podeu trobar més informació sobre aquesta vulnerabilitat a CVE-2024-3094. Aquesta vulnerabilitat permetia que un atacant executés codi maliciós amb privilegis elevats mitjançant un fitxer especialment manipulat que explota una debilitat en el procés de descompressió de fitxers.\nEficiència: Els SO han de ser eficients en l’ús dels recursos del sistema, com la CPU, la memòria i el disc dur. Això implica optimitzar els algorismes i les estructures de dades per garantir un rendiment òptim.\nEscalabilitat: Els SO han de ser capaços de créixer amb les necessitats del sistema, ja sigui en termes de càrrega de treball, nombre d’usuaris o mida de la xarxa. Això implica dissenyar sistemes que puguin adaptar-se a canvis en les condicions del sistema i mantenir un rendiment estable en tot moment.\nMantenibilitat: Els SO han de ser fàcils de mantenir i actualitzar per garantir un funcionament continu i sense interrupcions. Això implica dissenyar sistemes amb una arquitectura clara i modular que permeti fer canvis i millores sense afectar la funcionalitat existent.\nCompatibilitat: Els SO han de ser compatibles amb una àmplia gamma de programari i dispositius per garantir una transició suau entre versions i maximitzar l’ús de programari existent. Això implica dissenyar sistemes que puguin interactuar amb una varietat de dispositius i aplicacions sense problemes.\nUsabilitat: Els SO han de ser fàcils d’utilitzar i entendre per als usuaris, amb una interfície clara i intuïtiva que faciliti la interacció amb el sistema. Això implica dissenyar sistemes amb una interfície d’usuari coherent i funcionalitats accessibles per a tots els usuaris.\nAdaptabilitat: Els SO han de ser capaços d’adaptar-se a canvis en l’entorn del sistema, com ara actualitzacions de programari, canvis en la càrrega de treball o noves tecnologies. Això implica dissenyar sistemes que puguin evolucionar amb el temps i mantenir la seva funcionalitat en situacions canviants.\nTolerància a Fallades: Els SO han de ser tolerants a fallades per garantir la integritat del sistema en cas de problemes. Això implica dissenyar sistemes que puguin recuperar-se de fallades inesperades i mantenir la seva operació en situacions advers\nTransparència: Els SO han de ser transparents per als usuaris i desenvolupadors, amb una interfície clara i consistent que permeti interactuar amb el sistema de manera senzilla. Això implica dissenyar sistemes amb una interfície d’usuari coherent i funcionalitats accessibles per a tots els usuaris.\n\n\nCas pràctic: Vehicle autònom\nImaginem que estem dissenyant un sistema operatiu per a un vehicle autònom. Quins serien els requisits clau que hauríem de tenir en compte en el disseny del sistema operatiu?\n\nSeguretat: La seguretat és una prioritat en un vehicle autònom, ja que ha de garantir que el vehicle no pugui ser controlat remotament per un atacant malintencionat. Això implica implementar mesures de seguretat com xifrat de comunicacions, autenticació robusta i protecció contra vulnerabilitats conegudes. A més, s’han de protegir les dades sensibles, com les dades de localització i informació personal dels passatgers.\nTolerància a fallades: El sistema ha de ser tolerant a fallades, amb mecanismes per detectar, aïllar i recuperar-se de errors. Això implica utilitzar tècniques com la redundància de components i sistemes, així com implementar mecanismes de recuperació i reconfiguració automàtica en cas de fallades. La capacitat de recuperació ha de permetre al vehicle continuar funcionant amb seguretat fins i tot en cas de fallades parcials. Els accidents no poden ser una opció.\nGestió de recursos: El sistema ha de gestionar eficientment els recursos del vehicle, com la CPU, la memòria i els sensors. Ha de prioritzar les tasques crítiques per a la conducció segura, com la detecció de obstacles i la presa de decisions en temps real, mentre optimitza altres processos per a un rendiment global equilibrat.\nAdaptabilitat: Ha de ser capaç d’adaptar-se a canvis en les condicions de la carretera, com variacions en el clima, el trànsit i l’estat de les carreteres. Això requereix una infraestructura flexible i adaptable que pugui ajustar les estratègies de conducció i la gestió dels recursos en resposta a les condicions dinàmiques.\n\n\n\nCas pràctic: Sistema operatiu d’un telèfon mòbil\nAra, considerem el sistema operatiu d’un telèfon mòbil:\n\nUsabilitat: La interfície ha de ser fàcil d’utilitzar i intuitiva per als usuaris, amb funcionalitats accessibles i una navegació clara. Ha de permetre als usuaris interactuar amb el dispositiu de manera eficaç i senzilla, amb opcions de personalització i configuració per adaptar-se a les preferències de l’usuari.\nCompatibilitat: Ha de ser compatible amb una àmplia gamma d’aplicacions i serveis, assegurant-se que les aplicacions funcionin correctament en diferents models de dispositius i versions del sistema operatiu. Això implica la gestió de la compatibilitat amb hardware divers i la integració amb serveis de tercers.\nSeguretat de dades: El sistema operatiu ha de protegir la privacitat i la confidencialitat de les dades dels usuaris. Això implica implementar mesures de seguretat com xifrat de dades emmagatzemades i en trànsit, control d’accessos a aplicacions, i actualitzacions de seguretat regulars per abordar vulnerabilitats noves.\nEficiencia energètica: Ha de ser eficient en l’ús de la bateria, optimitzant els processos i serveis per maximitzar l’autonomia. Això pot incloure tècniques com la gestió intel·ligent del consum energètic, l’optimització del rendiment dels processadors i la gestió efectiva de les aplicacions en segon pla.\nRendiment: Ha de proporcionar un rendiment fluït i ràpid, amb temps de resposta mínims per a les accions dels usuaris. Això implica una gestió eficient dels recursos del sistema, incloent la CPU, la memòria RAM i l’emmagatzatge, així com l’optimització de les operacions d’entrada/sortida.\nMobilitat: Ha de ser dissenyat per a la mobilitat, amb funcionalitats com la connexió sense fils, la geolocalització i la integració amb serveis de xarxa mòbil. Això implica la gestió de la connectivitat, la gestió de la xarxa i la integració amb serveis de localització per proporcionar una experiència mòbil completa.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#referències",
    "href": "notes/01-introduction.html#referències",
    "title": "Introducció",
    "section": "Referències",
    "text": "Referències\n\nModern Operating Systems, Andrew S. Tanenbaum, Herbert Bos, Pearson, 2014.\nOperating System Concepts, Abraham Silberschatz, Peter B. Galvin, Greg Gagne, Wiley, 2018.\nOperating Systems: Three Easy Pieces, Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau, Arpaci-Dusseau Books, 2014.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html",
    "href": "activities/unit00/01-debianbin.html",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informació de l’usuari, gestionar fitxers i directoris.\nPracticar la manipulació de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creació de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#objectius",
    "href": "activities/unit00/01-debianbin.html#objectius",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informació de l’usuari, gestionar fitxers i directoris.\nPracticar la manipulació de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creació de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#introducció",
    "href": "activities/unit00/01-debianbin.html#introducció",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "Introducció",
    "text": "Introducció\nAls sistemes operatius basats en el nucli de Linux, no hi ha una paperera de reciclatge per defecte. Aquesta funcionalitat, habitual en altres sistemes, no està integrada nativament en l’estructura de fitxers de Linux. L’objectiu d’aquest laboratori és implementar una paperera de reciclatge per a Linux i crear una eina que permeti utilitzar-la (rmsf).\nman rmsf",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "href": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "rmsf(1) - Manual de l’usuari",
    "text": "rmsf(1) - Manual de l’usuari\n\nNOM\nrmsf - Eliminació segura de fitxers i carpetes\n\n\nSÍNTESI\nrmsf file …\n\n\nDESCRIPCIÓ\nL’eina rmsf mou els fitxers i carpetes especificats a la línia de comandes al directori .trash/, situat al directori personal de l’usuari. Aquest procés no suposa l’eliminació definitiva dels fitxers. El programa crea el directori .trash si no existeix. Si els fitxers no tenen permisos d’escriptura i el dispositiu d’entrada estàndard és un terminal, l’usuari rebrà una sol·licitud de confirmació (mostrada a la sortida d’error estàndard).\n\n\nESTAT DE SORTIDA\nrmsf retorna un codi d’èxit 0 en cas d’èxit i &gt;0 si es produeix algun error.\n\n\nEXEMPLES\nEls següents exemples mostren l’ús comú:\n\nrmsf file1\nrmsf file1 dir\nrmsf file1 dir/file2 b\nrmsf file1 dir/subdir/file2",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#tasques",
    "href": "activities/unit00/01-debianbin.html#tasques",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "Tasques",
    "text": "Tasques\n\nObtenint informació de l’usuari\nEl primer pas per implementar rmsf és obtenir informació sobre l’usuari que executa el programa. En particular, necessitem saber quin és el seu directori home per poder crear la paperera allà. Necessitem consultar dues crides a sistema per aconseguir-ho: getuid() i getpwuid().\n\n\n\n\n\n\nConsell\n\n\n\nAquestes crides a sistema es defineixen als fitxers d’encapçalament &lt;unistd.h&gt; i &lt;pwd.h&gt;, respectivament i es poden consultar a la pàgina del manual: man 2 getuid i man 3 getpwuid.\n\n\nConstrueix el programa whoami.c que imprimeix el nom de l’usuari actual.\n\n\nComprovant si un directori existeix\nAbans de moure res, hem de saber si la paperera ($HOME/.trash) existeix. Per això, utilitzarem la crida a sistema stat(), que ens permet obtenir informació sobre un fitxer o directori. Per veure com funciona, consulta la pàgina del manual: man 2 stat.\nConstrueix el programa mystat.c que comprova si un directori existeix amb stat().\nConstrueix també una versió alternativa mystat2.c que utilitzi opendir() per comprovar l’existència del directori. Consulta la pàgina del manual: man 3 opendir.\n\n\n\n\n\n\nConsellSeccions del manual\n\n\n\nLa diferencia entre la secció 2 i la 3 del manual és que la primera fa referència a crides a sistema (sistema operatiu) i la segona a funcions de la biblioteca estàndard de C.\n\n\n\n\nConcatenant rutes\nPer construir la ruta completa de la paperera ($HOME/.trash), necessitem concatenar cadenes. Una cadena fixa (“.trash”) amb la cadena que representa el directori home de l’usuari. La biblioteca estàndard de C proporciona diverses funcions per treballar amb cadenes, com strcat(), strcpy(), i sprintf().\nCrear un petit programa que concateni el home de l’usuari amb la cadena “.trash”. Peer fer-ho, utilitzarem memòria dinàmica amb malloc() per reservar l’espai necessari per a la cadena resultant i free() per alliberar-la després d’usar-la.\n\n\nCreant directoris\nPer poder veure la informació de la crida a sistema mkdir() fem man 2 mkdir.\nImplementa el programa mkd.c que donat un directori comprovi si existeix i si no el crei amb tots els permisos per l’usuari i sense permisos pel grup i altres.\n\n\nMovent fitxers i directoris\nPer moure fitxers, utilitzarem la crida a sistema rename(), que permet canviar el nom o la ubicació d’un fitxer o directori. Consulta la pàgina del manual: man 2 rename.\nImplementa el programa mymv.c que mogui un fitxer a la paperera. Pode assumir que la paperera ja existeix.\n\n\nImplementant rmsf\nAmb totes les peces anteriors, ja podem muntar rmsf. Implementa el programa rmsf.c.\n\n\nExercicis Opcionals\n\nFeu servir aquest enllaç per crear un repositori privat a la organització del curs a GitHub: https://classroom.github.com/a/fQB99psI\nPuja el codi rmsf.c al repositori.\nImplementa un Makefile per compilar i executar el programa.\nActualitzeu el programa utilitzant la llibreria getopt per poder passar opcions com:\n\n-h per mostrar l’ajuda.\n-v per mostrar la versió.\n-d per enviar a la paperera de reciclatge fitxers i directoris.\n-r per recuperar fitxers i directoris de la paperera de reciclatge a la seva ubicació original.\n-t per mostrar la ubicació de la paperera de reciclatge.\n\nAfegiu una opció per preguntar a l’usuari si vol enviar a la paperera cada fitxer o directori. I en cas afirmatiu, enviar-lo. En cas negatiu, no fer res. Aquesta opció pot estar activada per defecte i es pot desactivar amb l’opció -y.\nInvestiga com crear una realsease a GitHub i crea una release amb el teu codi anomenada v1.0.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contribueix",
    "section": "",
    "text": "Aquest material és de codi obert i podeu col·laborar-hi, complementar-lo o corregir-lo mitjançant pull requests al repositori.\n\n\n\nFork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original.\n\n\n\n\nPer editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "href": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "title": "Contribueix",
    "section": "",
    "text": "Fork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original."
  },
  {
    "objectID": "CONTRIBUTING.html#edició-del-material",
    "href": "CONTRIBUTING.html#edició-del-material",
    "title": "Contribueix",
    "section": "",
    "text": "Per editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducció\n📖\n📚\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualització i Control de Versions\n📖\n\n📄 📄 📄 📄 📄\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducció a la programació de Sistema (I) (C)\n📖\n\n\n\n👩🏻‍💻"
  },
  {
    "objectID": "course-information/schedule.html#planificació",
    "href": "course-information/schedule.html#planificació",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducció\n📖\n📚\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualització i Control de Versions\n📖\n\n📄 📄 📄 📄 📄\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducció a la programació de Sistema (I) (C)\n📖\n\n\n\n👩🏻‍💻"
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-sense-virtualització",
    "href": "labs/01-lab-introduction.html#esquema-sense-virtualització",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema sense virtualització",
    "text": "Esquema sense virtualització",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-amb-virtualització",
    "href": "labs/01-lab-introduction.html#esquema-amb-virtualització",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema amb virtualització",
    "text": "Esquema amb virtualització",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 1: Objectiu",
    "text": "Laboratori 1: Objectiu\n\nUna màquina virtual amb Debian 12 comparint recursos amb el vostre ordinador físic.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 1: Tasques",
    "text": "Laboratori 1: Tasques\n\nInstal·lar un hypervisor: VMWare Workstation Pro o VMWare Fusion.\nDesplegar una màquina virtual amb Linux dins de l’hypervisor.\n\n\n📄 Laboratori 1: Instal·lació de Debian 12",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 2: Objectiu",
    "text": "Laboratori 2: Objectiu\n\nConnectar VSCode que s’executa a la màquina real per executar i comunicar-se amb la màquina virtual via SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 2: Tasques",
    "text": "Laboratori 2: Tasques\n\nConfigurar VSCode per connectar-se a la màquina virtual via SSH.\nProvar la connexió i executar ordres a la màquina virtual des de VSCode\n\n\n📄 Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 3: Objectiu",
    "text": "Laboratori 3: Objectiu\n\n\n📄 Laboratori 3: Hola món en C a Debian",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "href": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El problema de les versions 💾",
    "text": "El problema de les versions 💾\nQuantes vegades us ha passat que heu perdut un document o heu treballat sobre una versió antiga?\n\n\nprojecte_final.docx\nprojecte_final_v1.docx\nprojecte_final_definitiu.docx\n\n\n\nÉs difícil saber quin és l’arxiu correcte, quins canvis s’hi han fet i per què. I si vull recuperar parts d’una versió anterior?",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#la-solució-control-de-versions",
    "href": "labs/01-lab-introduction.html#la-solució-control-de-versions",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "La solució: Control de Versions",
    "text": "La solució: Control de Versions\nImagina’t que cada vegada que fas un canvi important en el teu document:\n\nGuardes una foto del document en aquell moment, amb una descripció dels canvis que has fet.\nAconsegueixes tenir un historial de totes les versions del document.\n\n\nSeria com tenir una màquina del temps per als teus documents!",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Control de Versions amb Git 🕰️",
    "text": "Control de Versions amb Git 🕰️",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-túnel-del-temps-de-git",
    "href": "labs/01-lab-introduction.html#el-túnel-del-temps-de-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El túnel del temps de Git ⏳",
    "text": "El túnel del temps de Git ⏳",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-multivers-de-git",
    "href": "labs/01-lab-introduction.html#el-multivers-de-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El multivers de Git 🌌",
    "text": "El multivers de Git 🌌",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 4: Objectiu",
    "text": "Laboratori 4: Objectiu\n\nInstal·lar i configurar el vostre entorn de desenvolupament (IDE) per connectar-vos a la màquina virtual mitjançant SSH i utilitzar Git per al control de versions dels vostres projectes.\nReplicarem l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.\n\n\n📄 Laboratori 4: Git",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#collaboració-en-equip",
    "href": "labs/01-lab-introduction.html#collaboració-en-equip",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Col·laboració en equip 🤝",
    "text": "Col·laboració en equip 🤝\nEn la vostra vida professional, és molt probable que treballeu en equips on diverses persones col·laboren en els mateixos projectes. Necessitareu que tots els membres de l’equip puguin sincronitzar els seus controls de versions i compartir els canvis de manera eficient.\n\nSeria com quan feu fotos amb el vostre mòbil i es guarden automàticament al núvol i les podeu veure en qualsevol moment i des de qualsevol dispositiu i les podeu compartir fàcilment.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Control de Versions amb GitHub 🐙",
    "text": "Control de Versions amb GitHub 🐙\nGitHub és una plataforma en línia que facilita aquesta col·laboració, us permet mantenir una còpia als seus servidors i compartir els vostres projectes amb altres persones o tenir una còpia de seguretat al núvol per si perdeu la vostra còpia local.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-de-collaboració-amb-github",
    "href": "labs/01-lab-introduction.html#esquema-de-collaboració-amb-github",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema de col·laboració amb GitHub",
    "text": "Esquema de col·laboració amb GitHub",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 5: Objectiu",
    "text": "Laboratori 5: Objectiu\n\nCrear una calculadora col·laborativa utilitzant Git i GitHub.\nAprendre a treballar amb branques i fer merge de canvis.\nPracticar la resolució de conflictes en un entorn de col·laboració.\n\n\n📄 Laboratori 5: Calculadora col·laborativa",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html",
    "href": "labs/01-introduction/lab02.html",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la màquina virtual mitjançant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#objectius",
    "href": "labs/01-introduction/lab02.html#objectius",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la màquina virtual mitjançant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#requisits-previs",
    "href": "labs/01-introduction/lab02.html#requisits-previs",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nMàquina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) instal·lat al vostre ordinador. Podeu descarregar-lo des de https://code.visualstudio.com/.\nObtenir la IP de la màquina virtual. Per fer-ho, podeu:\n\nConsultar la informació a VMWare: \nO bé, iniciar sessió a la màquina virtual i executar la comanda ip a per obtenir la IP: \n\n\n\n\n\n\n\nNota\n\n\n\nEn els dos casos, la IP de la màquina virtual és 172.16.10.223.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-màquina-virtual",
    "href": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-màquina-virtual",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Configurant VSCode per connectar-se a la màquina virtual",
    "text": "Configurant VSCode per connectar-se a la màquina virtual\nUn cop hagueu instal·lat el vostre entorn de desenvolupament (IDE), podeu afegir les següents extensions utilitzant el marketplace de VSCode: remote-ssh. Primer, feu clic a Marketplace (1), després cerqueu remote-ssh i, finalment, feu clic a (3) per instal·lar la extensió. Consulteu la imatge:\n\nUn cop hagueu instal·lat la extensió, ja podeu connectar-vos a la màquina virtual. Per fer-ho, feu clic a la icona de la part inferior esquerra (1) i seleccioneu l’opció Remote-SSH: Connect to Host… (2). Consulteu la imatge:\n\nAra apareixerà una finestra on podreu escriure la connexió SSH. També veureu l’opció Add a New SSH Host. Feu clic en aquesta opció i introduïu la comanda SSH per connectar-vos a la màquina virtual. Consulteu la imatge:\n\nSeleccioneu la primera opció del menú desplegable amb la ruta del vostre usuari i feu clic a Add. Consulteu la imatge:\n\ni comproveu que l’amfitrió s’ha afegit correctament.\n\nAra feu clic a Open Config i observeu que s’ha creat una nova entrada amb el vostre usuari i la IP de la màquina virtual:\nHost 172.16.10.223\n  HostName 172.16.10.223\n  User jordi\nUs recomano que modifiqueu el fitxer de configuració perquè sigui més fàcil de recordar. Per exemple, podeu canviar el nom de l’amfitrió per vm-curs0-debian12 :\nHost vm-curs0-debian12\n  HostName 172.16.10.202\n  User jordi\nUn cop hagueu modificat el fitxer de configuració, guardem-lo i tanquem-lo. Ara ja podeu connectar-vos a la màquina virtual vm-curs0-debian12. Per fer-ho:\n\nFeu clic a la icona de la part inferior esquerra.\nSeleccioneu Remote-SSH: Connect to Host….\nSeleccioneu vm-curs0-debian12:\n\n\nUs apareixerà una finestra emergent que us demanarà si voleu confiar en l’amfitrió. Feu clic a Continue. \nUs apareixerà una altra finestra emergent que us demanarà la contrasenya de l’usuari jordi. \n\n\n\n\n\n\n\nNota\n\n\n\nLa primera vegada que us connecteu a la màquina virtual, VSCode instal·larà el servidor remot a la màquina virtual. Això pot trigar uns minuts.\n\n\nUn cop us hàgiu connectat, veureu que la finestra de VSCode ha canviat i que ara esteu treballant a la màquina virtual. Podeu comprovar-ho a la part inferior esquerra on apareix el nom de l’amfitrió vm-curs0-debian12.\n\nPer comprovar que tot funciona correctament, podeu obrir una terminal integrada a VSCode i executar la comanda uname -a per veure la informació del sistema i comprovar que esteu a la màquina virtual.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html",
    "href": "labs/01-introduction/lab04.html",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "",
    "text": "Instal·lar i configurar Git a la màquina virtual.\nReplicar l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#objectius",
    "href": "labs/01-introduction/lab04.html#objectius",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "",
    "text": "Instal·lar i configurar Git a la màquina virtual.\nReplicar l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#requisits-previs",
    "href": "labs/01-introduction/lab04.html#requisits-previs",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nMàquina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) connectat a la màquina virtual mitjançant SSH (vegeu Laboratori 2).",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#installació-de-git-a-la-màquina-virtual",
    "href": "labs/01-introduction/lab04.html#installació-de-git-a-la-màquina-virtual",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Instal·lació de Git a la màquina virtual",
    "text": "Instal·lació de Git a la màquina virtual\n\nConnecteu VSCode a la màquina virtual mitjançant SSH (vegeu Laboratori 2).\nInicia la sessió de l’usuari root amb la comanda:\nsu -\nEl guionet - és important perquè carregui correctament les variables d’entorn de l’usuari root.\nCom a usuari root. Instal·la el programari git amb la comanda:\napt install git -y\nUn cop finalitzi la instal·lació, comproveu la versió de git amb la comanda:\ngit --version\nSortiu de la sessió de l’usuari root amb la comanda:\nexit",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#configuració-de-git",
    "href": "labs/01-introduction/lab04.html#configuració-de-git",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Configuració de Git",
    "text": "Configuració de Git\nPer començar a treballar amb Git, primer cal configurar el nostre usuari i correu electrònic. Aquesta informació s’utilitzarà per identificar els commits que fem al repositori. Per configurar el nostre usuari i correu electrònic, executem les següents comandes:\ngit config --global user.name \"JordiMateo\"\ngit config --global user.email \"jordi.mateo@udl.cat\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#replicació-de-lexemple",
    "href": "labs/01-introduction/lab04.html#replicació-de-lexemple",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Replicació de l’exemple",
    "text": "Replicació de l’exemple\n\nCrearem un repositori nou anomenat projecte-final:\nmkdir projecte-final\nAccedim al directori del projecte:\ncd projecte-final\no bé podeu fer click a Obre la carpeta a VSCode i seleccionar el directori projecte-final.\n\nCrearem els 3 fitxers (treball.txt, figura1.png, figura2.png) i els afegirem al directori de treball:\necho \"Aquest és el fitxer de treball.\" &gt; treball.txt\ntouch figura1.png figura2.png\n\nAra inicialitzarem el repositori Git:\ngit init\n\no bé, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode i fer click a Inicia el repositori Git.\n\n\n\n\n\n\n\nNota\n\n\n\n\nSi feu anar la línia de comandes, haures de posar els fitxers a la caixa d’espera (staging area) manualment. git add . afegeix tots els fitxers del directori actual a la caixa d’espera.\nSi feu servir la eina integrada de Git a VSCode, us apareixerà una finestra emergent que us demanarà si voleu afegir tots els fitxers a la caixa d’espera (staging area). Feu click a Yes.\n\n\n\n\nSi us fixeu, veureu que VSCODE us indica que hi ha 3 fitxers nous que encara no s’han confirmat (posats al camió de mudances).\n\n\n\nAra farem el primer commit amb el missatge “Primer commit: Afegits els fitxers inicials”. Podeu fer-ho des de la línia de comandes:\ngit commit -m \"Primer commit: Afegits els fitxers inicials\"\no bé, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode, escriure el missatge del commit i fer click a la icona de check (✓) per confirmar els canvis.\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserveu que després de fer el commit, els fitxers ja no apareixen a la secció de canvis pendents (Changes). I teniu la linia temporal inicialitzada amb un commit.\n\n\n\n\nFarem un canvi al fitxer treball.txt:\necho \"Afegit la introducció.\" &gt;&gt; treball.txt\n\nCom el document treball.txt ja està a la caixa d’espera, només cal que fem un nou commit:\ngit commit -am \"Segon commit: Afegida la introducció al fitxer de treball\"\n\nAra podem veure l’historial dels commits fets fins ara:\ngit log\n\nPodem tornar a una versió anterior si cal. Per exemple, per tornar al primer commit:\ngit checkout HEAD~1\no bé, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, després a la pestanya d’Historial (History) i fent click dret al commit on volem tornar i seleccionant l’opció Checkout.\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a una versió anterior, el directori de treball es posa en la versió seleccionada, ara ja no tenim el text “Afegit la introducció.” al fitxer treball.txt. Això és perquè hem tornat a la versió anterior on aquest canvi no existia.\n\n\n\nPer tornar a la versió més recent, fem:\ngit checkout main\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a la versió més recent, el directori de treball es torna a la versió més nova, i ara tornem a tenir el text “Afegit la introducció.” al fitxer treball.txt.\n\n\n\nAra podem crear una branca nova per treballar en una nova funcionalitat:\ngit checkout -b metodologia\no bé, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, després a la part inferior esquerra on apareix el nom de la branca actual (main) i fent click a Create new branch.\n\nFarem un canvi al fitxer treball.txt a la branca metodologia:\necho \"Afegida la secció de metodologia.\" &gt;&gt; treball.txt\n\nFem un commit amb aquest canvi:\ngit commit -m \"Afegida la secció de metodologia al fitxer de treball\"\nPodem veure les branques existents:\ngit branch\n\nPer tornar a la branca principal:\ngit checkout main\nPer anar a la branca metodologia:\ngit checkout metodologia\nTambé podem fusionar la branca metodologia a la branca main:\ngit checkout main\ngit merge metodologia\n\n\nAmb això hem explorat les funcionalitats bàsiques de Git. Podeu continuar experimentant amb més canvis, branques i commits per familiaritzar-vos amb el flux de treball de Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar més les vostres habilitats amb Git. Centreu-vos en els exercicis MAIN.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "href": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Desenvolupament en sistemes Linux/UNIX",
    "text": "Desenvolupament en sistemes Linux/UNIX\nEl desenvolupament de programari de sistema el realitzarem amb els llenguatge C i basa en els compiladors GNU gcc.\n#!/bin/sh\n# ./check.sh\ngcc -v\nif [ $? != 0 ]; then\n       echo \"GCC is not installed!\"\nfi\nld -v\nif [ $? != 0 ]; then\n        echo \"Please install binutils!\"\nfi\n\nFitxer: scripts/check.sh\n\n\nPer poder desenvolupar en C en un sistema Linux/UNIX necessitem tenir instal·lat el compilador GCC i les eines de binutils. Aquestes eines són necessàries per a la compilació i enllaçat dels programes. Per comprovar si tenim instal·lat aquestes eines podem executar el script anterior. Si no tenim instal·lat aquestes eines, podem instal·lar-les amb la comanda sudo apt-get install build-essential en sistemes basats en Debian o sudo dnf groupinstall \"Development Tools\" en sistemes basats en RedHat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "href": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Navegant a les entranyes del compilador GCC",
    "text": "Navegant a les entranyes del compilador GCC\n\n\n\n\n\n\n\nEls llenguatges de programació compilats són aquells que es tradueixen a codi màquina abans de l’execució. Aquest procés de traducció es realitza per un programa anomenat compilador. El compilador és un programa que tradueix el codi font d’un programa escrit en un llenguatge de programació de nivell alt a codi màquina. En el cas de C, hi ha diferents etapes codi, ensamblador i enllaçador. El compilador GCC és un compilador de codi obert que es pot utilitzar per a la compilació de programes en C, C++, Fortran, Ada, etc. Aquest compilador és molt potent i permet la compilació de programes en diferents plataformes. A més, el compilador GCC és molt flexible i permet la configuració de diferents opcions de compilació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-i",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (I)",
    "text": "Etapes de la compilació i l’enllaç (I)\nPreprocessador\n\nEl preprocessador processa el codi font, buscant instruccions que comencen amb un hash (#), com #include, #define, i #ifdef.\nInclou fitxers d’encapçalament (headers) i substitueix macros i definicions. També elimina els comentaris.\nGenera un fitxer de codi font amb les instruccions del preprocessador processades, preparat per a la compilació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-ii",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (II)",
    "text": "Etapes de la compilació i l’enllaç (II)\nCompilador\n\nTraduïx el codi font al assemblador equivalent. En alguns compiladors, el codi es pot convertir directament en codi màquina en aquesta etapa.\nTraduir el codi de nivell alt a codi de nivell baix i optimitzar-lo per al maquinari subjacent.\nGenera un fitxer de codi assemblador amb l’extensió .s. Per exemple, si el fitxer de codi font és hola.c, el fitxer generat seria hola.s.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iii",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (III)",
    "text": "Etapes de la compilació i l’enllaç (III)\nAssemblador\n\nConverteix el codi assemblador en codi objecte o codi de màquina.\nProduir codi binari que pugui ser entès per la CPU.\nGenera un fitxer de codi objecte amb l’extensió .o. Per exemple, el fitxer resultant seria hola.o.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iv",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iv",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (IV)",
    "text": "Etapes de la compilació i l’enllaç (IV)\nEnllaçador (Linker)\n\nEnllaça el codi objecte amb les biblioteques necessàries per crear l’executable final.\nOrganitzar i combinar el codi objecte i les biblioteques, resolent les referències externes.\nGenera l’executable final, que és el fitxer que podeu executar. Per exemple, hola.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-etapes",
    "href": "slides/01-c.html#exemple-etapes",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Etapes",
    "text": "Exemple: Etapes\n\n\n#include &lt;stdio.h&gt;\n\n#define x 10\n#define y 5\n\nint \nmain(){\n  printf(\"El resultat de l'opearció: \n      %d + %d = %d\\n\", x,y,x+y);\n    return 0;\n}\n\nFitxer: sources/ex1.c\n\n\n\nExecutable: gcc -o ex1 ex1.c\nAssemblador: gcc -S -o ex1.s ex1.c\nCodi objecte: gcc -c -o ex1.o ex1.c\nPreprocessador: gcc -E -o ex1.i ex1.c\nDesensamblador: objdump -d ex1.o o objdump -d -M intel ex1\n\n\n\n\n\n\n\n\n\nNotes\n\n\n\n-M intel indica l’ús de la sintaxi Intel per a una millor llegibilitat.\nTots aquests fitxers generats els posarem al .gitignore.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "href": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funciona el compilador GCC?",
    "text": "Com funciona el compilador GCC?\ngcc &lt;codi&gt; -g -c &lt;codi&gt; -o &lt;executable&gt; -I &lt;dirIncludes&gt; -L &lt;dirLibs&gt;\n\n-g: Genera informació de depuració.\n-c: Enllaça només el fitxer especificat.\n-o: Fitxer executable de sortida (per defecte a a.out).\n-I: Directoris on es cercaran els fitxers .h.\n-L: Directoris on es cercaran les biblioteques.\n-l: Biblioteques a enllaçar.\n-Wall: Mostra tots els missatges d’advertència.\n-Werror: Converteix els missatges d’advertència en errors.\n-Wextra: Mostra missatges d’advertència addicionals.\n…: Altres opcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-hola-món",
    "href": "slides/01-c.html#el-nostre-primer-programa-hola-món",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "El nostre primer programa: Hola món",
    "text": "El nostre primer programa: Hola món\n\n\n\nPreprocessador: El fitxer stdio proporciona la definició de la funció printf.\nmain(): Funció principal i obligatòria. Aquesta no rep cap argument i retorna un enter.\nLa funció printf rep un argument del tipus char *.\nreturn 0: Indica que tot ha anat bé i acaba la funció main().\n\n\n#include &lt;stdio.h&gt;\n/* This is a comment */\nint main()\n{\n    printf(\"Hola món!\\n\");\n    return 0;\n}\n\n# Compilem hola.c\ngcc -o hola hola.c \n# Executem hola\n./hola \n\n\nLa funció printf es troba a la biblioteca estàndard de C, podem consultar man s3 printf per obtenir més informació. Aquesta funció permet mostrar text per pantalla. Els arguments que rep són una cadena de caràcters i els valors que volem mostrar. Els valors es substitueixen a la cadena de caràcters mitjançant el format %d per a enters, %f per a nombres en punt flotant, %c per a caràcters i %s per a cadenes de caràcters. Els caràcters \\n indiquen un salt de línia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "href": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "El nostre primer programa amb llibreries externes",
    "text": "El nostre primer programa amb llibreries externes\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\nint main (void)\n{\n  double x = 2.0;\n  double y = sqrt (x);\n  printf (\"La rai­z cuadrada de %f es %f\\n\", x, y);\n  return 0;\n}\n\nFitxer: sources/arrel.c\n\n// Complilació amb ruta global a la llibreria\ngcc -Wall SO_usingLibraries.c /usr/lib/x86_64-linux-gnu/libm.a -o calc\n// Compilació utilitzant la forma abreujada\ngcc -Wall SO_usingLibraries.c -lm -o calc\n\nPer obtenir informació sobre la funció sqrt podeu consultar la pàgina de manual amb la comanda man -s3 sqrt. Aquesta funció es troba a la biblioteca matemàtica, per això cal enllaçar-la amb el programa. Per això s’utilitza l’opció -lm. Quan compilem un programa en C, el compilador pot incorporar certes funcions de la biblioteca estàndard de forma automàtica perquè són part de les especificacions del llenguatge (com printf, scanf, etc.). No obstant això, altres funcions, com les de la biblioteca matemàtica, no es troben dins d’aquest conjunt i, per tant, cal especificar manualment que volem enllaçar-les amb el programa.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-i",
    "href": "slides/01-c.html#activitat-calculadora-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: Calculadora (I)",
    "text": "Activitat: Calculadora (I)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble suma(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n\ndouble suma(\n  double a, \n  double b) \n  {\n    return a + b;\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  suma(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-ii",
    "href": "slides/01-c.html#activitat-calculadora-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: Calculadora (II)",
    "text": "Activitat: Calculadora (II)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble potencia(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n#include &lt;math.h&gt;\ndouble potencia(\n  double a, \n  double b) \n  {\n    return pow(a, b);\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  potencia(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc -lm\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#els-arguments-dentrada",
    "href": "slides/01-c.html#els-arguments-dentrada",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Els arguments d’entrada",
    "text": "Els arguments d’entrada\nLa funció main() té dos arguments que tradicionalment s’anomenen argc (Longitud del vector d’argument) i argv (Matriu de punters de caràcters).\n\n\nRetorna un enter\n\n0: En cas d’èxit.\n-1 (negatiu): en cas de fallada.\n\n\nint \nmain(int argc, \n     char *argv[]) \n{...}\n\n./a.out -o foo -vv\nargv = [ \"/path/to/a.out\", \n  \"-o\" \"foo\", \"-vv\" ];\n\n\nArgv és una representació tokenitzada.\nArgv[0] mai està buit i sempre conté la ruta completa a l’executable.\n\n\nCom ja hem vist la funció main() és la primera funció del vostre programa que s’executa quan comença a executar-se. Aquesta funció crida a **_start()**, que normalment proporciona la biblioteca de temps d’execució C, enllaçat automàticament quan es compila el programa.\nLa funció main() té dos arguments que tradicionalment s’anomenen argc (Longitud del vector d’argument) i argv (Matriu de punters de caràcters) i retorna un nombre enter amb signe. La majoria dels entorns Unix esperen que els programes tornin 0 (zero) en cas d’èxit i -1 (negatiu) en cas de fallada.\nArgv és una representació tokenitzada de la línia d’ordres que va invocar el vostre programa. Argv[0] mai està buit i sempre conté la ruta completa a l’executable.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-check_args.c",
    "href": "slides/01-c.html#exemple-check_args.c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: check_args.c",
    "text": "Exemple: check_args.c\n\n\n#include &lt;stdio.h&gt;\n\nint\nmain(int argc, char **argv) {\n\n  int i;\n\n  for (i=0; i&lt;argc; i++) {\n    printf(\"%s\\n\", argv[i]);\n  }\n\n  return 0;\n}\n\ngcc check_args.c -o check_args\n./check_args a.out\n./check_args *.c\n./check_args $USER $PWD $SHELL\n\n\nAquest programa ens permet observa com es capturen els arguments.\nAra executarem aquest programa amb els diferents tipus de shell que tenim instal·lades.\nPer modificar la shell: chsh -s /bin/sh jordi.\n\n\n\nFitxer: sources/check_args.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include",
    "href": "slides/01-c.html#include",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Include",
    "text": "Include\nEn el llenguatge de programació C, la directiva #include diu al preprocessador que insereixi el contingut d’un altre fitxer al codi font en el punt on es trobi la directiva #include.\n\n#include &lt;header_file&gt;: El preprocessador cercarà una ruta de directori predeterminada per localitzar el fitxer de capçalera. Normalment, els fitxers són: /usr/include.\n#include \"header_file\": El preprocessador buscarà el fitxer de capçalera al mateix directori que el fitxer font",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include-header-més-improtants",
    "href": "slides/01-c.html#include-header-més-improtants",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Include: Header més improtants",
    "text": "Include: Header més improtants\n\n\n\n\n\n\n\nHeader\nFuncionalitat\n\n\n\n\nstdio\nSubministra entrada i sortida: funcions FILE, stdin, stdout, stderr i fprint().\n\n\nstdlib\nSubministra funcions d’utilitat: malloc(), calloc() i realloc().\n\n\nunistd\nSubministraments EXIT_FAILURE, EXIT_SUCCESS.\n\n\nerrno\nDefineix la variable errno externa i tots els valors que pot prendre.\n\n\nassert\nSubministra funcions de diagnòstic.\n\n\ntime\nSubministraments Funcions de data i hora.\n\n\nmath\nProporciona funcions de suport matemàtiques.\n\n\nstring\nProporciona funcions memcpy(), memset() i strlen().\n\n\ngetopt\nProporciona optarg, opterr i getopt() externs.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#define",
    "href": "slides/01-c.html#define",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Define",
    "text": "Define\nLa directiva #define permet la definició de macros dins del codi font. Aquestes definicions de macro permeten declarar valors constants per utilitzar-los en tot el codi. Les definicions de macro no són variables i el programa no les pot canviar. Utilitzeu aquesta sintaxi quan creeu constants que representen nombres, cadenes o expressions.\n\n\n#definir el valor CNAME\n#definir CNAME (expressió)\n\n#define DEFAULT_PROGNAME \"myProgName\"\n#define BUFSIZE 4096\n\n\nL’expressió s’ha d’entregar entre parèntesis si conté operadors.\nNO poseu ; al final de les sentències #define.\nQuan s’anomena un #define per distingir-lo dels noms de variables i funcions, utilitzeu majúscules.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#external-declarations",
    "href": "slides/01-c.html#external-declarations",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "External declarations",
    "text": "External declarations\nUna declaració externa porta aquest nom a l’espai de noms de la unitat de compilació actual (també conegut com fitxer) i permet al programa accedir a aquesta variable. La paraula clau extern amplia la visibilitat de la funció a tot el programa, la funció es pot utilitzar (anomenar) a qualsevol lloc de qualsevol dels fitxers de tot el programa, sempre que aquests fitxers continguin una declaració de la funció.\nextern int errno;\n// errno s'utilitza com a canal de comunicació per la  biblioteca \n// C estàndard per comunicar el motiu de fallada d'una funció determinada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llibreria-errno",
    "href": "slides/01-c.html#llibreria-errno",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llibreria errno",
    "text": "Llibreria errno\nLa variable global errno és defineix a la biblioteca errno.h.\n\nAquest valor de variable només és rellevant quan la trucada retorna un error (normalment el codi -1).\nPer més informació: $ man errno\nEs pot veure un missatge d’error descriptiu identificat per errno utilitzant la funció perror de la biblioteca &lt;stdio.h&gt;. Funció: void perror(const char*); Aquesta funció primer mostra el missatge i després l’error. #include &lt;stdio.h&gt;.\n\n\nFitxer: sources/errno_example.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-echo-amb-c",
    "href": "slides/01-c.html#activitat-echo-amb-c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: echo amb c",
    "text": "Activitat: echo amb c\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n  int i;\n  if (argc &lt; 2) {\n    fprintf(stderr, \"Usage: %s &lt;string&gt;\\n\", argv[0]);\n    return -1;\n  }\n  for (i = 1; i &lt; argc; i++) {\n    printf(\"%s \", argv[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\nFitxer: sources/echo.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-cd-amb-c",
    "href": "slides/01-c.html#activitat-cd-amb-c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: cd amb c",
    "text": "Activitat: cd amb c\n#include &lt;stdio.h&gt;  // Per fprintf() i perror()\n#include &lt;unistd.h&gt; // Per chdir()\n\nint main(int argc, char *argv[]) {\n    if (argc &lt; 2) {\n        fprintf(stderr, \"Usage: %s &lt;directory&gt;\\n\", argv[0]);\n        return 1;\n    }\n    if (chdir(argv[1]) == -1) {\n        perror(\"chdir\");\n        return 1;  \n    }\n    return 0;  \n}\n\nFitxer: sources/cd.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-un-makefile",
    "href": "slides/01-c.html#què-és-un-makefile",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és un Makefile?",
    "text": "Què és un Makefile?\nUn fitxer Makefile és un fitxer de text que conté un conjunt de regles utilitzades per construir un programa. Aquestes regles indiquen al sistema com compilar i enllaçar el programa.\n\nAutomatització: Simplifica el procés de compilació i enllaçat.\nEficiència: Només es compilen els fitxers modificats, no tot el projecte.\nOrganització: Organitza el codi i les dependències de manera estructurada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#organització-del-makefile",
    "href": "slides/01-c.html#organització-del-makefile",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Organització del Makefile",
    "text": "Organització del Makefile\ntarget: dependencies\n    command\n\ntarget: Nom de l’objectiu (executable o fitxer objecte).\ndependencies: Fitxers necessaris per a generar l’objectiu.\ncommand: Comandaments per a compilar o generar l’objectiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "href": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Plantilla per compilar un programa",
    "text": "Plantilla per compilar un programa\nCC = gcc\nCFLAGS = -Wall -O2\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): programa.c\n    $(CC) $(CFLAGS) -o $(TARGET) programa.c\n\nclean:\n    rm -f $(TARGET)\n\nLa opció -O2 és un nivell d’optimització per al compilador. Indica al compilador que optimitzi el codi generat per a un millor rendiment. Inclou un conjunt d’optimitzacions per millorar la velocitat i la grandària del codi. Tenim diferents nivells d’optimització, per exemple -O0, -O1, -O2, -O3, -Os, -Og, -Ofast.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "href": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com gestiona l’entrada i sortida el SO?",
    "text": "Com gestiona l’entrada i sortida el SO?\nUns dels objectius del SO és proporcionar una màquina virtual que uniformitzi la complexitat dels dispositius d’E/S, necessitem independitzar les operacions i els dispositius.\n\nDispositius reals: Existeix en el món real. Combinació de diferents elements harwdare i software.\nDispositius físics: Formats pel perifèric i pel seu hardware de control i el programari que el gestiona (drivers).\nDispositius lògics: El resultat d’un programari del sistema que crea aquest dispositiu.\n\nNull: Dispositiu d’E/S sobre el qual podem escriure tot el que vulguem i sempre és buit.\nFinestra: Dispositiu lògic d’E/S que combina 4 dispositius físics: pantalla, teclat, memòria i un apuntador (ratolí).\n\n\n\nL’espai lògic és una agrupació d’informació emmagatzemada a la memòria física utilitzant la memòria virtual. Per tant, l’espai lògic d´’un procés es pot veure com un dispositiu entrada/sortida. Us podeu imaginar aquest espai lògic com un fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#esquema-de-dispositius",
    "href": "slides/01-c.html#esquema-de-dispositius",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Esquema de dispositius",
    "text": "Esquema de dispositius",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#dispositius-virtuals",
    "href": "slides/01-c.html#dispositius-virtuals",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Dispositius virtuals",
    "text": "Dispositius virtuals\nUn dispositiu virtual és un dispositiu que a priori no està associat a cap dispositiu real. En temps d’execució el sistema operatiu associarà el dispositiu virtual amb el dispositiu real.\n\nAssociació implícita: El sistema i el procés que ha iniciat l’execució són els encarregats de fer l’associació. Els dispositius virtuals associats de manera implícita són els dispositius estàndard, en el cas d’Unix tenim entrada estàndard (stdin), sortida estàndard(stdout) i sortida estàndard d’errors (stderr).\nAssociació explícita: Aquesta associació es dona entre un dispositiu virtual i un dispositiu real pel mateix programa durant l’execució. Per efectuar-la el programa necessita realitzar una operació específica que donat un dispositiu real generi un dispositiu virtual associat. A partir d’aquest moment el programa realitzarà les operacions d’E/S del dispositiu mitjançant el dispositiu virtual.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-es",
    "href": "slides/01-c.html#operacions-es",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions E/S",
    "text": "Operacions E/S\nEl processos utilitzen els descriptors de fitxers per accedir als dispositius un cop ja han estat oberts per llegir i escriure informació.\n\n\nOperacions\n\nllegir(dispositiu,buffer de lectura,posició)\nescriure(dispositiu,buffer escriptura,posició)\nobrir(dispositiu, operació)\ntancar(dispositiu)\nposicionar(dispositiu, posició)\n\n\nDescriptors\n\n0: Entrada estàndard (stdin)\n1: Sortida estàndard(stdout)\n2: Sortida estàndard d’errors (stderr)\n\n\n\nFixeu-vos que el fet d’utilitzar dispositius virtuals no soluciona el problema de la independència si el sistema operatiu únicament utilitza els dispositius virtuals i aquests han de conèixer les peculiaritats dels dispositius reals per poder operar-hi. Per tant, necessitem una nova capa per damunt dels drivers que uniformitzi les operacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxer",
    "href": "slides/01-c.html#descriptors-de-fitxer",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxer",
    "text": "Descriptors de fitxer",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#fitxers",
    "href": "slides/01-c.html#fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Fitxers",
    "text": "Fitxers\n\n\n\nUn fitxer és una seqüència contigua de bytes.\nEl sistema operatiu no imposa cap format específic.\nCada byte es pot adreçar individualment.\nUn descriptor de fitxer és un nombre enter positiu específic que identifica els seus fixers oberts.\nTots els fitxers oberts per una aplicació es tanquen automàticament quan el procés acaba.\n\n\n\n\n\nValor\nSignificat\nDefecte\n\n\n\n\n0\nstdin (teclat)\nSI\n\n\n1\nstdout (pantalla)\nSI\n\n\n2\nstderr (pantalla)\nSI\n\n\n\\(3...N\\)\ndisponibles pels usuaris\nNO\n\n\n\n\nopen() : obre fitxers per llegir i/o escriure o per crear-los.\ncreat() : crea un fitxer buit.\nread() : llegeix informació d’un fitxer.\nwrite() : escriu informació en un fitxer.\nlseek() : aneu a un byte específic del fitxer.\nunlink() : elimina un fitxer.\nfcntl() : controla els atributs d’un fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#obrint-fitxers",
    "href": "slides/01-c.html#obrint-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Obrint fitxers",
    "text": "Obrint fitxers\nPer crear o obrir un fitxer fem anar les crides a sistema open() i creat(). Aquestes retornen la seva descripció, o retornen -1 si hi ha hagut algun error.\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; sys/stat.h&gt; \n#include &lt; fcntl.h&gt; \n\nint open ( const char *path, \n  int flags [, mode_t mode ]);\nint creat (const char *path, \n  mode_t mode);\n\n\npath: cadena amb el camí relatiu o absolut al fitxer.\nflags: mètode d’obertura de fitxer:\n\nO_RDONLY - només lectura.\nO_WRONLY - només escriptura.\nO_RDWR - lectura i escriptura.\nO_CREAT - crea el fitxer si no existeix.\nO_TRUNC - si existeix, l’obre i es trunca a 0 bytes.\nO_APPEND - escriu al final del fitxer.\n\nmode: especifica els permisos si es crea un fitxer nou (0644: -rw-r–r–)\n\n\n\nPodeu consultar la pàgina de manual de les crides a sistema per obtenir més informació:\n\nman -s2 fcntl\nman -s2 stat\nman -s2 open\nman creat",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#tancant-fitxers",
    "href": "slides/01-c.html#tancant-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Tancant fitxers",
    "text": "Tancant fitxers\nPer tancar un fitxer utilitzarem close(). Aquesta crida a sistema desassocia el fitxer del procés. Retorna 0 si tot funciona correctament, en ca d’error -1.\n#include &lt;unistd.h&gt; \nint close(int fd);\n\nfd: Descriptor de fitxer que volem tancar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-i",
    "href": "slides/01-c.html#descriptors-de-fitxers-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (I)",
    "text": "Descriptors de fitxers (I)\nint main() {\n \n int fd1, fd2, fd3;\n FILE *f;\n printf(\"STDIN_FILENO: %d\\n\", STDIN_FILENO); \n printf(\"stdout: %d\\n\", fileno(stdout)); \n printf(\"STDERR_FILENO: %d\\n\", STDERR_FILENO);\n\n printf(\"\\nOpening /dev/zero...\\n\");\n if ((fd1 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n } else {\n  printf(\"fd1: %d\\n\", fd1);\n }\n\nFitxer: sources/descriptors.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-ii",
    "href": "slides/01-c.html#descriptors-de-fitxers-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (II)",
    "text": "Descriptors de fitxers (II)\n printf(\"\\nOpening /dev/zero a second time...\\n\");\n if ((fd2 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd2: %d\\n\", fd2);\n\n printf(\"\\nNow closing fd1, but keeping fd2 open..\\n\");\n (void)close(fd1);\n\n printf(\"\\nOpening /dev/zero a third time...\\n\");\n if ((fd3 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd3: %d\\n\", fd3);",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-iii",
    "href": "slides/01-c.html#descriptors-de-fitxers-iii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (III)",
    "text": "Descriptors de fitxers (III)\n printf(\"\\nNow closing fd2 and fd3.\\n\");\n (void)close(fd2);\n (void)close(fd3);\n\n printf(\"Now opening /dev/zero as a stream.\\n\");\n if ((f = fopen(\"/dev/zero\", \"r\")) == NULL) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"f: %d\\n\", fileno(f));\n (void)fclose(f);\n\n return EXIT_SUCCESS;\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-i",
    "href": "slides/01-c.html#llegint-fitxers-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxers (I)",
    "text": "Llegint fitxers (I)\n\n\n#include &lt;unistd.h&gt; \nssize_t read\n(int fd, \n void *buf, size_t);\n\nssize_t write\n(int fd, \n void *buf, size_t);\n\nread(): Intenta llegir/escriure fins a nbytes bytes del fitxer especificat per fd i emmagatzemar-los a l’àrea de memòria que comença a buf. Paràmetres:\n\nfd: descriptor del fitxer que es llegirà/escriurà.\nnbytes: nombre de bytes a llegir/escriure.\nbuf : apunta a la memòria intermèdia on es desarà la informació de lectura/escriptura. Retorna:\n\nSi té èxit, retorna el nombre de bytes de lectura/escriptura (0 significa final del fitxer).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxer-ii",
    "href": "slides/01-c.html#llegint-fitxer-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxer (II)",
    "text": "Llegint fitxer (II)\nint main(int argc, char* argv[]) {\n  char string[11]; int b_read;\n  int file = open (\"my_file\", O_RDONLY); \n  if(file == -1) { \n    perror(\"Error while opening file\");\n    exit(1);\n  }\n  b_read = read(file, string, 10);\n  close(file);\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n    b_read, string);\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer.c\n\n\nPer generar un fitxer amb dades aleatòries: head -c 1024 &lt;/dev/urandom &gt; my_file.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-fitxers",
    "href": "slides/01-c.html#escrivint-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Escrivint fitxers",
    "text": "Escrivint fitxers\nint main(int argc, char* argv[]) {\n\n  const char* string = \"\\nWinter is coming\\n\\n\";\n\n  int file = open(\"new_file\", O_CREAT|O_WRONLY, 0644);\n\n  if(file == -1) { \n    perror(\"Error when opening file\");\n    exit(1);\n  }\n\n  write(file, string, strlen(string));\n  close(file);\n\n  exit(0);\n}\n\nFitxer: sources/escriure_fitxer.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegintescrivint-en-llocs-específics",
    "href": "slides/01-c.html#llegintescrivint-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint/Escrivint en llocs específics",
    "text": "Llegint/Escrivint en llocs específics\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; unistd.h&gt; \noff_t lseek( int fd,\n off_t offset, \n int whence)\n\n\nfd: descriptor de fitxer.\noffset: desplaçament relatiu del punter en bytes.\nwhence: directiva de desplaçament:\n\nSEEK_SET: el punter es col·loca offset bytes.\nSEEK_CUR: el punter es mou offset bytes des de la seva posició actual.\nSEEK_END: el punter es mou offset bytes des del final del fitxer.\n\nSi té èxit, retorna la posició absoluta del punter (en bytes).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-en-llocs-específics",
    "href": "slides/01-c.html#llegint-fitxers-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxers en llocs específics",
    "text": "Llegint fitxers en llocs específics\nint main(int argc, char* argv[]) {\n  char string[11];\n  int b_read;\n\n  int file = open (\"my_file\", O_RDONLY); \n\n  lseek(file, 46, SEEK_SET);\n  b_read = read(file, string, 10); // Read 10 bytes\n  close(file);\n\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n  b_read, string);\n\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-en-llocs-específics",
    "href": "slides/01-c.html#escrivint-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Escrivint en llocs específics",
    "text": "Escrivint en llocs específics\nchar buf1[] = \"abcdefghij\";\nchar buf2[] = \"ABCDEFGHIJ\";\n\nint main() {\n  int fd;\n  if((fd = creat(\"new_file2\", 0644)) &lt; 0) {\n    perror(\"new_file2\"); exit(-1);\n  }\n\n  if(write(fd, buf1, 10) != 10)       perror(\"buf1\");    // offset == 10\n  if(lseek(fd, 4, SEEK_SET) == -1)    perror(\"lseek\");   // offset == 4\n  if(write(fd, buf2, 10) != 10)       perror(\"buf2\");    // offset == 14\n\n  return 0;\n}\n\nFitxer: sources/escriure_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-són-els-punters",
    "href": "slides/01-c.html#què-són-els-punters",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què són els punters?",
    "text": "Què són els punters?\n\n\nConcepte\n\nTotes les dades (variables, constants,…) s’emmagatzemen des d’una determinada adreça de memòria i utilitzant tants bytes com sigui necessari.\nUn punter és una variable guardada en una adreça de mèmoria que conté un altra adreça de memòria.\n\n\nOperadors\n\n&: Retorna l’adreça de l’apuntador. Per exemple &x ens dóna l’adreça de la variable x.\n* Retorn el valor de la variable situada a l’adreça especificada pel seu operand (dereferencing).\n\n\n\nEl valor que retorna l’operador & depèn de la posició del seu operand i, per tant, no està sota el control del programador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-i",
    "href": "slides/01-c.html#com-funcionen-els-punters-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funcionen els punters? (I)",
    "text": "Com funcionen els punters? (I)\nint main (int argc, char * argv[]){\nint s=10,n,m;\nint *ptr=&s;\n};",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-ii",
    "href": "slides/01-c.html#com-funcionen-els-punters-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funcionen els punters? (II)",
    "text": "Com funcionen els punters? (II)\n\n\nint \nmain (int argc, \n    char * argv[]){\n    int s=10;\n    float f=10.5;\n    char a='a';\n\n    int *pt1 = &s;\n    float *pt2 = &f;\n    char *pt3= &a;\n};\n\n\n\n\nFitxer: sources/punters_diapos.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-i",
    "href": "slides/01-c.html#operacions-amb-punters-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions amb punters (I)",
    "text": "Operacions amb punters (I)\n\nAssignació (=): Assigna una adreça a un punter.\nComparació (==, !=): Igualtat o desigualtat.\nInicialització (NULL): Indica que el punter no conté cap adreça.\nIncrement (++), decrement (–): Canviar un punter a l’element següent/anterior d’una sèrie (per exemple, una matriu).\nIndexat ([]): accés a l’element n d’una sèrie.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-ii",
    "href": "slides/01-c.html#operacions-amb-punters-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions amb punters (II)",
    "text": "Operacions amb punters (II)\nint n = 2;\nint *ptr1 = NULL;\nptr1 = &n;\n(*ptr1)++        //Modifiquem el valor de la variable a la que apunta\nptr1++           //Modifiquem l'adreça de memòria on apunta",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-paràmetres-valor",
    "href": "slides/01-c.html#pas-de-paràmetres-valor",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Pas de paràmetres (valor)",
    "text": "Pas de paràmetres (valor)\n#include &lt;stdio.h&gt;\n\nint sumar_per_valor(int a, int b) {\n    a = a + b;\n    return a;\n}\n\nint main() {\n    int x = 5;int y = 3;\n    printf(\"Abans de la crida per valor: x = %d, y = %d\\n\", x, y);\n    int resultat = sumar_per_valor(x, y);\n    printf(\"Després de la crida per valor: x = %d, y = %d\\n\", x, y);\n    printf(\"Resultat de la suma: %d\\n\", resultat);\n\n    return 0;\n}\n\nFitxer: sources/pas_valor.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-paràmetres-referència",
    "href": "slides/01-c.html#pas-de-paràmetres-referència",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Pas de paràmetres (referència)",
    "text": "Pas de paràmetres (referència)\n#include &lt;stdio.h&gt;\n\nvoid sumar_per_referencia(int *a, int *b) {\n    *a = *a + *b;\n}\n\nint main() {\n    int x = 5; int y = 3;\n    printf(\"Abans de la crida per referència: x = %d, y = %d\\n\", x, y);\n    sumar_per_referencia(&x, &y);\n    printf(\"Després de la crida per referència: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenació-dun-array",
    "href": "slides/01-c.html#exemple-ordenació-dun-array",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenació d’un array",
    "text": "Exemple: Ordenació d’un array\nvoid ordenar(int n, int* ptr)\n{\n    int i, j, t;\n    for (i = 0; i &lt; n; i++) {\n        for (j = i + 1; j &lt; n; j++) {\n            if (*(ptr + j) &lt; *(ptr + i)) {\n                t = *(ptr + i);\n                *(ptr + i) = *(ptr + j);\n                *(ptr + j) = t;\n            }\n        }\n    }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-la-stack",
    "href": "slides/01-c.html#què-és-la-stack",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és la Stack?",
    "text": "Què és la Stack?\nÉs una estructura LIFO (Last-In,First-Out). La pila és una regió especial de memòria i la gestiona automàticament la CPU, de manera que no cal assignar ni desassignar memòria. La memòria de pila es divideix en trames successives on cada vegada que es crida una funció, s’assigna una nova trama de pila.\nCaracterístiques de la Stack\n\nOrdre seqüencial: Les variables s’empilen i desempilen en ordre seqüencial.\nGestió automàtica: No cal que el programador assigni o alliberi memòria manualment.\nLimitació de mida: La pila és limitada, i si es supera el seu límit, es produeix un desbordament de pila.\nVariables locals: Les variables de la pila només existeixen mentre la funció està en execució.\nEficient: L’accés a la memòria de la pila és molt ràpid, ja que segueix un ordre seqüencial i clar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-la-heap",
    "href": "slides/01-c.html#què-és-la-heap",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és la Heap?",
    "text": "Què és la Heap?\nLa heap és una àrea de memòria on s’assigna memòria de manera dinàmica durant el temps d’execució. Aquesta memòria es gestiona a través de funcions específiques com malloc(), calloc() i free(), i és responsabilitat del programador garantir que la memòria s’alliberi quan ja no sigui necessària.\nCaracterístiques de la Heap\n\nGestió manual: El programador ha de controlar l’assignació i alliberament de la memòria.\nFlexibilitat: És útil per a grans blocs de memòria o per a objectes que han de romandre en memòria més temps que una funció específica.\nLimitació per memòria física: La mida de la heap està limitada per la quantitat de memòria física disponible al sistema.\nCost d’execució: Les operacions amb la heap són més lentes comparades amb la pila, a causa de la gestió dinàmica i la fragmentació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-heap-vs-stack",
    "href": "slides/01-c.html#exemple-heap-vs-stack",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Heap vs Stack",
    "text": "Exemple: Heap vs Stack\n\n\nint main() {     \n    int y;   \n    char *str; \n    y = 4;\n    printf(\"stack memory: %d\\n\", y);\n    str = malloc(100*sizeof(char)); \n    str[0] = 'm';\n    printf(\"heap memory:%c\\n\", str[0]); \n    free(str);         \n    return 0;\n}\n\n\n\n\nFitxer: sources/zones_mem.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#stackoverflow",
    "href": "slides/01-c.html#stackoverflow",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "StackOverflow",
    "text": "StackOverflow\n\n\nExemple\nvoid func() {\n    int vector[1000];\n    func();\n}\n\nint main() {\n    func();\n    return 0;\n}\n\nQuè és un StackOverflow?\nUn stack overflow es produeix quan la pila del programa supera la seva capacitat màxima. Això pot passar quan es criden funcions recursives de manera infinita o quan s’assignen grans quantitats de memòria a la pila.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-i",
    "href": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb memòria dinàmica (I)",
    "text": "Exemple: Ordenar amb memòria dinàmica (I)\nint main() {\n    int* nums = NULL;  \n    int n = 0, max_elements = 10, num;\n\n    nums = (int*)malloc(max_elements * sizeof(int));\n    if (nums == NULL) {\n        printf(\"Error en l'assignació de memòria.\\n\");\n        return 1;\n    }\n\n    capta_dades(n, nums);\n    ordenar(n, nums);\n    free(nums);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-ii",
    "href": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb memòria dinàmica (II)",
    "text": "Exemple: Ordenar amb memòria dinàmica (II)\n\ncapta_dades(int n, int* nums) {\n  while (scanf(\"%d\", &num) != EOF) {\n    if (n &gt;= max_elements) {\n      max_elements *= 2;\n      int* temp = (int*)realloc(nums, max_elements * sizeof(int));\n      if (temp == NULL) {\n        printf(\"Error en l'assignació de memòria.\\n\");\n        free(nums);\n        return 1;\n      }\n      nums = temp;\n    }\n  nums[n] = num;\n  n++;\n  }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qué-són-els-structs",
    "href": "slides/01-c.html#qué-són-els-structs",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Qué són els structs?",
    "text": "Qué són els structs?\nUna estructura és un tipus de dades derivats format per membres que són tipus de dades fonamentals o derivats. Una única estructura emmagatzemaria les dades d’un objecte. Una matriu d’estructures emmagatzemaria les dades de diversos objectes.\n\n\nSenser reserva espai de Memòria\nstruct user {\nint pid;\nchar * name;\n}\n\nReservant espai de Memòria\nstruct user {\nint pid;\nchar * name;\n} user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qué-són-els-typedef",
    "href": "slides/01-c.html#qué-són-els-typedef",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Qué són els Typedef?",
    "text": "Qué són els Typedef?\nTypedef s’utilitza per crear sinònims per a noms de tipus de dades definits prèviament.\n\n\ntypedef int L;\nint a;\nL a;\n\ntypedef struct {\nint pid;\nchar * name;\n} User; \n\n\n\n\nUser user;\nuser.name=\"\nJordi Mateo\";\nuser.pid=5000;\n\nUser * user1;\nuser1-&gt;name=\"Jack \nsparrow\";\n*(user1).pid=5001;\nUser *user2 = &user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "href": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Calculant la distancia entre 2 punts",
    "text": "Calculant la distancia entre 2 punts\ntypedef struct {\n  float x; float y;\n} point ;\n \nfloat dist( point A, point B) {\n  return(sqrt((A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y)));\n}\n \nint main(){\n  float d; point A, B;\n  printf(\"The coordinates of the point A are: \");\n  scanf(\"%f %f\",&A.x,&A.y);\n  printf(\"\\nThe coordinates of the point B are: \");\n  scanf(\"%f %f\",&B.x,&B.y);\n  printf(\"\\nThe distance between A and B is %f\\n\", dist(A,B));\n  exit (0);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exercicis",
    "href": "slides/01-c.html#exercicis",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exercicis",
    "text": "Exercicis\n\nDebianBin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#això-és-tot-per-avui",
    "href": "slides/01-c.html#això-és-tot-per-avui",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nPreguntes?\nTot el codi i exemples addicionals els trobareu a la carpeta 01-sources del repositori GitHub del curs.\n\nTAKE HOME MESSAGE\nEl kernel de Linux s’ha escrit en C, per tant, és important conèixer aquest llenguatge de programació si volem entendre com funciona el sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ·Introducció a la programació de Sistema (I) (C)"
    ]
  }
]